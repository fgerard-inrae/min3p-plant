!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 789 $
!> $Author: dsu $
!> $Date: 2021-03-22 21:33:49 -0700 (Mon, 22 Mar 2021) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/mip_mt/mip_math.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!> module: mip_math
!>
!> written by: Danyang Su
!>
!> module descrption:
!>   module of math functions used in MIP_MT model
!>   including
!>   1. mip_math_bwlabeln: find the connected regions of an image
!> Note:  
!>   These functions are available in Matlab but not available from Fortran library.
!>   Currently support 1D and 2D image.
!> 
module mip_math

    implicit none
    
    interface mip_math_bwlabeln
        module procedure mip_math_bwlabeln_1
        module procedure mip_math_bwlabeln_2
    end interface mip_math_bwlabeln
    
    interface mip_math_imdilate
        module procedure mip_math_imdilate_1
        module procedure mip_math_imdilate_2
        module procedure mip_math_imdilate_r1
    end interface mip_math_imdilate
    
    interface mip_math_find
        module procedure mip_math_find_1
        module procedure mip_math_find_2
        module procedure mip_math_find_r1
        module procedure mip_math_find_r2
    end interface mip_math_find
    
    interface mip_math_bwselect
        module procedure mip_math_bwselect_1
        module procedure mip_math_bwselect_2
        module procedure mip_math_bwselect_3
    end interface mip_math_bwselect
    
    public  mip_math_bwlabeln_test, mip_math_imdilate_test,            &
            mip_math_bwselect_test
    
    private number_of_runs, fill_run_vectors, first_pass,              &
            mip_math_bwlabeln_1, mip_math_bwlabeln_2,                  &
            mip_math_imdilate_1, mip_math_imdilate_2,                  &
            mip_math_bwselect_1, convert2bit
    
contains

    !>
    !> entry of bwlabeln
    !> currently only test for 2D 
    !> modify from www.cnblogs.com/waring/p/4233705.html
    !> with bug fixed.
    !>
    subroutine mip_math_bwlabeln_1(nx, ny, nz, arrayin, mode, num,     &
                                   results)
    
      implicit none
      !c passed variables      
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz, mode, num
      !c input image values   
      integer, allocatable :: arrayin(:)
      !c returned result
      integer, allocatable :: results(:)

      !c local variables
      integer :: i, j, num_runs, number, idxstart
      integer, allocatable :: sc(:), ec(:), r(:), labels(:)
      
      num_runs = number_of_runs(nx, ny, nz, arrayin) 
!#ifdef DEBUG
!      write(*,*) "num_runs",num_runs
!#endif
      if (num_runs == 0) then
        num = 0
        return
      end if
      
      allocate(sc(num_runs))
      sc = 0
      allocate(ec(num_runs))
      ec = 0
      allocate(r(num_runs))
      r = 0
      allocate(labels(num_runs))
      labels = 0
      
      
      call fill_run_vectors(nx, ny, nz, arrayin, sc, ec, r)      
      call first_pass(sc, ec, r, labels, num_runs, mode)

      results = 0      
      number = 0
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        !add codes here, current not support 3D      
      else if ((nx > 1 .and. ny > 1) .or. (nx > 1 .and. nz > 1)) then          
        do i = 1, num_runs 
          idxstart = (r(i) - 1)*nx
          do j = sc(i), ec(i)
            results(idxstart+j) = labels(i)          
          end do
          if (number < labels(i)) then
            number = labels(i)
          end if
        end do          
      else if (ny > 1 .and. nz > 1) then
        do i = 1, num_runs 
          idxstart = (r(i) - 1)*ny
          do j = sc(i), ec(i)
            results(idxstart+j) = labels(i)          
          end do
          if (number < labels(i)) then
            number = labels(i)
          end if
        end do
      else
        do i = 1, num_runs 
          do j = sc(i), ec(i)
            results(j) = labels(i)          
          end do
          if (number < labels(i)) then
            number = labels(i)
          end if
        end do
      end if

      num = number
      
      deallocate(sc)
      deallocate(ec)
      deallocate(r)
      deallocate(labels)
    
    end subroutine mip_math_bwlabeln_1

    !>
    !> entry of bwlabeln
    !> currently only test for 2D 
    !>
    subroutine mip_math_bwlabeln_2(nx, ny, nz, arrayin, mode, num,     &
                                   results, sc, ec, r)
    
      implicit none
      !c passed variables      
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz, mode, num
      !c input image values   
      integer, allocatable :: arrayin(:)
      !c returned result
      integer, allocatable :: results(:)
      !c returned start colume index of cluster
      integer, allocatable :: sc(:)
      !c returned end colume index of cluster
      integer, allocatable :: ec(:)
      !c returned row index of cluster
      integer, allocatable :: r(:)

      !c local variables
      integer :: i, j, num_runs, number, idxstart
      integer, allocatable :: labels(:)
      
      num_runs = number_of_runs(nx, ny, nz, arrayin)      
      
      if (num_runs == 0) then
        num = 0
        return
      end if
      
      if (allocated(sc)) then
        deallocate(sc)
      end if
      allocate(sc(num_runs))
      sc = 0
      
      if (allocated(ec)) then
        deallocate(ec)
      end if
      allocate(ec(num_runs))
      ec = 0
      
      if (allocated(r)) then
        deallocate(r)  
      end if
      allocate(r(num_runs))
      r = 0
      
      
      allocate(labels(num_runs))      
      labels  = 0
      call fill_run_vectors(nx, ny, nz, arrayin, sc, ec, r)
      
      call first_pass(sc, ec, r, labels, num_runs, mode)

      results = 0      
      number = 0
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        !add codes here, current not support 3D      
      else if ((nx > 1 .and. ny > 1) .or. (nx > 1 .and. nz > 1)) then          
        do i = 1, num_runs 
          idxstart = (r(i) - 1)*nx
          do j = sc(i), ec(i)
            results(idxstart+j) = labels(i)          
          end do
          if (number < labels(i)) then
            number = labels(i)
          end if
        end do          
      else if (ny > 1 .and. nz > 1) then
        do i = 1, num_runs 
          idxstart = (r(i) - 1)*ny
          do j = sc(i), ec(i)
            results(idxstart+j) = labels(i)          
          end do
          if (number < labels(i)) then
            number = labels(i)
          end if
        end do
      else
        do i = 1, num_runs 
          do j = sc(i), ec(i)
            results(j) = labels(i)          
          end do
          if (number < labels(i)) then
            number = labels(i)
          end if
        end do
      end if

      num = number
      
      deallocate(labels)
    
    end subroutine mip_math_bwlabeln_2
                                   
    !>
    !> test bwlabeln
    !>
    subroutine mip_math_bwlabeln_test
    
      implicit none
      
      integer :: i, j, nx, ny, nz, nxyz, n, mode, num
      integer, allocatable :: bwin(:), bwout(:)
      
      !c 1D case, 8
      nx = 8
      ny = 1
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 8
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/1,1,1,0,1,0,1,1/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 1D-1 input:"
      write(*,'(100i4)') bwin(1:n)  
      
      write(*,*) "output: num ", num
      write(*,'(100i4)') bwout(1:n)  
      
      bwin  =  (/0,1,1,1,1,0,1,0/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 1D-2 input:"
      write(*,'(100i4)') bwin(1:n)  
      
      write(*,*) "output: num ", num
      write(*,'(100i4)') bwout(1:n) 
      
      
      !c 2D case, 8x8
      nx = 8
      ny = 8
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 8
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/1,1,1,0,0,0,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             0,0,0,0,0,0,1,0,              &
   &             1,1,1,0,0,0,0,0,              &
   &             1,0,1,0,0,0,1,0,              &
   &             1,0,1,0,0,1,1,0,              &
   &             1,1,1,0,0,0,0,0/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 2D-1 input:"
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: num ", num
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
     
      bwin  =  (/1,1,1,0,0,0,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             1,0,0,0,1,1,0,0,              &
   &             1,0,1,0,0,0,1,0,              &
   &             0,0,1,0,0,0,1,0,              &
   &             1,0,1,0,1,0,1,0,              &
   &             1,1,1,1,1,0,0,0,              &
   &             0,1,0,0,0,0,0,0/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 2D-2 input:"
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: num ", num
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
      !c 2D case, 20x20
      nx = 20
      ny = 20
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 20
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/                                  &
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,&
        &  0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,&
        &  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,&
        &  0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,&
        &  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 2D-3 input:"
      do i = 1, n
        write(*,'(100(i1,1x))') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: num ", num
      do i = 1, n
        write(*,'(100(i1,1x))') bwout((i-1)*n+1:i*n)  
      end do
      
      !c 2D case, 30x30
      nx = 30
      ny = 30
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 30
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/                                                      &
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 2D-4 input:"
      do i = 1, n
        write(*,'(100(i1,1x))') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: num ", num
      do i = 1, n
        write(*,'(100(i1,1x))') bwout((i-1)*n+1:i*n)  
      end do
      
     
      !c 2D case, 50x50
      nx = 50
      ny = 50
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 50
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/                                                                                           &
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
      & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/)
      
      call mip_math_bwlabeln_1(nx, ny, nz, bwin, mode, num, bwout)      
      
      write(*,*) "-->test 2D-5 input:"
      do i = 1, n
        write(*,'(100(i1,1x))') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: num ", num
      do i = 1, n
        write(*,'(100(i2,1x))') bwout((i-1)*n+1:i*n)  
      end do
     
    
    end subroutine mip_math_bwlabeln_test
    
    !>
    !> dilate an image
    !>
    subroutine mip_math_imdilate_r1(nx, ny, nz, arrayin, mode, results)
    
      implicit none
      !c passed variables      
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz, mode
      !c input image values   
      integer, allocatable :: arrayin(:)
      !c returned result
      real*8, allocatable :: results(:)

      !c local variables
      integer :: ix, iy, iz, ivol, nvols, nxx, nyy, nzz,               &
                 iup, idown, ileft, iright,iupleft, iupright,          &
                 idownleft, idownright

      results = arrayin
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        !add codes here, current not support 3D      
      else if ((nx > 1 .and. ny > 1) .or. (ny > 1 .and. nz > 1) .or.   &
               (nx > 1 .and. nz > 1)) then 
          
        if (nx > 1 .and. ny > 1) then
          nxx = nx
          nyy = ny
        else if (ny > 1 .and. nz > 1) then
          nxx = ny
          nyy = nz
        else if (nx > 1 .and. nz > 1) then
          nxx = nx
          nyy = nz
        end if
        
        do iy = 1, nyy
          do ix = 1, nxx
            ivol = (iy-1)*nxx+ix
            if (arrayin(ivol) /= 0) then                
              ileft = ivol-1
              iright = ivol + 1              
              if (ix == 1) then
                ileft = ivol  
              else if (ix == nxx) then
                iright = ivol
              end if
              
              iup = ivol + nxx
              idown = ivol - nxx
              if (iy == 1) then
                idown = ivol 
              else if (iy == nyy) then
                iup = ivol  
              end if
              
              results(ileft) = 1
              results(iright) = 1
              results(iup) = 1
              results(idown) = 1  
              
              if (mode == 8) then
                iupleft = iup - 1
                iupright = iup + 1
                idownleft = idown - 1
                idownright = idown + 1
                if (ix == 1) then
                  iupleft = iup
                  idownleft = idown
                else if (ix == nxx) then
                  iupright = iup
                  idownright = idown
                end if
                results(iupleft) = 1
                results(iupright) = 1
                results(idownleft) = 1
                results(idownright) = 1 
              end if              
            end if
          end do
        end do
      else
        nvols = nx*ny*nz
        do ivol = 1, nvols
          if (arrayin(ivol) /= 0) then
            if (ivol == 1) then
              results(ivol+1) = 1  
            else if (ivol == nvols) then
              results(ivol-1) = 1   
            else
              results(ivol-1) = 1   
              results(ivol+1) = 1   
            end if
          end if
        end do
      end if

    
    end subroutine mip_math_imdilate_r1
    
    !>
    !> dilate an image
    !>
    subroutine mip_math_imdilate_1(nx, ny, nz, arrayin, mode, results)
    
      implicit none
      !c passed variables      
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz, mode
      !c input image values   
      integer, allocatable :: arrayin(:)
      !c returned result
      integer, allocatable :: results(:)

      !c local variables
      integer :: ix, iy, iz, ivol, nvols, nxx, nyy, nzz,               &
                 iup, idown, ileft, iright,iupleft, iupright,          &
                 idownleft, idownright

      results = arrayin
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        !add codes here, current not support 3D      
      else if ((nx > 1 .and. ny > 1) .or. (ny > 1 .and. nz > 1) .or.   &
               (nx > 1 .and. nz > 1)) then 
          
        if (nx > 1 .and. ny > 1) then
          nxx = nx
          nyy = ny
        else if (ny > 1 .and. nz > 1) then
          nxx = ny
          nyy = nz
        else if (nx > 1 .and. nz > 1) then
          nxx = nx
          nyy = nz
        end if
        
        do iy = 1, nyy
          do ix = 1, nxx
            ivol = (iy-1)*nxx+ix
            if (arrayin(ivol) /= 0) then                
              ileft = ivol-1
              iright = ivol + 1              
              if (ix == 1) then
                ileft = ivol  
              else if (ix == nxx) then
                iright = ivol
              end if
              
              iup = ivol + nxx
              idown = ivol - nxx
              if (iy == 1) then
                idown = ivol 
              else if (iy == nyy) then
                iup = ivol  
              end if
              
              results(ileft) = 1
              results(iright) = 1
              results(iup) = 1
              results(idown) = 1  
              
              if (mode == 8) then
                iupleft = iup - 1
                iupright = iup + 1
                idownleft = idown - 1
                idownright = idown + 1
                if (ix == 1) then
                  iupleft = iup
                  idownleft = idown
                else if (ix == nxx) then
                  iupright = iup
                  idownright = idown
                end if
                results(iupleft) = 1
                results(iupright) = 1
                results(idownleft) = 1
                results(idownright) = 1 
              end if              
            end if
          end do
        end do
      else
        nvols = nx*ny*nz
        do ivol = 1, nvols
          if (arrayin(ivol) /= 0) then
            if (ivol == 1) then
              results(ivol+1) = 1  
            else if (ivol == nvols) then
              results(ivol-1) = 1   
            else
              results(ivol-1) = 1   
              results(ivol+1) = 1   
            end if
          end if
        end do
      end if

    
    end subroutine mip_math_imdilate_1
    
    !>
    !> dilate an image
    !>
    subroutine mip_math_imdilate_2(nx, ny, nz, arrayin, mode, results, &
                                   num_runs, sc, ec, r)
    
      implicit none
      !c passed variables      
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz, mode, num_runs
      !c input image values   
      integer, allocatable :: arrayin(:)
      !c returned result, out
      integer, allocatable :: results(:)
      !c start colume index of cluster, input
      integer, allocatable :: sc(:)
      !c end colume index of cluster, input
      integer, allocatable :: ec(:)
      !c row index of cluster, input
      integer, allocatable :: r(:)

      !c local variables
      integer :: i, j, ix, iy, iz, ivol, nvols, nxx, nyy, nzz,         &
                 idxstart, iup, idown, ileft, iright,                  &
                 iupleft, iupright, idownleft, idownright

      results = arrayin
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        !add codes here, current not support 3D   
      else if ((nx > 1 .and. ny > 1) .or. (ny > 1 .and. nz > 1) .or.   &
               (nx > 1 .and. nz > 1)) then 
          
        if (nx > 1 .and. ny > 1) then
          nxx = nx
          nyy = ny
        else if (ny > 1 .and. nz > 1) then
          nxx = ny
          nyy = nz
        else if (nx > 1 .and. nz > 1) then
          nxx = nx
          nyy = nz
        end if          
          
        do i = 1, num_runs
          idxstart = (r(i) - 1)*nxx  
          do j = sc(i), ec(i)
            ivol = j + idxstart
             
            ileft = ivol-1
            iright = ivol + 1              
            if (j == 1) then
              ileft = ivol  
            else if (j == nxx) then
              iright = ivol
            end if
            
            iup = ivol + nxx
            idown = ivol - nxx
            if (r(i) == 1) then
              idown = ivol 
            else if (r(i) == nyy) then
              iup = ivol  
            end if
            
            results(ileft) = 1
            results(iright) = 1
            results(iup) = 1
            results(idown) = 1  
            
            if (mode == 8) then
              iupleft = iup - 1
              iupright = iup + 1
              idownleft = idown - 1
              idownright = idown + 1
              if (j == 1) then
                iupleft = iup
                idownleft = idown
              else if (j == nxx) then
                iupright = iup
                idownright = idown
              end if
              results(iupleft) = 1
              results(iupright) = 1
              results(idownleft) = 1
              results(idownright) = 1 
            end if              
          end do
        end do
      else
        nvols = nx*ny*nz  
        do i = 1, num_runs 
          do j = sc(i), ec(i)
            if (j == 1) then
              results(j+1) = 1  
            else if (j == nvols) then
              results(j-1) = 1  
            else
              results(j-1) = 1  
              results(j+1) = 1  
            end if
          end do
        end do
      end if
    
    end subroutine mip_math_imdilate_2
                                   
    !>
    !> test bwlabeln
    !>
    subroutine mip_math_imdilate_test
    
      implicit none
      
      integer :: i, j, nx, ny, nz, nxyz, n, mode, num
      integer, allocatable :: bwin(:), bwout(:)
      
      !c 1D case, 8
      nx = 8
      ny = 1
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 8
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/0,1,0,0,1,0,1,1/)
      
      call mip_math_imdilate_1(nx, ny, nz, bwin, mode, bwout)
      
      write(*,*) "-->test 1D-1 input:"
      write(*,'(100i4)') bwin(1:n)  
      
      write(*,*) "output: "
      write(*,'(100i4)') bwout(1:n)  
     
      bwin  =  (/0,1,0,0,0,0,1,0/)
      
      call mip_math_imdilate_1(nx, ny, nz, bwin, mode, bwout)
      
      write(*,*) "-->test 1D-2 input:"
      write(*,'(100i4)') bwin(1:n)  
      
      write(*,*) "output: "
      write(*,'(100i4)') bwout(1:n) 
      
      
      !c 2D case, 8x8
      nx = 8
      ny = 8
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 8
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      bwin  =  (/1,1,1,0,0,0,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             0,0,0,0,0,0,1,0,              &
   &             1,1,1,0,0,0,0,0,              &
   &             1,0,1,0,0,0,1,0,              &
   &             1,0,1,0,0,1,1,0,              &
   &             1,1,1,0,0,0,0,0/)
      
      call mip_math_imdilate_1(nx, ny, nz, bwin, mode, bwout)
      
      write(*,*) "-->test 2D-1 input:"
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
     
      bwin  =  (/1,1,1,0,0,0,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             1,1,1,0,0,0,1,0,              &
   &             1,1,1,0,0,0,1,0,              &
   &             1,1,1,0,0,0,1,0,              &
   &             1,1,1,0,0,1,1,0,              &
   &             1,1,1,0,0,0,0,0/)
      
      call mip_math_imdilate_1(nx, ny, nz, bwin, mode, bwout)
      
      write(*,*) "-->test 2D-2 input:"
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
    
    end subroutine mip_math_imdilate_test
    
    !>
    !> subroutine of bwlabeln
    !> calculate number of non-zero groups for each row
    !> e.g., 1 1 0 0 0 1 1 1 0 0, the results is 2
    !> work for 1D, 2D and 3D
    !>
    integer function number_of_runs(nx, ny, nz, arrayin)
    
      implicit none
      
      !c passed variables  
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz  
      !c input image values
      integer, allocatable :: arrayin(:)
      
      !c local variables
      integer :: ix, iy, iz, istart, nruns
      
      !c start calculating
      nruns = 0
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        do iz = 1, nz
          do iy = 1, ny  
            istart = (iz-1)*ny*nx+(iy-1)*nx
            if (arrayin(istart+1) /= 0) then
              nruns = nruns + 1
            end if
            do ix = 2, nx
              if (arrayin(istart+ix) /= 0 .and.                        &
                  arrayin(istart+ix-1) == 0) then
                nruns = nruns + 1  
              end if
            end do
          end do
        end do          
      else if (nx > 1 .and. ny > 1) then
        do iy = 1, ny  
          istart = (iy-1)*nx
          if (arrayin(istart+1) /= 0) then
            nruns = nruns + 1
          end if
          do ix = 2, nx
            if (arrayin(istart+ix) /= 0 .and.                        &
                arrayin(istart+ix-1) == 0) then
              nruns = nruns + 1  
            end if
          end do
        end do
      else if (ny > 1 .and. nz > 1) then
        do iz = 1, nz  
          istart = (iz-1)*ny
          if (arrayin(istart+1) /= 0) then
            nruns = nruns + 1
          end if
          do iy = 2, ny
            if (arrayin(istart+iy) /= 0 .and.                        &
                arrayin(istart+iy-1) == 0) then
              nruns = nruns + 1  
            end if
          end do
        end do
      else if (nx > 1 .and. nz > 1) then
        do iz = 1, nz  
          istart = (iz-1)*nx
          if (arrayin(istart+1) /= 0) then
            nruns = nruns + 1
          end if
          do ix = 2, nx
            if (arrayin(istart+ix) /= 0 .and.                        &
                arrayin(istart+ix-1) == 0) then
              nruns = nruns + 1  
            end if
          end do
        end do
      else if (nx > 1) then
        if (arrayin(1) /= 0) then
          nruns = nruns + 1
        end if
        do ix = 2, nx
          if (arrayin(ix) /= 0 .and. arrayin(ix-1) == 0) then
            nruns = nruns + 1  
          end if
        end do
      else if (ny > 1) then
        if (arrayin(1) /= 0) then
          nruns = nruns + 1
        end if
        do iy = 2, ny
          if (arrayin(iy) /= 0 .and. arrayin(iy-1) == 0) then
            nruns = nruns + 1  
          end if
        end do
      else if (nz > 1) then
        if (arrayin(1) /= 0) then
          nruns = nruns + 1
        end if
        do iz = 2, nz
          if (arrayin(iz) /= 0 .and. arrayin(iz-1) == 0) then
            nruns = nruns + 1  
          end if
        end do  
      end if
      
      number_of_runs = nruns
    
    end function number_of_runs
    
    !>
    !> return one if the input is nonzero
    !>    or zero if the input is zero
    !>
    integer function convert2bit(inputvalue)
    
      implicit none
      
      integer :: inputvalue
      
      if (inputvalue == 0) then
        convert2bit = 0
      else
        convert2bit = 1
      end if
      
    
    end function convert2bit
    
    !>
    !> subroutine of bwlabeln
    !> calculate for index
    !> 
    !> work for 1D, 2D
    !>
    subroutine fill_run_vectors(nx, ny, nz, arrayin, sc, ec, r)
    
      implicit none
      
      !c passed variables      
      !c number of discretization in x, y and z direction
      integer :: nx, ny, nz  
      !c input image values   
      integer, allocatable :: arrayin(:)
      !c start column index
      integer, allocatable :: sc(:)
      !c end column index
      integer, allocatable :: ec(:)
      !c row index
      integer, allocatable :: r(:)
      
      !c local variables
      integer :: ix, iy, iz, istart, idx, prev
      
      !c start calculating
      idx = 1
      
      if (nx > 1 .and. ny > 1 .and. nz > 1) then
        !add codes here, current not support 3D        
      else if (nx > 1 .and. ny > 1) then
        do iy = 1, ny 
          prev = 0  
          istart = (iy-1)*nx
          do ix = 1, nx
            if (convert2bit(arrayin(istart+ix)) /= prev) then
              if (prev == 0) then
                sc(idx) = ix
                r(idx) = iy
                prev = 1
              else
                ec(idx) = ix - 1
                prev = 0
!#ifdef DEBUG
!            if(idx>0) then
!              write(*,'(4(a,1x,i4,1x))') "idx",idx,"sc(idx)",sc(idx),"ec(idx)",ec(idx),"r(idx)",r(idx)
!            end if
!#endif
                idx = idx + 1
              end if
            end if
            if (ix == nx .and. prev == 1) then
              ec(idx) = ix
!#ifdef DEBUG
!            if(idx>0) then
!              write(*,'(4(a,1x,i4,1x))') "idx",idx,"sc(idx)",sc(idx),"ec(idx)",ec(idx),"r(idx)",r(idx)
!            end if
!#endif
              idx = idx + 1
            end if
          end do
        end do
      else if (ny > 1 .and. nz > 1) then
        do iz = 1, nz 
          prev = 0  
          istart = (iz-1)*ny
          do iy = 1, ny
            if (convert2bit(arrayin(istart+iy)) /= prev) then
              if (prev == 0) then
                sc(idx) = iy
                r(idx) = iz
                prev = 1
              else
                ec(idx) = iy - 1
                prev = 0
!#ifdef DEBUG
!            if(idx>0) then
!              write(*,'(4(a,1x,i4,1x))') "idx",idx,"sc(idx)",sc(idx),"ec(idx)",ec(idx),"r(idx)",r(idx)
!            end if
!#endif
                idx = idx + 1
              end if
            end if
            if (iy == ny .and. prev == 1) then
              ec(idx) = iy
!#ifdef DEBUG
!            if(idx>0) then
!              write(*,'(4(a,1x,i4,1x))') "idx",idx,"sc(idx)",sc(idx),"ec(idx)",ec(idx),"r(idx)",r(idx)
!            end if
!#endif
              idx = idx + 1
            end if
          end do
        end do
      else if (nx > 1 .and. nz > 1) then
        do iz = 1, nz 
          prev = 0  
          istart = (iz-1)*nx
          do ix = 1, nx
            if (convert2bit(arrayin(istart+ix)) /= prev) then
              if (prev == 0) then
                sc(idx) = ix
                r(idx) = iz
                prev = 1
              else
                ec(idx) = ix - 1
                prev = 0
!#ifdef DEBUG
!            if(idx>0) then
!              write(*,'(4(a,1x,i4,1x))') "idx",idx,"sc(idx)",sc(idx),"ec(idx)",ec(idx),"r(idx)",r(idx)
!            end if
!#endif
                idx = idx + 1
              end if
            end if
            if (ix == nx .and. prev == 1) then
              ec(idx) = ix
!#ifdef DEBUG
!            if(idx>0) then
!              write(*,'(4(a,1x,i4,1x))') "idx",idx,"sc(idx)",sc(idx),"ec(idx)",ec(idx),"r(idx)",r(idx)
!            end if
!#endif
              idx = idx + 1
            end if
          end do
        end do
      else if (nx > 1) then
        prev = 0  
        do ix = 1, nx
          if (convert2bit(arrayin(ix)) /= prev) then
            if (prev == 0) then
              sc(idx) = ix
              r(idx) = 1
              prev = 1
            else
              ec(idx) = ix - 1
              prev = 0
              idx = idx + 1
            end if
          end if
          if (ix == nx .and. prev == 1) then
            ec(idx) = ix
            idx = idx + 1
          end if
        end do
      else if (ny > 1) then
        prev = 0  
        do iy = 1, ny
          if (convert2bit(arrayin(iy)) /= prev) then
            if (prev == 0) then
              sc(idx) = iy
              r(idx) = 1
              prev = 1
            else
              ec(idx) = iy - 1
              prev = 0
              idx = idx + 1
            end if
          end if
          if (iy == ny .and. prev == 1) then
            ec(idx) = iy
            idx = idx + 1
          end if
        end do
      else if (nz > 1) then
        prev = 0  
        do iz = 1, nz
          if (convert2bit(arrayin(iz)) /= prev) then
            if (prev == 0) then
              sc(idx) = iz
              r(idx) = 1
              prev = 1
            else
              ec(idx) = iz - 1
              prev = 0
              idx = idx + 1
            end if
          end if
          if (iz == nz .and. prev == 1) then
            ec(idx) = iz
            idx = idx + 1
          end if
        end do
      end if
    
    end subroutine fill_run_vectors
    
    !>
    !> subroutine of bwlabeln
    !> loop over all groups, mark the group number for the image
    !> 
    !> work for 1D, 2D
    !>
    subroutine first_pass(sc, ec, r, labels, num_runs, mode)    
    
      implicit none
      
      !c passed variables      
      !c start column index
      integer, allocatable :: sc(:)
      !c end column index
      integer, allocatable :: ec(:)
      !c row index
      integer, allocatable :: r(:)
      !c group number labels
      integer, allocatable :: labels(:)
      !c 
      integer :: num_runs, mode
      
      !c local variables
      integer :: i, j, k, p, max_label, min_label, non_num, minus_label
      integer :: cur_row, next_label, offset, equal_idx,               &
                 first_run_on_prev_row, last_run_on_prev_row,          &
                 first_run_on_this_row
      integer, allocatable :: equal_i(:), equal_j(:)
      integer, allocatable :: hist(:), non_labels(:)
      logical :: b_check
                 
      
      !c initialize variables
      cur_row = 1
      next_label = 1
      first_run_on_prev_row = 0
      last_run_on_prev_row = 0
      first_run_on_this_row = 1
      if (mode == 8) then
        offset = 0
        !offset = 1 for mode == 8, not work, need further check
      else
        offset = 0
      end if
      equal_idx = 1
      
      allocate(equal_i(num_runs))
      equal_i = 0
      allocate(equal_j(num_runs))
      equal_j = 0
      
      !c loop over all groups
      do k = 1, num_runs
        if (r(k) == cur_row + 1) then
          cur_row = cur_row + 1
          first_run_on_prev_row = first_run_on_this_row
          first_run_on_this_row = k
          last_run_on_prev_row = k - 1
        else if (r(k) > cur_row + 1) then 
          first_run_on_prev_row = 0
          last_run_on_prev_row = 0
          first_run_on_this_row = k
          cur_row = r(k)           
        end if
        if (first_run_on_prev_row >= 1) then
          p = first_run_on_prev_row
          do while (p <= last_run_on_prev_row .and.                   &
                    sc(p) <= (ec(k) + offset))
            if (sc(k) <= ec(p) + offset) then
              if (labels(k) == 0) then
                labels(k) = labels(p)
              else if (labels(k) /= labels(p)) then
                equal_i(equal_idx) = labels(k)
                equal_j(equal_idx) = labels(p)
                equal_idx = equal_idx + 1
              end if
            end if
            p = p + 1
          end do
        end if
        if (labels(k) == 0) then  
          next_label = next_label + 1
          labels(k) = next_label 
        end if
        
!#ifdef DEBUG
!        write(*,*) "first_pass-1,k",k,"labels(k)",labels(k)      
!#endif
      end do      
      
      !c process labels
      do i = 1, equal_idx
        if (equal_i(i) > equal_j(i)) then
          max_label = equal_i(i)
        else
          max_label = equal_j(i) 
        end if
        
        if (equal_i(i) < equal_j(i)) then
          min_label = equal_i(i)
        else
          min_label = equal_j(i) 
        end if        
        
        do j = 1, num_runs
          if (labels(j) == max_label) then
            labels(j) = min_label
          end if          
        end do
      end do
      
!#ifdef DEBUG
!      do j = 1, num_runs
!        write(*,*) "proc-label-2,j",j,"labels(j)",labels(j)      
!      end do
!#endif
      
      deallocate(equal_i)
      deallocate(equal_j)
      
      !c bug fixes, check the neighbour cluster, DSU, 20151007
      b_check = .true.      
      do while(b_check)
        b_check = .false.  
        do i = 1, num_runs-1
          do j = i+1, num_runs
            if (labels(i)==labels(j)) then
              cycle
            end if
            if(r(i)-r(j) /= 1 .and. r(i)-r(j) /= -1) then
              cycle  
            end if
            if((sc(i)>=sc(j).and.sc(i)<=ec(j)) .or.   &
               (ec(i)>=sc(j).and.ec(i)<=ec(j)) .or.   &
               (sc(j)>=sc(i).and.sc(j)<=ec(i)) .or.   &
               (ec(j)>=sc(i).and.ec(j)<=ec(i))) then 
              if(labels(i) > labels(j)) then
                labels(i) = labels(j)     
              else
                labels(j) = labels(i)  
              end if              
              b_check = .true.
!#ifdef DEBUG
!              write(*,'(2(a,1x,i6,1x))') "merge cluster",i,"and",j
!              write(*,'(3(a,1x,i6,1x))') "sc(i)",sc(i),"ec(i)",ec(i),"r(i)",r(i)
!              write(*,'(3(a,1x,i6,1x))') "sc(j)",sc(j),"ec(j)",ec(j),"r(j)",r(j)
!#endif
            end if
          end do
        end do
      end do  
      
      
      !c process ignore labels
      allocate(hist(0:next_label))
      hist = 0
      do i = 1, num_runs
        hist(labels(i)) = hist(labels(i)) + 1
      end do
      
      allocate(non_labels(next_label))
      non_labels = 0
      non_num = 1
      
      do i = 2, next_label
        if (hist(i) == 0) then
          non_labels(non_num) = i
          non_num = non_num + 1
        end if
      end do
      
      do j = 1, num_runs
        k = labels(j)
        do i = non_num, 1, -1
          if (k > non_labels(i)) then
            labels(j) = labels(j) - i
            exit
          end if
        end do
!#ifdef DEBUG
!        write(*,*) "first_pass-2,j",j,"labels(j)",labels(j)      
!#endif
      end do
      
      !c bug fixes, set the minmum label to 1 if it is not, DSU, 20151007
      !c make all labels consecutive
      if (num_runs > 0) then
        min_label = minval(labels(1:num_runs),1)
        if (min_label /= 1) then
          minus_label = min_label - 1
          do j = 1, num_runs
            labels(j) = labels(j) - minus_label
          end do
        end if
        max_label = maxval(labels(1:num_runs),1)
        
        j = 0
        k = max_label
!#ifdef DEBUG
!        do j = 1, num_runs
!          write(*,*) "consc-label-0,j",j,"labels(j)",labels(j)      
!        end do
!
!        write(*,*) "max_label",max_label  
!#endif
        do i = 2, max_label
          if(i >= k) then
            exit  
          end if
          if(all(labels /= i)) then
            do j = 1, num_runs
              if (labels(j) == k) then
                labels(j) = i  
              end if
            end do
            k = maxval(labels(1:num_runs),1)
          end if
        end do
        
!#ifdef DEBUG  
!        do j = 1, num_runs
!          write(*,*) "consc-label-1,j",j,"labels(j)",labels(j)      
!        end do
!#endif
        
      end if
      
      deallocate(hist)
      deallocate(non_labels)
    
    end subroutine first_pass
    
    !>
    !> return an array containing the linear indices of each nonzero element in array arrayin
    !> 
    subroutine mip_math_find_1(arrayin, num_nonzero, indices, minval_opt)
    
      implicit none
      
      integer, allocatable :: arrayin(:)
      integer, allocatable :: indices(:)
      integer, intent(inout) :: num_nonzero
      integer, optional :: minval_opt
      
      !c local variables
      integer :: i, j, n
      integer :: minval
      
      if(present(minval_opt)) then
          minval = minval_opt
      else
          minval = 0
      end if
      
      n = size(arrayin,1)
  
      indices = 0
      
      j = 0
      do i = 1, n
        if (arrayin(i) > minval) then
          j = j + 1
          indices(j) = i
        end if
      end do
      
      num_nonzero = j
    
    end subroutine mip_math_find_1
    
    !>
    !> return an array containing the linear indices and value of 
    !> each nonzero element in array arrayin
    !> 
    subroutine mip_math_find_2(arrayin, num_nonzero, indices, values, minval_opt)
    
      implicit none
      
      integer, allocatable :: arrayin(:)
      integer, allocatable :: indices(:)
      integer, allocatable :: values(:)
      integer, intent(inout) :: num_nonzero
      integer, optional :: minval_opt
      
      !c local variables
      integer :: i, j, n
      integer :: minval
      
      if(present(minval_opt)) then
          minval = minval_opt
      else
          minval = 0
      end if
      
      n = size(arrayin,1)

      indices = 0
      values = 0
      
      j = 0
      do i = 1, n
        if (arrayin(i) > minval) then
          j = j + 1
          indices(j) = i
          values(j) = arrayin(i)
        end if
      end do
      
      num_nonzero = j
    
    end subroutine mip_math_find_2
    
    !>
    !> return an array containing the linear indices of each nonzero element in array arrayin
    !> 
    subroutine mip_math_find_r1(arrayin, num_nonzero, indices, minval_opt)
    
      implicit none
      
      real*8, allocatable :: arrayin(:)
      integer, allocatable :: indices(:)
      integer, intent(inout) :: num_nonzero
      real*8, optional :: minval_opt
      
      !c local variables
      integer :: i, j, n
      real*8 :: minval
      
      if(present(minval_opt)) then
          minval = minval_opt
      else
          minval = 0.0d0
      end if
      
      n = size(arrayin,1)
      indices = 0
      
      j = 0
      do i = 1, n
        if (arrayin(i) > minval) then
          j = j + 1
          indices(j) = i
        end if
      end do
      
      num_nonzero = j
    
    end subroutine mip_math_find_r1
    
    !>
    !> return an array containing the linear indices and value of 
    !> each nonzero element in array arrayin
    !> 
    subroutine mip_math_find_r2(arrayin, num_nonzero, indices, values, minval_opt)
    
      implicit none
      
      real*8, allocatable :: arrayin(:)
      integer, allocatable :: indices(:)
      real*8, allocatable :: values(:)
      integer, intent(inout) :: num_nonzero
      real*8, optional :: minval_opt
      
      !c local variables
      integer :: i, j, n
      real*8 :: minval
      
      if(present(minval_opt)) then
          minval = minval_opt
      else
          minval = 0.0d0
      end if
      
      n = size(arrayin,1)

      indices = 0
      values = 0
      
      j = 0
      do i = 1, n
        if (arrayin(i) > minval) then
          j = j + 1
          indices(j) = i
          values(j) = arrayin(i)
        end if
      end do
      
      num_nonzero = j
    
    end subroutine mip_math_find_r2  
    
    
    !>
    !> return a binary image containing the objects that overlap the provided index
    !> mode = 4, looks for 4-connected objects
    !>      = 8, looks for 8 connected objects
    !> note: return the non-zero indices only
    !>       not high efficient
    !>
    subroutine mip_math_bwselect_1(nx, ny, nz, arrayin, indexin, mode, &
                                   arrayout, num_out)
    
      implicit none
      
      !c passed variables
      integer :: nx, ny, nz, mode, num_out
      integer, allocatable :: arrayin(:)
      integer, allocatable :: indexin(:)
      integer, allocatable :: arrayout(:)
      
      
      !c local variables
      integer :: i, j, ilast, n, nlabels, label, ivol, nvols
      integer, allocatable :: select_labels(:), kept_labels(:)
      
      num_out = 0
      
      !c use bwlabeln to label all the clusters
      call mip_math_bwlabeln_1(nx, ny, nz, arrayin, mode, num_out, arrayout)
      
      if (num_out == 0) then
        return  
      end if
      
      !c collect labels that need to be kept
      allocate(select_labels(num_out)) 
      select_labels = -1
      
      nlabels = 0
      n = size(indexin,1) 
      j = 0      
      if (n > 0) then          
        ilast = n + 1  
        do i = 1, n  
          ivol = indexin(i)  
          if (arrayout(ivol) > 0) then
            j = j + 1  
            select_labels(j) = arrayout(ivol)
            ilast = i
            exit
          end if
        end do
        
        do i =ilast, n
          ivol = indexin(i)
          label = arrayout(ivol)
          if (label > 0 .and. all(select_labels /= label)) then 
            j = j + 1
            select_labels(j) = label
          end if
        end do
        
        nlabels = j
      end if
      
      allocate(kept_labels(nlabels))
      kept_labels(1:nlabels) = select_labels(1:nlabels)
      
      deallocate(select_labels)
      
      !c if the label is in the collected labels, keep it and modify the value to 1
      !c else, remove it
      nvols = nx*ny*nz      
      do ivol = 1, nvols
        if (any(kept_labels == arrayout(ivol))) then
          arrayout(ivol) = 1  
        else
          arrayout(ivol) = 0
        end if
      end do
      
      deallocate(kept_labels)
      
      num_out = nlabels
      
    end subroutine mip_math_bwselect_1
                                   
    !>
    !> return a binary image containing the objects that overlap the provided index
    !> mode = 4, looks for 4-connected objects
    !>      = 8, looks for 8 connected objects
    !> note: return the non-zero indices only
    !>       not high efficient
    !>
    subroutine mip_math_bwselect_2(nx, ny, nz, arrayin, indexin, mode, &
                                   arrayout, arrayout_vol, num_out)
    
      implicit none
      
      !c passed variables
      integer :: nx, ny, nz, mode, num_out
      integer, allocatable :: arrayin(:)
      integer, allocatable :: indexin(:)
      integer, allocatable :: arrayout(:)
      integer, allocatable :: arrayout_vol(:)
      
      !c local variables
      integer :: i, j, ilast, n, nlabels, label, ivol, jvol, nvols
      integer, allocatable :: select_labels(:), label_vols(:)
      
      num_out = 0
      
      !c use bwlabeln to label all the clusters
      call mip_math_bwlabeln_1(nx, ny, nz, arrayin, mode, num_out, arrayout) 
      
      if (num_out == 0) then
        return
      end if
      
      !c collect labels that need to be kept
      allocate(select_labels(num_out)) 
      select_labels = -1
      
      allocate(label_vols(num_out))
      label_vols = 0
      
      nlabels = 0
      arrayout_vol = 0
      
      n = size(indexin,1) 
      j = 0      
      if (n > 0) then          
        ilast = n + 1  
        do i = 1, n  
          ivol = indexin(i)  
          
          if (arrayout(ivol) > 0) then
            j = j + 1  
            select_labels(j) = arrayout(ivol)
            label_vols(j) = ivol
            ilast = i
            exit
          end if
          
        end do
        
        do i =ilast, n
          ivol = indexin(i)
          label = arrayout(ivol)
          if (label > 0 .and. all(select_labels /= label)) then 
            j = j + 1
            select_labels(j) = label
            label_vols(j) = ivol
          end if
        end do
        
        nlabels = j
      end if
      
      
      !c assign the cluster label and volume label
      !c if a cluster is connected to two or more specific volume
      !c then it will be assigned one selected volume label
      nvols = nx*ny*nz      
      do ivol = 1, nvols
        do j = 1, nlabels
          if (arrayout(ivol) == select_labels(j) .and. arrayout(ivol) > 0) then
            arrayout(ivol) = 1 
            arrayout_vol(ivol) = label_vols(j)
            exit
          end if
        end do
      end do
      
      deallocate(select_labels)
      
      num_out = nlabels
      
    end subroutine mip_math_bwselect_2
                                   
    !>
    !> return a binary image containing the objects that overlap the provided index
    !> mode = 4, looks for 4-connected objects
    !>      = 8, looks for 8 connected objects
    !> note: return the non-zero indices only
    !>       not high efficient
    !>
    subroutine mip_math_bwselect_3(nx, ny, nz, arrayin, indexin, mode, &
                                   arrayout, arrayout_vol, num_out)
    
      implicit none
      
      !c passed variables
      integer :: nx, ny, nz, mode, num_out
      integer, allocatable :: arrayin(:)
      integer, allocatable :: indexin(:,:)
      integer, allocatable :: arrayout(:)
      integer, allocatable :: arrayout_vol(:)
      
      !c local variables
      integer :: i, j, k, ilast, n, nlabels, label, ivol, jvol, nvols
      integer, allocatable :: select_labels(:), label_vols(:)
      logical :: bexit
      
      num_out = 0
      
      !c use bwlabeln to label all the clusters
      call mip_math_bwlabeln_1(nx, ny, nz, arrayin, mode, num_out, arrayout)      
     
      if (num_out == 0) then
        return
      end if
      
      !c collect labels that need to be kept
      allocate(select_labels(num_out)) 
      select_labels = -1
      
      allocate(label_vols(num_out))
      label_vols = 0
      
      nlabels = 0
      arrayout_vol = 0
      
      n = size(indexin,1) 
      j = 0      
      if (n > 0) then          
        ilast = n + 1  
        bexit = .false.
        do i = 1, n  
          do k = 1, 7  
            ivol = indexin(k,i)  
            if (ivol < 1) then
              cycle  
            end if
            if (arrayout(ivol) > 0) then
              j = j + 1  
              select_labels(j) = arrayout(ivol)
              jvol = indexin(1,i)
              label_vols(j) = jvol
              ilast = i
              bexit = .true.
              exit
            end if
          end do
          if (bexit) then
            exit  
          end if
        end do
        
        do i =ilast, n
          do k = 1, 7  
            ivol = indexin(k,i)
            if (ivol < 1) then
              cycle  
            end if
            label = arrayout(ivol)
            if (label > 0 .and. all(select_labels /= label)) then 
              j = j + 1
              select_labels(j) = label
              jvol = indexin(1,i)
              label_vols(j) = jvol
            end if
          end do
        end do
        
        nlabels = j
      end if
      
      
      !c assign the cluster label and volume label
      !c if a cluster is connected to two or more specific volume
      !c then it will be assigned one selected volume label
      nvols = nx*ny*nz      
      do ivol = 1, nvols
        do j = 1, nlabels
          if (arrayout(ivol) == select_labels(j) .and. arrayout(ivol) > 0) then
            arrayout(ivol) = 1 
            arrayout_vol(ivol) = label_vols(j)
            exit
          end if
        end do
      end do
      
      deallocate(select_labels)
      
      num_out = nlabels
      
    end subroutine mip_math_bwselect_3
                                   
    !>
    !> test bwlabeln
    !>
    subroutine mip_math_bwselect_test
    
      implicit none
      
      integer :: i, j, nx, ny, nz, nxyz, n, mode, num
      integer, allocatable :: bwin(:), bwout(:), indexin(:), bwout_vol(:)
      
      !c 1D case, 8
      nx = 8
      ny = 1
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 8
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      allocate(indexin(2))
      indexin = 0
      
      bwin  =  (/0,1,0,0,1,0,1,1/)
      indexin = (/2,7/)
      
      call mip_math_bwselect_1(nx, ny, nz, bwin, indexin, mode, &
                               bwout, num)
      
      write(*,*) "-->bwselect test 1D-1 input:"
      write(*,'(100i4)') bwin(1:n) 
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      write(*,'(100i4)') bwout(1:n)  
      
      bwin  =  (/0,1,0,0,1,0,1,1/)
      indexin = (/2,5/)
      
      call mip_math_bwselect_1(nx, ny, nz, bwin, indexin, mode, &
                               bwout, num)
      
      write(*,*) "-->bwselect test 1D-2 input:"
      write(*,'(100i4)') bwin(1:n) 
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      write(*,'(100i4)') bwout(1:n)  
      
      
      !c 2D case, 8x8
      nx = 8
      ny = 8
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 8
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      if (allocated(indexin)) then
        deallocate(indexin)  
      end if
      allocate(indexin(4))
      indexin = 0
      
      if(allocated(bwout_vol)) then
        deallocate(bwout_vol)  
      end if
      allocate(bwout_vol(nxyz))
      bwout_vol = 0
      
      mode = 4
      bwin  =  (/0,0,0,0,0,0,0,0,              &
   &             1,1,0,0,1,1,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             0,0,0,0,0,0,1,0,              &
   &             1,1,1,0,0,0,0,0,              &
   &             1,0,1,0,0,0,1,0,              &
   &             1,0,1,0,0,1,0,0,              &
   &             0,1,0,0,0,0,1,1/)
      indexin = (/2,3,4,5/)
      
      call mip_math_bwselect_2(nx, ny, nz, bwin, indexin, mode, &
                               bwout, bwout_vol, num)
      
      write(*,*) "-->bwselect mode 4 test 2D-1 input:"
   
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output vol: "
      do i = 1, n
        write(*,'(100i4)') bwout_vol((i-1)*n+1:i*n)  
      end do
      
      bwin  =  (/1,0,1,0,1,0,0,0,              &
   &             0,1,1,0,1,1,0,0,              &
   &             1,0,1,0,1,1,0,0,              &
   &             0,1,0,0,0,0,1,0,              &
   &             1,0,1,0,2,3,3,0,              &
   &             1,0,0,0,0,1,1,0,              &
   &             1,1,1,0,0,1,0,0,              &
   &             0,1,0,0,0,0,1,1/)
      indexin = (/2,3,4,5/)
      
      call mip_math_bwselect_2(nx, ny, nz, bwin, indexin, mode, &
                               bwout, bwout_vol, num)
      
      write(*,*) "-->bwselect mode 4 test 2D-2 input:"
   
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output vol: "
      do i = 1, n
        write(*,'(100i4)') bwout_vol((i-1)*n+1:i*n)  
      end do
      
      bwin  =  (/1,0,1,0,0,0,0,0,              &
   &             1,1,0,0,1,1,0,0,              &
   &             1,1,1,0,1,1,0,0,              &
   &             0,1,0,0,0,0,1,0,              &
   &             1,0,1,0,2,3,3,0,              &
   &             1,0,0,0,0,1,1,0,              &
   &             1,1,1,0,0,1,1,0,              &
   &             0,1,0,0,0,0,1,1/)
      indexin = (/1,31,58,63/)
      
      call mip_math_bwselect_2(nx, ny, nz, bwin, indexin, mode, &
                               bwout, bwout_vol, num)
      
      write(*,*) "-->bwselect mode 4 test 2D-3 input:"
   
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output vol: "
      do i = 1, n
        write(*,'(100i4)') bwout_vol((i-1)*n+1:i*n)  
      end do
      
      bwin  =  (/0,0,0,0,1,0,0,0,              &
   &             0,0,0,0,1,0,0,0,              &
   &             0,0,0,0,0,0,0,0,              &
   &             0,0,0,0,0,0,0,0,              &
   &             0,0,0,0,0,0,0,0,              &
   &             0,0,0,0,0,0,0,0,              &
   &             0,0,0,0,0,0,0,0,              &
   &             0,0,0,0,0,0,0,0/)
      indexin = (/4,5,6,8/)
      
      call mip_math_bwselect_2(nx, ny, nz, bwin, indexin, mode, &
                               bwout, bwout_vol, num)
      
      write(*,*) "-->bwselect mode 4 test 2D-4 input:"
   
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output vol: "
      do i = 1, n
        write(*,'(100i4)') bwout_vol((i-1)*n+1:i*n)  
      end do
      
      
      !c 2D case, 8x8
      nx = 20
      ny = 20
      nz = 1
      mode = 4
      nxyz = nx*ny*nz
      n = 20
      if (allocated(bwin)) then
        deallocate(bwin)  
      end if
      allocate(bwin(nxyz))
      bwin = 0
      
      if (allocated(bwout)) then
        deallocate(bwout)  
      end if
      allocate(bwout(nxyz))
      bwout = 0
      
      if (allocated(indexin)) then
        deallocate(indexin)  
      end if
      allocate(indexin(4))
      indexin = 0
      
      if(allocated(bwout_vol)) then
        deallocate(bwout_vol)  
      end if
      allocate(bwout_vol(nxyz))
      bwout_vol = 0
      
      mode = 4
      
      bwin  =  (/                                  &
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,&
        &  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,&
        &  0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,&
        &  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,&
        &  0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,&
        &  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,&
        &  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/)
      
      indexin = (/10,11,12,13/)
      
      call mip_math_bwselect_2(nx, ny, nz, bwin, indexin, mode, &
                               bwout, bwout_vol, num)
            
      write(*,*) "-->bwselect mode 4 test 2D-5 input:"
   
      do i = 1, n
        write(*,'(100i4)') bwin((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "indexin: " 
      write(*,'(100i4)') indexin
      
      write(*,*) "output: "
      do i = 1, n
        write(*,'(100i4)') bwout((i-1)*n+1:i*n)  
      end do
      
      write(*,*) "output vol: "
      do i = 1, n
        write(*,'(100i4)') bwout_vol((i-1)*n+1:i*n)  
      end do
      
    
    end subroutine mip_math_bwselect_test

end module mip_math
