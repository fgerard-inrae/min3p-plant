!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/mip_mt/mip_bubble.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!> module: mip_bubble
!>
!> written by: Danyang Su
!>
!> module description:
!>   module of mip (macroscopic invasion percolation) parameters
!>   Invasion percolation in a gradient includes fragmentation and mobilization of multiple 
!>   clusters, multi-component mass transfer under equilibrium conditions.!>
!> Note:  
!>   MIP code was originally written in Matlab by Kevin Mumford on March 24, 2007
!> 
    
module mip_bubble

#ifdef OPENMP
    use omp_lib 
#endif
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif

    implicit none
    
    !> switch to use mip model or not
    logical :: mip_mt_enable

    !> ----------------------------------------
    !> phisical constants
    !> ----------------------------------------
    
    !> water density (kg/m3)
    real*8 :: mip_density
    
    !> gravitational acceleration (m/s2)
    real*8 :: mip_gravity
    
    !> density times gravity, convert ratio of water head (m) to Pa
    real*8 :: mip_hw2pa
    
    !> air-water interfacial tension (N/m)
    real*8 :: mip_ift
    
    !> displacement pressure (m of H2O)
    real*8 :: mip_hd
    
    !> Brooks-Corey exponent (-)
    real*8 :: mip_gamma
    
    !> Pe/Pt ratio (-)
    real*8 :: mip_alpha_pept
    
    !> temperature (K)
    real*8 :: mip_t
    
    !> gas constant in (m3.Pa/mol.K)
    real*8 :: mip_r
    
    !> gas convertion parameter, mip_rgasjoule_tempks = mip_r*mip_t*1.0d3 
    real*8 :: mip_rgasjoule_tempks
    
    !> atmospheric pressure (Pa)
    real*8 :: mip_patm
   
    
    !!> NAPL (1,1,1-TCA) vapour pressure (Pa)
    !real*8 :: mip_pvp    
    !!> saturation O2 pressure (pa)
    !real*8 :: mip_psat_o2    
    !!> saturation N2 pressure (pa)
    !real*8 :: mip_psat_n2
    
    !> gas saturation pressure (pa), O2, N2, NAPL
    real*8, allocatable :: mip_psat(:)
    
    !> ----------------------------------------
    !> domain vairalbes, value obtained from min3p codes
    !> ----------------------------------------   
    !> number of blocks in x direction
    integer :: mip_nvx
    
    !> number of blocks in y direction
    integer :: mip_nvy
    
    !> number of blocks in z direction
    integer :: mip_nvz
    
    !> number of total blocks
    integer :: mip_nvols
    
    !> bwlabeln image processing mode
    integer :: mip_bwlabeln_mode
    
    !> hydraulic conductivity in bubble region
    logical :: mip_adjust_bubble_cond
    real*8 :: mip_bubble_cond_ratio
    
    !> 'bubble collapse threshold in capillary fringe'
    !> if zone air saturation is larger than the threshold and water pressure is
    !> less than the threshold, the zone is consider as capillary fringe edge and 
    !> bubble will collapse
    real*8 :: mip_sg_collapse
    real*8 :: mip_pw_collapse
    
    !> update pressure, bubble entry and terminal threshold
    logical :: mip_update_bubble_entry
    
    !> ----------------------------------------
    !> gas vairalbes
    !> ---------------------------------------- 
    
    !> number of gases
    integer :: mip_ngas
    
    !> gas pair, gas phase to aqueous phase
    integer, allocatable :: mip_gas2aqueous(:)
    
    !> gas pair, aqueous phase to gas phase
    integer, allocatable :: mip_aqueous2gas(:)
    
    !> gas species
    logical, allocatable :: mip_gasspecies(:,:)
    
    !> number of aquous species, excluding H2O, equal to number of unknows per volume
    integer :: mip_nc
    
    !> number of secondary species
    integer :: mip_nx
    
    !> critical (spanning) gas saturation (-)
    real*8 :: mip_sgcrit
    
    !> critical bubble contraction pressure [Pa]
    real*8 :: mip_pg_contraction
    
    !> critical bubble contraction saturation (-)
    real*8 :: mip_sg0
    
    !> sg corresponding to breakthrough pressure Pe (-)
    real*8 :: mip_sgm 
    
    !> redisual water saturation, hardwired, can be obtained from MIN3P (-)
    real*8 :: mip_swr 
    
   
    !> tolerance
    real*8 :: mip_tolerance
    
    !> pressure shift for unsaturated flow part
    real*8 :: mip_pressure_shift
    
    !c maximum pressure update in bubble iteration[Pa]
    real*8 :: mip_max_pg_update
    
    !c maximum pressure update ratio in bubble iteration[-]
    real*8 :: mip_max_pg_update_ratio

    !c maximum iterations in bubble pressure update
    integer :: mip_bubble_iterations


    !> jacobi matrix and rhs for sg solver
    real*8, allocatable :: mip_xsg(:,:)
    real*8, allocatable :: mip_xsg_old(:,:)

    !> flag to indicate if the bubble state is changed in the current bubble iteration
    integer, allocatable :: mip_g_flag(:)
        
    
    !> sgstore
    real*8 :: mip_sgstore
    
    !> location index
    integer :: mip_tx
    integer :: mip_ty
    integer :: mip_tz
    
#ifdef DEBUG
    !> total gas saturation
    real*8 :: mip_sg_sum

    !> number of volumns connected to the napl
    integer :: mip_napl_cluster_vols

    !> total gas saturation of volumns connected to the napl
    real*8 :: mip_sg_sum_napl_cluster
    real*8 :: mip_sg_sum_napl_cluster2
    
    !> average pressure
    real*8 :: mip_pgavgt_max    
    real*8 :: mip_pgavgt_min
#endif

    !> define sg space, gas saturation (-)
    real*8, allocatable :: mip_sg(:)
    
    !> define sg space prior to redistribution, gas saturation (-)
    real*8, allocatable :: mip_sg_pre(:)
    
    !> define disconnected gas space
    integer, allocatable :: mip_d(:)
    
    !> define connected gas space
    integer, allocatable :: mip_g(:)
    
    !> total gas pressure space (Pa)
    real*8, allocatable :: mip_pgt(:)
    
    !> location of gas source, corresponding to boundary volumes
    integer, allocatable :: mip_brt_idx(:)  
    
    !> mark if the volume is a gas source boundary volume
    integer, allocatable :: mip_brt_flags(:)    
    
    !> number of control volumes of mip bubble source
    integer :: mip_brt_num
    
    !> number of bubble clusters
    integer :: mip_bdcluster_num
    
    !> mineral index corresponding to component
    integer, allocatable :: mip_brt_comp(:)
    
    !> define connected gas space for mass transfer
    !> for clusters connected to the boundary values (source/sink)
    !> 1 for connected volumes and 0 for unconnected volumes
    integer, allocatable :: mip_g_bws(:)
    !> corresponding to mip_g_bws, nonzero value ivol for connected volume 
    !> of boundary volume ivol and 0 for unconnected volumes
    integer, allocatable :: mip_g_vols(:)


    !> ----------------------------------------
    !> flow information
    !> ----------------------------------------
    
    !> update permeability based on gas saturation
    logical :: mip_update_relperm
    
    
    !> ----------------------------------------
    !> concentration information
    !> ----------------------------------------
    
    !> Constant Henry's law coefficients for gases (Pa.m3/mol) [O2, N2, NAPL]
    real*8, allocatable :: mip_henry(:)    
   
    !> partitioning constant (-)
    real*8, allocatable :: mip_partition_k(:)
    
    !> partial pressure matrix (Pa)
    real*8, allocatable :: mip_pg(:,:)    
    
    !> partial pressure matrix (Pa) in previous bubble activity
    real*8, allocatable :: mip_pg_old(:,:)

    !> aqueous concentration, [moles/l water]
    !> corresponding to gas phase only, not all aqueous phase in MIN3P
    real*8, allocatable :: mip_cw(:,:)
    
    !> total concentration of compound in the aqueous and gas phases, [moles/l water]
    real*8, allocatable :: mip_ct(:,:)
    
    !> total concentration of compound in the aqueous and gas phases of 
    !> current control volume, [moles/l water]    
    real*8, allocatable :: mip_ct_vol(:,:)
    
    !> ----------------------------------------
    
    !> random seed
    integer :: mip_rlist_seed
    !> random pore radius (m)
    real*8, allocatable :: mip_rlist(:)
    
    !> pore radius based on entry pressure (m)
    real*8, allocatable :: mip_rp(:)
    
    !> water pressure (m)
    real*8, allocatable :: mip_pw(:)
    real*8, allocatable :: mip_pw_vol(:)
    
    !> entry pressure (m of H2O)
    real*8, allocatable :: mip_pd(:)
    real*8, allocatable :: mip_pd_vol(:)
    
    !> breakthrough pressure (m of H2O)
    real*8, allocatable :: mip_pe(:)
    
    !> terminal pressure (m of H2O)
    real*8, allocatable :: mip_pt(:)
    
    !> entry threshold (m of H2O)
    real*8, allocatable :: mip_te(:)
    
    !> terminal threshold (m of H2O)
    real*8, allocatable :: mip_tt(:)
    
    !> bwlabeln image processing results
    integer, allocatable :: mip_bwlabels(:) 
    
    !> define matrix of 1 cluster per space, mip_clusters(nvols,num)
    integer, allocatable :: mip_clusters(:,:)
    
    !> temporaly matrix, mip_cluster_a(nvols), mip_cluster_i
    integer, allocatable :: mip_cluster_a(:)
    real*8, allocatable :: mip_cluster_i(:)
    real*8, allocatable :: mip_cluster_ri(:)
    
    !> temporatory nonzero value/indices storage
    integer, allocatable :: mip_indices_a(:)
    integer, allocatable :: mip_indices_i(:)
    integer, allocatable :: mip_indices_sg(:)
    real*8, allocatable :: mip_values_i(:)
    
    !> convergence variables
    logical :: mip_mt_not_converged
    
    !> information level
    integer :: mip_idetail
    
    !> debug information
    integer :: info_debug
    
    !> read pore radius from external file
    logical :: mip_external_rp_file
    
#ifdef OPENMP
    integer :: chunk
#endif
    
contains

    !> 
    !> mip model control parameters
    !>
    subroutine mip_ctrl_params
    
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use phys, only : dens_h2o 
      use gen,  only : ilog, idat, itmp, igen, rank, time_factor,      &
                       b_enable_output,  b_enable_output_gen,          &
                       gacc, nvxgl, nvygl, nvzgl, uvsnew, zg, n,       &
                       zlmaxgbl, zlmingbl, numofthreads_mip_bubble,    &
                       memory_monitor
      
      use chem, only : ng, nx, nameg, tempk, rgasjoule, pa_atm, rgasatm
      
      use bbls, only : gas_pair, gas_species
      
#ifdef GPL
      use gn_mod, only : limit, abstol, reltol, iprint, iscale,        &
                         ZLOW, ZHIGH, ZCONSEC, ZCPMIN, ZCPMAX, ZCP,    &
                         NewtStep1st
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
    
      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: i, igas, ip, ierr, ierrcd, ivol, l_string, nvols_half
      
      real*8 :: cfd_a
      
      logical :: found_section, found_subsection
      
      character*72 :: section_header, subsection
      
      external CheckErr, readbloc 

      ierrcd = 0
      info_debug = -1
     
      !c assign domain variables      
      !> number of blocks in x direction
      mip_nvx = nvxgl   
      !> number of blocks in y direction
      mip_nvy = nvygl     
      !> number of blocks in z direction
      mip_nvz = nvzgl
      !> number of total blocks
      mip_nvols = mip_nvx*mip_nvy*mip_nvz
      nvols_half = ceiling(mip_nvols/2.0d0)
      
      if (mip_nvx > 1 .and. mip_nvy > 1 .and. mip_nvz > 1) then
        mip_bwlabeln_mode = 6     !or 18 or 26  
      else if ((mip_nvx > 1 .and. mip_nvy > 1) .or.                    &
               (mip_nvy > 1 .and. mip_nvz > 1) .or.                    &
               (mip_nvx > 1 .and. mip_nvz > 1)) then
        mip_bwlabeln_mode = 4     !or 8  
      else
        mip_bwlabeln_mode = 2           
      end if
      
      !c assign parameters for mip_mt model
      
      !c initial cluster connected to the napl surface
      mip_bdcluster_num = 0
      
      !> water density (kg/m3)
      mip_density = dens_h2o
      !> gravitational acceleration (m/s2)
      mip_gravity = gacc
      !> density times gravity, convert ratio of water head (m) to Pa
      mip_hw2pa = dens_h2o*gacc
      
      !> temperature (K)
      mip_t = tempk
      !> gas constant in (m3.Pa/mol.K)
      mip_r = rgasjoule
      !> atmospheric pressure (Pa)
      mip_patm = pa_atm
      !> gas conversion parameter
      mip_rgasjoule_tempks = mip_r*mip_t*1.0d3 
      
      !> air-water interfacial tension (N/m)
      mip_ift = 0.072d0
      !> displacement pressure (m of H2O)
      mip_hd = 0.0542d0
      !> Brooks-Corey exponent
      mip_gamma = 3.94d0        
      !> Pe/Pt ratio
      mip_alpha_pept = 1.0d0/0.57d0      
   
      !c assign parameters for gas variables      
      !> number of gases
      mip_ngas = ng
      
      !> number of aquous species, excluding H2O, equal to number of unknows per volume
      mip_nc = n
      
      !> number of secondary species
      mip_nx = nx
      
      !> critical spanning gas saturation
      mip_sgcrit = 0.30d0
      
      !> sg corresponding to breakthrough pressure Pe
      mip_sgm = mip_sgcrit
      
      !> critical bubble contraction pressure [Pa]
      mip_pg_contraction = 0.0d0
      
      !> critical bubble contraction saturation (-)
      mip_sg0 = 0.08
      
      !> redisual water saturation, hardwired
      !> corresponding to MIN3P swr(izn), izn = mprop(ivol)
      mip_swr = 0.03      
      
      !> hydraulic conductivity in bubble region
      mip_adjust_bubble_cond = .false.
      mip_bubble_cond_ratio = 1.0d-20    
     
      !> update pressure and bubble entry/terminal threshold
      mip_update_bubble_entry = .false.
      
      !> tolerance
      mip_tolerance = 1.0d-4   
      
      !> pressure shift for unsaturated flow part
      mip_pressure_shift = abs(zlmaxgbl-zlmingbl)
      
      !> sgstore
      mip_sgstore = 0.0d0
      
      !> force same sequence of random numbers each time
      mip_rlist_seed = 11

      !> allocate gas pair
      allocate (mip_gas2aqueous(mip_ngas), stat = ierr)
      mip_gas2aqueous = 1
      call checkerr(ierr,'mip_gas2aqueous',ilog)
      call memory_monitor(sizeof(mip_gas2aqueous),'mip_gas2aqueous',.true.)
      
      allocate (mip_aqueous2gas(mip_ngas), stat = ierr)
      mip_aqueous2gas = 1
      call checkerr(ierr,'mip_gas2aqueous',ilog) 
      call memory_monitor(sizeof(mip_aqueous2gas),'mip_aqueous2gas',.true.)     
      
      !> allocate gas species, ng, nx
      allocate (mip_gasspecies(mip_ngas, mip_nx), stat = ierr)
      mip_gasspecies = .false.
      call checkerr(ierr,'mip_gasspecies',ilog)
      call memory_monitor(sizeof(mip_gasspecies),'mip_gasspecies',.true.)
      
      !> allocate memory space
      allocate (mip_psat(mip_ngas), stat = ierr)
      mip_psat = 0.0d0
      call checkerr(ierr,'mip_psat',ilog)
      call memory_monitor(sizeof(mip_psat),'mip_psat',.true.)
      
      !> sg space
      allocate (mip_sg(mip_nvols), stat = ierr)
      mip_sg = 0.0d0
      call checkerr(ierr,'mip_sg',ilog)
      call memory_monitor(sizeof(mip_sg),'mip_sg',.true.)
      
      !> sg space prior to redistribution
      allocate (mip_sg_pre(mip_nvols), stat = ierr)
      mip_sg_pre = 0.0d0
      call checkerr(ierr,'mip_sg_pre',ilog)
      call memory_monitor(sizeof(mip_sg_pre),'mip_sg_pre',.true.)
      
      !> disconnected gas space
      allocate (mip_d(mip_nvols), stat = ierr)
      mip_d = 0
      call checkerr(ierr,'mip_d',ilog) 
      call memory_monitor(sizeof(mip_d),'mip_d',.true.)
      
      !> connected gas space
      allocate (mip_g(mip_nvols), stat = ierr)
      mip_g = 0
      call checkerr(ierr,'mip_g',ilog)
      call memory_monitor(sizeof(mip_g),'mip_g',.true.)
      
      !> total gas pressure space
      allocate (mip_pgt(mip_nvols), stat = ierr)
      mip_pgt = 0.0d0
      call checkerr(ierr,'mip_pgt',ilog)
      call memory_monitor(sizeof(mip_pgt),'mip_pgt',.true.)
      
      !c concentration information      
      !> Henry's law coefficients for gases (Pa.m3/mol) [O2, N2, NAPL]
      allocate (mip_henry(mip_ngas), stat = ierr)
      mip_henry = 0.0d0
      call checkerr(ierr,'mip_henry',ilog)
      call memory_monitor(sizeof(mip_henry),'mip_henry',.true.)
      
      !> partitioning constant (-)
      allocate (mip_partition_k(mip_ngas), stat = ierr)
      mip_partition_k = 0.0d0
      call checkerr(ierr,'mip_partition_k',ilog)
      call memory_monitor(sizeof(mip_partition_k),'mip_partition_k',.true.)   
      
      !> partial pressure matrix
      allocate (mip_pg(mip_ngas,mip_nvols), stat = ierr)
      mip_pg = 0.0d0
      call checkerr(ierr,'mip_pg',ilog)
      call memory_monitor(sizeof(mip_pg),'mip_pg',.true.)
      
      !> partial pressure matrix in previous bubble activity step
      allocate (mip_pg_old(mip_ngas,mip_nvols), stat = ierr)
      mip_pg_old = 0.0d0
      call checkerr(ierr,'mip_pg_old',ilog)
      call memory_monitor(sizeof(mip_pg_old),'mip_pg_old',.true.)

      !> aqueous concentration, corresponding to gas, including other aqueous species
      allocate (mip_cw(mip_ngas,mip_nvols), stat = ierr)
      mip_cw = 0.0d0
      call checkerr(ierr,'mip_cw',ilog) 
      call memory_monitor(sizeof(mip_cw),'mip_cw',.true.)
      
      !> total aqueous concentration, corresponding to gas, including other aqueous species
      allocate (mip_ct(mip_ngas,mip_nvols), stat = ierr)
      mip_ct = 0.0d0
      call checkerr(ierr,'mip_ct',ilog)
      call memory_monitor(sizeof(mip_ct),'mip_ct',.true.)
      
      allocate (mip_ct_vol(mip_ngas, numofthreads_mip_bubble), stat = ierr)
      mip_ct_vol = 0.0d0
      call checkerr(ierr,'mip_ct_vol',ilog)
      call memory_monitor(sizeof(mip_ct_vol),'mip_ct_vol',.true.) 
      
      allocate (mip_pd_vol(numofthreads_mip_bubble), stat = ierr)
      mip_pd_vol = 0.0d0
      call checkerr(ierr,'mip_pd_vol',ilog) 
      call memory_monitor(sizeof(mip_pd_vol),'mip_pd_vol',.true.)
      
      allocate (mip_pw_vol(numofthreads_mip_bubble), stat = ierr)
      mip_pw_vol = 0.0d0
      call checkerr(ierr,'mip_pw_vol',ilog) 
      call memory_monitor(sizeof(mip_pw_vol),'mip_pw_vol',.true.)
      
      !> assign pore radius based on entry pressure (m)
      allocate (mip_rp(mip_nvols), stat = ierr)
      mip_rp = 0.0d0
      call checkerr(ierr,'mip_rp',ilog)
      call memory_monitor(sizeof(mip_rp),'mip_rp',.true.)
      
      !> assign water pressure (cm)
      allocate (mip_pw(mip_nvols), stat = ierr)
      mip_pw = 0.0d0
      call checkerr(ierr,'mip_pw',ilog) 
      call memory_monitor(sizeof(mip_pw),'mip_pw',.true.)
      
      !> entry pressure (m of H2O)
      allocate (mip_pd(mip_nvols), stat = ierr)
      mip_pd = 0.0d0
      call checkerr(ierr,'mip_pd',ilog) 
      call memory_monitor(sizeof(mip_pd),'mip_pd',.true.)
      
      !> breakthrough pressure (m of H2O)
      allocate (mip_pe(mip_nvols), stat = ierr)
      mip_pe = 0.0d0
      call checkerr(ierr,'mip_pe',ilog) 
      call memory_monitor(sizeof(mip_pe),'mip_pe',.true.)
      
      !> terminal pressure (m of H2O)
      allocate (mip_pt(mip_nvols), stat = ierr)
      mip_pt = 0.0d0
      call checkerr(ierr,'mip_pt',ilog) 
      call memory_monitor(sizeof(mip_pt),'mip_pt',.true.)
      
      !> entry threshold (m of H2O)
      allocate (mip_te(mip_nvols), stat = ierr)
      mip_te = 0.0d0
      call checkerr(ierr,'mip_te',ilog) 
      call memory_monitor(sizeof(mip_te),'mip_te',.true.)
      
      !> terminal threshold (m of H2O)
      allocate (mip_tt(mip_nvols), stat = ierr)
      mip_tt = 0.0d0
      call checkerr(ierr,'mip_tt',ilog) 
      call memory_monitor(sizeof(mip_tt),'mip_tt',.true.)
      
      !> bwlabeln image processing results
      allocate (mip_bwlabels(mip_nvols), stat = ierr)
      mip_bwlabels = 0
      call checkerr(ierr,'mip_bwlabels',ilog) 
      call memory_monitor(sizeof(mip_bwlabels),'mip_bwlabels',.true.)
      
      !> define matrix of 1 cluster per space
      allocate (mip_clusters(mip_nvols,nvols_half), stat = ierr)
      mip_clusters = 0
      call checkerr(ierr,'mip_clusters',ilog)
      call memory_monitor(sizeof(mip_clusters),'mip_clusters',.true.)
      
      !> temporaly cluster matrix
      allocate (mip_cluster_a(mip_nvols), stat = ierr)
      mip_cluster_a = 0
      call checkerr(ierr,'mip_cluster_a',ilog)
      call memory_monitor(sizeof(mip_cluster_a),'mip_cluster_a',.true.)
      
      allocate (mip_indices_a(mip_nvols), stat = ierr)
      mip_indices_a = 0
      call checkerr(ierr,'mip_indices_a',ilog)
      call memory_monitor(sizeof(mip_indices_a),'mip_indices_a',.true.)
      
      allocate (mip_indices_i(mip_nvols), stat = ierr)
      mip_indices_i = 0
      call checkerr(ierr,'mip_indices_i',ilog)
      call memory_monitor(sizeof(mip_indices_i),'mip_indices_i',.true.)
      
      allocate (mip_indices_sg(mip_nvols), stat = ierr)
      mip_indices_sg = 0
      call checkerr(ierr,'mip_indices_sg',ilog)
      call memory_monitor(sizeof(mip_indices_sg),'mip_indices_sg',.true.)
      
      allocate (mip_values_i(mip_nvols), stat = ierr)
      mip_values_i = 0.0d0
      call checkerr(ierr,'mip_values_i',ilog)
      call memory_monitor(sizeof(mip_values_i),'mip_values_i',.true.)
      
      allocate (mip_cluster_i(mip_nvols), stat = ierr)
      mip_cluster_i = 0
      call checkerr(ierr,'mip_cluster_i',ilog)
      call memory_monitor(sizeof(mip_cluster_i),'mip_cluster_i',.true.)
      
      allocate (mip_cluster_ri(mip_nvols), stat = ierr)
      mip_cluster_ri = 0
      call checkerr(ierr,'mip_cluster_ri',ilog)
      call memory_monitor(sizeof(mip_cluster_ri),'mip_cluster_ri',.true.)
      
      allocate (mip_g_bws(mip_nvols), stat = ierr)
      mip_g_bws = 0
      call checkerr(ierr,'mip_g_bws',ilog)
      call memory_monitor(sizeof(mip_g_bws),'mip_g_bws',.true.)
      
      allocate (mip_g_vols(mip_nvols), stat = ierr)
      mip_g_vols = 0
      call checkerr(ierr,'mip_g_vols',ilog)
      call memory_monitor(sizeof(mip_g_vols),'mip_g_vols',.true.)
      
      allocate (mip_brt_idx(mip_nvols), stat = ierr)
      mip_brt_idx = 0
      call checkerr(ierr,'mip_brt_idx',ilog)
      call memory_monitor(sizeof(mip_brt_idx),'mip_brt_idx',.true.)


      mip_brt_num = 0
      
      !c  read mip-mt model parameters from 
      !c  input file and write to temporary storage    
      section_header = 'control parameters - mip bubble model'
      call readbloc(idat,itmp,section_header,found_section,.true.)  
      if (.not.found_section) then
        section_header = 'control parameters - invasion percolation bubble flow'
        call readbloc(idat,itmp,section_header,found_section,.true.) 
      end if
     
      !c  define length of section header
      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
        l_string=72
      end if
      
!c  write section header to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a)')('-',i=1,72)
      end if

      if(rank == 0 .and. b_enable_output) then
        write(*,'(/1x,a)') section_header(:l_string)
        write(*,'(1x,72a)')('-',i=1,72)
      end if
      
      if (rank == 0 .and. b_enable_output) then
        write(ilog,'(a)') 'mip bubble model'
      end if
      
      if (found_section) then
          
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(/a)')'physical constants:'
          write(igen,'(a)') '-------------------'
        end if
          
        subsection = 'air-water interfacial tension'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 1
          read(itmp,*,err=999,end=999) mip_ift
        end if 
        
        subsection = 'update bubble relative permeability'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          mip_update_relperm = .true.
        else
          mip_update_relperm = .false.
        end if
        
        subsection = 'update bubble entry and terminal threshold'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          mip_update_bubble_entry = .true.
        else
          mip_update_bubble_entry = .false.  
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1x,l1)')                                  &
            'update bubble entry and terminal threshold [-]      = ',&
            mip_update_bubble_entry
        end if
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'air-water interfacial tension [N/m]                 = ',&
               mip_ift
        end if
        
        subsection = 'displacement pressure'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 2
          read(itmp,*,err=999,end=999) mip_hd
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'displacement pressure [m of H2O]                    = ',&
               mip_hd
        end if
        
        subsection = 'brooks-corey exponent'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 3
          read(itmp,*,err=999,end=999) mip_gamma
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'brooks-corey exponent [-]                           = ',&
               mip_gamma
        end if
        
        subsection = 'ratio of terminal pressure over entry pressure'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 4
          read(itmp,*,err=999,end=999) mip_alpha_pept
          mip_alpha_pept = 1.0d0/mip_alpha_pept
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'ratio of terminal pressure over entry pressure [-]  = ',&
               1.0d0/mip_alpha_pept
        end if

        subsection = 'critical spanning gas saturation'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 5
          read(itmp,*,err=999,end=999) mip_sgcrit
          mip_sgm = mip_sgcrit
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'critical spanning gas saturation [-]                = ',&
               mip_sgcrit
        end if
        
        subsection = 'critical bubble contraction pressure'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 6
          read(itmp,*,err=999,end=999) mip_pg_contraction
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'critical bubble contraction pressure [Pa]           = ',&
               mip_pg_contraction
        end if
        
        subsection = 'critical bubble contraction saturation'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 7
          read(itmp,*,err=999,end=999) mip_sg0
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'critical bubble contraction saturation [-]          = ',&
               mip_sg0
        end if
        
        subsection = 'residual water saturation'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 8
          read(itmp,*,err=999,end=999) mip_swr
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'residual water saturation [-]                       = ',&
               mip_swr
        end if
        
        subsection = 'random pore radius seed'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 9
          read(itmp,*,err=999,end=999) mip_rlist_seed
        else
          mip_rlist_seed = 0
        end if 
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1x,i6)')                                      &
              'random pore radius seed [-]                         = ',&
               mip_rlist_seed
        end if
        
        subsection = 'bubble hydraulic conductivity ratio'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          mip_adjust_bubble_cond = .true.
          ierrcd = 10
          read(itmp,*,err=999,end=999) mip_bubble_cond_ratio
          if(rank == 0 .and. b_enable_output) then
            write(igen,'(a,1pe12.4)')                                  & 
              'bubble hydraulic conductivity ratio [-]             = ',&
              mip_bubble_cond_ratio
          end if
        else
          mip_adjust_bubble_cond = .false.  
        end if     
        
        mip_sg_collapse = 0.30d0
        mip_pw_collapse = -0.10d0
        subsection = 'bubble collapse threshold in capillary fringe'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 11
          read(itmp,*,err=999,end=999) mip_sg_collapse, mip_pw_collapse         
        end if 
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
            'air saturation threshold for bubble collapse [-]    = ',  &
            mip_sg_collapse
          write(igen,'(a,1pe12.4)')                                    & 
            'water pressure threshold for bubble collapse [m]    = ',  &
            mip_pw_collapse
        end if
       
        !c other mip-mt parameters read from MIN3P general parameters
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(a,1pe12.4)')                                    & 
              'water density [kg/m^3]                              = ',&
               mip_density
          write(igen,'(a,1pe12.4)')                                    & 
              'gravitational acceleration [m/s^2]                  = ',&
               mip_gravity
          write(igen,'(a,1pe12.4)')                                    & 
              'kelvin temperature  [K]                             = ',&
               mip_t
          write(igen,'(a,1pe12.4)')                                    & 
              'gas constant in [m3.Pa/mol.K]                       = ',&
               mip_r
          write(igen,'(a,1pe12.4)')                                    & 
              'atmospheric pressure [Pa]                           = ',&
               mip_patm
        end if
        
        !c parameters for gas component
        subsection = 'saturated gas pressure'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          do igas = 1, mip_ngas
            ierrcd = 12
            read(itmp,*,err=999,end=999) mip_psat(igas)  
          end do
        else
          goto 998
        end if
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(/a)') 'saturated gas pressure [Pa]:         '
          write(igen,'(a)')  '-------------------------------------'
          do igas = 1, mip_ngas  
            write(igen,'(a12,1x,1pe15.4)') nameg(igas), mip_psat(igas)
          end do
        end if
        
        subsection = 'henrys law coefficient'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          do igas = 1, mip_ngas
            ierrcd = 13
            read(itmp,*,err=999,end=999) mip_henry(igas)  
            mip_partition_k(igas)=mip_henry(igas)/mip_t/mip_r
          end do
        else
          goto 998
        end if
        
        if(rank == 0 .and. b_enable_output) then
          write(igen,'(/a)') 'henrys law coefficient [Pa m^3/mol]: '
          write(igen,'(a)')  '-------------------------------------'
          do igas = 1, mip_ngas  
            write(igen,'(a12,1x,1pe15.4)') nameg(igas), mip_henry(igas)
          end do
          
          write(igen,'(/a)') 'partitioning constant [-]:           '
          write(igen,'(a)')  '-------------------------------------'
          do igas = 1, mip_ngas  
            write(igen,'(a12,1x,1pe15.4)') nameg(igas), mip_partition_k(igas)
          end do          
        end if

        !c maximum bubble pressure update in iteration
        subsection = 'maximum bubble pressure update'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 14
          read(itmp,*,err=999,end=999) mip_bubble_iterations,          &
               mip_max_pg_update, mip_max_pg_update_ratio
        else
          mip_bubble_iterations = 1000
          mip_max_pg_update = 1.0d0
          mip_max_pg_update_ratio = 1.0d-3
        end if

        !c parameters for newton iteration settings
        subsection = 'newton iteration settings'
#ifdef GPL
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 15
          read(itmp,*,err=999,end=999) limit
          read(itmp,*,err=999,end=999) abstol
          read(itmp,*,err=999,end=999) reltol
          read(itmp,*,err=999,end=999) mip_idetail
          read(itmp,*,err=999,end=999) iscale
          read(itmp,*,err=999,end=999) ZLOW, ZHIGH, ZCONSEC
          read(itmp,*,err=999,end=999) ZCPMIN, ZCPMAX, ZCP
          read(itmp,*,err=999,end=999) NewtStep1st
        else
          goto 998
        end if
        
        !c *******Debug information output********
        !c solver information level, 0=none, 1=final f0 and x0, 2=iterations,
        !c 3=each x tried, 4=all except Jacobian and Hessian, 5=all
        !c only for test
        iprint = 0
#endif
        
        subsection = 'debug information level'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 16
          read(itmp,*,err=999,end=999) info_debug
        else
          info_debug = -1  
        end if
     
        subsection = 'read pore radius from external file'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          mip_external_rp_file = .true.
        else
          mip_external_rp_file = .false.
        end if
        
        !c *******Debug information output*end****
        
      end if
   
      mip_gas2aqueous = gas_pair
      do igas = 1, mip_ngas
        ip = mip_gas2aqueous(igas) 
        mip_aqueous2gas(ip) = igas
      end do
      
      mip_gasspecies = gas_species
      
      !c allocate space for sg solver
      allocate(mip_xsg(mip_ngas+2,mip_nvols))
      call memory_monitor(sizeof(mip_xsg),'mip_xsg',.true.)

      allocate(mip_xsg_old(mip_ngas+2,mip_nvols))
      call memory_monitor(sizeof(mip_xsg_old),'mip_xsg_old',.true.)

      !> flag to indicate if the bubble state is changed in the current bubble iteration
      allocate(mip_g_flag(mip_nvols))
      call memory_monitor(sizeof(mip_g_flag),'mip_g_flag',.true.)
      
#ifdef DEBUG
      mip_pgavgt_max = 0.0d0 
      mip_pgavgt_min = 1.0d100
#endif

      return
      
998   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',trim(subsection),' is missing"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
     
999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
    
    end subroutine mip_ctrl_params
    
    
    !> 
    !> assign initial condition
    !> 
    subroutine mip_initial_cond
    

      use gen,  only :                                                 &
#ifdef OPENMP
                       i_omp_type_mip_bubble, numofthreads_mip_bubble, &
#endif
                       ilog, idat, idbg, igen, rank, prefix, l_prfx,   &
                       gnew, cnew, totcnew, uvsnew, sgnew, zg,         &
                       totgnew, fully_saturated, variably_saturated,   &
                       memory_monitor
    
      use file_unit, only : lun_get, lun_free
      
      implicit none
      
      integer :: irp_file, ivx, ivz
      integer :: ivol, igas, ic, ip, ierr
      real*8 :: cfd_a, cfd_b, cfd_c
      
      real*8, parameter :: r0 = 0.0d0
      
#ifdef OPENMP
      chunk = mip_nvols / numofthreads_mip_bubble
      if(mod(mip_nvols, numofthreads_mip_bubble) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
#ifdef SCHEDULE_DYNAMIC
      chunk = 1                                         !This is the default chunk size for dynamic scheduling.
#endif
#endif


      !c random pore radius
      allocate (mip_rlist(mip_nvols), stat = ierr)
      mip_rlist = 0.0d0
      call checkerr(ierr,'mip_rlist',ilog) 
      call memory_monitor(sizeof(mip_rlist),'mip_rlist',.true.)

      !c generate uniform random number
      if(mip_rlist_seed <= 0) then
         call RANDOM_SEED()
      else if(mip_rlist_seed > mip_nvols) then
         mip_rlist_seed = mip_nvols
         call RANDOM_SEED(size=mip_rlist_seed) 
      else
        call RANDOM_SEED(size=mip_rlist_seed)
      end if
      call RANDOM_NUMBER(mip_rlist(1:mip_nvols))   
      
      !c lumped parameter for CFD
      cfd_a = (mip_density*mip_gravity*mip_hd/2.0d0/mip_ift/1000)**mip_gamma
      cfd_b = 2.0d0*mip_ift/mip_density/mip_gravity
      cfd_c = (((1.0d0-mip_sgm)-mip_swr)/(1.0d0-mip_swr))**(-1.0d0/mip_gamma)  
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol, igas, ip)                                    
#endif

#ifdef OPENMP      
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
      !c critical pore radius based on entry pressure (m)
      do ivol = 1, mip_nvols
        mip_rp(ivol) = (mip_rlist(ivol)/cfd_a)**(1.0d0/mip_gamma)/1000.0d0
      end do
#ifdef OPENMP
    !$omp end do
#endif
      
      !c read from matlab exported data for test   
      if (mip_external_rp_file) then
        irp_file = lun_get()
        open(irp_file,file=prefix(:l_prfx)//'.rp',status='old')
        do ivz = 1, mip_nvz-1
          read(irp_file,*) mip_rp((ivz-1)*mip_nvx+1:ivz*mip_nvx-1)
        end do
        close(irp_file)
        call lun_free(irp_file)
        
        do ivz = 1, mip_nvz-1
          do ivx = 1, mip_nvx-1
            mip_rp((ivz-1)*mip_nvx+ivx) = mip_rp((ivz-1)*mip_nvx+ivx)*1.0d-3
          end do
        end do
      else
        irp_file = lun_get()
        open(irp_file,file=prefix(:l_prfx)//'_o.rp',status='unknown')
        do ivz = 1, mip_nvz
          write(irp_file,'(1000e16.8)') mip_rp((ivz-1)*mip_nvx+1:ivz*mip_nvx)*1.0d3             !convert from unit m to mm.
        end do
        close(irp_file)
        call lun_free(irp_file)
      end if
#ifdef OPENMP 
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
      do ivol = 1, mip_nvols
        !c entry pressure (m of H2O)  
        mip_pd(ivol) = cfd_b / mip_rp(ivol)
        !c breakthrough presure (m of H2O)
        mip_pe(ivol) = cfd_c * mip_pd(ivol)
        !c terminal pressure (m of H2O)
        mip_pt(ivol) = mip_pe(ivol) / mip_alpha_pept
      end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
      !c modify re-invasion potential
      do ivol = 1, mip_nvols
        if (mip_d(ivol) == 1) then
          !c decrease re-invasion potential at pool surface due to NAPL presence  
          mip_pt(ivol) = mip_pt(ivol) / 10.0d0
        end if
      end do
#ifdef OPENMP
    !$omp end do
#endif
           
      !> assign flow and reactive transport variables from MIN3P 
      !c gas partial pressure
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
      do ivol = 1, mip_nvols
        mip_sg(ivol) = sgnew(ivol)
      end do
#ifdef OPENMP
    !$omp end do
#endif

      !c water pressure head (m)
      if (fully_saturated) then
#ifdef OPENMP          
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
        do ivol = 1, mip_nvols
          mip_pw(ivol) = uvsnew(ivol) - zg(ivol)
        end do
#ifdef OPENMP
    !$omp end do
#endif
      else if (variably_saturated) then
#ifdef OPENMP          
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
        do ivol = 1, mip_nvols
          mip_pw(ivol) = uvsnew(ivol)
        end do
#ifdef OPENMP
    !$omp end do
#endif
      end if

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
      do ivol = 1, mip_nvols
        !c entry threshold (m of H2O)
        mip_te(ivol) = mip_pe(ivol) + mip_pw(ivol)
        !c terminal threshold (m of H2O)
        mip_tt(ivol) = mip_pt(ivol) + mip_pw(ivol) 
      end do
#ifdef OPENMP
    !$omp end do
#endif

      !c assign partial gas pressure
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
      do ivol = 1, mip_nvols
        mip_pgt(ivol) = 0.0d0  
        do igas = 1, mip_ngas
          mip_pg(igas,ivol) = gnew(igas,ivol)*mip_rgasjoule_tempks
          mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
        end do
      end do
#ifdef OPENMP
    !$omp end do
#endif
      
      !c aqueous concentration
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas
          ip = mip_gas2aqueous(igas) 
          mip_cw(igas,ivol) = cnew(ip,ivol)
        end do
      end do 
#ifdef OPENMP
    !$omp end do
#endif
     
      !c total concentration of aqueous and gas phases
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas
          ip = mip_gas2aqueous(igas)
          
          !c use concentration of aqueous from MIP model
          !mip_ct(igas,ivol) = (1.0d0+(mip_partition_k(igas)-1.0d0)*    &
          !                     mip_sg(ivol))*mip_cw(igas,ivol)
          
          !c use concentration of aqueous and gas phase from MIN3P  (optional, slightly different)
          mip_ct(igas,ivol) = (1.0d0-mip_sg(ivol))*totcnew(ip,ivol)+   &
                               mip_sg(ivol)*totgnew(ip,ivol)

        end do
      end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif 

      !c release memory for unused variables
      call memory_monitor(-sizeof(mip_rlist),'mip_rlist',.true.)
      deallocate(mip_rlist)
    
    end subroutine mip_initial_cond
    
    
    
    !> 
    !> assign boundary condition volumes
    !> 
    subroutine mip_boundary_vols
    
      use gen,  only : idbg, ilog, b_enable_output, memory_monitor
      use chem, only : iam, jam, nc
    
      implicit none
      
      integer :: i1, i2, ivol, ierr, im, ic, istart, istop, ncomp

      integer, allocatable :: iwork(:)
      
      !c reallocate boundary volumes of napl source
      
      allocate (iwork(mip_brt_num), stat = ierr)
      iwork = 0
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'iwork',.true.)
      
      iwork(1:mip_brt_num) = mip_brt_idx(1:mip_brt_num)
      
      call memory_monitor(-sizeof(iwork),'',.true.)
      deallocate(mip_brt_idx)

      allocate (mip_brt_idx(mip_brt_num), stat = ierr)
      mip_brt_idx = 0
      call checkerr(ierr,'mip_brt_idx',ilog)
      call memory_monitor(sizeof(mip_brt_idx),'mip_brt_idx',.true.)
      mip_brt_idx = iwork
      
      call memory_monitor(-sizeof(iwork),'iwork',.true.)
      deallocate(iwork)      
     
#ifdef DEBUG
      if (info_debug == 4 .or. info_debug == 999) then
        write(idbg,*) "boundary volumes of napl source"
        do i1 = 1, mip_brt_num
          write(idbg,*) mip_brt_idx(i1)
        end do
      end if  
#endif

      allocate(mip_brt_flags(mip_nvols), stat = ierr)
      mip_brt_flags = 0
      call checkerr(ierr,'mip_brt_flags',ilog)
      call memory_monitor(sizeof(mip_brt_flags),'mip_brt_flags',.true.)
      
      do ivol = 1, mip_nvols
        if (any(mip_brt_idx == ivol)) then
          mip_brt_flags(ivol) = 1  
        end if
      end do

      !c find the index of napl in minerals
      allocate (iwork(nc), stat = ierr)
      iwork = 0
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'iwork',.true.)
      
      ncomp = 0
      do im = 1, size(iam,1)-1
        istart = iam(im)
        istop = iam(im+1)-1 
        do i1 = istart, istop
          ic = jam(i1)
          if (all(iwork /= ic)) then
            ncomp = ncomp + 1
            iwork(ncomp) = ic
          end if
        end do
      end do
      
      allocate (mip_brt_comp(ncomp), stat = ierr)
      mip_brt_comp = 0
      call checkerr(ierr,'mip_brt_comp',ilog)
      call memory_monitor(sizeof(mip_brt_comp),'mip_brt_comp',.true.)
      
      mip_brt_comp(1:ncomp) = iwork(1:ncomp)
      
      call memory_monitor(-sizeof(iwork),'iwork',.true.)
      deallocate(iwork)
      
#ifdef DEBUG
      if (info_debug == 2 .or. info_debug == 999) then
        write(idbg,*) "index of mineral-napl"
        do i1 = 1, size(mip_brt_comp,1)
          write(idbg,*) mip_brt_comp(i1)
        end do
      end if  
#endif
      
    end subroutine mip_boundary_vols

    !>
    !> Pass MIN3P variables to MIP model and apply MIP boundary condition
    !>
    subroutine mip_solver_input

      use phys, only : aentry

      use gen,  only :                                                 &
#ifdef OPENMP
                       i_omp_type_mip_bubble, numofthreads_mip_bubble, &
                       maxvol_omp, maxval_omp,                         &
#endif
                       gnew, cnew, uvsnew, rank, ilog, idbg, totcnew,  &
                       totgnew, zg, time_io, fully_saturated, totcflux,&
                       variably_saturated, delt, cvol, mpropvs, sgnew, &
                       pornew, memory_monitor
    
      implicit none

      integer :: i, j, ivol, igas, ip, ix, jvol, istart, iend, tid,    &
                 izn, chunk, itemp

      real*8 :: rtemp, rtemp2, rGasInRate, rGasIn, rGasVol
      
      tid = 1                          !  temporary use
      
      !c update aqueous concentrations
#ifdef DEBUG
      if (info_debug == 1 .or. info_debug == 999) then
        write(idbg,*) "ivol    mip-cw (mol/l)   mip-ct (mol/l)"
      end if
#endif

#ifdef OPENMP
      chunk = mip_nvols / numofthreads_mip_bubble
      if(mod(mip_nvols, numofthreads_mip_bubble) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
#ifdef SCHEDULE_DYNAMIC
      chunk = 1                                         !This is the default chunk size for dynamic scheduling.
#endif
#endif

      !c calculate aqueous concentration
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol, igas, ip)                                    
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif   
#endif
      do ivol = 1, mip_nvols
        mip_sg(ivol) = sgnew(ivol)
        do igas = 1, mip_ngas
          ip = mip_gas2aqueous(igas)
          
          !c aqueous concentration
          mip_cw(igas,ivol) = cnew(ip,ivol)

          !c gas phase
          mip_pg(igas,ivol) = gnew(igas,ivol) * mip_rgasjoule_tempks          

          !c total concentration of aqueous and gas phases
          !c to be checked later
          !c mip_ct(igas,ivol) = totcnew(ip,ivol)          

          !c use concentration of aqueous from MIP
          !mip_ct(igas,ivol) = (1.0d0+(mip_partition_k(igas)-1.0d0)*    &
          !                     mip_sg(ivol))*mip_cw(igas,ivol)
          
          !c use concentration of aqueous and gas phase from MIN3P
          mip_ct(igas,ivol) = (1.0d0-mip_sg(ivol))*totcnew(ip,ivol) +  &
                               mip_sg(ivol)*totgnew(ip,ivol)
        end do

        mip_pgt(ivol) = sum(mip_pg(:,ivol))

#ifdef DEBUG
          if (info_debug  == 7 .or. info_debug == 999) then
            if(ivol==922 .or. ivol==1033) then
              write(idbg,*) "check mip_ct, sg ", mip_sg(ivol)," totcnew(:,ivol) ",&
                            totcnew(:,ivol)," totgnew(:,ivol) ",totgnew(:,ivol)
            end if
          end if
#endif
      end do 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
      
      !c update bubble entry and terminal threshold
      if (mip_update_bubble_entry) then       
        if (fully_saturated) then
          mip_pw = uvsnew - zg
        else if (variably_saturated) then
          mip_pw = uvsnew
        end if

        do ivol = 1, mip_nvols
          !c entry threshold (m of H2O)
          mip_te(ivol) = mip_pe(ivol) + mip_pw(ivol)
          !c terminal threshold (m of H2O)
          mip_tt(ivol) = mip_pt(ivol) + mip_pw(ivol)
        end do
      end if

!c to be checked later, apply MIP boundary condition, hardwired here
!c control volume 34, apply to third gas component
!c cvol(34) = 0.004*0.004/rhalf = 1.6d-5 m^3
!c porosity = 0.40
!c 1,1,1-tca solubility 9.82d-3 mol/L, dt = 170s,
!c pg = cw*henry*1.0d3 = 9.82d-3 mol/L * 1.692d3 Pa m^3/mol * 1.0d3 L/m^3
!c    = 1.6615d4 Pa


      
      igas = 3
      !do ivol = 15, 15
      do ivol = 15, 90, 15
        mip_sg(ivol) = 0.30          !assumption
        
        !c gas injection rate in mol/day
        !rGasInRate = 1.5d-4            !mol/day
        !rGasInRate = 1.5d-3            !mol/day
        rGasInRate = 2.0d-3 * (ivol/15.0)

        rGasIn = rGasInRate * delt     !mol
  
        !c apply ideal gas law to calculate pressure of the gas
        rGasVol = cvol(ivol)*pornew(ivol)*mip_sg(ivol)
        mip_pg(igas,ivol) = mip_pg(igas,ivol) + rGasIn/rGasVol/1.0d3*mip_rgasjoule_tempks
  
        !c apply Henry's law to calculate aqueous phase concentration
        mip_cw(igas,ivol) = mip_pg(igas,ivol)/mip_henry(igas)/1.0d3
        mip_pgt(ivol) = sum(mip_pg(:,ivol))
        do i = 1, 3
          mip_ct(i,ivol) = mip_pg(i,ivol)/mip_r/mip_t*mip_sg(ivol)/1.0d3 + &
                              mip_cw(i,ivol)*(1.0d0-mip_sg(ivol))
        end do      
  
        !c to be checked later
        !write(*,*) "after  Pg=",mip_pg(:,ivol), "Pgt=",mip_pgt(ivol),    &
        !           "Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol),              &
        !           "gnew",gnew(:,ivol),"uvsnew",uvsnew(ivol),"sg",mip_sg(ivol)
      end do
     
      if (mip_idetail == 1) then
        write(*,'(/a)') "MIP_MT Solver Convergence Summary:"
        write(*,'(2a)') "  Volumes    MaxIters    MaxResidual",      &
              "    MaxUpdate    MaxRatio    MaxVol    Specie"
        write(ilog,'(/a)') "MIP_MT Solver Convergence Summary:"
        write(ilog,'(2a)') "  Volumes    MaxIters    MaxResidual",   &
              "    MaxUpdate    MaxRatio    MaxVol    Specie"
      else if (mip_idetail == 2) then
        write(*,'(/a)') "MIP_MT Solver Convergence Detail:"
        write(*,'(a)') "  Volume  Iterations    Residual    Solver Info"
        write(ilog,'(/a)') "MIP_MT Solver Convergence Detail:"
        write(ilog,'(a)') "  Volume  Iterations    Residual    Solver Info"
      end if
      
#ifdef DEBUG
      if (info_debug == 7 .or. info_debug == 999) then
        itemp = 0
        rtemp = 0.0d0
        rtemp2 = 0.0d0
        mip_sg_sum_napl_cluster = 0.0d0
        mip_sg_sum_napl_cluster2 = 0.0d0
        do i = 1, mip_nvols
          if (mip_sg(i) > 0.0d0 .and. mip_g(i) > 0) then
            itemp = itemp + 1
            rtemp = rtemp + mip_sg(i)
            rtemp2 = rtemp2 + sgnew(i)
            if (mip_g_vols(i) > 0) then
              mip_sg_sum_napl_cluster = mip_sg_sum_napl_cluster + mip_sg(i)
              mip_sg_sum_napl_cluster2 = mip_sg_sum_napl_cluster2 + sgnew(i)
            end if
          end if
        end do
        write(idbg,*) "sum of sg before ",rtemp,                      &
              " sum of sgnew ", rtemp2," delt_sg ",                   &
              rtemp-mip_sg_sum," nvols ", itemp, " napl_cluster_vols",&
              mip_napl_cluster_vols, " sg_napl_cluster ",             &
              mip_sg_sum_napl_cluster, " sgnew_napl_cluster ",        &
              mip_sg_sum_napl_cluster2
        mip_sg_sum = rtemp
        mip_napl_cluster_vols = 0
      end if
      if (info_debug == 6 .or. info_debug == 999) then
        do i = 1, 6
          do j = 32, 36
            ivol = (i-1)*111+j
             write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),4(a,1x,3(e16.8,1x)))')&
                   "ivol",ivol,"initial    Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),           &
                   "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol),             &
                   "gnew",gnew(:,ivol),"totcnew",totcnew(1:mip_ngas,ivol),                   &
                   "totgnew",totgnew(1:mip_ngas,ivol)
          end do
        end do
      end if         

      if (info_debug == 10 .or. info_debug == 999) then
        ivol = 34  
        jvol = 145
        write(idbg,'(2(4(a,1x,e10.2,1x),a,1x,3(e10.2,1x),a,1x,e10.2,1x,2(a,1x,3(e10.2,1x))))')&
              "t=", time_io,"Sg=",mip_sg(ivol),"pw=",mip_pw(ivol),                         &
              "pd=",mip_pd(ivol),"Pg=",mip_pg(:,ivol),                                     &
              "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol),                &
              "t=", time_io,"Sg=",mip_sg(jvol),"pw=",mip_pw(jvol),                         &
              "pd=",mip_pd(jvol),"Pg=",mip_pg(:,jvol),                                     &
              "Pgt=",mip_pgt(jvol),"Cw",mip_cw(:,jvol),"CT",mip_ct(:,jvol)
      end if
#endif

    end subroutine mip_solver_input

    !>
    !> Solve MIP model based on the flow and transport result from MIN3P
    !> this subroutine locates the bubble cluster and calculate gas partial
    !c pressure and aqueous concentration due to bubble redistribution
    !>
    subroutine mip_solver

      use mip_math, only : mip_math_bwlabeln, mip_math_imdilate,       &
                           mip_math_find, mip_math_bwselect


      use gen,  only :                                                 &
#ifdef OPENMP
                       i_omp_type_mip_bubble, numofthreads_mip_bubble, &
                       maxvol_omp, maxval_omp,                         &
#endif
                       gnew, cnew, uvsnew, sgnew, delt, mpropvs,       &
                       mtime, rank, ilog, idbg, ivol2bvs, btypevs,     &
                       memory_monitor

      use phys, only : aentry
      use chem, only : nameg

      implicit none

      integer :: i, j, ivol, igas, ic, num, inum, ibz, izn, ip, ibrt,  &
                 ibrt_start, ibrt_stop, ivol_entry, ivol_terminal,     &
                 istart, iend, ix, iz, jvol, i1, tid, ibvs, itemp,     &
                 num_nonzero_i, num_nonzero_a, num_nonzero_sg

      real*8 :: tcflux


      real*8 :: min_i, max_ri, gmasst, sgtot, pgavgt, pgtot,           &
                g_term, x_term, sum_pressure

      !> total gas mass in cluster
      real*8, allocatable :: gmass(:), gmass_vols(:)

      !> weighted average gas pressure
      real*8, allocatable :: pgavg(:)


      !> convergence parameters
      real*8, parameter :: pg_min = 1.0d-20, r0 = 0.0d0, conv3 = 1.0d3
      logical :: growthflag, sg_ivol_converged
      real*8  :: sg_ivol_rnorm, sg_rnorm_max, max_pg_update,           &
                 max_pg_update_ratio
      integer :: sg_nvols, sg_niter_max, sg_ivol_niter, sgsolver_info, &
                 max_pg_update_ivol, max_pg_update_igas,               &
                 bubble_iterations

      external :: flux_calc, totconc, totconcg

      real*8 :: rtemp, rtemp2

      allocate(gmass(mip_ngas))
      call memory_monitor(sizeof(gmass),'gmass',.true.)

      allocate(pgavg(mip_ngas))
      call memory_monitor(sizeof(pgavg),'pgavg',.true.)

      tid = 1                          !  temporary use

      mip_rgasjoule_tempks = mip_r*mip_t*1.0d3

#ifdef OPENMP
      chunk = mip_nvols / numofthreads_mip_bubble
      if(mod(mip_nvols, numofthreads_mip_bubble) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
#ifdef SCHEDULE_DYNAMIC
      chunk = 1                                         !This is the default chunk size for dynamic scheduling.
#endif
#endif

      !c modify and mark MIP_MT variables
      bubble_iterations = 0
      mip_g_flag = 0

      do while(mip_mt_not_converged)

      bubble_iterations = bubble_iterations + 1
      mip_pg_old = mip_pg

      sg_rnorm_max = 0.0d0
      sg_nvols = 0
      sg_niter_max = 0
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (tid, ivol, igas, ip, izn,                          &
    !$omp sg_ivol_converged, sg_ivol_niter,                           &
    !$omp sg_ivol_rnorm, sgsolver_info)                               &
    !$omp reduction(+:sg_nvols)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif  
#endif
      do ivol = 1, mip_nvols

#ifdef OPENMP
        tid = omp_get_thread_num()+1
#else
        tid = 1
#endif
          
        izn = mpropvs(ivol)  
        !c skip volume without gas or unsaturated zone
        if ((uvsnew(ivol) < aentry(izn) .and. mip_g(ivol) < 1) .or.    &
             mip_sg(ivol) <= 0.0d0) then
#ifdef DEBUG
          if (info_debug == 5 .and. mod(mtime,50) == 0 .or. info_debug == 999) then
            write(idbg,'(i6,1x,2(i4,1x),100(e10.2,1x))')               &
                  ivol,mip_d(ivol),mip_g(ivol),mip_sg(ivol),           &
                  mip_pg(:,ivol),mip_pgt(ivol),mip_cw(:,ivol),         &
                  mip_ct(:,ivol)
          end if
#endif
          cycle  
        end if        
        
#ifdef DEBUG
        if (info_debug == 3 .or. info_debug == 999) then
          write(idbg,*) "mass transfer for volume ",ivol
        end if
#endif
        
        !c initial guess, convert to Pa
        if (bubble_iterations == 1 .or. mip_g_flag(ivol) /= 0) then
          do igas = 1, mip_ngas
            mip_xsg(igas,ivol) = mip_cw(igas,ivol)*mip_henry(igas)*1.0d3
          end do
          mip_xsg(mip_ngas+1,ivol) = mip_sg(ivol)
          mip_xsg(mip_ngas+2,ivol) = mip_pe(ivol)*mip_hw2pa
        else
          mip_xsg(:,ivol) = mip_xsg_old(:,ivol)
        end if
        
        mip_ct_vol(1:mip_ngas, tid) = mip_ct(1:mip_ngas,ivol)*1.0d3
        mip_pw_vol(tid) = mip_pw(ivol)*mip_hw2pa
        mip_pd_vol(tid) = mip_pd(ivol)*mip_hw2pa  
        
      
#ifdef DEBUG
        if (info_debug == 4 .or. info_debug == 999) then
          write(idbg,'(a10,i8)') "ivol",ivol
          write(idbg,'(a10,i8)') "mip_ngas", mip_ngas
          write(idbg,'(a10,10e16.8)') "initial guess:",mip_xsg(:,ivol)
          write(idbg,'(a10,10e16.8)') "ct:",mip_ct_vol
          write(idbg,'(a10,10e16.8)') "H:",mip_henry
          write(idbg,'(a10,10e16.8)') "K:",mip_partition_k
          write(idbg,'(a10,10e16.8)') "Patm:",mip_patm
          write(idbg,'(a10,10e16.8)') "Pw:",mip_pw_vol
          write(idbg,'(a10,10e16.8)') "Pd:",mip_pd_vol
          write(idbg,'(a10,10e16.8)') "gamma:",mip_gamma
          write(idbg,'(a10,10e16.8)') "swr:",mip_swr
        end if  
#endif
        call sgsolver_gn(mip_ngas+2,mip_xsg(:,ivol),                   &
                         mip_xsg_old(:,ivol),sg_ivol_converged,        &
                         sg_ivol_niter,sg_ivol_rnorm, sgsolver_info)
        
#ifdef DEBUG
        if (info_debug == 4 .or. info_debug == 999) then
          write(idbg,'(a,1x,100(e16.8,1x))')                           &
                "solver result ",mip_xsg(:,ivol)
        end if
#endif
        
        if (sg_ivol_converged) then

          mip_xsg_old(:,ivol) = mip_xsg(:,ivol)

          if (mip_idetail == 1) then
            sg_nvols = sg_nvols + 1 
#ifdef OPENMP
            maxvol_omp(tid) = max(sg_niter_max,sg_ivol_niter)
            maxval_omp(tid) = max(sg_rnorm_max,sg_ivol_rnorm)
#else
            sg_niter_max = max(sg_niter_max,sg_ivol_niter)
            sg_rnorm_max = max(sg_rnorm_max,sg_ivol_rnorm)
#endif
          else if (mip_idetail == 2) then
            write(*,'(i8,2x,i8,6x,e10.2,2x,i6/)') ivol,sg_ivol_niter,  &
                  sg_ivol_rnorm,sgsolver_info

            write(ilog,'(i8,2x,i8,6x,e10.2,2x,i6/)') ivol,             &
                  sg_ivol_niter,sg_ivol_rnorm,sgsolver_info
          end if
        else
          if (rank == 0) then
            write(*,'(/a, i8)')   'mip_mt not converged, volume ', ivol
            if (sgsolver_info == 128) then
              write(*,'(a)') "Fatal error: input error" 
              write(ilog,'(a)') "Fatal error: input error" 
            else if (sgsolver_info == 129) then
              write(*,'(2a)') "Fatal error: acobian is zero--",        &
                    "cannot proceed with unchanging function"  
              write(ilog,'(2a)') "Fatal error: acobian is zero--",     &
                    "cannot proceed with unchanging function" 
            else if (sgsolver_info == 130) then
              write(*,'(2a)') "Fatal error: evaluation limit ",        &
                    "exceeded without termination" 
              write(ilog,'(2a)') "Fatal error: evaluation limit ",     &
                    "exceeded without termination" 
            else if (sgsolver_info == 133) then
              write(*,*) "Fatal error: hook search error: ",           &
                    "could not find a suitable mu in 30 tries" 
              write(ilog,*) "Fatal error: hook search error: ",        &
                    "could not find a suitable mu in 30 tries" 
            end if
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
        end if   
        

        if (mip_xsg(mip_ngas+1,ivol) > mip_sgcrit) then
#ifdef DEBUG
          if (info_debug == 12 .or. info_debug == 999) then
            write(idbg,'(a,1x,i6,1x,a,1x,e10.2)') "ivol",ivol,         &
                  ">mip_sgcrit",mip_xsg(mip_ngas+1,ivol)
          end if
#endif
          !c for sg greater than allowable Sg
          !c the calculation of mip_sg below plays an importnant role in bubble expansion speed, need further check
          
          !c method 1
          !c slow expansion if using this one
          !if(mip_xsg(mip_ngas+1,ivol) > 1.0d0-mip_swr) then
          !  mip_sg(ivol) = 1.0d0-mip_swr
          !else if (mip_xsg(mip_ngas+1,ivol) < 0.0d0) then
          !  mip_sg(ivol) = 0.0d0 
          !else
          !  mip_sg(ivol) = max(1.0d0-mip_swr,mip_xsg(mip_ngas+1,ivol))
          !end if
          
          !c method 2
          !c speed between method 1 and method 3
          !if(mip_xsg(mip_ngas+1,ivol) > 1.0d0) then
          !  mip_sg(ivol) = 1.0d0
          !else if (mip_xsg(mip_ngas+1,ivol) < 0.0d0) then
          !  mip_sg(ivol) = 0.0d0
          !else
          !  mip_sg(ivol) = max(1.0d0,mip_xsg(mip_ngas+1,ivol))  
          !end if
          
          !c method 3
          !c fast expansion if using this one
          !c to be checked later, previous use max here.
          mip_sg(ivol) = min(1.0d0,mip_xsg(mip_ngas+1,ivol))
          
          !c add to G (Connected) blocks
          mip_g(ivol) = 1
          !c remove from D (disconnected) blocks
          mip_d(ivol) = 0   
          
          !c set partial pressure and total pressure based on the results   
          mip_pgt(ivol) = 0.0d0 
          do igas = 1, mip_ngas
            mip_pg(igas,ivol) = max(mip_xsg(igas,ivol),pg_min)
            mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
          end do
          
        else if (mip_xsg(mip_ngas+1,ivol) > r0) then
#ifdef DEBUG
          if (info_debug == 12 .or. info_debug == 999) then
            write(idbg,'(a,1x,i6,1x,a,1x,e10.2)') "ivol",ivol,         &
                  ">mip_sg0",mip_xsg(mip_ngas+1,ivol)
          end if
#endif
          !c for sg greater than allowable Sg          
          mip_sg(ivol) = mip_xsg(mip_ngas+1,ivol)
          
          !c set partial pressure and total pressure based on the results
          mip_pgt(ivol) = 0.0d0 
          do igas = 1, mip_ngas
            mip_pg(igas,ivol) = max(mip_xsg(igas,ivol),pg_min)
            mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
          end do          
          
        else
#ifdef DEBUG
          if (info_debug == 12 .or. info_debug == 999) then
            write(idbg,'(a,1x,i6,1x,a,1x,e10.2)') "ivol",ivol,         &
                  "<=mip_sg0",mip_xsg(mip_ngas+1,ivol)
          end if
#endif
          !!c for sg greater than allowable Sg
          !c Method 1
          !mip_sg(ivol) = 0.0d0
          !!c remove from D (disconnected) blocks
          !mip_d(ivol) = 0 
          !!c remove from G (Connected) blocks
          !mip_g(ivol) = 0
          !
          !!c set partial pressure to zero
          !do igas = 1, mip_ngas
          !  mip_pg(igas,ivol) = pg_min
          !end do    
          
          !c for sg greater than allowable Sg
          !c Method 2
          mip_sg(ivol) = max(r0, mip_xsg(mip_ngas+1,ivol))
          !c remove from D (disconnected) blocks
          mip_d(ivol) = 0 
          !c remove from G (Connected) blocks
          mip_g(ivol) = 0
          
          !c set partial pressure to zero
          mip_pgt(ivol) = 0.0d0 
          do igas = 1, mip_ngas
            mip_pg(igas,ivol) = max(mip_xsg(igas,ivol),pg_min)
            mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
          end do 

        end if
        
        if (mip_pgt(ivol) < mip_pg_contraction) then
          !c remove from D (disconnected) blocks
          mip_d(ivol) = 0 
          !c remove from G (Connected) blocks
          mip_g(ivol) = 0
        end if
        
#ifdef DEBUG
        if (info_debug == 10 .or. info_debug == 999) then
          write(idbg,'(i6,1x,2(i4,1x),100(e10.2,1x))')                 &
                ivol,mip_d(ivol),mip_g(ivol),mip_sg(ivol),             &
                mip_pg(:,ivol),mip_pgt(ivol),mip_cw(:,ivol),           &
                mip_ct(:,ivol)
        end if
#endif
      end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif
      
      if (mip_idetail == 1) then
#ifdef OPENMP
        sg_niter_max = maxval(maxvol_omp,1)
        sg_rnorm_max = maxval(maxval_omp)
#endif
      end if

      !%---update aqueous concentrations (temporary - keep only for Sg=0) NOT TRUE
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol, igas)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas  
          mip_cw(igas,ivol) = mip_ct(igas,ivol)/                       &
                 (1.0d0+(mip_partition_k(igas)-1.0d0)*mip_sg(ivol))
        end do
      end do  
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

#ifdef DEBUG
      if(info_debug == 11 .or. info_debug == 999) then
        write(idbg,*) "transfer is finished"  
        write(idbg,*) "mip_sg(34)=",mip_sg(34)
      end if

      if (info_debug == 4 .or. info_debug == 999) then
        do i = 1, 6
          do j = 32, 36 
            ivol = (i-1)*111+j
            write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),a,1x,3(e16.8,1x))')& 
                  "ivol",ivol,"transfer   Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),        &
                  "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol)            
          end do
        end do  
      end if
      
      if (info_debug  == 3 .or. info_debug == 999) then

        write(idbg,*) "mip_cw after mass transfer"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_cw(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_ct after mass transfer"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_ct(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pg after mass transfer"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_pg(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pgt after mass transfer"
        do ix = 1, mip_nvz
          istart = (ix-1)*mip_nvx+1
          iend = ix*mip_nvx
          write(idbg,'(111(e10.2,1x))') mip_pgt(istart:iend)  
        end do
          
        write(idbg,*) "mip_sg after mass transfer"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(f5.2,1x))') mip_sg(istart:iend)  
        end do
        
        write(idbg,*) "mip_g after mass transfer"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
        end do
        
      end if
      
#endif
      
      !> store sg based on mass transfer step prior to redistribution
      mip_sg_pre = mip_sg
      
      !> redistribution of gas in connected clusters
      !c set to no growth (allow expansion/mobilization/contraction)
      growthflag = .false.
      if (any(mip_g > 0)) then
        !c as long as expansion/mobilization/contraction events are occuring
        do while (.not.growthflag)
          growthflag = .true.
          
          !c separate clusters
          call mip_math_bwlabeln(mip_nvx, mip_nvy, mip_nvz, mip_g,     &
                                 mip_bwlabeln_mode, num, mip_bwlabels)
          
          mip_clusters = 0    

          !c step through entire domain (opportunity to improve here)
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
          do ivol = 1, mip_nvols
            if (mip_bwlabels(ivol) > 0) then
              !c assign values to individual spaces  
              mip_clusters(ivol,mip_bwlabels(ivol)) = 1
#ifdef DEBUG
              if (info_debug == 1 .or. info_debug == 999) then
                write(idbg,'(2(a,1x,i8,1x))') "cluster:ivol",ivol,      &
                      "label",mip_bwlabels(ivol)
              end if
#endif
            end if
          end do
#ifdef OPENMP
    !$omp end do
#endif
#ifdef OPENMP
    !$omp end parallel
#endif


#ifdef DEBUG
          if (info_debug == 3 .or. info_debug == 999) then
            write(idbg,*) "number of clusters ",num 
          end if
          
          if (info_debug == 3 .or. info_debug == 999) then
              write(idbg,*) "mip_g"
              do ix = 1, mip_nvz
                  istart = (ix-1)*mip_nvx+1
                  iend = ix*mip_nvx
                  write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
              end do 
          end if
          
          if (info_debug == 3 .or. info_debug == 999) then
              write(idbg,*) "mip_sg"
              do ix = 1, mip_nvz
                  istart = (ix-1)*mip_nvx+1
                  iend = ix*mip_nvx
                  write(idbg,'(111(f5.2,1x))') mip_sg(istart:iend)  
              end do 
          end if
#endif


          
          !c expansion/mobilization/contraction check
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (i, ibvs, igas, ivol, inum,                         &
    !$omp mip_indices_a, mip_indices_i,                               &
    !$omp ivol_entry, ivol_terminal, max_ri, min_i, mip_cluster_a,    &
    !$omp mip_cluster_i, mip_cluster_ri, gmass, gmasst,               &
    !$omp pgavg, pgavgt, sgtot, mip_values_i,                         &
    !$omp num_nonzero_i, num_nonzero_a)                               &
    !$omp reduction(.and.:growthflag)
#endif

#ifdef OPENMP
    !$omp do schedule(dynamic, 1)
#endif
          do inum = 1, num

            if (.not. growthflag) then
              cycle
            end if

#ifdef DEBUG
            if (info_debug == 3 .or. info_debug == 999) then
              write(idbg,'(2(a,1x,i8,1x))') "enter expansion/mobilization:inum",inum,"num",num
            end if
#endif
              
            !c identify cluster and adjacent blocks  
            !c define gas cluster  
            mip_cluster_a = mip_clusters(1:mip_nvols,inum) 

            !c increase cluster perimeter
            call mip_math_imdilate(mip_nvx, mip_nvy, mip_nvz,          &
                     mip_cluster_a, mip_bwlabeln_mode, mip_cluster_i)
            
#ifdef DEBUG
            if (info_debug  == 2 .or. info_debug == 999) then
              write(idbg,*) "mip_cluster_b"
              do ix = 1, mip_nvz
                  istart = (ix-1)*mip_nvx+1
                  iend = ix*mip_nvx
                  write(idbg,'(111(f5.1,1x))') mip_cluster_i(istart:iend)  
              end do 
            end if
#endif
            !c define available entry thresholds, add pressure shift to avoid negative value
            mip_cluster_i = (mip_cluster_i - mip_cluster_a)*(mip_te+mip_pressure_shift)
            !c define terminal thresholds in cluster
            mip_cluster_ri = mip_cluster_a*(mip_tt+mip_pressure_shift)
            
            !c locate non-zero values in mip_cluster_a
            call mip_math_find(mip_cluster_a,num_nonzero_a,mip_indices_a)
            !c locate non-zero values in mip_cluster_i
            call mip_math_find(mip_cluster_i,num_nonzero_i,mip_indices_i,mip_values_i) 

            
#ifdef DEBUG
            if (info_debug == 5 .and. mod(mtime,50) == 0 .or. info_debug == 999) then
              write(*,*) "mip_cluster_i num-inum ", num, inum  
              write(idbg,*) "mip_cluster_i num-inum ", num, inum
              write(idbg,*) "mip_indices_i ", mip_indices_i(:)
              !write(idbg,*) "mip_cluster_i"
              !do ix = 1, 80
              !    istart = (ix-1)*mip_nvx+1
              !    iend = istart + 80
              !    write(idbg,'(111(f3.1,1x))') mip_cluster_i(istart:iend)  
              !end do 
              
              !write(idbg,*) "mip_cluster_ri"
              !do ix = 1, 80
              !    istart = (ix-1)*mip_nvx+1
              !    iend = istart + 80
              !    write(idbg,'(111(f3.1,1x))') mip_cluster_ri(istart:iend)  
              !end do 
            end if
#endif
            
            !c locate minimum entry threshold, local index
            ivol_entry = minloc(mip_values_i(1:num_nonzero_i),1)
            !c define minimum entry threshold
            min_i = mip_values_i(ivol_entry)-mip_pressure_shift
            !c revert ivol_entry to global volume index
            ivol_entry = mip_indices_i(ivol_entry)
            
            !c locate maximum terminal threshold
            ivol_terminal = maxloc(mip_cluster_ri,1)
            !c define maximum terminal threshold
            max_ri = mip_cluster_ri(ivol_terminal)-mip_pressure_shift

#ifdef DEBUG
            if (info_debug == 5 .and. mod(mtime,50) == 0 .or. info_debug == 999) then
              write(idbg,*) "entry volume",ivol_entry,"threshold", min_i
              write(idbg,*) "terml volume",ivol_terminal,"threshold", max_ri              
            end if
            
            if (info_debug == 3 .or. info_debug == 999) then
              write(idbg,'(5(a,1x,i6,1x),100(i6,1x))') "ivol_entry",   &
                    ivol_entry,"ivol_terminal",ivol_terminal,          &
                    "mip_d(ivol_entry)", mip_d(ivol_entry),            &
                    "mip_g(ivol_entry)", mip_g(ivol_entry),            &
                    "mip_indices_i",mip_indices_i(:)
            end if
#endif
      
            !c define gas mass
            gmass = 0.0d0
            do i = 1, num_nonzero_a
              ivol = mip_indices_a(i)
              do igas = 1, mip_ngas
                gmass(igas) = gmass(igas) + mip_pg(igas,ivol)*mip_sg(ivol) 
              end do
            end do
            
            !c define total gas mass
            gmasst = 0.0d0
            do i = 1, num_nonzero_a
              ivol = mip_indices_a(i)
              gmasst = gmasst + mip_pgt(ivol)*mip_sg(ivol)
            end do
            
            !c force minimum sg in connected cluster to sgm
            do i = 1, num_nonzero_a
              ivol = mip_indices_a(i)
              mip_sg(ivol) = mip_sgcrit
            end do
            
            !c define total volume of cluster
            sgtot = 0.0d0
            do i = 1, num_nonzero_a
              ivol = mip_indices_a(i)
              sgtot = sgtot + mip_sg(ivol)
            end do
            
            !c weight average gas pressure
            do igas = 1, mip_ngas
              pgavg(igas) = gmass(igas)/sgtot
            end do             
            pgavgt = gmasst/sgtot
            
#ifdef DEBUG
            mip_pgavgt_max=max(mip_pgavgt_max,pgavgt)
            mip_pgavgt_min=min(mip_pgavgt_min,pgavgt)
#endif
            
#ifdef DEBUG
            if (info_debug == 7 .or. info_debug == 999) then
              write(idbg,'(2(a,1x,i6,1x),9(a,1x,e16.8,1x))')           &
                  "cluster",inum,"clustervols",num_nonzero_a,          &
                  "sgtot",sgtot, "max_ri",max_ri,"min_i",min_i,        &
                  "pgavgt",pgavgt,"pgavgt_max",mip_pgavgt_max,         &
                  "pgavgt_min",mip_pgavgt_min
              write(idbg,*) "cluster vols: ",mip_indices_a(1:num_nonzero_a)
              write(idbg,*) "cluster sg: ",mip_sg(mip_indices_a(1:num_nonzero_a))
              write(idbg,*) "cluster pg-1: ",mip_pg(1,mip_indices_a(1:num_nonzero_a))
              write(idbg,*) "cluster pg-2: ",mip_pg(2,mip_indices_a(1:num_nonzero_a))
              write(idbg,*) "cluster pg-3: ",mip_pg(3,mip_indices_a(1:num_nonzero_a))
            end if            
#endif
            
            !c redistribute pressure within cluster
            do i = 1, num_nonzero_a
              ivol = mip_indices_a(i)
              do igas = 1, mip_ngas
                mip_pg(igas,ivol) = pgavg(igas)
              end do
              mip_pgt(ivol) = pgavgt
            end do
            
#ifdef DEBUG
            if (info_debug == 3 .or. info_debug == 999) then
              write(idbg,'(7(a,1x,e16.8,1x))') "gmasst", gmasst,       &
                    "sgtot",sgtot,"pgavgt",pgavgt,"max_ri",max_ri,     &
                    "min_i",min_i
            end if            
#endif
            
            if (sgtot >= num_nonzero_a*mip_sgcrit-mip_tolerance) then
#ifdef DEBUG
              !c check for mobilization
              if (info_debug == 7 .or. info_debug == 999) then
                write(idbg,*) "entry flag T, pgavgt ",pgavgt,          &
                              " min_i ", min_i, " maxri ",max_ri
              end if
#endif
              
              !c check if the new invade new block is at the boundary
              ibvs = ivol2bvs(ivol_entry)
              if (ibvs > 0) then                  
#ifdef DEBUG
                if (info_debug == 12 .or. info_debug == 999) then
                  write(idbg,*) "bubble collapses at boundary ",ivol_entry
                end if
#endif
                !c reset gas pressure
                do i = 1, num_nonzero_a
                  ivol = mip_indices_a(i)  
                  !c revert the gas saturation to the value before bubble is formed
                  mip_sg(ivol) = sgnew(ivol)
                  !c unlabel the bubble cluster
                  mip_clusters(ivol,inum) = 0
                  
                  mip_pgt(ivol) = 0.0d0                  
                  do igas = 1, mip_ngas
                    !c revert the gas partial pressure to the value before bubble is formed
                    mip_pg(igas,ivol) = gnew(igas,ivol)*mip_rgasjoule_tempks
                    !c assign a total pressure
                    mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
                    !c subtract the mass that was retained by the cluster 
                    gmass(igas) = gmass(igas) - mip_pg(igas,ivol)*mip_sg(ivol) 
                  end do
                  
                  if(btypevs(ibvs) == 'first' .or. btypevs(ibvs) == 'seepage') then
                    !c bubble collapses and releases the mass to the new invaded block  
                    !c update the concentration for the block where bubble collapses
                    !c change in gaseous phase saturation is ignored
                    do igas = 1, mip_ngas
                      if (gmass(igas) < 0.0d0) then
                        gmass(igas) = 0.0d0  
                      end if
#ifdef OPENMP
    !$omp critical
#endif
                      mip_cw(igas,ivol_entry) = mip_cw(igas,ivol_entry) +  &
                             gmass(igas)/mip_rgasjoule_tempks/             &
                             (1.0d0+(mip_partition_k(igas)-1.0d0)*mip_sg(ivol))
                      !the aqueous volume when bubble collapses is ignored, which is not strict here if mip_sg->1. 
#ifdef OPENMP
    !$omp end critical
#endif
                    end do 
                    
                  end if

                end do
                
                !c force to redistribute and check cluster again
                growthflag = .false.
                !c leave do loop, stop looking at cluster and redefine clusters
#ifndef OPENMP 
                exit
#endif
                
              !c check if the new invade new block is in the unsaturated zone
              !c if so, bubble collapses and mass is released to this new block
              else if (mip_sg(ivol_entry) > mip_sg_collapse .and.           &
                  mip_pw(ivol_entry) < mip_pw_collapse) then
#ifdef DEBUG
                if (info_debug == 12 .or. info_debug == 999) then
                  write(idbg,*) "bubble collapses at volume ",ivol_entry,   &
                        " sg ",mip_sg(ivol_entry)," pw ",mip_pw(ivol_entry)
                end if
#endif
                !c reset gas pressure
                do i = 1, num_nonzero_a
                  ivol = mip_indices_a(i)  
                  !c revert the gas saturation to the value before bubble is formed
                  mip_sg(ivol) = sgnew(ivol)
                  !c unlabel the bubble cluster
                  mip_clusters(ivol,inum) = 0
                  
                  mip_pgt(ivol) = 0.0d0
                  do igas = 1, mip_ngas
                    !c revert the gas partial pressure to the value before bubble is formed
                    mip_pg(igas,ivol) = gnew(igas,ivol)*mip_rgasjoule_tempks
                    !c assign a total pressure
                    mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
                    !c subtract the mass that was retained by the cluster 
                    gmass(igas) = gmass(igas) - mip_pg(igas,ivol)*mip_sg(ivol) 
                  end do
                end do
                
                !c update the concentration for the block where bubble collapses
                !c change in gaseous phase saturation is ignored
                do igas = 1, mip_ngas
                  if (gmass(igas) < 0.0d0) then
                    gmass(igas) = 0.0d0  
                  end if
#ifdef OPENMP
    !$omp critical
#endif
                  mip_cw(igas,ivol_entry) = mip_cw(igas,ivol_entry) +  &
                         gmass(igas)/mip_rgasjoule_tempks/             &
                         (1.0d0+(mip_partition_k(igas)-1.0d0)*mip_sg(ivol))
#ifdef OPENMP
    !$omp end critical
#endif
                   !the aqueous volume when bubble collapses is ignored, which is not strict here if mip_sg->1. 
                end do  
                
                !c force to redistribute and check cluster again
                growthflag = .false.
                !c leave do loop, stop looking at cluster and redefine clusters
#ifndef OPENMP 
                exit
#endif
                            
              !c check for invasion
              else if (max_ri > min_i) then
#ifdef DEBUG
                if (info_debug == 12 .or. info_debug == 999) then
                  write(idbg,*) "entry flag: invade new block, ivol_entry ",ivol_entry,&
                                " cluster num ",inum," max_ri ", max_ri," min_i ",min_i
                end if
#endif

#ifdef OPENMP
    !$omp critical
#endif
                !c invade new block
                mip_clusters(ivol_entry,inum) = 1
                !c take new block off D list
                mip_d(ivol_entry) = 0 
                !c remove re-invade block from G list
                mip_clusters(ivol_terminal,inum) = 0                
                
                mip_pgt(ivol_entry) = 0.0d0
                !c remove total pressure from re-invaded block
                mip_pgt(ivol_terminal) = 0.0d0
                do igas = 1, mip_ngas
                  !c modify gas pressure if invading a D block  
                  mip_pg(igas,ivol_entry) = mip_pg(igas,ivol_entry)*   &
                                            mip_sg(ivol_entry)/        &
                                            mip_sgcrit
                  !c add pressure (mass) from re-invaded block to cluster
                  mip_pg(igas,ivol_entry) = mip_pg(igas,ivol_entry) +  &
                                            mip_pg(igas,ivol_terminal)*&
                                            mip_sg(ivol_terminal)/     &
                                            mip_sgcrit
                  !c assign a total pressure
                  mip_pgt(ivol_entry) = mip_pgt(ivol_entry) +          &
                                        mip_pg(igas,ivol_entry)
                  !c remove patial pressure from re-invaded block
                  mip_pg(igas,ivol_terminal) = 0.0d0                  
                end do
                
                !c remove gas from re-invaded block
                mip_sg(ivol_terminal) = 0.0d0
                mip_sg(ivol_entry) = mip_sgm
#ifdef OPENMP
    !$omp end critical
#endif

                !c force to redistribute and check cluster again
                growthflag = .false.
                !c leave do loop, stop looking at cluster and redefine clusters
#ifndef OPENMP 
                exit
#endif
                
              !c check for expansion
              else if (pgavgt > min_i*mip_density*mip_gravity+mip_patm) then
                  
#ifdef DEBUG
                if (info_debug == 12 .or. info_debug == 999) then
                  write(idbg,*) "entry flag: expansion, ivol_entry ",  &
                                ivol_entry," pgavgt ",pgavgt,          &
                                " min_i ",min_i
                end if

                if (info_debug == 4 .or. info_debug == 999) then
                  write(idbg,'(2(a,1x,i6,1x),100(i6,1x))')             &
                        "entry flag: expansion, ivol_entry ",          &
                        ivol_entry,"mip_indices_a",mip_indices_a(:)
                  write(idbg,*) "pgavgt",pgavgt,"vs ", min_i*mip_density*mip_gravity+mip_patm
                end if
#endif
                  
#ifdef DEBUG
                if (info_debug == 2 .or. info_debug == 999) then
                  if (inum > 10 .and. num == 13) then
                    write(idbg,'(a,1x,i4,1x,3(a,1x,e16.8,1x),2(e16.8,1x))')&
                          "check deadlock-1, ivol_entry",ivol_entry,     &
                          "mip_sg",mip_sg(ivol_entry), "mip_pgt",        &
                          mip_pgt(ivol_entry),"mip_pg",mip_pg(:,ivol_entry)  
                    write(idbg,'(2(a,1x,i4,1x),a,1x,e16.8)') "mip_d",  &
                          mip_d(ivol_entry),"mip_clusters",            &
                          mip_clusters(ivol_entry,inum),               &
                          "mip_sg",mip_sg(ivol_entry)
                  end if
                end if
#endif

#ifdef OPENMP
    !$omp critical
#endif
                !c invade new block
                mip_clusters(ivol_entry,inum) = 1
                !c take new block off D list
                mip_d(ivol_entry) = 0 
                
                mip_pgt(ivol_entry) = 0.0d0
                do igas = 1, mip_ngas
                  !c modify gas pressure if invading a D block  
                  mip_pg(igas,ivol_entry) = mip_pg(igas,ivol_entry)*   &
                                            mip_sg(ivol_entry)/        &
                                            mip_sgcrit

                  !c assign a total pressure
                  mip_pgt(ivol_entry) = mip_pgt(ivol_entry) +          &
                                        mip_pg(igas,ivol_entry)                
                end do
                
                mip_sg(ivol_entry) = mip_sgm
#ifdef OPENMP
    !$omp end critical
#endif

                !c force to redistribute and check cluster again
                growthflag = .false.
                
#ifdef DEBUG
                if (info_debug == 2 .or. info_debug == 999) then
                  if (inum > 10 .and. num == 13) then
                    write(idbg,'(a,1x,i4,1x,3(a,1x,e16.8,1x),2(e16.8,1x))')&
                          "check deadlock-2, ivol_entry",ivol_entry,     &
                          "mip_sg",mip_sg(ivol_entry), "mip_pgt",        &
                          mip_pgt(ivol_entry),"mip_pg",mip_pg(:,ivol_entry) 
                  end if
                end if
#endif                
                !c leave do loop, stop looking at cluster and redefine clusters
#ifndef OPENMP 
                exit
#endif
              
              !c check for contraction (optional), need further check, not work well
              else if (pgavgt < max_ri*mip_density*mip_gravity+mip_patm .and. &
                       pgavgt < mip_pg_contraction) then
                if (num_nonzero_a == 1 .or. any(mip_brt_flags(mip_indices_a(1:num_nonzero_a))==1)) then
                  cycle
                end if
                !c for withdrawl following loss of pressure, needs mass balance calculation and check
                if(pgavgt*num_nonzero_a/(num_nonzero_a-1) < min_i*mip_density*mip_gravity+mip_patm) then
                  !c for snap-off following loss of pressure
#ifdef DEBUG    
                  if (info_debug == 12 .or. info_debug == 999) then
                    write(idbg,*) "loss of pressure, remove re-invade block, pgavgt ",pgavgt," max_ri ",max_ri
                  end if
#endif          
                
                  !c remove re-invade block
                  mip_clusters(ivol_terminal,inum) = 0
                  !c add to D list
                  mip_d(ivol_terminal) = 0
                  !c reset gas saturation
                  mip_sg(ivol_terminal)=0.0d0
                
                  !c locate mineral threshold
                  ivol = minloc(mip_cluster_ri,1)
                  mip_pgt(ivol) = 0.0d0
                  do igas=1, mip_ngas
                    mip_pg(ivol,igas)=mip_pg(ivol,igas)+mip_pg(ivol_terminal,igas)
                    mip_pgt(ivol) = mip_pgt(ivol)+mip_pg(ivol,igas)
                  end do
                
                  !c force to redistribute and check cluster again, not necessary if the bubble shrinks, DSU 2016-07-05
                  growthflag = .false.
                  !c leave do loop, stop looking at cluster and redefine clusters
#ifndef OPENMP  
                  exit
#endif          
                end if
              end if

            end if
            
          end do !inum = 1, num
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

          !c reassemble all connected clusters
          mip_g = 0
          do inum = 1, num
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, 1)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, 1)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
            do ivol = 1, mip_nvols
              mip_g(ivol) = mip_g(ivol) + mip_clusters(ivol,inum)
            end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif
          end do
          
          !c re-assign sg values
          !c locate non-zero values in sg
          call mip_math_find(mip_sg,num_nonzero_sg,mip_indices_sg,    &
                             mip_sg0)
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (i, ivol)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, 1)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, 1)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
          do i = 1, num_nonzero_sg
            ivol = mip_indices_sg(i)
            if (mip_sg_pre(ivol) > 0) then
              mip_pgt(ivol) = 0  
              do igas = 1, mip_ngas
                mip_pg(igas,ivol) = mip_pg(igas,ivol)*mip_sg(ivol)/mip_sg_pre(ivol)
                mip_pgt(ivol) = mip_pgt(ivol) + mip_pg(igas,ivol)
              end do
              mip_sg(ivol) = mip_sg_pre(ivol)
            end if
          end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif
          
#ifdef DEBUG
          do ivol = 1, mip_nvols
            if (mip_g(ivol) > 1) then
              write(idbg,*) "check final mip_g"
              do ix = 1, mip_nvz
                  istart = (ix-1)*mip_nvx+1
                  iend = ix*mip_nvx
                  write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
              end do 
              write(*,*) "force to check cluster mip_g"
              close(idbg)
              stop
            end if
          end do
#endif
          
        end do  !growthflag

        !c store bubble state flag, if mip_g_flag is not zero, there is state change
        mip_g_flag = mip_g - mip_g_flag
        
#ifdef DEBUG
        if(info_debug == 11 .or. info_debug == 999) then
          write(idbg,*) "redistribution is finished"  
          write(idbg,*) "mip_sg(34)=",mip_sg(34)
        end if
        
        if (info_debug == 4 .or. info_debug == 999) then
          do i = 1, 6
            do j = 32, 36 
              ivol = (i-1)*111+j
              write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),a,1x,3(e16.8,1x))')& 
                    "ivol",ivol,"redistri   Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),        &
                    "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol)
            end do
          end do
        end if
#endif
        
      end if
      
#ifdef DEBUG
      if (info_debug  == 3 .or. info_debug == 999) then
        write(idbg,*) "mip_cw after redistribution"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_cw(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_ct after redistribution"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_ct(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pg after redistribution"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_pg(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pgt after redistribution"
        do ix = 1, mip_nvz
          istart = (ix-1)*mip_nvx+1
          iend = ix*mip_nvx
          write(idbg,'(111(e10.2,1x))') mip_pgt(istart:iend)  
        end do
          
        write(idbg,*) "mip_sg after redistribution"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(f5.2,1x))') mip_sg(istart:iend)  
        end do
        
        write(idbg,*) "mip_g after redistribution"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
        end do       
        
      end if
#endif
      
     
#ifdef DEBUG
      if(info_debug == 11 .or. info_debug == 999) then
        write(idbg,*) "re-assign is finished"  
        write(idbg,*) "mip_sg(34)=",mip_sg(34)
      end if
      
      if (info_debug == 4 .or. info_debug == 999) then
        do i = 1, 6
          do j = 32, 36 
            ivol = (i-1)*111+j
            write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),a,1x,3(e16.8,1x))')& 
                  "ivol",ivol,"reassign   Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),        &
                  "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol)
          end do
        end do
      end if
      
      if (info_debug == 1 .or. info_debug == 999) then
       write(idbg,*) "mip_g value"
       do i = 1, 111
         write(idbg,'(111(i1,1x))') mip_g((i-1)*111+1:i*111) 
       end do
      end if
#endif

#ifdef DEBUG
      if (info_debug  == 3 .or. info_debug == 999) then

        write(idbg,*) "mip_cw after reassign"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_cw(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_ct after reassign"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_ct(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pg after reassign"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_pg(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pgt after reassign"
        do ix = 1, mip_nvz
          istart = (ix-1)*mip_nvx+1
          iend = ix*mip_nvx
          write(idbg,'(111(e10.2,1x))') mip_pgt(istart:iend)  
        end do
          
        write(idbg,*) "mip_sg after reassign"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(f5.2,1x))') mip_sg(istart:iend)  
        end do
        
        write(idbg,*) "mip_g after reassign"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
        end do       
        
      end if
#endif
      
      !c transport aqueous mass for cluster connected to pool surface
      !c update mip_pg and mip_cw due to boundary condition
      !c calculate new conponent, species and gas concentration based on MIP_MT models 
      mip_bdcluster_num = 0
      call mip_math_bwselect(mip_nvx, mip_nvy, mip_nvz, mip_g,         &
                             mip_brt_idx, 4, mip_g_bws,                &
                             mip_g_vols, mip_bdcluster_num)

#ifdef DEBUG
            if (info_debug == 7 .or. info_debug == 999) then
              mip_napl_cluster_vols = 0
            end if
#endif
 
      !c treating napl surface
      if (mip_bdcluster_num > 0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol, jvol, igas, ip)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
        do ivol = 1, mip_nvols
          !c connected napl surface volume  
          jvol = mip_g_vols(ivol)
          if (jvol > 0) then
#ifdef DEBUG
            if (info_debug == 7 .or. info_debug == 999) then
              mip_napl_cluster_vols = mip_napl_cluster_vols + 1
            end if
#endif
            do igas = 1, mip_ngas
              ip = mip_gas2aqueous(igas)
              !c only update the napl concentration
              if (all(mip_brt_comp /= ip)) then
                cycle  
              end if  
              !method 1
              mip_pg(igas,ivol) = mip_psat(igas)
              mip_cw(igas,ivol) = mip_pg(igas,ivol)/mip_henry(igas)/1.0d3
              !method 2
              !mip_cw(igas,ivol) = cnew(ip,jvol)
              !mip_pg(igas,ivol) = mip_cw(igas,ivol)*mip_henry(igas)*1.0d3
            end do            
          end if        
        end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif
      end if
      
#ifdef DEBUG
      if(info_debug == 11 .or. info_debug == 999) then
        write(idbg,*) "update napl surface is finished"  
        write(idbg,*) "mip_sg(34)=",mip_sg(34)
      end if

      if (info_debug == 4 .or. info_debug == 999) then
        do i = 1, 6
          do j = 32, 36 
            ivol = (i-1)*111+j
            write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),a,1x,3(e16.8,1x))')& 
                  "ivol",ivol,"naplsurf   Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),        &
                  "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol)
          end do
        end do
      end if
#endif

#ifdef DEBUG
      if (info_debug  == 3 .or. info_debug == 999) then
        write(idbg,*) "mip_cw after napl surface"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_cw(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_ct after napl surface"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_ct(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pg after napl surface"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_pg(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pgt after napl surface"
        do ix = 1, mip_nvz
          istart = (ix-1)*mip_nvx+1
          iend = ix*mip_nvx
          write(idbg,'(111(e10.2,1x))') mip_pgt(istart:iend)  
        end do
          
        write(idbg,*) "mip_sg after napl surface"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(f5.2,1x))') mip_sg(istart:iend)  
        end do
        
        write(idbg,*) "mip_g after napl surface"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
        end do  
        
      end if
#endif
      
      !c update aqueous concentrations at boundary according to LEA (Option 1)
      do i = 1, size(mip_brt_idx,1)
        ivol = mip_brt_idx(i) 
        if (mip_g(ivol) < 1) then
          cycle  
        end if
        do igas = 1, mip_ngas
          ip = mip_gas2aqueous(igas)
          !c only update the napl concentration
          if (all(mip_brt_comp /= ip)) then
            cycle  
          end if
          !method 1
          !mip_cw(igas,ivol) = mip_psat(igas)/mip_henry(igas)/1.0d3
          !mip_pg(igas,ivol) = mip_psat(igas)*(mip_d(ivol)+mip_g(ivol))
          !method 2
          mip_cw(igas,ivol) = cnew(ip,ivol)
          mip_pg(igas,ivol) = mip_cw(igas,ivol)*mip_henry(igas)*1.0d3* &
                              (mip_d(ivol)+mip_g(ivol))
        end do 
      end do
      
      !c update total concentrations and total pressure
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol, igas, rtemp)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas
          mip_ct(igas,ivol)=mip_pg(igas,ivol)*mip_sg(ivol)/mip_rgasjoule_tempks+ &
                            mip_cw(igas,ivol)*(1.0d0-mip_sg(ivol))
        end do
      end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

      
#ifdef DEBUG
      if(info_debug == 6 .or. info_debug == 999) then
        rtemp = sum(mip_sg)
        write(idbg,*) "sum of sg after ",rtemp
      end if  

      if(info_debug == 11 .or. info_debug == 999) then
        write(idbg,*) "update boundary is finished" 
        write(idbg,*) "mip_sg(34)=",mip_sg(34)
      end if
    
      if (info_debug == 4 .or. info_debug == 999) then
        do i = 1, 6
          do j = 32, 36 
            ivol = (i-1)*111+j
            write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),2(a,1x,3(e16.8,1x)))')& 
                  "ivol",ivol,"updatebd   Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),           &
                  "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol)
          end do
        end do  
        write(idbg,*) ''
      end if
      
      if (info_debug == 3 .or. info_debug == 999) then
        write(idbg,*) "mip_cw after boundary condition"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_cw(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_ct after boundary condition"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_ct(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pg after boundary condition"
        do igas = 1, mip_ngas
          write(idbg,*) "gas",igas  
          do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(e10.2,1x))') mip_pg(igas,istart:iend)  
          end do
        end do
        
        write(idbg,*) "mip_pgt after boundary condition"
        do ix = 1, mip_nvz
          istart = (ix-1)*mip_nvx+1
          iend = ix*mip_nvx
          write(idbg,'(111(e10.2,1x))') mip_pgt(istart:iend)  
        end do
          
        write(idbg,*) "mip_sg after boundary condition"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(f5.2,1x))') mip_sg(istart:iend)  
        end do
        
        write(idbg,*) "mip_g after boundary condition"
        do ix = 1, mip_nvz
            istart = (ix-1)*mip_nvx+1
            iend = ix*mip_nvx
            write(idbg,'(111(i3,1x))') mip_g(istart:iend)  
        end do   
      end if      
#endif
      
#ifdef DEBUG 
      if (info_debug == 1 .or. info_debug == 999) then
        write(idbg,*) "after redistribution"
        write(idbg,'(4a)')                                             &
                      "        ivol  mip_d  mip_g   mip_sg       ",    &
                      "mip_pg                                    ",    &
                      "         mip_pgt          mip_cw          ",    &
                      "                                   mip_ct"
        do ivol = 1, mip_nvols
          if (info_debug == 0 .and. (ivol > 28 .and. ivol < 42) .or. info_debug == 999) then  
            write(idbg,'(i8,1x,2(i4,1x),100(e10.2,1x))') ivol,mip_d(ivol),&
                  mip_g(ivol),mip_sg(ivol),mip_pg(:,ivol),mip_pgt(ivol), &
                  mip_cw(:,ivol),mip_ct(:,ivol)
          end if
        end do
      end if
#endif

      !c check convergence
      max_pg_update = 0.0d0
      max_pg_update_ratio = 0.0d0
      max_pg_update_ivol = 0.0d0
      max_pg_update_igas = 0.0d0
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas
          rtemp = abs(mip_pg(igas,ivol)-mip_pg_old(igas,ivol))
          if (mip_pg_old(igas,ivol) < pg_min) then
            if (mip_pg(igas,ivol) < pg_min) then
              rtemp2 = 0.0d0
            else
              rtemp2 = 1.0d10
            end if
          else
            rtemp2 = rtemp/mip_pg_old(igas,ivol)
          end if
          if (rtemp > max_pg_update) then
            max_pg_update = rtemp
            max_pg_update_ivol = ivol
            max_pg_update_igas = igas
          end if
          if (rtemp2 > max_pg_update_ratio) then
            max_pg_update_ratio = rtemp2
          end if
        end do
      end do

#ifdef DEBUG
      if (sg_nvols == 58 .and. max_pg_update_ivol == 2025) then
        write(ilog,*) "pg_old of 2025 vol ", mip_pg_old(:,2025)
        write(ilog,*) "pg_new of 2025 vol ", mip_pg(:,2025)
      end if
#endif

      if (mip_idetail == 1 .and. sg_nvols > 0) then
        write(*,'(i8,5x,i8,5x,e10.2,3x,2(e10.2,2x),i8,5x,a12)')        &
              sg_nvols,sg_niter_max,sg_rnorm_max,max_pg_update,        &
              max_pg_update_ratio,max_pg_update_ivol,                  &
              nameg(max_pg_update_igas)
        write(ilog,'(i8,5x,i8,5x,e10.2,3x,2(e10.2,2x),i8,5x,a12)')     &
              sg_nvols,sg_niter_max,sg_rnorm_max,max_pg_update,        &
              max_pg_update_ratio,max_pg_update_ivol,                  &
              nameg(max_pg_update_igas)
      end if

      if (max_pg_update < mip_max_pg_update .or.                       &
          max_pg_update_ratio < mip_max_pg_update_ratio) then
        mip_mt_not_converged = .false.
      else if (bubble_iterations >= mip_bubble_iterations) then
        mip_mt_not_converged = .false.
        if (mip_idetail == 1) then
          write(*,'(a)') "Maximum bubble iterations reached, exit"
        end if
        exit
      end if

#ifdef DEBUG
       if (info_debug == 7 .or. info_debug == 999) then
         itemp = 0
         rtemp = 0.0d0
         rtemp2 = 0.0d0
         do i = 1, mip_nvols
           if (mip_sg(i) > 0.0d0 .and. mip_g(i) > 0) then
             itemp = itemp + 1
             rtemp = rtemp + mip_sg(i)
             if (mip_g_vols(i) > 0) then
               rtemp2 = rtemp2 + mip_sg(i)
             end if
           end if
         end do
         write(idbg,*) "bubble iteration ",bubble_iterations,          &
               " number of vols ", itemp, " sum of sg ", rtemp,        &
               " sum of napl bd cluster sg", rtemp2
       end if
#endif

      end do

      call memory_monitor(-sizeof(gmass),'gmass',.true.)
      deallocate(gmass)

      call memory_monitor(-sizeof(pgavg),'pgavg',.true.)
      deallocate(pgavg)

    end subroutine mip_solver

    !>
    !> Pass MIP variables back to MIN3P
    !>
    subroutine mip_solver_output

      use gen, only :                                                  &
#ifdef OPENMP
                      i_omp_type_mip_bubble, numofthreads_mip_bubble,  &
#endif
                      gnew, cnew, cx, sanew, sgnew, idbg, pornew

      implicit none

      integer :: i, j, ivol, igas, ip, tid

      tid = 1                          !  temporary use

      mip_rgasjoule_tempks = mip_r*mip_t*1.0d3

#ifdef OPENMP
      chunk = mip_nvols / numofthreads_mip_bubble
      if(mod(mip_nvols, numofthreads_mip_bubble) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
#ifdef SCHEDULE_DYNAMIC
      chunk = 1                                         !This is the default chunk size for dynamic scheduling.
#endif
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_omp_type_mip_bubble == 1)                             &
    !$omp num_threads(numofthreads_mip_bubble)                        &
    !$omp default(shared)                                             &
    !$omp private (ivol, igas, ip)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
      !c update gas concentration back to min3p
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas
          gnew(igas,ivol) = mip_pg(igas,ivol)/mip_rgasjoule_tempks
        end do
      end do 
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
      !c update aqueous concentration back to min3p
      do ivol = 1, mip_nvols
        do igas = 1, mip_ngas
          ip = mip_gas2aqueous(igas) 
          cnew(ip,ivol) = mip_cw(igas,ivol)
        end do
      end do
#ifdef OPENMP
    !$omp end do
#endif
      
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
      !c update gaseous phase saturation and aqueous phase saturation back to min3p
      do ivol = 1, mip_nvols
        sgnew(ivol) = mip_sg(ivol)
        sanew(ivol) = 1.0d0-sgnew(ivol)
      end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

      if (info_debug == 4 .or. info_debug == 999) then
        do i = 1, 6
          do j = 32, 36
            ivol = (i-1)*111+j
            write(idbg,'(a,1x,i6,1x,2(a,1x,e16.8,1x,a,1x,3(e16.8,1x)),2(a,1x,3(e16.8,1x)))')&
                  "ivol",ivol,"updateall  Sg=",mip_sg(ivol),"Pg=",mip_pg(:,ivol),           &
                  "Pgt=",mip_pgt(ivol),"Cw",mip_cw(:,ivol),"CT",mip_ct(:,ivol),             &
                  "gnew",gnew(:,ivol)
          end do
        end do
      end if

    end subroutine mip_solver_output

    !>
    !> construct function for gn 
    !>
    subroutine sgsolver_gn_func(m, n, x, r)
    
#ifdef DEBUG
      use gen, only : idbg
#endif
    
      implicit none
      
      !c input parameters
      integer :: m, n
      real*8 :: x(n), r(m)
      
      !c local variable
      integer :: i, tid
      real*8 :: rtemp
      real*8,parameter :: r0 = 0.0d0, r1 = 1.0d0
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
      
      rtemp = 0.0d0
      
      !c set the lower boundary for the solution
      do i = 1, n
        if (x(i) < r0) then
          x(i) = r0
        end if
      end do
      if (x(n-1) > r1) then
        x(n-1) = r1
      end if
      
      !c calculate function
      do i = 1, n-2
        r(i) = x(i)-mip_ct_vol(i,tid)*mip_henry(i)/                    &
                  (1.0d0+(mip_partition_k(i)-1.0d0)*x(n-1)) 
        rtemp = rtemp + x(i)
      end do
      r(n-1) = (x(n)/mip_pd_vol(tid))**(-mip_gamma) -                  &
                  (1.0d0-x(n-1)-mip_swr)/(1.0d0-mip_swr)
      r(n) = rtemp - mip_patm - mip_pw_vol(tid) - x(n)      
    
    end subroutine sgsolver_gn_func
    
    !>
    !> sg solver using netlib gn
    !>
    subroutine sgsolver_gn(n, x, xold, converged, niter, rnorm, info)     
 
#ifdef GPL
       use gn_mod, only : r0, iter, iscale
#endif
      
      implicit none
     
      !> input variables
      integer :: n, max_niter   
      real*8 :: max_abstol, max_rtol
      real*8 :: x(n), xold(n)
      
      !> output variables
      integer :: niter, info
      logical :: converged  
      real*8 :: rsumsquar, rnorm
      
      !> local variable            
      integer :: iscale_bk
     
#ifdef GPL
      external :: gn
#endif
     
      converged = .false.
      
#ifdef GPL
      iscale_bk = iscale

      if (iscale_bk == 2) then
        xold = x  
        iscale = 1
        call gn(sgsolver_gn_func,n,n,info,x,rsumsquar)
        if (info /= 128 .and. info /= 129 .and. info /= 130 .and.      &
            info /= 133) then
          converged = .true.  
          rnorm = sqrt(rsumsquar)
          niter = iter
        else
          x = xold  
          iscale = 0
          call gn(sgsolver_gn_func,n,n,info,x,rsumsquar)
          if (info /= 128 .and. info /= 129 .and. info /= 130 .and.    &
              info /= 133) then
            converged = .true.  
            rnorm = sqrt(rsumsquar)
            niter = iter
          else
            converged = .false.
          end if
        end if
      else
        call gn(sgsolver_gn_func,n,n,info,x,rsumsquar)      
        if (info /= 128 .and. info /= 129 .and. info /= 130 .and.      &
            info /= 133) then
          converged = .true.  
          rnorm = sqrt(rsumsquar)
          niter = iter
        else
          converged = .false.
        end if
      end if
       
      iscale = iscale_bk
#endif
    
    end subroutine sgsolver_gn 
                            
end module mip_bubble
