!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/solver/solver_ddmethod.F90 $
!---------------------------------------------------------------------
!********************************************************************!

#ifdef PETSC

!> module: solver_dd
!>
!> written by: Danyang Su
!>
!> module description:
!>
!> Module of solver for domain decomposition method  
!>
!> Note:  
!> See http://www.mcs.anl.gov/petsc/ for detail


module solver_dd

#include <petscversion.h>
    use solver_snes_common  
    
    implicit none  

    integer, parameter :: n_binary_limit = 1024          !2147483647

    contains
    
    !>
    !> Create distributed array (DMDA) for flow
    !> problem
    !>
    subroutine solver_dd_DMDACreate_flow_heat(bflag_flow)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscdmda.h>
#ifdef USG
#include <petsc/finclude/petscdmplex.h>
#include <petsc/finclude/petscdmlabel.h>
#endif
      use petscdmda
#ifdef USG
      use petscdmplex
#endif
#endif

      use gen, only: nvxgbl, nvygbl, nvzgbl, idbg, ilog, rank, nprcs,  &
                     mpiarray_ndim, mpiarray_sizes_gbl,                &
                     mpiarray_sizes_sub, mpiarray_starts_sub,          &
                     mpiarray_sizes_vel_gbl, mpiarray_sizes_vel_sub,   &
                     mpiarray_starts_vel_sub, discretization_type

      use dens, only : density_dependence
      use dual, only : dual_porosity
      use m_heat_transport, only : heat_transport, decoupled_type_vs_heat
      use petsc_mpi_common, only : petsc_mpi_finalize

      implicit none

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdmdef.h>
#include <petsc/finclude/petscdm.h>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscdmda.h90>
#ifdef USG
#include <petsc/finclude/petscdmplex.h>
#endif
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscdmdef.h>
#include <finclude/petscdm.h>
#include <finclude/petscdmda.h>
#include <finclude/petscdmda.h90>
#ifdef USG
#include <finclude/petscdmplex.h>
#endif
#endif

      PetscBool :: bflag_flow

      type(userctx), pointer :: dmda_selec
      Vec, pointer :: x_selec
      Vec, pointer :: b_selec
      Vec, pointer :: r_selec
      Vec, pointer :: x_loc_selec
      Vec, pointer :: b_loc_selec
      Vec, pointer :: r_loc_selec
        
      PetscErrorCode :: ierr

      PetscInt :: i, istart, iend, info_debug
#ifdef USG
      PetscSection :: section
      DMLabel :: label
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
      DMLabel, pointer :: nolabel(:) => NULL()
#endif
      PetscInt :: numFields, numBC
      PetscInt, target, dimension(1) ::  numComp
      PetscInt, target, dimension(4) ::  numDof
      PetscInt, target, dimension(1) ::  bcField

      PetscInt, pointer :: pNumComp(:)
      PetscInt, pointer :: pNumDof(:)
      PetscInt, pointer :: pBcField(:)
      IS, target, dimension(1) ::   bcCompIS
      IS, target, dimension(1) ::   bcPointIS
      IS, pointer :: pBcCompIS(:)
      IS, pointer :: pBcPointIS(:)
      DMLabel, pointer :: pLabels(:) => NULL()
#endif

      !c point to flow or decoupled heat variables
      if (bflag_flow) then
        dmda_selec => dmda_flow
        x_selec => x_flow
        b_selec => b_flow
        r_selec => r_flow
        x_loc_selec => x_flow_loc
        b_loc_selec => b_flow_loc
        r_loc_selec => r_flow_loc
      else
        dmda_selec => dmda_heat
        x_selec => x_heat
        b_selec => b_heat
        r_selec => r_heat
        x_loc_selec => x_heat_loc
        b_loc_selec => b_heat_loc
        r_loc_selec => r_heat_loc
      end if

      !> Initialize
      if((heat_transport .and. decoupled_type_vs_heat <= 1) .or.       &
        dual_porosity) then
        dmda_selec%dof = 2
      else
        dmda_selec%dof = 1
      end if

      dmda_selec%swidth = stencil_width

      !c structured grid
      if (discretization_type == 0) then
        dmda_selec%dim  = 0

        dmda_selec%xs   = 0
        dmda_selec%xe   = 0
        dmda_selec%xl   = 1
        dmda_selec%gxs  = 0
        dmda_selec%gxe  = 0
        dmda_selec%gxl  = 1

        dmda_selec%ys   = 0
        dmda_selec%ye   = 0
        dmda_selec%yl   = 1
        dmda_selec%gys  = 0
        dmda_selec%gye  = 0
        dmda_selec%gyl  = 1

        dmda_selec%zs   = 0
        dmda_selec%ze   = 0
        dmda_selec%zl   = 1
        dmda_selec%gzs  = 0
        dmda_selec%gze  = 0
        dmda_selec%gzl  = 1

        dmda_selec%nvxgbl   = 1
        dmda_selec%nvygbl   = 1
        dmda_selec%nvzgbl   = 1

        dmda_selec%npx  = 1
        dmda_selec%npy  = 1
        dmda_selec%npz  = 1
        
        !> Initialize mpi subarray parameters
        if (bflag_flow) then
          mpiarray_ndim = 1
        
          mpiarray_sizes_gbl = 1
          mpiarray_sizes_sub = 1
          mpiarray_starts_sub = 0
        
          mpiarray_sizes_vel_gbl = 1
          mpiarray_sizes_vel_sub = 1
          mpiarray_starts_vel_sub = 0
        end if
   
        !> Create DMDA and get local grid boundary
        !3D domain
        if (nvxgbl > 1 .and. nvygbl > 1 .and. nvzgbl > 1) then  
!cdsu Note: DMDABoundaryType has become DMBoundaryType, and all the 
!cdsu enumerationvalues have also been renamed from PETSc 3.5
!cdsu For the windows version, we still use PETSc 3.4.

          call DMDACreate3d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                    DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,             &
                    DMDA_BOUNDARY_NONE,                                &
#else
                    DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                 &
                    DM_BOUNDARY_NONE,                                  &
#endif

                    DMDA_STENCIL_BOX,nvxgbl,nvygbl,nvzgbl,             &
                    PETSC_DECIDE,PETSC_DECIDE,                         &
                    PETSC_DECIDE,                                      &
                    dmda_selec%dof, dmda_selec%swidth,                 &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,dmda_selec%da,ierr) 
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                   dmda_selec%nvxgbl,dmda_selec%nvygbl,                &
                   dmda_selec%nvzgbl,                                  &
                   dmda_selec%npx,dmda_selec%npy,                      &
                   dmda_selec%npz, PETSC_NULL_INTEGER,                 &
                   PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,              &
                   PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,              &
                   PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%xs,             &
                   dmda_selec%ys,dmda_selec%zs,                        &
                   dmda_selec%xl,dmda_selec%yl,                        &
                   dmda_selec%zl,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gxs,       &
                   dmda_selec%gys,dmda_selec%gzs,                      &
                   dmda_selec%gxl,dmda_selec%gyl,                      &
                   dmda_selec%gzl,ierr)
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 3            
            mpiarray_sizes_gbl(1) = nvxgbl            
            mpiarray_sizes_sub(1) = dmda_selec%xl
            mpiarray_starts_sub(1) = dmda_selec%xs
            
            mpiarray_sizes_gbl(2) = nvygbl          
            mpiarray_sizes_sub(2) = dmda_selec%yl
            mpiarray_starts_sub(2) = dmda_selec%ys
            
            mpiarray_sizes_gbl(3) = nvzgbl
            mpiarray_sizes_sub(3) = dmda_selec%zl
            mpiarray_starts_sub(3) = dmda_selec%zs
            
            mpiarray_sizes_vel_gbl(1) = nvxgbl-1 
            if(dmda_selec%xs == dmda_selec%gxs) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%xs
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl 
              mpiarray_starts_vel_sub(1) = dmda_selec%xs-1
            end if
            
            mpiarray_sizes_vel_gbl(2) = nvygbl-1
            if(dmda_selec%ys == dmda_selec%gys) then
              mpiarray_sizes_vel_sub(2) = dmda_selec%yl-1  
              mpiarray_starts_vel_sub(2) = dmda_selec%ys
            else
              mpiarray_sizes_vel_sub(2) = dmda_selec%yl 
              mpiarray_starts_vel_sub(2) = dmda_selec%ys-1
            end if
            
            mpiarray_sizes_vel_gbl(3) = nvzgbl-1 
            if(dmda_selec%zs == dmda_selec%gzs) then
              mpiarray_sizes_vel_sub(3) = dmda_selec%zl-1  
              mpiarray_starts_vel_sub(3) = dmda_selec%zs
            else
              mpiarray_sizes_vel_sub(3) = dmda_selec%zl 
              mpiarray_starts_vel_sub(3) = dmda_selec%zs-1
            end if
          end if
            
        !2D xy domain                                                  
        else if (nvxgbl > 1 .and. nvygbl > 1) then    
          call DMDACreate2d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                  DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,               &
#else
                  DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                   &
#endif
                  DMDA_STENCIL_BOX,                                    &
                  nvxgbl,nvygbl,PETSC_DECIDE,PETSC_DECIDE,             &
                  dmda_selec%dof, dmda_selec%swidth,                   &
                  PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,               &
                  dmda_selec%da,ierr) 
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                    dmda_selec%nvxgbl,dmda_selec%nvygbl,               &
                    PETSC_NULL_INTEGER,                                &
                    dmda_selec%npx,dmda_selec%npy,                     &
                    PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,            &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%xs,             &
                   dmda_selec%ys,PETSC_NULL_INTEGER,                   &
                   dmda_selec%xl,dmda_selec%yl,                        &
                   PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gxs,       &
                   dmda_selec%gys,PETSC_NULL_INTEGER,                  &
                   dmda_selec%gxl,dmda_selec%gyl,                      &
                   PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 2            
            mpiarray_sizes_gbl(1) = nvxgbl            
            mpiarray_sizes_sub(1) = dmda_selec%xl
            mpiarray_starts_sub(1) = dmda_selec%xs
            
            mpiarray_sizes_gbl(2) = nvygbl          
            mpiarray_sizes_sub(2) = dmda_selec%yl
            mpiarray_starts_sub(2) = dmda_selec%ys
            
           
            mpiarray_sizes_vel_gbl(1) = nvxgbl-1 
            if(dmda_selec%xs == dmda_selec%gxs) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%xs
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl 
              mpiarray_starts_vel_sub(1) = dmda_selec%xs-1
            end if
            
            mpiarray_sizes_vel_gbl(2) = nvygbl-1
            if(dmda_selec%ys == dmda_selec%gys) then
              mpiarray_sizes_vel_sub(2) = dmda_selec%yl-1  
              mpiarray_starts_vel_sub(2) = dmda_selec%ys
            else
              mpiarray_sizes_vel_sub(2) = dmda_selec%yl 
              mpiarray_starts_vel_sub(2) = dmda_selec%ys-1
            end if
          end if
        !2D yz domain                                                  
        else if (nvygbl > 1 .and. nvzgbl > 1) then
          call DMDACreate2d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                    DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,             &
#else
                    DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                 &
#endif
                    DMDA_STENCIL_BOX,                                  &
                    nvygbl,nvzgbl,PETSC_DECIDE,PETSC_DECIDE,           &
                    dmda_selec%dof, dmda_selec%swidth,                 &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%da,ierr)
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                    dmda_selec%nvygbl,dmda_selec%nvzgbl,               &
                    PETSC_NULL_INTEGER,                                &
                    dmda_selec%npy,dmda_selec%npz,                     &
                    PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,            &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%ys,             &
                    dmda_selec%zs,PETSC_NULL_INTEGER,                  &
                    dmda_selec%yl,dmda_selec%zl,                       &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gys,       &
                    dmda_selec%gzs,PETSC_NULL_INTEGER,                 &
                    dmda_selec%gyl,dmda_selec%gzl,                     &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 2            
            mpiarray_sizes_gbl(1) = nvygbl            
            mpiarray_sizes_sub(1) = dmda_selec%yl
            mpiarray_starts_sub(1) = dmda_selec%ys
            
            mpiarray_sizes_gbl(2) = nvzgbl          
            mpiarray_sizes_sub(2) = dmda_selec%zl
            mpiarray_starts_sub(2) = dmda_selec%zs
            
            mpiarray_sizes_vel_gbl(1) = nvygbl-1 
            if(dmda_selec%ys == dmda_selec%gys) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%yl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%ys
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%yl 
              mpiarray_starts_vel_sub(1) = dmda_selec%ys-1
            end if
            
            mpiarray_sizes_vel_gbl(2) = nvzgbl-1
            if(dmda_selec%zs == dmda_selec%gzs) then
              mpiarray_sizes_vel_sub(2) = dmda_selec%zl-1  
              mpiarray_starts_vel_sub(2) = dmda_selec%zs
            else
              mpiarray_sizes_vel_sub(2) = dmda_selec%zl 
              mpiarray_starts_vel_sub(2) = dmda_selec%zs-1
            end if
          end if
        !2D xz domain                                                  
        else if (nvzgbl > 1 .and. nvxgbl > 1) then  
          call DMDACreate2d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                    DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,             &
#else
                    DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                 &
#endif
                    DMDA_STENCIL_BOX,                                  &
                    nvxgbl,nvzgbl,PETSC_DECIDE,PETSC_DECIDE,           &
                    dmda_selec%dof, dmda_selec%swidth,                 &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%da,ierr)
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                    dmda_selec%nvxgbl,dmda_selec%nvzgbl,               &
                    PETSC_NULL_INTEGER,                                &
                    dmda_selec%npx,dmda_selec%npz,                     &
                    PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,            &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%xs,             &
                    dmda_selec%zs,PETSC_NULL_INTEGER,                  &
                    dmda_selec%xl,dmda_selec%zl,                       &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gxs,       &
                    dmda_selec%gzs,PETSC_NULL_INTEGER,                 &
                    dmda_selec%gxl,dmda_selec%gzl,                     &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 2            
            mpiarray_sizes_gbl(1) = nvxgbl            
            mpiarray_sizes_sub(1) = dmda_selec%xl
            mpiarray_starts_sub(1) = dmda_selec%xs
            
            mpiarray_sizes_gbl(2) = nvzgbl          
            mpiarray_sizes_sub(2) = dmda_selec%zl
            mpiarray_starts_sub(2) = dmda_selec%zs
            
           
            mpiarray_sizes_vel_gbl(1) = nvxgbl-1 
            if(dmda_selec%xs == dmda_selec%gxs) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%xs
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl 
              mpiarray_starts_vel_sub(1) = dmda_selec%xs-1
            end if
            
            mpiarray_sizes_vel_gbl(2) = nvzgbl-1
            if(dmda_selec%zs == dmda_selec%gzs) then
              mpiarray_sizes_vel_sub(2) = dmda_selec%zl-1  
              mpiarray_starts_vel_sub(2) = dmda_selec%zs
            else
              mpiarray_sizes_vel_sub(2) = dmda_selec%zl 
              mpiarray_starts_vel_sub(2) = dmda_selec%zs-1
            end if
          end if
        !1D x domain                                                   
        else if (nvxgbl > 1) then
          call DMDACreate1d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                    DMDA_BOUNDARY_NONE,                                &
#else
                    DM_BOUNDARY_NONE,                                  &
#endif
                    nvxgbl,dmda_selec%dof,dmda_selec%swidth,           &
                    PETSC_NULL_INTEGER,dmda_selec%da,ierr)  
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                    dmda_selec%nvxgbl,PETSC_NULL_INTEGER,              &
                    PETSC_NULL_INTEGER,                                &
                    dmda_selec%npx,PETSC_NULL_INTEGER,                 &
                    PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,            &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%xs,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%xl,PETSC_NULL_INTEGER,                  &
                    PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gxs,       &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%gxl,PETSC_NULL_INTEGER,                 &
                    PETSC_NULL_INTEGER,ierr)  
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 1            
            mpiarray_sizes_gbl(1) = nvxgbl            
            mpiarray_sizes_sub(1) = dmda_selec%xl
            mpiarray_starts_sub(1) = dmda_selec%xs
            
            mpiarray_sizes_vel_gbl(1) = nvxgbl-1 
            if(dmda_selec%xs == dmda_selec%gxs) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%xs
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%xl 
              mpiarray_starts_vel_sub(1) = dmda_selec%xs-1
            end if
          end if                                                            
        !1D y domain                                                   
        else if (nvygbl > 1) then           
          call DMDACreate1d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                    DMDA_BOUNDARY_NONE,                                &
#else
                    DM_BOUNDARY_NONE,                                  &
#endif
                    nvygbl,dmda_selec%dof,dmda_selec%swidth,           &
                    PETSC_NULL_INTEGER,dmda_selec%da,ierr)
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                    dmda_selec%nvygbl,PETSC_NULL_INTEGER,              &
                    PETSC_NULL_INTEGER,                                &
                    dmda_selec%npy,PETSC_NULL_INTEGER,                 &
                    PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,            &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%ys,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%yl,PETSC_NULL_INTEGER,                  &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gys,       &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_selec%gyl,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 1            
            mpiarray_sizes_gbl(1) = nvygbl            
            mpiarray_sizes_sub(1) = dmda_selec%yl
            mpiarray_starts_sub(1) = dmda_selec%ys
            
            mpiarray_sizes_vel_gbl(1) = nvygbl-1 
            if(dmda_selec%ys == dmda_selec%gys) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%yl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%ys
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%yl 
              mpiarray_starts_vel_sub(1) = dmda_selec%ys-1
            end if
          end if                                                             
        !1D z domain                                                   
        else if (nvzgbl > 1) then
          call DMDACreate1d(Petsc_Comm_World,                          &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                    DMDA_BOUNDARY_NONE,                                &
#else
                    DM_BOUNDARY_NONE,                                  &
#endif
                    nvzgbl,dmda_selec%dof,dmda_selec%swidth,           &
                    PETSC_NULL_INTEGER,dmda_selec%da,ierr)
          CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
          call DMSetUp(dmda_selec%da,ierr)
          CHKERRQ(ierr)
#endif
                                                                       
          call DMDAGetInfo(dmda_selec%da,dmda_selec%dim,               &
                    dmda_selec%nvzgbl,PETSC_NULL_INTEGER,              &
                    PETSC_NULL_INTEGER,                                &
                    dmda_selec%npz,PETSC_NULL_INTEGER,                 &
                    PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,            &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetCorners(dmda_selec%da,dmda_selec%zs,             &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%zl,PETSC_NULL_INTEGER,                  &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
                                                                       
          call DMDAGetGhostCorners(dmda_selec%da,dmda_selec%gzs,       &
                    PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,             &
                    dmda_selec%gzl,PETSC_NULL_INTEGER,                 &
                    PETSC_NULL_INTEGER,ierr)
          CHKERRQ(ierr)
            
          !>Note: mpi subbary parameters are 0-based index
          if (bflag_flow) then
            mpiarray_ndim = 1            
            mpiarray_sizes_gbl(1) = nvzgbl            
            mpiarray_sizes_sub(1) = dmda_selec%zl
            mpiarray_starts_sub(1) = dmda_selec%zs
            
            mpiarray_sizes_vel_gbl(1) = nvzgbl-1 
            if(dmda_selec%zs == dmda_selec%gzs) then
              mpiarray_sizes_vel_sub(1) = dmda_selec%zl-1  
              mpiarray_starts_vel_sub(1) = dmda_selec%zs
            else
              mpiarray_sizes_vel_sub(1) = dmda_selec%zl 
              mpiarray_starts_vel_sub(1) = dmda_selec%zs-1
            end if
          end if
        end if

        !> Shift the starting indices up by one so that we can easily
        !> use the Fortran convention of 1-based indices (rather 0-based indices).
        dmda_selec%xs  = dmda_selec%xs+1        
        dmda_selec%ys  = dmda_selec%ys+1        
        dmda_selec%zs  = dmda_selec%zs+1
        
        dmda_selec%gxs = dmda_selec%gxs+1
        dmda_selec%gys = dmda_selec%gys+1
        dmda_selec%gzs = dmda_selec%gzs+1
        
        dmda_selec%xe  = dmda_selec%xs+dmda_selec%xl-1
        dmda_selec%ye  = dmda_selec%ys+dmda_selec%yl-1
        dmda_selec%ze  = dmda_selec%zs+dmda_selec%zl-1

        dmda_selec%gxe = dmda_selec%gxs+dmda_selec%gxl-1
        dmda_selec%gye = dmda_selec%gys+dmda_selec%gyl-1
        dmda_selec%gze = dmda_selec%gzs+dmda_selec%gzl-1

      !c unstructured grid
      else if (discretization_type > 0) then
#ifdef USG

        if (dmda_selec%dim < 1) then
          if (rank == 0) then
            if (bflag_flow) then
              write(*,*) 'Error: PETSc DMDA for flow is not set'
              write(ilog,*) 'Error: PETSc DMDA for flow is not set'
            else
              write(*,*) 'Error: PETSc DMDA for decoupled heat transport is not set'
              write(ilog,*) 'Error: PETSc DMDA for decoupled heat transport is not set'
            end if
          end if
          call petsc_mpi_finalize
          stop
        end if

        numFields = 1
        numComp(1) = 1
        pNumComp => numComp
        
        do i = 1, numFields*(dmda_selec%dim+1)
          numDof(i) = 0
        end do
        !c num of dof for vert, edge, cell
        numDof(0*(dmda_selec%dim+1)+1) = dmda_selec%dof
        pNumDof => numDof
        
        !c no BC is assigned, use NULL instead for pBcCompIS and pBcPointIS
        numBC = 0
        bcField(1) = 0
        pBcField => bcField

        !c bcCompIS and bcPointIS is not required, use null data
        pBcCompIS => bcCompIS
        pBcPointIS => bcPointIS

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
        call DMSetNumFields(dmda_selec%da,numFields,ierr)
        CHKERRQ(ierr)
#endif

        call DMPlexCreateSection(dmda_selec%da,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
                                nolabel,                               &
#else
                                dmda_selec%dim,numFields,              &
#endif
                                pNumComp,pNumDof,                      &
                                numBC,pBcField,                        &
                                pBcCompIS,pBcPointIS,                  &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                PETSC_NULL_IS,                         &
#else
                                PETSC_NULL_OBJECT,                     &
#endif
                                section,ierr)
        CHKERRQ(ierr)
        
        if (bflag_flow) then
          call PetscSectionSetFieldName(section,0,'flow',ierr)
          CHKERRQ(ierr)
        else
          call PetscSectionSetFieldName(section,0,'heat',ierr)
          CHKERRQ(ierr)
        end if
        
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 10)  
        call DMSetSection(dmda_selec%da,section,ierr)
        CHKERRQ(ierr)
#else
        call DMSetDefaultSection(dmda_selec%da,section,ierr)
        CHKERRQ(ierr)
#endif

        call PetscSectionDestroy(section,ierr)
        CHKERRQ(ierr)

        call DMSetUp(dmda_selec%da,ierr)
        CHKERRQ(ierr)
#endif
      end if

      !> Extract global and local vectors from DMDA; then duplicate for remaining
      !> vectors that are the same types
      call DMCreateGlobalVector(dmda_selec%da,x_selec,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(x_selec,b_selec,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(b_selec,r_selec,ierr)
      CHKERRQ(ierr)

      call DMCreateLocalVector(dmda_selec%da,x_loc_selec,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(x_loc_selec,b_loc_selec,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(b_loc_selec,r_loc_selec,ierr)
      CHKERRQ(ierr)

      !> get range
      call VecGetOwnershipRange(x_selec, istart, iend, ierr)
      CHKERRQ(ierr)
      dmda_selec%range_start = istart + 1
      dmda_selec%range_end = iend

      !> Check the result
#ifdef DEBUG
      info_debug = 0
      if(info_debug > 0) then
        if (discretization_type == 0) then
          write(idbg, '(a/,26(1x,a,1x,i4))')                           &
                "flow","dof",dmda_selec%dof,                           &
                "stencil_width", dmda_selec%swidth,                    &
                "dim",dmda_selec%dim,"nvxgbl",dmda_selec%nvxgbl,       &
                "nvygbl",dmda_selec%nvygbl,                            &
                "nvzgbl",dmda_selec%nvzgbl,                            &
                "xs",dmda_selec%xs,"xe",dmda_selec%xe,                 &
                "xl",dmda_selec%xl,"gxs",dmda_selec%gxs,               &
                "gxe",dmda_selec%gxe,"gxl",dmda_selec%gxl,             &
                "ys",dmda_selec%ys,"ye",dmda_selec%ye,                 &
                "yl",dmda_selec%yl,"gys",dmda_selec%gys,               &
                "gye",dmda_selec%gye,"gyl",dmda_selec%gyl,             &
                "zs",dmda_selec%zs,"ze",dmda_selec%ze,                 &
                "zl",dmda_selec%zl,"gzs",dmda_selec%gzs,               &
                "gze",dmda_selec%gze,"gzl",dmda_selec%gzl,             &
                "vec_range_start", dmda_selec%range_start,             &
                "vec_range_end", dmda_selec%range_end
        else if (discretization_type > 0) then
          write(idbg,'(a/,5(a,1x,i6,1x))')                             &
                "flow","dof",dmda_selec%dof,                           &
                "stencil_width",dmda_selec%swidth,                     &
                "dim",dmda_selec%dim,                                  &
                "vec_range_start", dmda_selec%range_start,             &
                "vec_range_end", dmda_selec%range_end
        end if
      end if
#endif
    
    end subroutine solver_dd_DMDACreate_flow_heat
    
    !>
    !> Create distributed array (DMDA) for reactive
    !> transport problem
    !>
    subroutine solver_dd_DMDACreate_react()

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscdmda.h>
#ifdef USG
#include <petsc/finclude/petscdmplex.h>
#endif
      use petscdmda
#ifdef USG
      use petscdmplex
#endif
#endif
      use gen, only: nvxgbl, nvygbl, nvzgbl, n, idbg, rank,            &
                     discretization_type

      implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdmdef.h>
#include <petsc/finclude/petscdm.h>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscdmda.h90>
#ifdef USG
#include <petsc/finclude/petscdmplex.h>
#endif
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscdmdef.h>
#include <finclude/petscdm.h>
#include <finclude/petscdmda.h>
#include <finclude/petscdmda.h90>
#ifdef USG
#include <finclude/petscdmplex.h>
#endif
#endif
        
      PetscErrorCode :: ierr
        
      PetscInt :: i, istart, iend, info_debug

#ifdef USG
      PetscSection :: section
      DMLabel :: label
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
      DMLabel, pointer :: nolabel(:) => NULL()
#endif
      PetscInt :: numFields, numBC
      PetscInt, target, dimension(1) ::  numComp
      PetscInt, target, dimension(4) ::  numDof
      PetscInt, target, dimension(1) ::  bcField

      PetscInt, pointer :: pNumComp(:)
      PetscInt, pointer :: pNumDof(:)
      PetscInt, pointer :: pBcField(:)
      IS, target, dimension(1) ::   bcCompIS
      IS, target, dimension(1) ::   bcPointIS
      IS, pointer :: pBcCompIS(:)
      IS, pointer :: pBcPointIS(:)

      DMLabel, pointer :: pLabels(:) => NULL()
#endif
        
      !> Initialize
      dmda_react%dim = dmda_flow%dim

      dmda_react%dof = n

      dmda_react%swidth = stencil_width

      !c structured grid
      if (discretization_type == 0) then
        
        dmda_react%xs   = 0
        dmda_react%xe   = 0
        dmda_react%xl   = 1
        dmda_react%gxs  = 0
        dmda_react%gxe  = 0
        dmda_react%gxl  = 1

        dmda_react%ys   = 0
        dmda_react%ye   = 0
        dmda_react%yl   = 1
        dmda_react%gys  = 0
        dmda_react%gye  = 0
        dmda_react%gyl  = 1

        dmda_react%zs   = 0
        dmda_react%ze   = 0
        dmda_react%zl   = 1
        dmda_react%gzs  = 0
        dmda_react%gze  = 0
        dmda_react%gzl  = 1

        dmda_react%nvxgbl   = 1
        dmda_react%nvygbl   = 1
        dmda_react%nvzgbl   = 1

        dmda_react%npx  = 1
        dmda_react%npy  = 1
        dmda_react%npz  = 1
   
        !> Create DMDA and get local grid boundary
        !3D domain
        if (nvxgbl > 1 .and. nvygbl > 1 .and. nvzgbl > 1) then 
!cdsu Note: DMDABoundaryType has become DMBoundaryType, and all the 
!cdsu enumerationvalues have also been renamed from PETSc 3.5.
!cdsu For the windows version, we still use PETSc 3.4. 
            call DMDACreate3d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,            &
                     DMDA_BOUNDARY_NONE,                               &
#else
                     DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                &
                     DM_BOUNDARY_NONE,                                 &
#endif
                     DMDA_STENCIL_BOX,nvxgbl,nvygbl,nvzgbl,            &
                     PETSC_DECIDE,PETSC_DECIDE,                        &
                     PETSC_DECIDE,                                     &
                     dmda_react%dof, dmda_react%swidth,                &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif
                                                                       
            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvxgbl,dmda_react%nvygbl,              &
                     dmda_react%nvzgbl,                                &
                     dmda_react%npx,dmda_react%npy,                    &
                     dmda_react%npz, PETSC_NULL_INTEGER,               &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%xs,           &
                     dmda_react%ys,dmda_react%zs,                      &
                     dmda_react%xl,dmda_react%yl,                      &
                     dmda_react%zl,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gxs,     &
                     dmda_react%gys,dmda_react%gzs,                    &
                     dmda_react%gxl,dmda_react%gyl,                    &
                     dmda_react%gzl,ierr)
             CHKERRQ(ierr)

        !2D xy domain                                                  
        else if (nvxgbl > 1 .and. nvygbl > 1) then  

            call DMDACreate2d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,            &
#else
                     DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                &
#endif
                     DMDA_STENCIL_BOX,                                 &
                     nvxgbl,nvygbl,PETSC_DECIDE,PETSC_DECIDE,          &
                     dmda_react%dof, dmda_react%swidth,                &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif

            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvxgbl,dmda_react%nvygbl,              &
                     PETSC_NULL_INTEGER,                               &
                     dmda_react%npx,dmda_react%npy,                    &
                     PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%xs,           &
                     dmda_react%ys,PETSC_NULL_INTEGER,                 &
                     dmda_react%xl,dmda_react%yl,                      &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gxs,     &
                     dmda_react%gys,PETSC_NULL_INTEGER,                &
                     dmda_react%gxl,dmda_react%gyl,                    &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)

        !2D yz domain                                                  
        else if (nvygbl > 1 .and. nvzgbl > 1) then     

            call DMDACreate2d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,            &
#else
                     DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                &
#endif
                     DMDA_STENCIL_BOX,                                 &
                     nvygbl,nvzgbl,PETSC_DECIDE,PETSC_DECIDE,          &
                     dmda_react%dof, dmda_react%swidth,                &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif

            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvygbl,dmda_react%nvzgbl,              &
                     PETSC_NULL_INTEGER,                               &
                     dmda_react%npy,dmda_react%npz,                    &
                     PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%ys,           &
                     dmda_react%zs,PETSC_NULL_INTEGER,                 &
                     dmda_react%yl,dmda_react%zl,                      &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gys,     &
                     dmda_react%gzs,PETSC_NULL_INTEGER,                &
                     dmda_react%gyl,dmda_react%gzl,                    &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)

        !2D xz domain                                                  
        else if (nvzgbl > 1 .and. nvxgbl > 1) then 
            call DMDACreate2d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,DMDA_BOUNDARY_NONE,            &
#else
                     DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,                &
#endif
                     DMDA_STENCIL_BOX,                                 &
                     nvxgbl,nvzgbl,PETSC_DECIDE,PETSC_DECIDE,          &
                     dmda_react%dof, dmda_react%swidth,                &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif
                                                                       
            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvxgbl,dmda_react%nvzgbl,              &
                     PETSC_NULL_INTEGER,                               &
                     dmda_react%npx,dmda_react%npz,                    &
                     PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%xs,           &
                     dmda_react%zs,PETSC_NULL_INTEGER,                 &
                     dmda_react%xl,dmda_react%zl,                      &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gxs,     &
                     dmda_react%gzs,PETSC_NULL_INTEGER,                &
                     dmda_react%gxl,dmda_react%gzl,                    &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)

        !1D x domain                                                   
        else if (nvxgbl > 1) then

            call DMDACreate1d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,                               &
#else
                     DM_BOUNDARY_NONE,                                 &
#endif
                     nvxgbl,dmda_react%dof,dmda_react%swidth,          &
                     PETSC_NULL_INTEGER,dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif
                                                                       
            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvxgbl,PETSC_NULL_INTEGER,             &
                     PETSC_NULL_INTEGER,                               &
                     dmda_react%npx,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%xs,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%xl,PETSC_NULL_INTEGER,                 &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gxs,     &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%gxl,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
        !1D y domain                                                   
        else if (nvygbl > 1) then
            call DMDACreate1d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,                               &
#else
                     DM_BOUNDARY_NONE,                                 &
#endif
                     nvygbl,dmda_react%dof,dmda_react%swidth,          &
                     PETSC_NULL_INTEGER,dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif
                                                                       
            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvygbl,PETSC_NULL_INTEGER,             &
                     PETSC_NULL_INTEGER,                               &
                     dmda_react%npy,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%ys,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%yl,PETSC_NULL_INTEGER,                 &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gys,     &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%gyl,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
        !1D z domain                                                   
        else if (nvzgbl > 1) then

            call DMDACreate1d(Petsc_Comm_World,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
                     DMDA_BOUNDARY_NONE,                               &
#else
                     DM_BOUNDARY_NONE,                                 &
#endif
                     nvzgbl,dmda_react%dof,dmda_react%swidth,          &
                     PETSC_NULL_INTEGER,dmda_react%da,ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
            call DMSetUp(dmda_react%da,ierr)
            CHKERRQ(ierr)
#endif
                                                                       
            call DMDAGetInfo(dmda_react%da,dmda_react%dim,             &
                     dmda_react%nvzgbl,PETSC_NULL_INTEGER,             &
                     PETSC_NULL_INTEGER,                               &
                     dmda_react%npz,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER, PETSC_NULL_INTEGER,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetCorners(dmda_react%da,dmda_react%zs,           &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%zl,PETSC_NULL_INTEGER,                 &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
                                                                       
            call DMDAGetGhostCorners(dmda_react%da,dmda_react%gzs,     &
                     PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,            &
                     dmda_react%gzl,PETSC_NULL_INTEGER,                &
                     PETSC_NULL_INTEGER,ierr)
            CHKERRQ(ierr)
            
        end if
        
        !> Shift the starting indices up by one so that we can easily
        !> use the Fortran convention of 1-based indices (rather 0-based indices).
        dmda_react%xs  = dmda_react%xs+1
        dmda_react%ys  = dmda_react%ys+1
        dmda_react%zs  = dmda_react%zs+1

        dmda_react%gxs = dmda_react%gxs+1
        dmda_react%gys = dmda_react%gys+1
        dmda_react%gzs = dmda_react%gzs+1

        dmda_react%xe  = dmda_react%xs+dmda_react%xl-1
        dmda_react%ye  = dmda_react%ys+dmda_react%yl-1
        dmda_react%ze  = dmda_react%zs+dmda_react%zl-1

        dmda_react%gxe = dmda_react%gxs+dmda_react%gxl-1
        dmda_react%gye = dmda_react%gys+dmda_react%gyl-1
        dmda_react%gze = dmda_react%gzs+dmda_react%gzl-1
        
      !c unstructured grid
      else if (discretization_type > 0) then
#ifdef USG
        call DMClone(dmda_flow%da,dmda_react%da,ierr)
        CHKERRQ(ierr)

        numFields = 1
        numComp(1) = 1
        pNumComp => numComp

        do i = 1, numFields*(dmda_react%dim+1)
          numDof(i) = 0
        end do
        !c num of dof for vert, edge, cell
        numDof(0*(dmda_react%dim+1)+1) = dmda_react%dof
        pNumDof => numDof

        !c no BC is assigned, use NULL instead for pBcCompIS and pBcPointIS
        numBC = 0
        bcField(1) = 0
        pBcField => bcField

        !c bcCompIS and bcPointIS is not required, use null data
        pBcCompIS => bcCompIS
        pBcPointIS => bcPointIS

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
        call DMSetNumFields(dmda_react%da,numFields,ierr)
        CHKERRQ(ierr)
#endif

        call DMPlexCreateSection(dmda_react%da,                        &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
                                 nolabel,                              &
#else
                                 dmda_react%dim,numFields,             &
#endif
                                 pNumComp,pNumDof,                     &
                                 numBC,pBcField,                       &
                                 pBcCompIS,pBcPointIS,                 &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                 PETSC_NULL_IS,                        &
#else
                                 PETSC_NULL_OBJECT,                    &
#endif
                                 section,ierr)
        CHKERRQ(ierr)

        call PetscSectionSetFieldName(section,0,'react',ierr)
        CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 10) 
        call DMSetSection(dmda_react%da,section,ierr)
        CHKERRQ(ierr)
#else
        call DMSetDefaultSection(dmda_react%da,section,ierr)
        CHKERRQ(ierr)
#endif

        call PetscSectionDestroy(section,ierr)
        CHKERRQ(ierr)

        call DMSetUp(dmda_react%da,ierr)
        CHKERRQ(ierr)

#endif
      end if

      !> Extract global and local vectors from DMDA; then duplicate for remaining
      !> vectors that are the same types
      call DMCreateGlobalVector(dmda_react%da,x_react,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(x_react,b_react,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(b_react,r_react,ierr)
      CHKERRQ(ierr)

      call DMCreateLocalVector(dmda_react%da,x_react_loc,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(x_react_loc,b_react_loc,ierr)
      CHKERRQ(ierr)
      call VecDuplicate(b_react_loc,r_react_loc,ierr)
      CHKERRQ(ierr)

      !> get range
      call VecGetOwnershipRange(x_react, istart, iend, ierr)
      CHKERRQ(ierr)
      dmda_react%range_start = istart + 1
      dmda_react%range_end = iend

      !> Check the result
#ifdef DEBUG
      info_debug = 0
      if(info_debug > 0) then
        if (discretization_type == 0) then
            write(idbg, '(a/,26(1x,a,1x,i4))')                         &
                  "reactive transport","dof",dmda_react%dof,           &
                  "stencil_width", dmda_react%swidth,                  &
                  "dim",dmda_react%dim,"nvxgbl",dmda_react%nvxgbl,     &
                  "nvygbl",dmda_react%nvygbl,                          &
                  "nvzgbl",dmda_react%nvzgbl,                          &
                  "xs",dmda_react%xs,"xe",dmda_react%xe,               &
                  "xl",dmda_react%xl,"gxs",dmda_react%gxs,             &
                  "gxe",dmda_react%gxe,"gxl",dmda_react%gxl,           &
                  "ys",dmda_react%ys,"ye",dmda_react%ye,               &
                  "yl",dmda_react%yl,"gys",dmda_react%gys,             &
                  "gye",dmda_react%gye,"gyl",dmda_react%gyl,           &
                  "zs",dmda_react%zs,"ze",dmda_react%ze,               &
                  "zl",dmda_react%zl,"gzs",dmda_react%gzs,             &
                  "gze",dmda_react%gze,"gzl",dmda_react%gzl,           &
                  "vec_range_start", dmda_react%range_start,           &
                  "vec_range_end", dmda_react%range_end
        else if (discretization_type > 0) then
          write(idbg,'(a/,5(a,1x,i6,1x))')                             &
                "react","dof",dmda_react%dof,                          &
                "stencil_width",dmda_react%swidth,                     &
                "dim",dmda_react%dim,                                  &
                "vec_range_start", dmda_react%range_start,             &
                "vec_range_end", dmda_react%range_end
        end if
      end if
#endif
    
    end subroutine solver_dd_DMDACreate_react
    
    !>Set global and local node index map
    subroutine solver_dd_mapping_set
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscis.h>
#include <petsc/finclude/petscdmda.h>
#ifdef USG
#include <petsc/finclude/petscdmplex.h>
#endif
        use petscis
        use petscdmda
#endif
        use gen, only: idbg, nvxgbl, nvygbl, nvzgbl, nvxls, nvxle,     &
                       nvyls, nvyle, nvzls, nvzle, nvxgls, nvxgle,     &
                       nvygls, nvygle, nvzgls, nvzgle, nn, nngl,       &
                       nngbl, node_idx_lg2l, node_idx_lg2g,            &
                       node_idx_lg2pg, node_idx_l2lg, rank, ilog,      &
                       mem_cur, mem_max, memory_monitor,               &
                       node_idx_vel_lg2g
        use petsc_mpi_common, only : petsc_mpi_finalize
    
        implicit none

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscis.h>
#include <petsc/finclude/petscdmdef.h>
#include <petsc/finclude/petscdm.h>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscdmda.h90>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscis.h>
#include <finclude/petscdmdef.h>
#include <finclude/petscdm.h>
#include <finclude/petscdmda.h>
#include <finclude/petscdmda.h90>
#endif

        
        PetscErrorCode :: ierr
               
        PetscInt :: ivx, ivy, ivz, ivol, ivol_l, ibase, ig, dof, ig_vel 

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
        PetscInt, pointer :: idx(:)
#else
        ISLocalToGlobalMapping :: ltogm
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 18)
        PetscInt :: ltog(2)
        PetscOffset :: idltog
#else
        PetscInt,pointer ::ltog(:)
#endif
#endif
        
        PetscInt :: info_debug
        
        external :: checkerr

        
        allocate(node_idx_lg2g(nngl), stat = ierr)
        call checkerr(ierr,'node_idx_lg2g',ilog)
        node_idx_lg2g = 0
        call memory_monitor(sizeof(node_idx_lg2g),'node_idx_lg2g',.true.)
        
        allocate(node_idx_vel_lg2g(nngl), stat = ierr)
        call checkerr(ierr,'node_idx_vel_lg2g',ilog)
        node_idx_vel_lg2g = 0
        call memory_monitor(sizeof(node_idx_vel_lg2g),'node_idx_vel_lg2g',.true.)
        
        allocate(node_idx_lg2l(nngl), stat = ierr)
        call checkerr(ierr,'node_idx_lg2l',ilog)
        node_idx_lg2l = 0
        call memory_monitor(sizeof(node_idx_lg2l),'node_idx_lg2l',.true.)
        
        allocate(node_idx_lg2pg(nngl), stat = ierr)
        call checkerr(ierr,'node_idx_lg2pg',ilog)
        node_idx_lg2pg = 0
        call memory_monitor(sizeof(node_idx_lg2pg),'node_idx_lg2pg',.true.)
        
        allocate(node_idx_l2lg(nn), stat = ierr)
        call checkerr(ierr,'node_idx_l2lg',ilog)
        node_idx_l2lg = 0

        !allocate(node_idx_lb2pg(nngl), stat = ierr)
        !call checkerr(ierr,'node_idx_lb2pg',ilog)
        !node_idx_lb2pg = -1

        ivol = 1
        ivol_l = 1
        
        select case (dmda_flow%dim)
            
        case (1)
            
            !1D x domain    
            if (nvxgbl > 1) then 
                do ivx = nvxgls,nvxgle  
                    node_idx_lg2g(ivol) = ivx
                    if (ivx == 1) then
                      node_idx_vel_lg2g(ivol) = -1
                    else
                      node_idx_vel_lg2g(ivol) = ivx-1 
                    end if
                    if(ivx < nvxls .or. ivx > nvxle) then
                        node_idx_lg2l(ivol) = -1
                    else
                        node_idx_lg2l(ivol) = ivol_l
                        node_idx_l2lg(ivol_l) = ivol
                        ivol_l = ivol_l + 1
                    end if
                    !if (ivx == nvxls .and. ivx > nvxgls) then
                    !  node_idx_lb2pg(ivol) = 1
                    !end if
                    ivol = ivol + 1
                end do
            !1D y domain
            else if (nvygbl > 1) then  
                do ivy = nvygls,nvygle
                    node_idx_lg2g(ivol) = ivy
                    if (ivy == 1) then
                      node_idx_vel_lg2g(ivol) = -1
                    else
                      node_idx_vel_lg2g(ivol) = ivy-1 
                    end if
                    if(ivy < nvyls .or. ivy > nvyle) then
                        node_idx_lg2l(ivol) = -1
                    else
                        node_idx_lg2l(ivol) = ivol_l
                        node_idx_l2lg(ivol_l) = ivol
                        ivol_l = ivol_l + 1
                    end if
                    !if (ivy == nvyls .and. ivy > nvygls) then
                    !  node_idx_lb2pg(ivol) = 1
                    !end if
                    ivol = ivol + 1
                end do
            !1D z domain
            else if (nvzgbl > 1) then 
                do ivz = nvzgls, nvzgle
                    node_idx_lg2g(ivol) = ivz
                    if (ivz == 1) then
                      node_idx_vel_lg2g(ivol) = -1
                    else
                      node_idx_vel_lg2g(ivol) = ivz-1 
                    end if
                    if(ivz < nvzls .or. ivz > nvzle) then
                        node_idx_lg2l(ivol) = -1
                    else
                        node_idx_lg2l(ivol) = ivol_l
                        node_idx_l2lg(ivol_l) = ivol
                        ivol_l = ivol_l + 1
                    end if
                    !if (ivz == nvzls .and. ivz > nvzgls) then
                    !  node_idx_lb2pg(ivol) = 1
                    !end if
                    ivol = ivol + 1
                end do  
            end if              
            
        case (2)
           
            !2D xy domain    
            if (nvxgbl > 1 .and. nvygbl > 1) then
                do ivy = nvygls,nvygle
                    ig = (ivy-1)*nvxgbl
                    ig_vel = (ivy-2)*(nvxgbl-1)
                    do ivx = nvxgls,nvxgle
                        node_idx_lg2g(ivol) = ig + ivx
                        if (ivx == 1 .or. ivy == 1) then
                          node_idx_vel_lg2g(ivol) = -1
                        else
                          node_idx_vel_lg2g(ivol) = ig_vel+ivx-1 
                        end if
                        if(ivx < nvxls .or. ivx > nvxle .or.           &
                           ivy < nvyls .or. ivy > nvyle) then
                            node_idx_lg2l(ivol) = -1
                        else
                            node_idx_lg2l(ivol) = ivol_l
                            node_idx_l2lg(ivol_l) = ivol
                            ivol_l = ivol_l + 1     
                        end if
                        !if ((ivx == nvxls .and. ivx > nvxgls) .or.     &
                        !    (ivy == nvyls .and. ivy > nvygls)) then
                        !  node_idx_lb2pg(ivol) = 1
                        !end if
                        ivol = ivol + 1   
                    end do
                end do
            !2D yz domain    
            else if (nvygbl > 1 .and. nvzgbl > 1) then
                do ivz = nvzgls, nvzgle
                    ig = (ivz-1)*nvygbl
                    ig_vel = (ivz-2)*(nvygbl-1)
                    do ivy = nvygls,nvygle            
                        node_idx_lg2g(ivol) = ig + ivy
                        if (ivz == 1 .or. ivy == 1) then
                          node_idx_vel_lg2g(ivol) = -1
                        else
                          node_idx_vel_lg2g(ivol) = ig_vel+ivy-1 
                        end if
                        if(ivy < nvyls .or. ivy > nvyle .or.           &
                           ivz < nvzls .or. ivz > nvzle) then
                            node_idx_lg2l(ivol) = -1
                        else    
                            node_idx_lg2l(ivol) = ivol_l
                            node_idx_l2lg(ivol_l) = ivol
                            ivol_l = ivol_l + 1
                        end if
                        !if ((ivy == nvyls .and. ivy > nvygls) .or.     &
                        !    (ivz == nvzls .and. ivz > nvzgls)) then
                        !  node_idx_lb2pg(ivol) = 1
                        !end if
                        ivol = ivol + 1     
                    end do
                end do
            !2D xz domain    
            else if (nvzgbl > 1 .and. nvxgbl > 1) then
                do ivz = nvzgls, nvzgle
                    ig = (ivz-1)*nvxgbl
                    ig_vel = (ivz-2)*(nvxgbl-1)
                    do ivx = nvxgls,nvxgle                   
                        node_idx_lg2g(ivol) = ig + ivx
                        if (ivz == 1 .or. ivx == 1) then
                          node_idx_vel_lg2g(ivol) = -1
                        else
                          node_idx_vel_lg2g(ivol) = ig_vel+ivx-1 
                        end if
                        if(ivx < nvxls .or. ivx > nvxle .or.           &
                           ivz < nvzls .or. ivz > nvzle) then
                            node_idx_lg2l(ivol) = -1
                        else    
                            node_idx_lg2l(ivol) = ivol_l
                            node_idx_l2lg(ivol_l) = ivol
                            ivol_l = ivol_l + 1
                        end if
                        !if ((ivx == nvxls .and. ivx > nvxgls) .or.     &
                        !    (ivz == nvzls .and. ivz > nvzgls)) then
                        !  node_idx_lb2pg(ivol) = 1
                        !end if
                        ivol = ivol + 1
                    end do
                end do
            end if
            
        case (3)             

            do ivz = nvzgls, nvzgle                
                do ivy = nvygls,nvygle
                    ig = (ivz-1)*nvygbl*nvxgbl+(ivy-1)*nvxgbl
                    ig_vel = (ivz-2)*(nvygbl-1)*(nvxgbl-1)+            &
                             (ivy-2)*(nvxgbl-1)
                    do ivx = nvxgls,nvxgle   
                        node_idx_lg2g(ivol) = ig + ivx
                        if (ivx == 1 .or. ivy == 1 .or. ivz == 1) then
                          node_idx_vel_lg2g(ivol) = -1
                        else
                          node_idx_vel_lg2g(ivol) = ig_vel+ivx-1 
                        end if
                        if(ivx < nvxls .or. ivx > nvxle .or.           &
                           ivy < nvyls .or. ivy > nvyle .or.           &
                           ivz < nvzls .or. ivz > nvzle) then
                            node_idx_lg2l(ivol) = -1
                        else
                            node_idx_lg2l(ivol) = ivol_l
                            node_idx_l2lg(ivol_l) = ivol
                            ivol_l = ivol_l + 1    
                        end if
                        !if ((ivx == nvxls .and. ivx > nvxgls) .or.     &
                        !    (ivy == nvyls .and. ivy > nvygls) .or.     &
                        !    (ivz == nvzls .and. ivz > nvzgls)) then
                        !  node_idx_lb2pg(ivol) = 1
                        !end if

                        ivol = ivol + 1                
                    end do
                end do
            end do
          
        end select
        
        info_debug = 0
#ifdef DEBUG
        if(info_debug > 0) then
            do ivol = 1, nngl
                write(idbg,'(5(a,1x,i6,1x))') "ivol_l",ivol,           &
                      "ivol_l_no_ghost",node_idx_lg2l(ivol),           &
                      "ivol_g",node_idx_lg2g(ivol),                    &
                      "ivol_vel_g",node_idx_vel_lg2g(ivol)
                      
            end do
        end if
#endif        
        
        !Check DMDA pointer to the list of global indices in the matrix
        !When dof == 2, size(idx,1) = 2*nngl
!cdsu Note:  DMDAGetGlobalIndicesF90 has been removed from PETSc 3.5, 
!cdsu Note:  use DMGetLocalToGlobalMapping instead.
!cdsu For the windows version, we still use PETSc 3.4. 

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
        call DMDAGetGlobalIndicesF90(dmda_flow%da,PETSC_NULL_INTEGER,  &
                                     idx,ierr)
        CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 18)
        call DMGetLocalToGlobalMapping(dmda_flow%da,ltogm,ierr)
        CHKERRQ(ierr)
        call ISLocalToGlobalMappingGetIndices(ltogm,ltog,idltog,ierr)
        CHKERRQ(ierr)
#else
        call DMGetLocalToGlobalMapping(dmda_flow%da,ltogm,ierr)
        CHKERRQ(ierr)
        call ISLocalToGlobalMappingGetIndicesF90(ltogm,ltog,ierr)
        CHKERRQ(ierr)
#endif
        
        dof = dmda_flow%dof
      
        do ivol = 1, nngl

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
            node_idx_lg2pg(ivol) = (idx(ivol*dof)+1)/dof
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 18)
            node_idx_lg2pg(ivol) = (ltog(ivol*dof + idltog)+1)/dof
#else
            node_idx_lg2pg(ivol) = (ltog(ivol*dof)+1)/dof
#endif


#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(2(a,1x,i10,1x))')"ivol",ivol,"global index",&
                                          node_idx_lg2pg(ivol)
            end if
#endif
        end do

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)

#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 18)
        call ISLocalToGlobalMappingRestoreIndices(ltogm,ltog,idltog,ierr)
        CHKERRQ(ierr)
#else
        call ISLocalToGlobalMappingRestoreIndicesF90(ltogm,ltog,ierr)
        CHKERRQ(ierr)
#endif
        
        if(info_debug > 1) then
            call petsc_mpi_finalize
            stop
        end if
        
   
    end subroutine solver_dd_mapping_set
   
    !> set DMDA coordinates 
    subroutine solver_dd_coordinates_set
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)

#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscdmda.h>
        use petscvec
        use petscdmda
#endif
        use gen, only: idbg, nvxgbl, nvygbl, nvzgbl, nvxls, nvxle,     &
                       nvyls, nvyle, nvzls, nvzle, nvxgls, nvxgle,     &
                       nvygls, nvygle, nvzgls, nvzgle,                 &
                       nvxgl, nvygl, nvzgl, xglat, yglat, zglat
    
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscdmdef.h>
#include <petsc/finclude/petscdm.h>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscdmda.h90>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscdmdef.h>
#include <finclude/petscdm.h>
#include <finclude/petscdmda.h>
#include <finclude/petscdmda.h90>
#endif
        
        PetscErrorCode :: ierr
        
        PetscScalar, pointer :: coords1d(:)
        !DMDACoor2d, pointer :: coords2d(:,:)
        !DMDACoor3d, pointer :: coords3d(:,:,:) 
        !Note: There is no DMDACoor2d or 3d in Fortran (maybe added later), 
        !should use PetscScalar instead. 
        !The first index is 0, 1 or 2 for the x, y, or z coordinate
        PetscScalar, pointer :: coords2d(:,:,:) 
        PetscScalar, pointer :: coords3d(:,:,:,:) 
        PetscReal :: xmin, xmax, ymin, ymax, zmin, zmax
        Vec :: gc,global
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
        type(tDM) :: cda
#else
        DM :: cda
#endif
        PetscInt :: ivx, ivy, ivz, ivol, istart1, iend1,               &
                    istart2, iend2, istart3, iend3, istart4, iend4,    &
                    ibase        

        PetscReal :: r0
        
        
        PetscInt :: info_debug
        
        parameter (r0 = 0.0d0)
        
        info_debug = 0

        xmin = 0.0
        xmax = 0.0
        ymin = 0.0
        ymax = 0.0
        zmin = 0.0
        zmax = 0.0
      
        
        select case (dmda_flow%dim)
            
        case (1)
            
            xmax = 1.0
            call DMDASetUniformCoordinates(dmda_flow%da,               &
                    xmin, xmax, ymin, ymax, zmin, zmax, ierr)
            CHKERRQ(ierr)
            
            call DMGetCoordinateDM(dmda_flow%da,cda,ierr)
            CHKERRQ(ierr)
            call DMGetCoordinatesLocal(dmda_flow%da,gc,ierr)
            CHKERRQ(ierr)
            call DMDAVecGetArrayF90(cda,gc,coords1d,ierr)
            CHKERRQ(ierr)
     
#ifdef DEBUG
            if(info_debug > 0) then
                !Please note the index is 0-based            
                istart1 = lbound(coords1d,1)
                iend1 = ubound(coords1d,1)  
                write(idbg,'(a/,2(a,1x,i10,1x))')                      &
                        "set the coordinates 1 dim",                   &
                        "start1",istart1,"end1",iend1
            end if
#endif
            
            ibase = 1 
            ivol = 0
            
            !1D x domain
            if (nvxgbl > 1) then                                
                do ivx = nvxls,nvxle
                    coords1d(ivx-ibase) = xglat(ivx)   
#ifdef DEBUG
                    if(info_debug > 0) then
                        ivol = ivx - nvxgls + 1
                        write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))')   &
                                "ivol_l", ivol,                        &
                                "xg", coords1d(ivx-ibase),             &
                                "yg", r0,                              &
                                "zg", r0
                    end if
#endif
                end do
            !1D y domain
            else if (nvygbl > 1) then                                
                do ivy = nvyls,nvyle
                    coords1d(ivy-ibase) = yglat(ivy)
#ifdef DEBUG
                    if(info_debug > 0) then
                        ivol = ivy - nvygls + 1
                        write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))')   &
                                "ivol_l", ivol,                        &
                                "xg", r0,                              &
                                "yg", coords1d(ivy-ibase),             &
                                "zg", r0
                    end if
#endif
                end do
            !1D z domain
            else if (nvzgbl > 1) then 
                do ivz = nvzls, nvzle
                    coords1d(ivz-ibase) = zglat(ivz)
#ifdef DEBUG
                    if(info_debug > 0) then
                        ivol = ivz - nvzgls + 1
                        write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))')   &
                                "ivol_l", ivol,                        &
                                "xg", r0,                              &
                                "yg", r0,                              &
                                "zg", coords1d(ivz-ibase)
                    end if
#endif
                end do  
            end if            

            call DMDAVecRestoreArrayF90(cda,gc,coords1d,ierr)
            CHKERRQ(ierr)
            
        case (2)
            xmax = 1.0
            ymax = 1.0
            call DMDASetUniformCoordinates(dmda_flow%da,               &
                    xmin, xmax, ymin, ymax, zmin, zmax, ierr)
            CHKERRQ(ierr)
            call DMGetCoordinateDM(dmda_flow%da,cda,ierr)
            CHKERRQ(ierr)
            call DMGetCoordinatesLocal(dmda_flow%da,gc,ierr)
            CHKERRQ(ierr)
            call DMDAVecGetArrayF90(cda,gc,coords2d,ierr)
            CHKERRQ(ierr)
            
            !Please note the index is 0-based
#ifdef DEBUG
            if(info_debug > 0) then
                istart1 = lbound(coords2d,1)
                iend1 = ubound(coords2d,1)  
            
                istart2 = lbound(coords2d,2)
                iend2 = ubound(coords2d,2) 
            
                istart3 = lbound(coords2d,3)
                iend3 = ubound(coords2d,3)
            
                write(idbg,'(a/,6(a,1x,i10,1x))')                      &
                      "set the coordinates 2 dim",                     &
                      "start1",istart1,"end1",iend1,                   &
                      "start2",istart2,"end2",iend2,                   &
                      "start3",istart3,"end3",iend3  
            end if
#endif
                                                                       
            ibase = 1 
            ivol = 1
                                                                       
            !2D xy domain                                              
            if (nvxgbl > 1 .and. nvygbl > 1) then                      
                do ivy = nvyls,nvyle                                   
                    do ivx = nvxls,nvxle                               
                        coords2d(1-ibase,ivx-ibase,ivy-ibase)          &
                            = xglat(ivx)                                 
                        coords2d(2-ibase,ivx-ibase,ivy-ibase)          &
                            = yglat(ivy)
#ifdef DEBUG
                        if(info_debug > 0) then
                          ivol = (ivy-nvygls)*nvxgl + ivx - nvxgls + 1   
                          write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))') &
                               "ivol_l", ivol,                         &
                               "xg", coords2d(1-ibase,ivx-ibase,       &
                                              ivy-ibase),              &
                               "yg", coords2d(2-ibase,ivx-ibase,       &
                                              ivy-ibase),              &
                               "zg", r0 
                        end if
#endif
                    end do
                end do
            !2D yz domain    
            else if (nvygbl > 1 .and. nvzgbl > 1) then                  
                do ivz = nvzls, nvzle
                    do ivy = nvyls,nvyle
                        coords2d(1-ibase,ivy-ibase,ivz-ibase)          &
                            = yglat(ivy)                               
                        coords2d(2-ibase,ivy-ibase,ivz-ibase)          &
                            = zglat(ivz)   
#ifdef DEBUG
                        if(info_debug > 0) then
                          ivol = (ivz-nvzgls)*nvygl + ivy-nvygls+1   
                          write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))') &
                               "ivol_l", ivol,                         &
                               "xg", r0,                               &
                               "yg", coords2d(1-ibase,ivy-ibase,       &
                                              ivz-ibase),              &
                               "zg", coords2d(2-ibase,ivy-ibase,       &
                                              ivz-ibase) 
                        end if
#endif
                    end do                                             
                end do                                                 
            !2D xz domain                                              
            else if (nvzgbl > 1 .and. nvxgbl > 1) then                   
                do ivz = nvzls, nvzle                                  
                    do ivx = nvxls,nvxle                               
                        coords2d(1-ibase,ivx-ibase,ivz-ibase)          &
                            = xglat(ivx)                               
                        coords2d(2-ibase,ivx-ibase,ivz-ibase)          &
                            = zglat(ivz)
#ifdef DEBUG
                        if(info_debug > 0) then
                          ivol = (ivz-nvzgls)*nvxgl + ivx-nvxgls+1  
                          write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))') &
                               "ivol_l", ivol,                         &
                               "xg", coords2d(1-ibase,ivx-ibase,       &
                                              ivz-ibase),              &
                               "yg", r0,                               &
                               "zg", coords2d(2-ibase,ivx-ibase,       &
                                              ivz-ibase)
                        end if
#endif
                    end do
                end do
                
            end if            

            call DMDAVecRestoreArrayF90(cda,gc,coords2d,ierr)
            CHKERRQ(ierr)
            
        case (3) 
            xmax = 1.0
            ymax = 1.0
            zmax = 1.0
            call DMDASetUniformCoordinates(dmda_flow%da,               &
                    xmin, xmax, ymin, ymax, zmin, zmax, ierr)
            CHKERRQ(ierr)
            call DMGetCoordinateDM(dmda_flow%da,cda,ierr)
            CHKERRQ(ierr)
            call DMGetCoordinatesLocal(dmda_flow%da,gc,ierr)
            CHKERRQ(ierr)
            call DMDAVecGetArrayF90(cda,gc,coords3d,ierr)
            CHKERRQ(ierr)
        
            !Please note the index is 0-based
#ifdef DEBUG
            if(info_debug > 0) then
                istart1 = lbound(coords3d,1)
                iend1 = ubound(coords3d,1)  
            
                istart2 = lbound(coords3d,2)
                iend2 = ubound(coords3d,2) 
            
                istart3 = lbound(coords3d,3)
                iend3 = ubound(coords3d,3) 
            
                istart4 = lbound(coords3d,4)
                iend4 = ubound(coords3d,4) 
        
                write(idbg,'(a/,8(a,1x,i10,1x))')                      &
                      "set the coordinates 3 dim",                     &
                      "start1",istart1,"end1",iend1,                   &
                      "start2",istart2,"end2",iend2,                   &
                      "start3",istart3,"end3",iend3,                   &
                      "start4",istart4,"end4",iend4
            end if
#endif
        
            ibase = 1
            do ivz = nvzls,nvzle
                do ivy = nvyls,nvyle
                    do ivx = nvxls,nvxle
                        coords3d(1-ibase,ivx-ibase,ivy-ibase,ivz-ibase)& 
                            = xglat(ivx)
                        coords3d(2-ibase,ivx-ibase,ivy-ibase,ivz-ibase)&
                            = yglat(ivy)
                        coords3d(3-ibase,ivx-ibase,ivy-ibase,ivz-ibase)&
                            = zglat(ivz)
#ifdef DEBUG
                        if(info_debug > 0) then
                          ivol = (ivz-nvzgls)*nvygl*nvxgl +            &
                                 (ivy-nvygls)*nvxgl + ivx-nvxgls+1   
                          write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))') &
                                  "ivol_l", ivol,                      &
                                  "xg", coords3d(1-ibase,ivx-ibase,    &
                                           ivy-ibase,ivz-ibase),       &
                                  "yg", coords3d(2-ibase,ivx-ibase,    &
                                           ivy-ibase,ivz-ibase),       &
                                  "zg", coords3d(3-ibase,ivx-ibase,    &
                                           ivy-ibase,ivz-ibase)
                        end if
#endif
                    end do
                end do
            end do
            
            call DMDAVecRestoreArrayF90(cda,gc,coords3d,ierr)
            CHKERRQ(ierr)
            
        end select
        
        call DMGetCoordinates(dmda_flow%da,global,ierr)
        CHKERRQ(ierr)
        call DMLocalToGlobalBegin(cda,gc,INSERT_VALUES,global,ierr)
        CHKERRQ(ierr)
        call DMLocalToGlobalEnd(cda,gc,INSERT_VALUES,global,ierr)
        CHKERRQ(ierr)
        call DMRestoreLocalVector(cda,gc,ierr)
        CHKERRQ(ierr)

    end subroutine solver_dd_coordinates_set
    
    
    !> get DMDA coordinates
    subroutine solver_dd_coordinates_get

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscdmda.h>
        use petscvec
        use petscdmda
#endif
        use gen, only: idbg, nvxgbl, nvygbl, nvzgbl, nvxls, nvxle,     &
                       nvyls, nvyle, nvzls, nvzle, nvxgls, nvxgle,     &
                       nvygls, nvygle, nvzgls, nvzgle, nvxgl, nvygl,   &
                       nvzgl, node_idx_lg2g, rank
    
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscdmdef.h>
#include <petsc/finclude/petscdm.h>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscdmda.h90>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscdmdef.h>
#include <finclude/petscdm.h>
#include <finclude/petscdmda.h>
#include <finclude/petscdmda.h90>
#endif
        
        PetscErrorCode :: ierr
        
        PetscScalar, pointer :: coords1d(:)
        !DMDACoor2d, pointer :: coords2d(:,:)
        !DMDACoor3d, pointer :: coords3d(:,:,:) 
        !Note: There is no DMDACoor2d or 3d in Fortran (maybe added later), 
        !should use PetscScalar instead. 
        !The first index is 0, 1 or 2 for the x, y, or z coordinate
        PetscScalar, pointer :: coords2d(:,:,:) 
        PetscScalar, pointer :: coords3d(:,:,:,:)   
        Vec :: gc
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
        type(tDM) :: cda
#else
        DM :: cda
#endif
        PetscInt :: i, ivol, ivx, ivy, ivz, istart1, iend1,            &
                    istart2, iend2, istart3, iend3, istart4, iend4,    &
                    ibase
        PetscReal :: r0
        PetscReal :: lmin(3), lmax(3)
        PetscReal :: gmin(3), gmax(3)        
       
        PetscInt :: info_debug
        
        parameter (r0 = 0.0d0)
        
        info_debug = 0
        
       
        !Check coordinates
        call DMGetCoordinateDM(dmda_flow%da,cda,ierr)
        CHKERRQ(ierr)
        call DMGetCoordinates(dmda_flow%da,gc,ierr)
        CHKERRQ(ierr)

        select case (dmda_flow%dim)
            
        case (1)
            
            call DMDAVecGetArrayF90(cda,gc,coords1d,ierr)
            CHKERRQ(ierr)
        
            !Please note the index is 0-based
#ifdef DEBUG
            if(info_debug > 0) then
                istart1 = lbound(coords1d,1)
                iend1 = ubound(coords1d,1)        
        
                write(idbg,'(a/,2(a,1x,i10,1x))')                      &
                      "get the coordinates 1 dim",                     &
                      "start1",istart1,"end1",iend1
            end if
#endif
            
            ibase = 1 
            ivol = 0
            
            !1D x domain    
            if (nvxgbl > 1) then
#ifdef DEBUG
                if(info_debug > 0) then
                  do ivx = nvxls,nvxle
                    ivol = ivx - nvxgls + 1
                    write(idbg,'(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))') &
                          "ivol_l", ivol,                              &
                          "ivol_g", node_idx_lg2g(ivol),               &
                          "xg", coords1d(ivx-ibase),                   &
                          "yg", r0,                                    &
                          "zg", r0
                  end do
                end if
#endif
            !1D y domain
            else if (nvygbl > 1) then  
#ifdef DEBUG
                if(info_debug > 0) then
                  do ivy = nvyls,nvyle
                    ivol = ivy - nvygls + 1
                    write(idbg,'(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))') &
                          "ivol_l", ivol,                              &
                          "ivol_g", node_idx_lg2g(ivol),               &
                          "xg", r0,                                    &
                          "yg", coords1d(ivy-ibase),                   &
                          "zg", r0
                  end do
                end if
#endif
            !1D z domain
            else if (nvzgbl > 1) then 
#ifdef DEBUG
                if(info_debug > 0) then
                  do ivz = nvzls, nvzle
                    ivol = ivz - nvzgls + 1
                    write(idbg,'(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))') &
                          "ivol_l", ivol,                              &
                          "ivol_g", node_idx_lg2g(ivol),               &
                          "xg", r0,                                    &
                          "yg", r0,                                    &
                          "zg", coords1d(ivz-ibase)
                  end do
                end if
#endif
            end if              
        
            call DMDAVecRestoreArrayF90(cda,gc,coords1d,ierr)
            CHKERRQ(ierr)
            
        case (2)
            
            call DMDAVecGetArrayF90(cda,gc,coords2d,ierr)
            CHKERRQ(ierr)
        
            !Please note the index is 0-based
#ifdef DEBUG
            if(info_debug > 0) then
                istart1 = lbound(coords2d,1)
                iend1 = ubound(coords2d,1)  
            
                istart2 = lbound(coords2d,2)
                iend2 = ubound(coords2d,2)
            
                istart3 = lbound(coords2d,3)
                iend3 = ubound(coords2d,3)
        
                write(idbg,'(a/,6(a,1x,i10,1x))')                      &
                      "get the coordinates 2 dim",                     &
                      "start1",istart1,"end1",iend1,                   &
                      "start2",istart2,"end2",iend2,                   &
                      "start3",istart3,"end3",iend3 
            end if
#endif

            ibase = 1
            ivol = 0
            
            !2D xy domain    
            if (nvxgbl > 1 .and. nvygbl > 1) then
#ifdef DEBUG
                if(info_debug > 0) then
                    do ivy = nvyls,nvyle
                        do ivx = nvxls,nvxle
                          ivol = (ivy-nvygls)*nvxgl + ivx-nvxgls+1 
                          write(idbg,                                  &
                               '(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))') &
                               "ivol_l", ivol,                         &
                               "ivol_g", node_idx_lg2g(ivol),          &
                               "xg", coords2d(1-ibase,ivx-ibase,       &
                                              ivy-ibase),              &
                               "yg", coords2d(2-ibase,ivx-ibase,       &
                                              ivy-ibase),              &
                               "zg", r0 
                        end do
                    end do
                end if
#endif
            !2D yz domain    
            else if (nvygbl > 1 .and. nvzgbl > 1) then  
#ifdef DEBUG
                if(info_debug > 0) then
                    do ivz = nvzls, nvzle
                        do ivy = nvyls,nvyle   
                          ivol = (ivz-nvzgls)*nvygl + ivy-nvygls+1    
                          write(idbg,                                  &
                               '(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))') &
                               "ivol_l", ivol,                         &
                               "ivol_g", node_idx_lg2g(ivol),          &
                               "xg", r0,                               &
                               "yg", coords2d(1-ibase,ivy-ibase,       &
                                              ivz-ibase),              &
                               "zg", coords2d(2-ibase,ivy-ibase,       &
                                              ivz-ibase)   
                        end do
                    end do
                end if
#endif
            !2D xz domain    
            else if (nvzgbl > 1 .and. nvxgbl > 1) then
#ifdef DEBUG
                if(info_debug > 0) then
                    do ivz = nvzls, nvzle
                        do ivx = nvxls,nvxle 
                          ivol = (ivz-nvzgls)*nvxgl + ivx-nvxgls+1   
                          write(idbg,                                  &
                               '(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))') &
                               "ivol_l", ivol,                         &
                               "ivol_g", node_idx_lg2g(ivol),          &
                               "xg", coords2d(1-ibase,ivx-ibase,       &
                                              ivz-ibase),              &
                               "yg", r0,                               &
                               "zg", coords2d(2-ibase,ivx-ibase,       &
                                              ivz-ibase)
                        end do
                    end do
                end if
#endif
            end if
            
            call DMDAVecRestoreArrayF90(cda,gc,coords2d,ierr)
            CHKERRQ(ierr)
            
        case (3) 

            call DMDAVecGetArrayF90(cda,gc,coords3d, ierr)
            CHKERRQ(ierr)
            
            !Please note the index is 0-based
#ifdef DEBUG
            if(info_debug > 0) then
                istart1 = lbound(coords3d,1)
                iend1 = ubound(coords3d,1)  
            
                istart2 = lbound(coords3d,2)
                iend2 = ubound(coords3d,2) 
            
                istart3 = lbound(coords3d,3)
                iend3 = ubound(coords3d,3) 
            
                istart4 = lbound(coords3d,4)
                iend4 = ubound(coords3d,4)
        
                write(idbg,'(a/,8(a,1x,i10,1x))')                      &
                      "get the coordinates 3 dim",                     &
                      "start1",istart1,"end1",iend1,                   &
                      "start2",istart2,"end2",iend2,                   &
                      "start3",istart3,"end3",iend3,                   &
                      "start4",istart4,"end4",iend4
            end if
#endif
            ibase = 1
            ivol = 0
#ifdef DEBUG
            if(info_debug > 0) then
                do ivz = nvzls, nvzle
                    do ivy = nvyls,nvyle
                        do ivx = nvxls,nvxle   
                          ivol = (ivz-nvzgls)*nvygl*nvxgl +            &
                                 (ivy-nvygls)*nvxgl + ivx-nvxgls+1  
                          write(idbg,                                  &
                                '(2(a,1x,i6,1x),3(a,1x,1pe15.6e3,1x))')&
                                "ivol_l", ivol,                        &
                                "ivol_g", node_idx_lg2g(ivol),         &
                                "xg", coords3d(1-ibase,ivx-ibase,      &
                                         ivy-ibase,ivz-ibase),         &
                                "yg", coords3d(2-ibase,ivx-ibase,      &
                                         ivy-ibase,ivz-ibase),         &
                                "zg", coords3d(3-ibase,ivx-ibase,      &
                                         ivy-ibase,ivz-ibase)
                        end do
                    end do
                end do
            end if
#endif
            call DMDAVecRestoreArrayF90(cda,gc,coords3d,ierr)
            CHKERRQ(ierr)
          
        end select

    end subroutine solver_dd_coordinates_get
    
    !>
    !> mykspconverged_flow
    !> This is a user-defined routine for testing
    !> convergence of the KSP iterative solvers.
    !>  Input Parameters:
    !>    ksp   - iterative context
    !>    n     - iteration number
    !>    rnorm - 2-norm (preconditioned) residual value (may be estimated)
    !>    dummy - optional user-defined monitor context (unused here)
    subroutine mykspconverged_flow(ksp_flow,n,rnorm,flag,dummy,ierr)
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscksp.h>
        use petscsys
        use petscksp
#endif
        use gen, only : rank
    
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscksp.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscksp.h>
#endif
        
        KSP                :: ksp_flow
        PetscInt           :: n,dummy
        KSPConvergedReason :: flag
        PetscReal          :: rnorm
        PetscErrorCode     :: ierr

        Vec                :: x_flow
        PetscReal          :: rnorm_relative
        PetscReal          :: neg_one
       
        neg_one = -1.0d0
        
        if(n == 0) then
            rnorm_init_flow = rnorm
        end if
        
        rnorm_relative = rnorm / rnorm_init_flow
       
        !Get true residual norm
        !This operation is expensive, use -ksp_norm_type unpreconditioned instead
        if(n > 0) then
            call KSPBuildSolution(ksp_flow,                            &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                  PETSC_NULL_VEC,                      &
#else
                                  PETSC_NULL_OBJECT,                   &
#endif
                                  x_flow, ierr)
            CHKERRQ(ierr)
            call KSPGetRhs(ksp_flow, b_flow, ierr)
            CHKERRQ(ierr)
            call KSPGetOperators(ksp_flow,a_flow,                      &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                 PETSC_NULL_MAT,                       &
#else
                                 PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,  &
#endif
                                 ierr)
            CHKERRQ(ierr)
            
            call calculate_norm(a_flow, x_flow, b_flow, r_flow,        &
                                rnorm_flow)
            
        else
            rnorm_flow = 1.0d30
        end if

        if (n > 0 .and. (rnorm_flow < abstol_flow .or.                 &
            rnorm_relative < rtol_flow)) then
          flag = 1
#ifdef DEBUG
          if(rank == 0) then
              if(rnorm_flow < abstol_flow .and.                        &
                      rnorm_relative < rtol_flow) then
                  write(*,'(2(1x, a, 1x, 1pe15.6e3))')                 &
                        "KSP converged due to abstol", rnorm_flow,     &
                        "and rstol", rnorm_relative
              else if (rnorm_flow < abstol_flow) then
                  write(*,'(1x, a, 1x, 1pe15.6e3)')                    &
                        "KSP converged due to abstol", rnorm_flow
              else if (rnorm_relative < rtol_flow) then
                  write(*,'(1x, a, 1x, 1pe15.6e3)')                    &
                        "KSP converged due to rstol", rnorm_relative
              end if
          end if
#endif
        else
          flag = 0
        endif
        
        ierr = 0

    end subroutine mykspconverged_flow
    
    !>
    !> mykspconverged_heat
    !> This is a user-defined routine for testing
    !> convergence of the KSP iterative solvers.
    !>  Input Parameters:
    !>    ksp   - iterative context
    !>    n     - iteration number
    !>    rnorm - 2-norm (preconditioned) residual value (may be estimated)
    !>    dummy - optional user-defined monitor context (unused here)
    subroutine mykspconverged_heat(ksp_heat,n,rnorm,flag,dummy,ierr)
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscksp.h>
        use petscsys
        use petscksp
#endif
        use gen, only : rank
    
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscksp.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscksp.h>
#endif
        
        KSP                :: ksp_heat
        PetscInt           :: n,dummy
        KSPConvergedReason :: flag
        PetscReal          :: rnorm
        PetscErrorCode     :: ierr

        Vec                :: x_heat
        PetscReal          :: rnorm_relative
        PetscReal          :: neg_one
       
        neg_one = -1.0d0
        
        if(n == 0) then
            rnorm_init_heat = rnorm
        end if
        
        rnorm_relative = rnorm / rnorm_init_heat
       
        !Get true residual norm
        !This operation is expensive, use -ksp_norm_type unpreconditioned instead
        if(n > 0) then
            call KSPBuildSolution(ksp_heat,                            &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                  PETSC_NULL_VEC,                      &
#else
                                  PETSC_NULL_OBJECT,                   &
#endif
                                  x_heat, ierr)
            CHKERRQ(ierr)
            call KSPGetRhs(ksp_heat, b_heat, ierr)
            CHKERRQ(ierr)
            call KSPGetOperators(ksp_heat,a_heat,                      &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                 PETSC_NULL_MAT,                       &
#else
                                 PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,  &
#endif
                                 ierr)
            CHKERRQ(ierr)
            
            call calculate_norm(a_heat, x_heat, b_heat, r_heat,        &
                                rnorm_heat)
            
        else
            rnorm_heat = 1.0d30
        end if

        if (n > 0 .and. (rnorm_heat < abstol_heat .or.                 &
            rnorm_relative < rtol_heat)) then
          flag = 1
#ifdef DEBUG
          if(rank == 0) then
              if(rnorm_heat < abstol_heat .and.                        &
                      rnorm_relative < rtol_heat) then
                  write(*,'(2(1x, a, 1x, 1pe15.6e3))')                 &
                        "KSP converged due to abstol", rnorm_heat,     &
                        "and rstol", rnorm_relative
              else if (rnorm_heat < abstol_heat) then
                  write(*,'(1x, a, 1x, 1pe15.6e3)')                    &
                        "KSP converged due to abstol", rnorm_heat
              else if (rnorm_relative < rtol_heat) then
                  write(*,'(1x, a, 1x, 1pe15.6e3)')                    &
                        "KSP converged due to rstol", rnorm_relative
              end if
          end if
#endif
        else
          flag = 0
        endif
        
        ierr = 0

    end subroutine mykspconverged_heat    
    !>
    !> mykspconverged_react
    !> This is a user-defined routine for testing
    !> convergence of the KSP iterative solvers.
    !>  Input Parameters:
    !>    ksp   - iterative context
    !>    n     - iteration number
    !>    rnorm - 2-norm (preconditioned) residual value (may be estimated)
    !>    dummy - optional user-defined monitor context (unused here)
    subroutine mykspconverged_react(ksp_react,n,rnorm,flag,dummy,ierr)

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
        use petscsys
#endif
        use gen, only : rank
    
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscksp.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscksp.h>
#endif
        
        KSP                :: ksp_react
        Vec                :: x_react
        PetscErrorCode     :: ierr
        PetscInt           :: n,dummy
        KSPConvergedReason :: flag
        PetscReal          :: rnorm
        PetscReal          :: rnorm_relative
        PetscReal          :: neg_one
       
        neg_one = -1.0d0
        
        if(n == 0) then
            rnorm_init_react = rnorm
        end if
        
        rnorm_relative = rnorm / rnorm_init_react
       
        !Get true residual norm
        !This operation is expensive, use -ksp_norm_type unpreconditioned instead
        if(n > 0) then
            call KSPBuildSolution(ksp_react,                           &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                  PETSC_NULL_VEC,                      &
#else
                                  PETSC_NULL_OBJECT,                   &
#endif
                                  x_react, ierr)
            CHKERRQ(ierr)

            call KSPGetRhs(ksp_react, b_react, ierr)
            CHKERRQ(ierr)

            call KSPGetOperators(ksp_react,a_react,                    &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                 PETSC_NULL_MAT,                       &
#else
                                 PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,  &
#endif
                                 ierr)
            CHKERRQ(ierr)
            
            call calculate_norm(a_react, x_react, b_react, r_react,    &
                                rnorm_react)
            
        else
            rnorm_react = 1.0d30
        end if

        if (n > 0 .and. (rnorm_react < abstol_react .or.               &
            rnorm_relative < rtol_react)) then
          flag = 1
#ifdef DEBUG
          if(rank == 0) then
              if(rnorm_react < abstol_react .and.                      &
                      rnorm_relative < rtol_react) then
                  write(*,'(2(1x, a, 1x, 1pe15.6e3))')                 &
                        "KSP converged due to abstol", rnorm_react,    &
                        "and rstol", rnorm_relative
              else if (rnorm_react < abstol_react) then
                  write(*,'(1x, a, 1x, 1pe15.6e3)')                    &
                        "KSP converged due to abstol", rnorm_react
              else if (rnorm_relative < rtol_react) then
                  write(*,'(1x, a, 1x, 1pe15.6e3)')                    &
                        "KSP converged due to rstol", rnorm_relative
              end if
          end if
#endif
        else
          flag = 0
        endif
        
        ierr = 0

    end subroutine mykspconverged_react
    

    !>
    !> calculate norm for the current solution
    !>
    subroutine calculate_norm(a, x, b, u, rnorm)

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif

      implicit none

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif

      ! passing variables
      Mat                :: a
      Vec                :: x, b, u
      PetscReal          :: rnorm
      PetscReal          :: neg_one

      ! local variables
      PetscErrorCode     :: ierr

      neg_one = -1.0d0

      rnorm = 1.0d30

      call MatMult(a, x, u, ierr)
      CHKERRQ(ierr)

      call VecAXPY(u, neg_one, b, ierr)
      CHKERRQ(ierr)

      call VecNorm(u,NORM_2,rnorm,ierr)
      CHKERRQ(ierr)

    end subroutine calculate_norm

    !> create petsc solver space for flow and decoupled heat transport problem
    subroutine solver_dd_snes_create_flow_heat(bflag_flow)

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
        use petscsys
#endif

#ifdef USG
        use parm, only : ncon_usg
#endif
        use gen, only : nn, nngl, nngbl, rank, nprcs, ilog, idbg,      &
                        row_idx_l2pg_vs, col_idx_l2pg_vs, iavs,        &
                        row_idx_l2pg_glob, col_idx_l2pg_glob, iaglob,  &
                        mem_cur, mem_max, memory_monitor,              &
                        b_enable_output, discretization_type

        use petsc_mpi_common, only : petsc_mpi_finalize
    
        implicit none   

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdef.h>
#include <petsc/finclude/petscdef.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscdef.h>
#ifdef PETSC_USE_LOG
#include <finclude/petsclog.h>
#endif
#endif

        PetscBool :: bflag_flow

        !c pointer variable to switch between flow and decoupled heat transport
        character(len=5) :: prefix_ksp
        type(userctx), pointer :: dmda_selec
        character(16) :: strKSPType_selec
        character(32) :: strPCType_selec
        character(32) :: strKSPConvergenceType_selec
        PetscInt :: pc_factor_level_selec

        PetscReal :: rtol_selec
        PetscReal :: abstol_selec
        PetscReal :: dtol_selec
        PetscInt :: maxits_selec

        PetscBool :: b_initial_guess_nonzero_selec
        PetscBool :: b_reuse_preconditioner_selec
        PetscBool :: b_use_petsc_default_selec

        Mat, pointer :: a_selec
        Mat, pointer :: a_selec_j
        Mat, pointer :: a_selec_fac
        KSP, pointer :: ksp_selec
        PC, pointer :: pc_selec        
        
        PetscBool, pointer :: b_set_preconditioner_selec
        PetscBool, pointer :: b_recal_norm_selec
        PetscBool, pointer :: b_check_norm_selec
        PetscBool, pointer :: b_mykspconverged_selec

#ifdef PETSC_HAVE_MUMPS
        PetscInt  :: ival,icntl,infog34
        PetscReal :: cntl,rinfo12,rinfo13,val
#endif

        PetscErrorCode :: ierr  
        PetscInt, allocatable :: d_nnz(:)
        PetscInt, allocatable :: o_nnz(:)        
        PetscInt :: i, j, k, nndof, nngldof, nngbldof, istart, iend,   &
                    range_s, range_e, d_nz, o_nz
        
        PetscBool :: bflag  

!c MatSolverType is used in PETSc-dev (3.8+) version or PETSc-3.9.0 above version
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
        MatSolverType :: solver_pkg
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
        MatSolverPackage :: solver_pkg
#endif

        external :: checkerr

        if (bflag_flow) then
          prefix_ksp = "flow_"
          strKSPType_selec = strKSPType_flow
          strKSPConvergenceType_selec = strKSPConvergenceType_flow
          strPCType_selec = strPCType_flow
          pc_factor_level_selec = pc_factor_level_flow

          rtol_selec = rtol_flow
          abstol_selec = abstol_flow
          dtol_selec = dtol_flow
          maxits_selec = maxits_flow

          b_use_petsc_default_selec = b_use_petsc_default_flow
          b_initial_guess_nonzero_selec = b_initial_guess_nonzero_flow
          b_reuse_preconditioner_selec = b_reuse_preconditioner_flow

          dmda_selec => dmda_flow          
          a_selec => a_flow
          a_selec_j => a_flow_j
          a_selec_fac => a_flow_fac
          ksp_selec => ksp_flow

          b_set_preconditioner_selec => b_set_preconditioner_flow
          b_recal_norm_selec => b_recal_norm_flow
          b_check_norm_selec => b_check_norm_flow
          b_mykspconverged_selec => b_mykspconverged_flow  
          pc_selec => pc_flow

        else
          prefix_ksp = "heat_"
          strKSPType_selec = strKSPType_heat
          strKSPConvergenceType_selec = strKSPConvergenceType_heat
          strPCType_selec = strPCType_heat
          pc_factor_level_selec = pc_factor_level_heat

          rtol_selec = rtol_heat
          abstol_selec = abstol_heat
          dtol_selec = dtol_heat
          maxits_selec = maxits_heat

          b_use_petsc_default_selec = b_use_petsc_default_heat
          b_initial_guess_nonzero_selec = b_initial_guess_nonzero_heat
          b_reuse_preconditioner_selec = b_reuse_preconditioner_heat

          dmda_selec => dmda_heat          
          a_selec => a_heat
          a_selec_j => a_heat_j
          a_selec_fac => a_heat_fac
          ksp_selec => ksp_heat

          b_set_preconditioner_selec => b_set_preconditioner_heat
          b_recal_norm_selec => b_recal_norm_heat
          b_check_norm_selec => b_check_norm_heat
          b_mykspconverged_selec => b_mykspconverged_heat
          pc_selec => pc_heat
        end if

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventRegister('log_x_flow',0,log_x_flow,ierr)
          CHKERRQ(ierr)
          call PetscLogEventRegister('log_b_flow',0,log_b_flow,ierr)
          CHKERRQ(ierr)
          !call PetscLogEventRegister('log_bnorm_flow',0,log_bnorm_flow,ierr)
          !CHKERRQ(ierr)
          call PetscLogEventRegister('log_a_flow',0,log_a_flow,ierr)
          CHKERRQ(ierr)
          call PetscLogEventRegister('log_ksp_flow',0,log_ksp_flow,ierr)
          CHKERRQ(ierr)
          call PetscLogEventRegister('log_tot_flow',0,log_tot_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventRegister('log_x_heat',0,log_x_heat,ierr)
          CHKERRQ(ierr)
          call PetscLogEventRegister('log_b_heat',0,log_b_heat,ierr)
          CHKERRQ(ierr)
          !call PetscLogEventRegister('log_bnorm_heat',0,log_bnorm_heat,ierr)
          !CHKERRQ(ierr)
          call PetscLogEventRegister('log_a_heat',0,log_a_heat,ierr)
          CHKERRQ(ierr)
          call PetscLogEventRegister('log_ksp_heat',0,log_ksp_heat,ierr)
          CHKERRQ(ierr)
          call PetscLogEventRegister('log_tot_heat',0,log_tot_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

        !> - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        !>  Create matrix data structure for Jacobian
        !> - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        !>
        !>  Note:  For the parallel case, vectors and matrices MUST be partitioned
        !>  accordingly.  When using distributed arrays (DMDAs) to create vectors,
        !>  the DMDAs determine the problem partitioning.  We must explicitly
        !>  specify the local matrix dimensions upon its creation for compatibility
        !>  with the vector distribution.
        !>
        !>  Note: Here we only approximately preallocate storage space for the
        !>  Jacobian.  See the users manual for a discussion of better techniques
        !>  for preallocating matrix memory.

        bflag = .false.
        !bflag = .true.

        if(bflag) then

          if(dmda_selec%dim == 1) then
            d_nz = 3
            o_nz = 3
          else if (dmda_selec%dim == 2) then
            d_nz = 5
            o_nz = 5
          else if (dmda_selec%dim == 3) then
            d_nz = 7
            o_nz = 7
          end if

#ifdef USG
          if (discretization_type > 0) then
            d_nz = ncon_usg
            o_nz = ncon_usg
          end if
#endif

          nndof = nn * dmda_selec%dof
          nngldof = nngl * dmda_selec%dof
          nngbldof = nngbl * dmda_selec%dof

          d_nz = d_nz * dmda_selec%dof
          o_nz = o_nz * dmda_selec%dof
        
        else 

          nndof = nn * dmda_selec%dof
          nngldof = nngl * dmda_selec%dof
          nngbldof = nngbl * dmda_selec%dof

          allocate(d_nnz(nndof), stat = ierr)
          call checkerr(ierr,'d_nnz',ilog)
          d_nnz = 0
          call memory_monitor(sizeof(d_nnz),'d_nnz',.true.)

          allocate(o_nnz(nndof), stat = ierr)
          call checkerr(ierr,'o_nnz',ilog)
          o_nnz = 0
          call memory_monitor(sizeof(o_nnz),'o_nnz',.true.)

          range_s = dmda_selec%range_start
          range_e = dmda_selec%range_end

          if(dmda_selec%dof == 1) then
              
            do i = 1, nngldof
              j = row_idx_l2pg_vs(i)
              if(j < 0) then
                cycle
              end if

              j = j - range_s + 1

              istart = iavs(i)
              iend = iavs(i+1)-1
              do k = istart, iend
                if(col_idx_l2pg_vs(k) >= range_s .and.               &
                   col_idx_l2pg_vs(k) <= range_e) then
                  d_nnz(j) = d_nnz(j) + 1
                else
                  o_nnz(j) = o_nnz(j) + 1
                end if
              end do
            end do

          else if(dmda_selec%dof == 2) then
              
            do i = 1, nngldof
              j = row_idx_l2pg_glob(i)
              if(j < 0) then
                cycle
              end if

              j = j - range_s + 1

              istart = iaglob(i)
              iend = iaglob(i+1)-1
              do k = istart, iend
                if(col_idx_l2pg_glob(k) >= range_s .and.               &
                   col_idx_l2pg_glob(k) <= range_e) then
                  d_nnz(j) = d_nnz(j) + 1
                else
                  o_nnz(j) = o_nnz(j) + 1
                end if
              end do
            end do 
          end if
        end if
       
        if(bflag) then
          call MatCreateAIJ(Petsc_Comm_World,                          &
                            nndof, nndof, nngbldof, nngbldof,          &
                            d_nz, PETSC_NULL_INTEGER,                  &
                            o_nz, PETSC_NULL_INTEGER,                  &
                            a_selec, ierr)
          CHKERRQ(ierr)
        else
          call MatCreateAIJ(Petsc_Comm_World,                          &
                            nndof, nndof, nngbldof, nngbldof,          &
                            PETSC_DECIDE, d_nnz(1:nndof),              &
                            PETSC_DECIDE, o_nnz(1:nndof),              &
                            a_selec, ierr)
          CHKERRQ(ierr)
        end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 16)
        call MatSetBlockSize(a_selec, dmda_selec%dof, ierr)
        CHKERRQ(ierr)
#endif
        
        if(.not.bflag) then
          call memory_monitor(-sizeof(d_nnz),'d_nnz',.true.)
          call memory_monitor(-sizeof(o_nnz),'o_nnz',.true.)
          deallocate(d_nnz)
          deallocate(o_nnz)
        end if

        !c MatOptions
#ifdef PETSC_HAVE_SUPERLU

        if (trim(strKSPType_selec) == "kspsuperlu" .or. &
            trim(strKSPType_selec) == "superlu") then

          call PetscOptionsInsertString(                               &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
               PETSC_NULL_OPTIONS,"-mat_superlu_diagpivotthresh 0.0",  &
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR == 7)
               PETSC_NULL_OBJECT,"-mat_superlu_diagpivotthresh 0.0",   &
#else
               "-mat_superlu_diagpivotthresh 0.0",                     &
#endif
               ierr)
          CHKERRQ(ierr)

          call PetscOptionsInsertString(                               &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
               PETSC_NULL_OPTIONS,"-mat_superlu_dist_fact SamePattern",&
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR == 7)
               PETSC_NULL_OBJECT,"-mat_superlu_dist_fact SamePattern", &
#else
               "-mat_superlu_dist_fact SamePattern",                   &
#endif
               ierr)
          CHKERRQ(ierr)
        end if

#endif
        call MatSetFromOptions(a_selec,ierr)
        CHKERRQ(ierr)

        ! Create the linear solver and set various options
        !    - First, set the KSP linear operators.  Here the matrix that
        !      defines the linear system also serves as the preconditioning
        !      matrix.
        call KSPCreate(Petsc_Comm_World, ksp_selec, ierr)
        CHKERRQ(ierr)

        ! set options for inout
        call KSPAppendOptionsPrefix(ksp_selec,prefix_ksp,ierr)
        CHKERRQ(ierr)

        call KSPSetInitialGuessNonzero(ksp_selec,                      &
                  b_initial_guess_nonzero_selec, ierr)
        CHKERRQ(ierr)
        
        if (b_reuse_preconditioner_selec) then
          if (.not.b_set_preconditioner_selec) then
            b_set_preconditioner_selec = .true.
            call MatConvert(a_selec,MATSAME,MAT_INITIAL_MATRIX,        &
                            a_selec_j,ierr)
            CHKERRQ(ierr)
          end if
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
          call KSPSetOperators(ksp_selec,a_selec,a_selec_j,            &
                               SAME_NONZERO_PATTERN,ierr)
#else
          call KSPSetOperators(ksp_selec,a_selec,a_selec_j,ierr)
#endif
        else
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
          call KSPSetOperators(ksp_selec,a_selec,a_selec,              &
                               SAME_NONZERO_PATTERN,ierr)
#else
          call KSPSetOperators(ksp_selec,a_selec,a_selec,ierr)
#endif
        end if
        CHKERRQ(ierr)

        call KSPSetDM(ksp_selec,dmda_selec%da,ierr)
        CHKERRQ(ierr)
        call KSPSetDMActive(ksp_selec,PETSC_FALSE,ierr)
        CHKERRQ(ierr)

        !c set convergence tolerance

        b_recal_norm_selec = .false.

        if(.not. b_use_petsc_default_selec) then

          if (trim(strKSPConvergenceType_selec) == "kspuserdefined" .or. &
              trim(strKSPConvergenceType_selec) == "userdefined") then
            b_mykspconverged_selec = .true.
            if (bflag_flow) then
              call KSPSetConvergenceTest(ksp_selec,mykspconverged_flow,&
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                        0,                             &
#else
                                        PETSC_NULL_OBJECT,             &
#endif
                                        PETSC_NULL_FUNCTION,ierr)
              CHKERRQ(ierr)
            else
              call KSPSetConvergenceTest(ksp_selec,mykspconverged_heat,&
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                        0,                             &
#else
                                        PETSC_NULL_OBJECT,             &
#endif
                                        PETSC_NULL_FUNCTION,ierr)
              CHKERRQ(ierr)            
            end if
          else
            b_mykspconverged_selec = .false.
          end if

          !Set linear solver defaults for this problem (optional).
          call KSPSetTolerances(ksp_selec, rtol_selec, abstol_selec,   &
                                dtol_selec, maxits_selec, ierr)
          CHKERRQ(ierr)

          if (rank == 0 .and. b_enable_output) then
            write(*,'(a)') "PETSc convergence parameters for flow/heat"
            write(*,'(4a14)') "rtol","abstol","divtol","maxits"
            write(*,'(3(1x,1pe15.6e3),1x,i6)') rtol_selec,abstol_selec,&
                                        dtol_selec,maxits_selec

            write(ilog,'(a)')"PETSc convergence parameters for flow/heat"
            write(ilog,'(4a14)') "rtol","abstol","divtol","maxits"
            write(ilog,'(3(1x,1pe15.6e3),1x,i6)') rtol_selec,          &
                  abstol_selec,dtol_selec,maxits_selec
          end if

        end if

        !c set KSP options
        if(.not. b_use_petsc_default_selec) then

#ifdef PETSC_HAVE_MUMPS
          if (trim(strKSPType_selec) == "kspmumps" .or. &
            trim(strKSPType_selec) == "mumps") then
            call KSPSetType(ksp_selec, KSPPREONLY, ierr)
            CHKERRQ(ierr)
            b_recal_norm_selec = .true.
            goto 101
          end if
#endif

#ifdef PETSC_HAVE_SUPERLU
          if (trim(strKSPType_selec) == "kspsuperlu" .or. &
            trim(strKSPType_selec) == "superlu") then
            call KSPSetType(ksp_selec, KSPPREONLY, ierr)
            CHKERRQ(ierr)
            b_recal_norm_selec = .true.
            goto 101
          end if
#endif

          if (trim(strKSPType_selec) == "kspgmres" .or. &
              trim(strKSPType_selec) == "gmres") then
            call KSPSetType(ksp_selec, KSPGMRES, ierr)
            CHKERRQ(ierr)
            goto 101
          else if (trim(strKSPType_selec) == "kspbcgs" .or. &
                   trim(strKSPType_selec) == "bcgs") then
            call KSPSetType(ksp_selec, KSPBCGS, ierr)
            CHKERRQ(ierr)
            goto 101
          else
            call KSPSetType(ksp_selec, KSPGMRES, ierr)
            CHKERRQ(ierr)
            goto 101
          end if

        end if

101     continue

        !c set PC options
        if(.not. b_use_petsc_default_selec) then

          call KSPGetPC(ksp_selec, pc_selec, ierr)
          CHKERRQ(ierr)

#ifdef PETSC_HAVE_MUMPS
          if (trim(strKSPType_selec) == "kspmumps" .or. &
            trim(strKSPType_selec) == "mumps") then

            !c force pctype to pclu for mumps solver
            call PCSetType(pc_selec,PCLU, ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
            call PCFactorSetMatSolverType(pc_selec,MATSOLVERMUMPS,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverType(pc_selec,ierr)
            CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
            call PCFactorSetMatSolverPackage(pc_selec,MATSOLVERMUMPS,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverPackage(pc_selec,ierr)
            CHKERRQ(ierr)
#endif

            call PCFactorGetMatrix(pc_selec,a_selec_fac,ierr)
            CHKERRQ(ierr)

            goto 201

          end if
#endif

#ifdef PETSC_HAVE_SUPERLU
          if (trim(strKSPType_selec) == "kspsuperlu" .or. &
            trim(strKSPType_selec) == "superlu") then

            !c force pctype to pclu for superlu_dist solver
            call PCSetType(pc_selec,PCLU, ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
            call PCFactorSetMatSolverType(pc_selec,MATSOLVERSUPERLU_DIST,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverType(pc_selec,ierr)
            CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
            call PCFactorSetMatSolverPackage(pc_selec,MATSOLVERSUPERLU_DIST,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverPackage(pc_selec,ierr)
            CHKERRQ(ierr)
#endif

            call PCFactorGetMatrix(pc_selec,a_selec_fac,ierr)
            CHKERRQ(ierr)

            goto 201

          end if
#endif

          if(trim(strPCType_selec) == "pcnone" .or. &
             trim(strPCType_selec) == "none") then
            call PCSetType(pc_selec,PCNONE, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pcjacobi" .or. &
             trim(strPCType_selec) == "jacobi") then
            call PCSetType(pc_selec,PCJACOBI, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pclu" .or. &
             trim(strPCType_selec) == "lu") then
            call PCSetType(pc_selec,PCLU, ierr)
            CHKERRQ(ierr)

           else if(trim(strPCType_selec) == "pcbjacobi" .or. &
             trim(strPCType_selec) == "bjacobi") then
            call PCSetType(pc_selec,PCBJACOBI, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pcilu" .or. &
             trim(strPCType_selec) == "ilu") then
            call PCSetType(pc_selec,PCILU, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pcasm" .or. &
             trim(strPCType_selec) == "asm") then
            call PCSetType(pc_selec,PCASM, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pcksp" .or. &
             trim(strPCType_selec) == "ksp") then
            call PCSetType(pc_selec,PCKSP, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pchypre" .or. &
             trim(strPCType_selec) == "hypre") then
            call PCSetType(pc_selec,PCHYPRE, ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pchypre-euclid" .or. &
                  trim(strPCType_selec) == "hypre-euclid") then
            call PCSetType(pc_selec,PCHYPRE, ierr)
            CHKERRQ(ierr)

            call PCHYPRESetType(pc_selec,"euclid", ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pchypre-pilut" .or. &
                  trim(strPCType_selec) == "hypre-pilut") then
            call PCSetType(pc_selec,PCHYPRE, ierr)
            CHKERRQ(ierr)

            call PCHYPRESetType(pc_selec,"pilut", ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pchypre-parasails" .or. &
                  trim(strPCType_selec) == "hypre-parasails") then
            call PCSetType(pc_selec,PCHYPRE, ierr)
            CHKERRQ(ierr)

            call PCHYPRESetType(pc_selec,"parasails", ierr)
            CHKERRQ(ierr)

          else if(trim(strPCType_selec) == "pchypre-boomeramg" .or. &
                  trim(strPCType_selec) == "hypre-boomeramg") then
            call PCSetType(pc_selec,PCHYPRE, ierr)
            CHKERRQ(ierr)

            call PCHYPRESetType(pc_selec,"boomeramg", ierr)
            CHKERRQ(ierr)

          else
            call PCSetType(pc_selec,PCBJACOBI, ierr)
            CHKERRQ(ierr)
          end if

          !c set incomplete factorization level
          if (pc_factor_level_selec > 0) then
            call PCFactorSetLevels(pc_selec, pc_factor_level_selec, ierr)
            CHKERRQ(ierr)
          end if


          if ((trim(strKSPType_selec) /= "kspmumps"   .and.  &
              trim(strKSPType_selec) /= "mumps"       .and.  &
              trim(strKSPType_selec) /= "kspsuperlu"  .and.  &
              trim(strKSPType_selec) /= "superlu")    .and.  &
              (trim(strPCType_selec) == "pcilu"       .or.   &
              trim(strPCType_selec) == "ilu"          .or.   &
              trim(strPCType_selec) == "pclu"         .or.   &
              trim(strPCType_selec) == "lu")          .and.  &
              nprcs > 1) then
              if(rank == 0) then
                write(*,'(5a,i4,a)') "Error: PCTYPE ",              &
                      trim(strPCType_selec)," is not supported for ",&
                      trim(strKSPType_selec)," using ", nprcs,       &
                      " processors"
                write(ilog,'(5a,i4,a)') "Error: PCTYPE ",           &
                      trim(strPCType_selec)," is not supported for ",&
                      trim(strKSPType_selec)," using ", nprcs,       &
                      " processors"
              end if
              call petsc_mpi_finalize
              stop
          end if

        end if

201     continue

        !c check solver package if not from configuration file
        call KSPGetPC(ksp_selec, pc_selec, ierr)
        CHKERRQ(ierr)
        
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
        call PCFactorGetMatSolverType(pc_selec,solver_pkg,ierr)
        CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
        call PCFactorGetMatSolverPackage(pc_selec,solver_pkg,ierr)
        CHKERRQ(ierr)
#endif
        
        if (solver_pkg == "superlu" .or.                   &
            solver_pkg == "superlu_dist" .or.              &
            solver_pkg == "mumps" .or.                     &
            solver_pkg == "mkl_pardiso" .or.               &
            solver_pkg == "mkl_cpardiso") then
          b_recal_norm_selec = .true. 
        else
          b_check_norm_selec = .false.
        end if

        !> If not doing matrix free then matrix operator and matrix used
        !> to construct preconditioner are the same
        !a_selec_j = a_selec

        !> Set runtime options (e.g., -ksp_monitor -ksp_rtol <rtol> -ksp_type <type>)
        !> Set different options prefix for linear system of flow.
        !> Set runtime options (e.g., -flow_pc_type <type>)

        ! KSPSetFromOptions must come after custom setup in order to override
        ! from command line
        call KSPSetFromOptions(ksp_selec,ierr)
        CHKERRQ(ierr) 

        if (bflag_flow) then
          call KSPGetTolerances(ksp_flow, rtol_flow, abstol_flow,      &
                                dtol_flow, maxits_flow, ierr)
          CHKERRQ(ierr)

          if (rank == 0 .and. b_enable_output) then
            write(*,'(/a)') "PETSc convergence parameters for flow"
            write(*,'(4a14)') "rtol","abstol","divtol","maxits"
            write(*,'(3(1x,1pe15.6e3),1x,i6)')                         &
                  rtol_flow,abstol_flow,dtol_flow,maxits_flow

            write(ilog,'(/a)')"PETSc convergence parameters for flow"
            write(ilog,'(4a14)') "rtol","abstol","divtol","maxits"
            write(ilog,'(3(1x,1pe15.6e3),1x,i6)')                      &
                  rtol_flow,abstol_flow,dtol_flow,maxits_flow
          end if
        else 
          call KSPGetTolerances(ksp_heat, rtol_heat, abstol_heat,      &
                                dtol_heat, maxits_heat, ierr)
          CHKERRQ(ierr)

          if (rank == 0 .and. b_enable_output) then
            write(*,'(/a)') "PETSc convergence parameters for heat transport"
            write(*,'(4a14)') "rtol","abstol","divtol","maxits"
            write(*,'(3(1x,1pe15.6e3),1x,i6)')                         &
                  rtol_heat,abstol_heat,dtol_heat,maxits_heat

            write(ilog,'(/a)')"PETSc convergence parameters for heat transport"
            write(ilog,'(4a14)') "rtol","abstol","divtol","maxits"
            write(ilog,'(3(1x,1pe15.6e3),1x,i6)')                      &
                  rtol_heat,abstol_heat,dtol_heat,maxits_heat
          end if
        end if

    end subroutine solver_dd_snes_create_flow_heat
    
    !> solve petsc solver space for flow problem
    subroutine solver_dd_snes_solve_flow_heat(ilog,bflag_flow,idetail, &
                      a_in,b_in,x_inout,ia_in,ja_in,nngl_in,itsolv,    &
                      over_flow,rnorm,row_idx_l2pg,col_idx_l2pg,       &
                      b_non_interlaced)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscksp.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
        use petscdmda
        use petscksp
#endif
    
        use gen, only : rank, node_idx_l2lg, ittot_vs, ittot_heat,     &
                        mtime, ittot_glob, b_output_matrix_petsc,      &
                        b_enable_output, itimestep_output_matrix
        use solver_snes_function, only : form_initial_guess,           & 
                                         compute_function,             &
                                         compute_jacobian
        use petsc_mpi_common, only : petsc_mpi_finalize
        
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscvec.h90>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscviewer.h>
#include <petsc/finclude/petscviewer.h90>
#include <petsc/finclude/petscksp.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscvec.h90>
#include <finclude/petscdmda.h>
#include <finclude/petscviewer.h>
#include <finclude/petscviewer.h90>
#include <finclude/petscksp.h>
#ifdef PETSC_USE_LOG
#include <finclude/petsclog.h>
#endif
#endif

#ifdef PETSC_HAVE_MUMPS
        PetscInt  :: ival,icntl,infog34
        PetscReal :: cntl,rinfo12,rinfo13,val
#endif

        PetscBool :: bflag_flow

        PetscInt :: ilog
        PetscInt :: idetail
        PetscInt :: nngl_in
        PetscInt :: ilocal
        PetscInt :: nlocal
        PetscInt :: firstlocal
        PetscReal, allocatable :: a_in(:)
        PetscReal, allocatable :: b_in(:)
        PetscReal, allocatable :: x_inout(:)
        PetscInt, allocatable  :: ia_in(:)
        PetscInt, allocatable  :: ja_in(:)
        PetscInt, allocatable :: row_idx_l2pg(:)
        PetscInt, allocatable :: col_idx_l2pg(:)
        PetscInt  :: itsolv
        PetscBool :: over_flow
        PetscBool :: b_non_interlaced
        PetscReal :: rnorm
        
        PetscViewer :: viewer        
        PetscScalar,pointer :: vecpointer(:)

        PC :: subpc
        KSP,allocatable,dimension(:) :: subksp     ! array of local KSP contexts on this processor
        PetscBool :: b_pc_factor_shift
        
        PetscErrorCode :: ierr
        PetscInt :: i, j, info_debug, reason   
        character(72) :: strinum


        !c pointer variable to switch between flow and decoupled heat transport
        character(len=5) :: prefix_ksp
        type(userctx), pointer :: dmda_selec
        character(16) :: strKSPType_selec
        character(32) :: strPCType_selec
        character(32) :: pc_factor_shift_selec
        PetscBool :: b_use_petsc_default_selec
        PetscBool :: b_form_initial_guess_selec  

        Mat, pointer :: a_selec        
        KSP, pointer :: ksp_selec
        Vec, pointer :: x_selec_loc
        Vec, pointer :: x_selec
        Vec, pointer :: b_selec_loc
        Vec, pointer :: b_selec
        Vec, pointer :: r_selec
        PC, pointer :: pc_selec

        PetscReal, pointer :: rnorm_selec
        PetscReal :: dtol_selec

        PetscBool, pointer :: b_recal_norm_selec
        PetscBool, pointer :: b_mykspconverged_selec

        if (bflag_flow) then
          prefix_ksp = 'flow_'
          strKSPType_selec = strKSPType_flow
          strPCType_selec = strPCType_flow
          pc_factor_shift_selec = pc_factor_shift_flow

          b_use_petsc_default_selec = b_use_petsc_default_flow
          b_form_initial_guess_selec = b_form_initial_guess_flow

          dtol_selec = dtol_flow

          dmda_selec => dmda_flow          
          a_selec => a_flow
          ksp_selec => ksp_flow
          x_selec_loc => x_flow_loc
          x_selec => x_flow
          b_selec_loc => b_flow_loc
          b_selec => b_flow
          r_selec => r_flow
          pc_selec => pc_flow
          rnorm_selec => rnorm_flow          
          b_recal_norm_selec => b_recal_norm_flow
          b_mykspconverged_selec => b_mykspconverged_flow
        else
          prefix_ksp = 'heat_'
          strKSPType_selec = strKSPType_heat
          strPCType_selec = strPCType_heat
          pc_factor_shift_selec = pc_factor_shift_heat

          b_use_petsc_default_selec = b_use_petsc_default_heat
          b_form_initial_guess_selec = b_form_initial_guess_heat

          dtol_selec = dtol_heat

          dmda_selec => dmda_heat          
          a_selec => a_heat
          ksp_selec => ksp_heat
          x_selec_loc => x_heat_loc
          x_selec => x_heat
          b_selec_loc => b_heat_loc
          b_selec => b_heat
          r_selec => r_heat
          pc_selec => pc_heat
          rnorm_selec => rnorm_heat          
          b_recal_norm_selec => b_recal_norm_heat
          b_mykspconverged_selec => b_mykspconverged_heat
        end if
       
#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventBegin(log_tot_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventBegin(log_tot_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif
        info_debug = 0

        over_flow = .false.

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
            if (bflag_flow) then
              if(ittot_vs > 0) then
                write(strinum, *) ittot_vs
              else
                write(strinum, *) ittot_glob
              end if
            else
              write(strinum, *) ittot_heat
            end if
            strinum = "_"//trim(adjustl(strinum))
        end if

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventBegin(log_x_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventBegin(log_x_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

        !Form initial guess X, only assemble the local owned part, without ghost nodes
        if (b_form_initial_guess_selec) then
          call form_initial_guess(rank,dmda_selec%da,x_inout,          &
                    x_selec_loc,x_selec,nngl_in,row_idx_l2pg,          &
                    col_idx_l2pg,b_non_interlaced)

          if(b_output_matrix_petsc .and. b_enable_output) then
            if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
              call PetscViewerASCIIOpen(Petsc_Comm_World,              &
                        "x_"//prefix_ksp//"in"//trim(strinum)//".txt", &
                        viewer,ierr)
              CHKERRQ(ierr)
            else
              call PetscViewerBinaryOpen(Petsc_Comm_World,             &
                        "x_"//prefix_ksp//"in"//trim(strinum)//".bin", &
                        FILE_MODE_WRITE, viewer,ierr)
              CHKERRQ(ierr)
            end if
            call VecView(x_selec, viewer, ierr)
            CHKERRQ(ierr)
            call PetscViewerDestroy(viewer, ierr)
            CHKERRQ(ierr)
          end if

        end if

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventEnd(log_x_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventEnd(log_x_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventBegin(log_b_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventBegin(log_b_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

        !Compute function B, only assemble the local part, without ghost nodes
        call compute_function(rank,dmda_selec%da,b_in,b_selec_loc,     &
                     b_selec,nngl_in,row_idx_l2pg,col_idx_l2pg,        &
                     b_non_interlaced)

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
            call PetscViewerASCIIOpen(Petsc_Comm_World,                &
                      "b_"//prefix_ksp//"in"//trim(strinum)//".txt",   &
                      viewer,ierr)
            CHKERRQ(ierr)
          else
            call PetscViewerBinaryOpen(Petsc_Comm_World,               &
                      "b_"//prefix_ksp//"in"//trim(strinum)//".bin",   &
                      FILE_MODE_WRITE, viewer,ierr)
            CHKERRQ(ierr)
          end if
          call VecView(b_selec, viewer, ierr)
          CHKERRQ(ierr)
          call PetscViewerDestroy(viewer, ierr)
          CHKERRQ(ierr)
        end if

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventEnd(log_b_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventEnd(log_b_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

!!cdsu  debug part, write matrix in petsc binary format
!        if(ittot_vs > 0) then
!            write(strinum, *) ittot_vs
!        else
!            write(strinum, *) ittot_glob
!        end if
!        strinum = "_"//trim(adjustl(strinum))
!
!        if (mtime == 1 .or. mtime == 22) then
!          call PetscViewerBinaryOpen(Petsc_Comm_World,               &
!                    "b_"//prefix_ksp//"check"//trim(strinum)//".bin",&
!                      FILE_MODE_WRITE, viewer,ierr)
!          CHKERRQ(ierr)
!          call VecView(b_selec, viewer, ierr)
!          CHKERRQ(ierr)
!          call PetscViewerDestroy(viewer, ierr)
!          CHKERRQ(ierr)
!        end if
!cdsu  debug part, write matrix in petsc binary format,end

!        !Check if the initial residual norm to see if it meets the convergence
!        !This part is time consuming and not required
!#ifdef PETSC_USE_LOG
!        call PetscLogEventBegin(log_bnorm_flow,ierr)
!        CHKERRQ(ierr)
!#endif
!        call VecNormBegin(b_selec, Norm_2, rnorm, ierr)
!        CHKERRQ(ierr)
!        call VecNormEnd(b_selec, Norm_2, rnorm, ierr)
!        CHKERRQ(ierr)
!        if(rnorm < 1.0d-300) then
!            if(idetail > 1 .and. rank == 0 .and. b_enable_output) then
!                write(ilog,100)
!            end if
!            itsolv = 0
!#ifdef PETSC_USE_LOG
!            call PetscLogEventEnd(log_bnorm_flow,ierr)
!            CHKERRQ(ierr)
!#endif
!            return
!        end if
!
!#ifdef PETSC_USE_LOG
!        call PetscLogEventEnd(log_bnorm_flow,ierr)
!        CHKERRQ(ierr)
!#endif

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventBegin(log_a_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventBegin(log_a_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif
        !Compute jacobian matrix A, only assemble the local part, without ghost nodes
        call compute_jacobian(rank,dmda_selec%da,                      &
                              a_selec,a_in,ia_in,ja_in,nngl_in,        &
                              row_idx_l2pg,col_idx_l2pg,               &
                              b_non_interlaced)

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
            call PetscViewerASCIIOpen(Petsc_Comm_World,                &
                      "a_"//prefix_ksp//"in"//trim(strinum)//".txt",   &
                      viewer,ierr)
            CHKERRQ(ierr)
          else
            call PetscViewerBinaryOpen(Petsc_Comm_World,               &
                      "a_"//prefix_ksp//"in"//trim(strinum)//".bin",   &
                      FILE_MODE_WRITE, viewer,ierr)
            CHKERRQ(ierr)
          end if
          call MatView(a_selec, viewer, ierr)
          CHKERRQ(ierr)
          call PetscViewerDestroy(viewer, ierr)
          CHKERRQ(ierr)
        end if

!cdsu  debug part, write matrix in petsc binary format
!        if (mtime == 1 .or. mtime == 22) then
!          call PetscViewerBinaryOpen(Petsc_Comm_World,               &
!                    "a_"//prefix_ksp//"check"//trim(strinum)//".bin",&
!                    FILE_MODE_WRITE, viewer,ierr)
!          CHKERRQ(ierr)
!          call MatView(a_selec, viewer, ierr)
!          CHKERRQ(ierr)
!          call PetscViewerDestroy(viewer, ierr)
!          CHKERRQ(ierr)
!        end if
!cdsu  debug part, write matrix in petsc binary format,end

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventEnd(log_a_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventEnd(log_a_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventBegin(log_ksp_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventBegin(log_ksp_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif
        !> Set runtime options (e.g., -ksp_monitor -ksp_rtol <rtol> -ksp_type <type>)
        !> Set different options prefix for linear system of flow.
        !> Set runtime options (e.g., -flow_pc_type <type>)

        call KSPSetFromOptions(ksp_selec,ierr)
        CHKERRQ(ierr)

        call KSPSetUp(ksp_selec,ierr)
        CHKERRQ(ierr)

        !c set PC options
        if(.not. b_use_petsc_default_selec) then

          if (trim(strKSPType_selec) == "kspgmres" .or. &
              trim(strKSPType_selec) == "gmres" .or.    &
              trim(strKSPType_selec) == "kspbcgs" .or.  &
              trim(strKSPType_selec) == "bcgs") then

            call KSPGetPC(ksp_selec, pc_selec, ierr)
            CHKERRQ(ierr)

            b_pc_factor_shift = .true.

            !c Extract the array of KSP contexts for the local blocks 
            if(trim(strPCType_selec) == "pcbjacobi" .or. &
               trim(strPCType_selec) == "bjacobi") then              
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
              call PCBJacobiGetSubKSP(pc_selec,nlocal,firstlocal,PETSC_NULL_KSP,ierr)
#else
              nlocal = 100
#endif
              allocate(subksp(nlocal))

              call PCBJacobiGetSubKSP(pc_selec,nlocal,firstlocal,subksp,ierr)
              CHKERRQ(ierr)
            else if(trim(strPCType_selec) == "pcasm" .or. &
                    trim(strPCType_selec) == "asm") then
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
              call PCASMGetSubKSP(pc_selec,nlocal,firstlocal,PETSC_NULL_KSP,ierr)
#else
              nlocal = 100
#endif
              allocate(subksp(nlocal))

              call PCASMGetSubKSP(pc_selec,nlocal,firstlocal,subksp,ierr)
              CHKERRQ(ierr)
            else
              b_pc_factor_shift = .false.
              allocate(subksp(100))    !assign a big enough value
            end if

            if (b_pc_factor_shift) then

              if (trim(pc_factor_shift_selec) == "none") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_NONE, ierr)
                  CHKERRQ(ierr)
                end do
              else if (trim(pc_factor_shift_selec) == "nonzero") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_NONZERO, ierr)
                  CHKERRQ(ierr)
                end do
              else if (trim(pc_factor_shift_selec) == "positive_definite") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_POSITIVE_DEFINITE, ierr)
                  CHKERRQ(ierr)
                end do
              else if (trim(pc_factor_shift_selec) == "inblocks") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_INBLOCKS, ierr)
                  CHKERRQ(ierr)
                end do
              end if
            end if
          end if
        end if

        call KSPSetUpOnBlocks(ksp_selec,ierr)
        CHKERRQ(ierr)

        !  Solve a x = b, where a is the Jacobian matrix.
        call KSPSolve(ksp_selec,b_selec,x_selec,ierr)
        CHKERRQ(ierr)        

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
            call PetscViewerASCIIOpen(Petsc_Comm_World,                &
                      "x_"//prefix_ksp//"out"//trim(strinum)//".txt",  &
                      viewer,ierr)
            CHKERRQ(ierr)
          else
            call PetscViewerBinaryOpen(Petsc_Comm_World,               &
                      "x_"//prefix_ksp//"out"//trim(strinum)//".bin",  &
                      FILE_MODE_WRITE, viewer, ierr)
            CHKERRQ(ierr)
          end if
          call VecView(x_selec, viewer, ierr)
          CHKERRQ(ierr)
          call PetscViewerDestroy(viewer, ierr)
          CHKERRQ(ierr)
        end if  

!cdsu  debug part, write matrix in petsc binary format
!        if (mtime == 1 .or. mtime == 22) then
!          call PetscViewerBinaryOpen(Petsc_Comm_World,               &
!                    "x_"//prefix_ksp//"check"//trim(strinum)//".bin",           &
!                    FILE_MODE_WRITE, viewer, ierr)
!          CHKERRQ(ierr)
!          call VecView(x_selec, viewer, ierr)
!          CHKERRQ(ierr)
!          call PetscViewerDestroy(viewer, ierr)
!          CHKERRQ(ierr)
!        end if
!cdsu  debug part, write matrix in petsc binary format,end

        !  Get iteration and convergence information
        call KSPGetIterationNumber(ksp_selec,itsolv,ierr)
        CHKERRQ(ierr)

        !call KSPGetErrorIfNotConverged(ksp_selec,over_flow,ierr)
        !CHKERRQ(ierr)

        call KSPGetConvergedReason(ksp_selec,reason,ierr)
        CHKERRQ(ierr)

        ! treat intial guess as solution if it meets convergence requirement
        ! treat divergence as overflow status
        if(reason <= 0) then
          over_flow = .true.
          if(rank == 0 .and. idetail > 1) then
            write(*,'(1x,a,1x,i6,1x)')                                 &
                  "solver failure due to convergence reason: ",reason
            write(ilog,'(1x,a,1x,i6,1x)')                              &
                  "solver failure due to convergence reason: ",reason
          end if
          goto 1000
        end if

        !Get residual norm, by default, preconditioned residual norm is calculated.
        if (b_recal_norm_selec) then
          call calculate_norm(a_selec, x_selec, b_selec, r_selec, rnorm)
        else
#if (PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR <= 8)
          if (b_mykspconverged_selec .and.                             &
                .not. b_use_petsc_default_selec) then
            rnorm = rnorm_selec
          else
#endif
            call KSPGetResidualNorm(ksp_selec, rnorm, ierr)
            CHKERRQ(ierr)
#if (PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR <= 8)
          end if
#endif
        end if
       
        if(abs(rnorm)>dtol_selec) then
          over_flow = .true.
          if(rank == 0 .and. idetail > 1) then
            write(*,'(1x,a,1x,i6,1x,a,1x,1pe15.6e3)')                  &
                  "solver failure: iteration",itsolv,"rnorm",rnorm
            write(ilog,'(1x,a,1x,i6,1x,a,1x,1pe15.6e3)')               &
                  "solver failure: iteration",itsolv,"rnorm",rnorm
          end if
          goto 1000
        end if

        !  Scatter ghost points to local vector, using the 2-step process
        !     DMGlobalToLocalBegin(), DMGlobalToLocalEnd().
        !  By placing code between these two statements, computations can be
        !  done while messages are in transition. 
        call DMGlobalToLocalBegin(dmda_selec%da,x_selec,INSERT_VALUES,   &
                                  x_selec_loc,ierr)
        CHKERRQ(ierr)
        call DMGlobalToLocalEnd(dmda_selec%da,x_selec,INSERT_VALUES,     &
                                  x_selec_loc,ierr) 
        CHKERRQ(ierr)
       
        call VecGetArrayF90(x_selec_loc,vecpointer,ierr)
        CHKERRQ(ierr)

        if(b_non_interlaced) then
          j = nngl_in/2  
          do i = 1, j
              x_inout(i) = vecpointer(2*i-1)
              x_inout(i+j) = vecpointer(2*i)
          end do
        else
          x_inout = vecpointer
        end if
        
        call VecRestoreArrayF90(x_selec_loc,vecpointer,ierr)
        CHKERRQ(ierr)
       
#ifdef DEBUG
        if(info_debug > 1) then
            write(*,*) "Force to stop at solver_dd_snes_solve_flow"
            call petsc_mpi_finalize
            stop
        end if
#endif

100     FORMAT (/1x,'Maximum error from previous solution is less',    &
              /1x,'than the specified convergence tolerance.')

1000    continue

        if (allocated(subksp)) then
          deallocate(subksp)
        end if

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventEnd(log_ksp_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventEnd(log_ksp_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif

#ifdef PETSC_USE_LOG
        if (bflag_flow) then
          call PetscLogEventEnd(log_tot_flow,ierr)
          CHKERRQ(ierr)
        else
          call PetscLogEventEnd(log_tot_heat,ierr)
          CHKERRQ(ierr)
        end if
#endif
       
        return
    
    end subroutine solver_dd_snes_solve_flow_heat
    
    !> create petsc solver space for reactive transport problem
    subroutine solver_dd_snes_create_react

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscmat.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
        use petscsys
        use petscmat
#endif

#ifdef USG
        use parm, only : ncon_usg
#endif
        use gen, only : nn, nngl, nngbl, rank, nprcs, row_idx_l2pg_rt, &
                        col_idx_l2pg_rt, iart, ilog, b_enable_output,  &
                        mem_cur, mem_max, memory_monitor,              &
                        discretization_type

        use petsc_mpi_common, only : petsc_mpi_finalize
    
        implicit none   
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdef.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscdef.h>
#ifdef PETSC_USE_LOG
#include <finclude/petsclog.h>
#endif
#endif

#ifdef PETSC_HAVE_MUMPS
        PetscInt  :: ival,icntl,infog34
        PetscReal :: cntl,rinfo12,rinfo13,val
#endif
        
        PetscErrorCode :: ierr  
        PetscInt, allocatable :: d_nnz(:)
        PetscInt, allocatable :: o_nnz(:)        
        PetscInt :: i, j, k, nndof, nngldof, nngbldof, istart, iend,   &
                    range_s, range_e, d_nz, o_nz
        
        PetscBool ::  bflag  

!c MatSolverType is used in PETSc-dev (3.8+) version or PETSc-3.9.0 above version
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
        MatSolverType :: solver_pkg_react
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
        MatSolverPackage :: solver_pkg_react
#endif

        external :: checkerr

#ifdef PETSC_USE_LOG
        call PetscLogEventRegister('log_x_react',0,log_x_react,ierr)
        CHKERRQ(ierr)
        call PetscLogEventRegister('log_b_react',0,log_b_react,ierr)
        CHKERRQ(ierr)
        !call PetscLogEventRegister('log_bnorm_react',0,log_bnorm_react,ierr)
        !CHKERRQ(ierr)
        call PetscLogEventRegister('log_a_react',0,log_a_react,ierr)
        CHKERRQ(ierr)
        call PetscLogEventRegister('log_ksp_react',0,log_ksp_react,ierr)
        CHKERRQ(ierr)
        call PetscLogEventRegister('log_tot_react',0,log_tot_react,ierr)
        CHKERRQ(ierr)
#endif

        !> - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        !>  Create matrix data structure for Jacobian
        !> - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        !>
        !>  Note:  For the parallel case, vectors and matrices MUST be partitioned
        !>  accordingly.  When using distributed arrays (DMDAs) to create vectors,
        !>  the DMDAs determine the problem partitioning.  We must explicitly
        !>  specify the local matrix dimensions upon its creation for compatibility
        !>  with the vector distribution.
        !>
        !>  Note: Here we only approximately preallocate storage space for the
        !>  Jacobian.  See the users manual for a discussion of better techniques
        !>  for preallocating matrix memory.

        bflag = .false.
        !bflag = .true.

        if(bflag) then        

          if(dmda_react%dim == 1) then
              d_nz = 3
              o_nz = 1
          else if (dmda_react%dim == 2) then
              d_nz = 5
              o_nz = 3
          else if (dmda_react%dim == 3) then
              d_nz = 7
              o_nz = 5
          end if

#ifdef USG
          if (discretization_type > 0) then
            d_nz = ncon_usg
            o_nz = ncon_usg
          end if
#endif

          nndof = nn * dmda_react%dof
          nngldof = nngl * dmda_react%dof
          nngbldof = nngbl * dmda_react%dof

          d_nz = d_nz * dmda_react%dof
          o_nz = o_nz * dmda_react%dof
        
        else
          nndof = nn * dmda_react%dof
          nngldof = nngl * dmda_react%dof
          nngbldof = nngbl * dmda_react%dof

          !Method 2: precisely preallocating
          allocate(d_nnz(nndof), stat = ierr)
          call checkerr(ierr,'d_nnz',ilog)
          d_nnz = 0
          call memory_monitor(sizeof(d_nnz),'d_nnz',.true.)

          allocate(o_nnz(nndof), stat = ierr)
          call checkerr(ierr,'o_nnz',ilog)
          o_nnz = 0
          call memory_monitor(sizeof(o_nnz),'o_nnz',.true.)

          range_s = dmda_react%range_start
          range_e = dmda_react%range_end

          do i = 1, nngldof
              j = row_idx_l2pg_rt(i)
              if(j < 0) then
                  cycle
              end if

              j = j - range_s + 1

              istart = iart(i)
              iend = iart(i+1)-1
              do k = istart, iend

                  if(col_idx_l2pg_rt(k) >= range_s .and.                 &
                     col_idx_l2pg_rt(k) <= range_e) then

                      d_nnz(j) = d_nnz(j) + 1
                  else
                      o_nnz(j) = o_nnz(j) + 1
                  end if
              end do

          end do

        end if

        if(bflag) then
          call MatCreateAIJ(Petsc_Comm_World,                          &
                            nndof, nndof, nngbldof, nngbldof,          &
                            d_nz, PETSC_NULL_INTEGER,                  &
                            o_nz, PETSC_NULL_INTEGER,                  &
                            a_react, ierr)
          CHKERRQ(ierr)
        else
          call MatCreateAIJ(Petsc_Comm_World,                          &
                            nndof, nndof, nngbldof, nngbldof,          &
                            PETSC_DECIDE, d_nnz(1:nndof),              &
                            PETSC_DECIDE, o_nnz(1:nndof),              &
                            a_react, ierr)
          CHKERRQ(ierr)
        end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 16)
        call MatSetBlockSize(a_react, dmda_react%dof, ierr)
        CHKERRQ(ierr)
#endif
        
        if(.not.bflag) then
          call memory_monitor(-sizeof(d_nnz),'d_nnz',.true.)
          call memory_monitor(-sizeof(o_nnz),'o_nnz',.true.)
          deallocate(d_nnz)
          deallocate(o_nnz)
        end if

        !c MatOptions
#ifdef PETSC_HAVE_SUPERLU

        if (trim(strKSPType_react) == "kspsuperlu" .or. &
            trim(strKSPType_react) == "superlu") then

          call PetscOptionsInsertString(                               &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
               PETSC_NULL_OPTIONS,"-mat_superlu_diagpivotthresh 0.0",  &
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR == 7)
               PETSC_NULL_OBJECT,"-mat_superlu_diagpivotthresh 0.0",   &
#else
               "-mat_superlu_diagpivotthresh 0.0",                     &
#endif
               ierr)
          CHKERRQ(ierr)

          call PetscOptionsInsertString(                               &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
               PETSC_NULL_OPTIONS,"-mat_superlu_dist_fact SamePattern",&
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR == 7)
               PETSC_NULL_OBJECT,"-mat_superlu_dist_fact SamePattern", &
#else
               "-mat_superlu_dist_fact SamePattern",                   &
#endif
               ierr)
          CHKERRQ(ierr)

        end if

#endif
        call MatSetFromOptions(a_react,ierr)
        CHKERRQ(ierr)

        ! Create the linear solver and set various options
        !    - First, set the KSP linear operators.  Here the matrix that
        !      defines the linear system also serves as the preconditioning
        !      matrix.
        call KSPCreate(Petsc_Comm_World, ksp_react, ierr)
        CHKERRQ(ierr)

        ! Set options for reactive transport
        call KSPAppendOptionsPrefix(ksp_react,"react_",ierr)
        CHKERRQ(ierr)

        call KSPSetInitialGuessNonzero(ksp_react,                      &
                b_initial_guess_nonzero_react, ierr)
        CHKERRQ(ierr)
        
        if (b_reuse_preconditioner_react) then
          if (.not.b_set_preconditioner_react) then
            b_set_preconditioner_react = .true.
            call MatConvert(a_react,MATSAME,MAT_INITIAL_MATRIX,        &
                            a_react_j,ierr)
            CHKERRQ(ierr)
          end if
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
          call KSPSetOperators(ksp_react,a_react,a_react_j,            &
                               SAME_NONZERO_PATTERN,ierr)
#else
          call KSPSetOperators(ksp_react,a_react,a_react_j,ierr)
#endif

        else
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
          call KSPSetOperators(ksp_react,a_react,a_react,              &
                               SAME_NONZERO_PATTERN,ierr)
#else
          call KSPSetOperators(ksp_react,a_react,a_react,ierr)
#endif
        end if
        CHKERRQ(ierr)

        call KSPSetDM(ksp_react,dmda_react%da,ierr)
        CHKERRQ(ierr)
        call KSPSetDMActive(ksp_react,PETSC_FALSE,ierr)
        CHKERRQ(ierr)

        !c set convergence tolerance
        b_recal_norm_react = .false.
        if(.not. b_use_petsc_default_react) then

          if (trim(strKSPConvergenceType_react) == "kspuserdefined" .or.&
              trim(strKSPConvergenceType_react) == "userdefined") then
              b_mykspconverged_react = .true.
            call KSPSetConvergenceTest(ksp_react,mykspconverged_react, &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                                       0,                              &
#else
                                       PETSC_NULL_OBJECT,              &
#endif
                                       PETSC_NULL_FUNCTION,ierr)
            CHKERRQ(ierr)
          else
            b_mykspconverged_react = .false.
          end if

          !Set linear solver defaults for this problem (optional).
          call KSPSetTolerances(ksp_react, rtol_react, abstol_react,   &
                                dtol_react, maxits_react, ierr)
          CHKERRQ(ierr)

        end if

        !c set KSP options
        if(.not. b_use_petsc_default_react) then

#ifdef PETSC_HAVE_MUMPS
          if (trim(strKSPType_react) == "kspmumps" .or. &
            trim(strKSPType_react) == "mumps") then
            call KSPSetType(ksp_react, KSPPREONLY, ierr)
            CHKERRQ(ierr)
            b_recal_norm_react = .true.
            goto 101
          end if
#endif

#ifdef PETSC_HAVE_SUPERLU
          if (trim(strKSPType_react) == "kspsuperlu" .or. &
            trim(strKSPType_react) == "superlu") then
            call KSPSetType(ksp_react, KSPPREONLY, ierr)
            CHKERRQ(ierr)
            b_recal_norm_react = .true.
            goto 101
          end if
#endif

          if (trim(strKSPType_react) == "kspgmres" .or. &
              trim(strKSPType_react) == "gmres") then
            call KSPSetType(ksp_react, KSPGMRES, ierr)
            CHKERRQ(ierr)
            goto 101
          else if (trim(strKSPType_react) == "kspbcgs" .or. &
                   trim(strKSPType_react) == "bcgs") then
            call KSPSetType(ksp_react, KSPBCGS, ierr)
            CHKERRQ(ierr)
            goto 101
          else
            call KSPSetType(ksp_react, KSPGMRES, ierr)
            CHKERRQ(ierr)
            goto 101
          end if

        end if

101     continue

        !c set PC options
        if(.not. b_use_petsc_default_react) then

          call KSPGetPC(ksp_react, pc_react, ierr)
          CHKERRQ(ierr)

#ifdef PETSC_HAVE_MUMPS
          if (trim(strKSPType_react) == "kspmumps" .or. &
            trim(strKSPType_react) == "mumps") then

            !c force pctype to pclu for mumps solver
            call PCSetType(pc_react,PCLU, ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
            call PCFactorSetMatSolverType(pc_react,MATSOLVERMUMPS,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverType(pc_react,ierr)
            CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
            call PCFactorSetMatSolverPackage(pc_react,MATSOLVERMUMPS,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverPackage(pc_react,ierr)
            CHKERRQ(ierr)
#endif

            call PCFactorGetMatrix(pc_react,a_react_fac,ierr)
            CHKERRQ(ierr)

            goto 201

          end if
#endif

#ifdef PETSC_HAVE_SUPERLU
          if (trim(strKSPType_react) == "kspsuperlu" .or. &
            trim(strKSPType_react) == "superlu") then

            !c force pctype to pclu for superlu_dist solver
            call PCSetType(pc_react,PCLU, ierr)
            CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
            call PCFactorSetMatSolverType(pc_react,MATSOLVERSUPERLU_DIST,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverType(pc_react,ierr)
            CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
            call PCFactorSetMatSolverPackage(pc_react,MATSOLVERSUPERLU_DIST,ierr)
            CHKERRQ(ierr)

            call PCFactorSetUpMatSolverPackage(pc_react,ierr)
            CHKERRQ(ierr)
#endif

            call PCFactorGetMatrix(pc_react,a_react_fac,ierr)
            CHKERRQ(ierr)

            goto 201

          end if
#endif

          if(trim(strPCType_react) == "pcnone" .or. &
             trim(strPCType_react) == "none") then
              call PCSetType(pc_react,PCNONE, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pcjacobi" .or. &
             trim(strPCType_react) == "jacobi") then
              call PCSetType(pc_react,PCJACOBI, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pclu" .or. &
             trim(strPCType_react) == "lu") then
              call PCSetType(pc_react,PCLU, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pcbjacobi" .or. &
             trim(strPCType_react) == "bjacobi") then
              call PCSetType(pc_react,PCBJACOBI, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pcilu" .or. &
             trim(strPCType_react) == "ilu") then
              call PCSetType(pc_react,PCILU, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pcasm" .or. &
             trim(strPCType_react) == "asm") then
              call PCSetType(pc_react,PCASM, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pcksp" .or. &
             trim(strPCType_react) == "ksp") then
              call PCSetType(pc_react,PCKSP, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pchypre" .or. &
             trim(strPCType_react) == "hypre") then
              call PCSetType(pc_react,PCHYPRE, ierr)
              CHKERRQ(ierr)

          else if(trim(strPCType_react) == "pchypre-euclid" .or. &
                  trim(strPCType_react) == "hypre-euclid") then
            call PCSetType(pc_react,PCHYPRE, ierr)
            CHKERRQ(ierr)
  
            call PCHYPRESetType(pc_react,"euclid", ierr)
            CHKERRQ(ierr)
  
          else if(trim(strPCType_react) == "pchypre-pilut" .or. &
                  trim(strPCType_react) == "hypre-pilut") then
            call PCSetType(pc_react,PCHYPRE, ierr)
            CHKERRQ(ierr)
  
            call PCHYPRESetType(pc_react,"pilut", ierr)
            CHKERRQ(ierr)
  
          else if(trim(strPCType_react) == "pchypre-parasails" .or. &
                  trim(strPCType_react) == "hypre-parasails") then
            call PCSetType(pc_react,PCHYPRE, ierr)
            CHKERRQ(ierr)
  
            call PCHYPRESetType(pc_react,"parasails", ierr)
            CHKERRQ(ierr)
  
          else if(trim(strPCType_react) == "pchypre-boomeramg" .or. &
                  trim(strPCType_react) == "hypre-boomeramg") then
            call PCSetType(pc_react,PCHYPRE, ierr)
            CHKERRQ(ierr)
  
            call PCHYPRESetType(pc_react,"boomeramg", ierr)
            CHKERRQ(ierr)

          else
              call PCSetType(pc_react,PCBJACOBI, ierr)
              CHKERRQ(ierr)

          end if

          !c set incomplete factorization level
          if (pc_factor_level_react > 0) then
            call PCFactorSetLevels(pc_react, pc_factor_level_react, ierr)
            CHKERRQ(ierr)
          end if

          if ((trim(strKSPType_react) /= "kspmumps"   .and.  &
              trim(strKSPType_react) /= "mumps"       .and.  &
              trim(strKSPType_react) /= "kspsuperlu"  .and.  &
              trim(strKSPType_react) /= "superlu")    .and.  &
              (trim(strPCType_react) == "pcilu"       .or.   &
              trim(strPCType_react) == "ilu"          .or.   &
              trim(strPCType_react) == "pclu"         .or.   &
              trim(strPCType_react) == "lu")          .and.  &
              nprcs > 1) then
              if(rank == 0) then
                write(*,'(5a,i4,a)') "Error: PCTYPE ",               &   
                      trim(strPCType_react)," is not supported for ",&
                      trim(strKSPType_react)," using ", nprcs,       &
                      " processors"
                write(ilog,'(5a,i4,a)') "Error: PCTYPE ",            &
                      trim(strPCType_react)," is not supported for ",&
                      trim(strKSPType_react)," using ", nprcs,       &
                      " processors"
              end if
              call petsc_mpi_finalize
              stop
          end if

        end if

201     continue
        
        !c check solver package if not from configuration file
        call KSPGetPC(ksp_react, pc_react, ierr)
        CHKERRQ(ierr)
        
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
        call PCFactorGetMatSolverType(pc_react,solver_pkg_react,ierr)
        CHKERRQ(ierr)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
        call PCFactorGetMatSolverPackage(pc_react,solver_pkg_react,ierr)
        CHKERRQ(ierr)
#endif
        
        if (solver_pkg_react == "superlu" .or.                   &
            solver_pkg_react == "superlu_dist" .or.              &
            solver_pkg_react == "mumps" .or.                     &
            solver_pkg_react == "mkl_pardiso" .or.               &
            solver_pkg_react == "mkl_cpardiso") then
          b_recal_norm_react = .true.
        else
          b_check_norm_react = .false.
        end if

        !> If not doing matrix free then matrix operator and matrix used
        !> to construct preconditioner are the same
        !a_react_j = a_react

        ! KSPSetFromOptions must come after custom setup in order to override
        ! from command line
        call KSPSetFromOptions(ksp_react,ierr)
        CHKERRQ(ierr) 

        call KSPGetTolerances(ksp_react, rtol_react, abstol_react,     &
                              dtol_react, maxits_react, ierr)
        CHKERRQ(ierr)

        if (rank == 0 .and. b_enable_output) then
          write(*,'(/a)') "PETSc convergence parameters for reactive transport"
          write(*,'(4a14)') "rtol","abstol","divtol","maxits"
          write(*,'(3(1x,1pe15.6e3),1x,i6)')                           &
                rtol_react,abstol_react,dtol_react,maxits_react

          write(ilog,'(/a)')"PETSc convergence parameters for reactive transport"
          write(ilog,'(4a14)') "rtol","abstol","divtol","maxits"
          write(ilog,'(3(1x,1pe15.6e3),1x,i6)')                        &
                rtol_react,abstol_react,dtol_react,maxits_react
        end if

    end subroutine solver_dd_snes_create_react

    !> solve petsc solver space for reactive transport problem
    subroutine solver_dd_snes_solve_react(ilog,idetail,a_in,b_in,      &
                      x_inout,ia_in,ja_in,nngl_in,itsolv,              &
                      over_flow,rnorm,row_idx_l2pg,col_idx_l2pg,       &
                      b_non_interlaced)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscksp.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
        use petscdmda
        use petscksp
#endif
        use gen, only : rank, node_idx_l2lg, ittot_rt,                 &
                        b_output_matrix_petsc, b_enable_output,        &
                        itimestep_output_matrix, mtime

        use solver_snes_function, only : form_initial_guess,           &
                                         compute_function,             &
                                         compute_jacobian

        use petsc_mpi_common, only : petsc_mpi_finalize

        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscvec.h>
#include <petsc/finclude/petscvec.h90>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscviewer.h>
#include <petsc/finclude/petscviewer.h90>
#include <petsc/finclude/petscksp.h>
#ifdef PETSC_USE_LOG
#include <petsc/finclude/petsclog.h>
#endif
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscvec.h>
#include <finclude/petscvec.h90>
#include <finclude/petscdmda.h>
#include <finclude/petscviewer.h>
#include <finclude/petscviewer.h90>
#include <finclude/petscksp.h>
#ifdef PETSC_USE_LOG
#include <finclude/petsclog.h>
#endif
#endif

#ifdef PETSC_HAVE_MUMPS
        PetscInt  :: ival,icntl,infog34
        PetscReal :: cntl,rinfo12,rinfo13,val
#endif

        PetscInt :: ilog
        PetscInt :: idetail
        PetscInt :: nngl_in
        PetscInt :: ilocal
        PetscInt :: nlocal
        PetscInt :: firstlocal
        PetscReal, allocatable :: a_in(:)
        PetscReal, allocatable :: b_in(:)
        PetscReal, allocatable :: x_inout(:)
        PetscInt, allocatable  :: ia_in(:)
        PetscInt, allocatable  :: ja_in(:)
        PetscInt, allocatable :: row_idx_l2pg(:)
        PetscInt, allocatable :: col_idx_l2pg(:)
        PetscInt  :: itsolv
        PetscBool :: over_flow
        PetscBool :: b_non_interlaced
        PetscReal :: rnorm

        PetscViewer :: viewer
        PetscScalar,pointer :: vecpointer(:)

        PC :: subpc
        KSP,allocatable,dimension(:) :: subksp     ! array of local KSP contexts on this processor
        PetscBool :: b_pc_factor_shift

        PetscErrorCode :: ierr
        PetscInt :: info_debug, reason
        character(72) :: strinum

#ifdef PETSC_USE_LOG
        call PetscLogEventBegin(log_tot_react,ierr)
        CHKERRQ(ierr)
#endif

        info_debug = 0

        over_flow = .false.

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          write(strinum, *) ittot_rt
          strinum = "_"//trim(adjustl(strinum))
        end if

#ifdef PETSC_USE_LOG
        call PetscLogEventBegin(log_x_react,ierr)
        CHKERRQ(ierr)
#endif

        !Form initial guess, only assemble the local owned part, without ghost nodes
        if (b_form_initial_guess_react) then

          call form_initial_guess(rank,dmda_react%da,x_inout,          &
                    x_react_loc, x_react,nngl_in, row_idx_l2pg,        &
                    col_idx_l2pg, b_non_interlaced)


          if(b_enable_output .and. (b_output_matrix_petsc .or.         &
             itimestep_output_matrix==mtime)) then
            if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
              call PetscViewerASCIIOpen(Petsc_Comm_World,              &
                        "x_react_in"//trim(strinum)//".txt",viewer,ierr)
              CHKERRQ(ierr)
            else
              call PetscViewerBinaryOpen(Petsc_Comm_World,             &
                        "x_react_in"//trim(strinum)//".bin",           &
                        FILE_MODE_WRITE, viewer, ierr)
              CHKERRQ(ierr)
            end if
            call VecView(x_react, viewer, ierr)
            CHKERRQ(ierr)
            call PetscViewerDestroy(viewer, ierr)
            CHKERRQ(ierr)
          end if

        end if

#ifdef PETSC_USE_LOG
        call PetscLogEventEnd(log_x_react,ierr)
        CHKERRQ(ierr)
#endif

#ifdef PETSC_USE_LOG
        call PetscLogEventBegin(log_b_react,ierr)
        CHKERRQ(ierr)
#endif

        !Compute function, only assemble the local part, without ghost nodes
        call compute_function(rank,dmda_react%da,b_in,b_react_loc,     &
                     b_react,nngl_in,row_idx_l2pg,col_idx_l2pg,        &
                     b_non_interlaced)

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
            call PetscViewerASCIIOpen(Petsc_Comm_World,                &
                      "b_react_in"//trim(strinum)//".txt",viewer, ierr)
            CHKERRQ(ierr)
          else
            call PetscViewerBinaryOpen(Petsc_Comm_World,               &
                      "b_react_in"//trim(strinum)//".bin",             &
                      FILE_MODE_WRITE, viewer, ierr)
            CHKERRQ(ierr)
          end if
          call VecView(b_react, viewer, ierr)
          CHKERRQ(ierr)
          call PetscViewerDestroy(viewer, ierr)
          CHKERRQ(ierr)
        end if

#ifdef PETSC_USE_LOG
        call PetscLogEventEnd(log_b_react,ierr)
        CHKERRQ(ierr)
#endif

!        !Check if the initial residual norm to see if it meets the convergence
!#ifdef PETSC_USE_LOG
!        call PetscLogEventBegin(log_bnorm_react,ierr)
!        CHKERRQ(ierr)
!#endif
!        call VecNormBegin(b_react, Norm_2, rnorm, ierr)
!        CHKERRQ(ierr)
!        call VecNormEnd(b_react, Norm_2, rnorm, ierr)
!        CHKERRQ(ierr)
!        if(rnorm < 1.0d-300) then
!            if(idetail > 1) then
!                write(ilog,100)
!            end if
!            itsolv = 0
!#ifdef PETSC_USE_LOG
!            call PetscLogEventEnd(log_bnorm_react,ierr)
!            CHKERRQ(ierr)
!#endif
!            return
!        end if
!#ifdef PETSC_USE_LOG
!        call PetscLogEventEnd(log_bnorm_react,ierr)
!        CHKERRQ(ierr)
!#endif

#ifdef PETSC_USE_LOG
        call PetscLogEventBegin(log_a_react,ierr)
        CHKERRQ(ierr)
#endif

        !Compute jacobian matrix, only assemble the local part, without ghost nodes
        call compute_jacobian(rank,dmda_react%da,                      &
                              a_react,a_in,ia_in,ja_in,nngl_in,        &
                              row_idx_l2pg,col_idx_l2pg,               &
                              b_non_interlaced)

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
            call PetscViewerASCIIOpen(Petsc_Comm_World,                &
                      "a_react_in"//trim(strinum)//".txt",viewer, ierr)
            CHKERRQ(ierr)
          else
            call PetscViewerBinaryOpen(Petsc_Comm_World,               &
                      "a_react_in"//trim(strinum)//".bin",             &
                      FILE_MODE_WRITE, viewer, ierr)
            CHKERRQ(ierr)
          end if
          call MatView(a_react, viewer, ierr)
          CHKERRQ(ierr)
          call PetscViewerDestroy(viewer, ierr)
          CHKERRQ(ierr)
        end if

#ifdef PETSC_USE_LOG
        call PetscLogEventEnd(log_a_react,ierr)
        CHKERRQ(ierr)
#endif

#ifdef PETSC_USE_LOG
        call PetscLogEventBegin(log_ksp_react,ierr)
        CHKERRQ(ierr)
#endif

        !> Set runtime options (e.g., -ksp_monitor -ksp_rtol <rtol> -ksp_type <type>) for reactive transport
        !> Set different options prefix for linear system of flow.
        !> Set runtime options (e.g., -react_pc_type <type>)

        call KSPSetFromOptions(ksp_react,ierr)
        CHKERRQ(ierr)

        call KSPSetUp(ksp_react,ierr)
        CHKERRQ(ierr)

        !c set PC options
        if(.not. b_use_petsc_default_react) then

          if (trim(strKSPType_react) == "kspgmres" .or. &
              trim(strKSPType_react) == "gmres" .or.    &
              trim(strKSPType_react) == "kspbcgs" .or.  &
              trim(strKSPType_react) == "bcgs") then

            call KSPGetPC(ksp_react, pc_react, ierr)
            CHKERRQ(ierr)

            b_pc_factor_shift = .true.

            !c Extract the array of KSP contexts for the local blocks 
            if(trim(strPCType_react) == "pcbjacobi" .or. &
               trim(strPCType_react) == "bjacobi") then
#if (PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR >= 11)
              call PCBJacobiGetSubKSP(pc_react,nlocal,firstlocal,PETSC_NULL_KSP,ierr)
#else
              nlocal = 100
#endif
              allocate(subksp(nlocal))

              call PCBJacobiGetSubKSP(pc_react,nlocal,firstlocal,subksp,ierr)
              CHKERRQ(ierr)
            else if(trim(strPCType_react) == "pcasm" .or. &
                    trim(strPCType_react) == "asm") then
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
              call PCASMGetSubKSP(pc_react,nlocal,firstlocal,PETSC_NULL_KSP,ierr)
#else
              nlocal = 100
#endif
              allocate(subksp(nlocal))

              call PCASMGetSubKSP(pc_react,nlocal,firstlocal,subksp,ierr)
              CHKERRQ(ierr)
            else
              b_pc_factor_shift= .false.
              allocate(subksp(100))    !assign a big enough value
            end if

            if (b_pc_factor_shift) then

              if (trim(pc_factor_shift_react) == "none") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_NONE, ierr)
                  CHKERRQ(ierr)
                end do
              else if (trim(pc_factor_shift_react) == "nonzero") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_NONZERO, ierr)
                  CHKERRQ(ierr)
                end do
              else if (trim(pc_factor_shift_react) == "positive_definite") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_POSITIVE_DEFINITE, ierr)
                  CHKERRQ(ierr)
                end do
              else if (trim(pc_factor_shift_react) == "inblocks") then
                do ilocal = 1, nlocal
                  call KSPGetPC(subksp(ilocal),subpc,ierr)
                  CHKERRQ(ierr)
                  call PCFactorSetShiftType(subpc,MAT_SHIFT_INBLOCKS, ierr)
                  CHKERRQ(ierr)
                end do
              end if
            end if
          end if
        end if

        call KSPSetUpOnBlocks(ksp_react,ierr)
        CHKERRQ(ierr)

        call KSPSolve(ksp_react,b_react,x_react,ierr)
        CHKERRQ(ierr)

        if(b_enable_output .and. (b_output_matrix_petsc .or.           &
           itimestep_output_matrix==mtime)) then
          if(nngl_in <= 1024 .and. nngl_in < n_binary_limit) then
            call PetscViewerASCIIOpen(Petsc_Comm_World,                &
                      "x_react_out"//trim(strinum)//".txt",viewer, ierr)
            CHKERRQ(ierr)
          else
            call PetscViewerBinaryOpen(Petsc_Comm_World,               &
                      "x_react_out"//trim(strinum)//".bin",            &
                      FILE_MODE_WRITE, viewer, ierr)
            CHKERRQ(ierr) 
          end if
          call VecView(x_react, viewer, ierr)
          CHKERRQ(ierr)
          call PetscViewerDestroy(viewer, ierr)
          CHKERRQ(ierr)
        end if

       
        !  Get iteration and convergence information
        call KSPGetIterationNumber(ksp_react,itsolv,ierr)
        CHKERRQ(ierr)

        !call KSPGetErrorIfNotConverged(ksp_react,over_flow,ierr)
        !CHKERRQ(ierr)
        
        call KSPGetConvergedReason(ksp_react,reason,ierr)
        CHKERRQ(ierr)

        ! treat intial guess as solution if it meets convergence requirement
        ! treat divergence as overflow status
        if(reason <= 0) then
          over_flow = .true.
          if(rank == 0 .and. idetail > 1) then
            write(*,'(1x,a,1x,i6,1x)')                                 &
                  "solver failure due to convergence reason: ",reason
            write(ilog,'(1x,a,1x,i6,1x)')                              &
                  "solver failure due to convergence reason: ",reason
          end if
          goto 1000
        end if

        !Get residual norm, by default, preconditioned residual norm is calculated.
        if (b_recal_norm_react) then
          call calculate_norm(a_react, x_react, b_react, r_react, rnorm)
        else
#if (PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR <= 8)
          if (b_mykspconverged_react .and.                               &
                .not. b_use_petsc_default_react) then
            rnorm = rnorm_react
          else
#endif
            call KSPGetResidualNorm(ksp_react, rnorm, ierr)
            CHKERRQ(ierr)
#if (PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR <= 8)
          end if
#endif
        end if
        
        if(abs(rnorm) > dtol_react) then
          over_flow = .true.
          if(rank == 0 .and. idetail > 1) then
            write(*,'(1x,a,1x,i6,1x,a,1x,1pe15.6e3)')                  &
                  "solver failure: iteration",itsolv,"rnorm",rnorm
            write(ilog,'(1x,a,1x,i6,1x,a,1x,1pe15.6e3)')               &
                  "solver failure: iteration",itsolv,"rnorm",rnorm
          end if
          goto 1000
        end if

        !  Scatter ghost points to local vector, using the 2-step process
        !     DMGlobalToLocalBegin(), DMGlobalToLocalEnd().
        !  By placing code between these two statements, computations can be
        !  done while messages are in transition. 
        call DMGlobalToLocalBegin(dmda_react%da,x_react,INSERT_VALUES, &
                                  x_react_loc,ierr)
        CHKERRQ(ierr)
        call DMGlobalToLocalEnd(dmda_react%da,x_react,INSERT_VALUES,   &
                                  x_react_loc,ierr) 
        CHKERRQ(ierr)
        call VecGetArrayF90(x_react_loc,vecpointer,ierr)
        CHKERRQ(ierr)
        
        x_inout = vecpointer
        call VecRestoreArrayF90(x_react_loc,vecpointer,ierr)
        CHKERRQ(ierr)
        
#ifdef DEBUG
        if(info_debug > 1) then
            call petsc_mpi_finalize
            stop
        end if
#endif
        
100     FORMAT (/1x,'Maximum error from previous solution is less',    &
              /1x,'than the specified convergence tolerance.')

1000    continue

        if (allocated(subksp)) then
          deallocate(subksp)
        end if

#ifdef PETSC_USE_LOG
        call PetscLogEventEnd(log_ksp_react,ierr)
        CHKERRQ(ierr)
#endif

#ifdef PETSC_USE_LOG
        call PetscLogEventEnd(log_tot_react,ierr)
        CHKERRQ(ierr)
#endif
        
        return
    
    end subroutine solver_dd_snes_solve_react
    
   
    !> Release solver space
    subroutine solver_dd_release_flow

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
        use petscsys
#endif

        use gen, only: varsat_flow
    
        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
        
        PetscErrorCode :: ierr
        
        if(varsat_flow) then  
            call MatDestroy(a_flow,ierr)
            CHKERRQ(ierr)

            if (b_reuse_preconditioner_flow) then
              call MatDestroy(a_flow_j,ierr)
              CHKERRQ(ierr)
            end if

            call VecDestroy(x_flow_loc,ierr)
            CHKERRQ(ierr)
            call VecDestroy(x_flow,ierr)
            CHKERRQ(ierr)
            call VecDestroy(r_flow_loc,ierr)
            CHKERRQ(ierr)
            call VecDestroy(r_flow,ierr)
            CHKERRQ(ierr)
            call VecDestroy(b_flow_loc,ierr)
            CHKERRQ(ierr)
            call VecDestroy(b_flow,ierr)
            CHKERRQ(ierr)

            if (trim(strKSPType_flow) == "kspsuperlu" .or. &
                trim(strKSPType_flow) == "superlu"    .or. &
                trim(strKSPType_flow) == "kspmumps"   .or. &
                trim(strKSPType_flow) == "mpmps") then
              call MatDestroy(a_flow_fac,ierr)
              CHKERRQ(ierr)
            else
              call KSPDestroy(ksp_flow,ierr)
              CHKERRQ(ierr)
            end if

        end if
   
    end subroutine solver_dd_release_flow 
    
    !> Release solver space
    subroutine solver_dd_release_heat

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
        use petscsys
#endif


        implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
        
        PetscErrorCode :: ierr
        
        call MatDestroy(a_heat,ierr)
        CHKERRQ(ierr)

        if (b_reuse_preconditioner_heat) then
          call MatDestroy(a_heat_j,ierr)
          CHKERRQ(ierr)
        end if

        call VecDestroy(x_heat_loc,ierr)
        CHKERRQ(ierr)
        call VecDestroy(x_heat,ierr)
        CHKERRQ(ierr)
        call VecDestroy(r_heat_loc,ierr)
        CHKERRQ(ierr)
        call VecDestroy(r_heat,ierr)
        CHKERRQ(ierr)
        call VecDestroy(b_heat_loc,ierr)
        CHKERRQ(ierr)
        call VecDestroy(b_heat,ierr)
        CHKERRQ(ierr)

        if (trim(strKSPType_heat) == "kspsuperlu" .or. &
            trim(strKSPType_heat) == "superlu"    .or. &
            trim(strKSPType_heat) == "kspmumps"   .or. &
            trim(strKSPType_heat) == "mpmps") then
          call MatDestroy(a_heat_fac,ierr)
          CHKERRQ(ierr)
        else
          call KSPDestroy(ksp_heat,ierr)
          CHKERRQ(ierr)
        end if

   
    end subroutine solver_dd_release_heat    

    !> Release solver space
    subroutine solver_dd_release_react

#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
        use petscsys
#endif

        use gen, only: reactive_transport
    
        implicit none

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
        PetscErrorCode :: ierr

        if(reactive_transport) then
            call MatDestroy(a_react,ierr)
            CHKERRQ(ierr)

            if (b_reuse_preconditioner_react) then
              call MatDestroy(a_react_j,ierr)
              CHKERRQ(ierr)
            end if

            call VecDestroy(x_react_loc,ierr)
            CHKERRQ(ierr)
            call VecDestroy(x_react,ierr)
            CHKERRQ(ierr)
            call VecDestroy(r_react_loc,ierr)
            CHKERRQ(ierr)
            call VecDestroy(r_react,ierr)
            CHKERRQ(ierr)
            call VecDestroy(b_react_loc,ierr)
            CHKERRQ(ierr)
            call VecDestroy(b_react,ierr)
            CHKERRQ(ierr)

            if (trim(strKSPType_react) == "kspsuperlu" .or. &
                trim(strKSPType_react) == "superlu"    .or. &
                trim(strKSPType_react) == "kspmumps"   .or. &
                trim(strKSPType_react) == "mpmps") then
              call MatDestroy(a_react_fac,ierr)
              CHKERRQ(ierr)
            else
              call KSPDestroy(ksp_react,ierr)
              CHKERRQ(ierr)
            end if

        end if
   
    end subroutine solver_dd_release_react

    !>
    !> Create dmplex based on the given cell list
    !> for PETSc DMPLEX only
    !>
    subroutine solver_dd_create_dmplex

#ifdef USG

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdmplex.h>
#include <petsc/finclude/petscdmlabel.h>
      use petscsys
      use petscdm
      use petscdmplex
      use petscdmlabel
#endif
      use geometry_definition
      use gen, only : ilog, idbg, rank, str_rank, b_enable_output,     &
                      mem_cur, mem_max, memory_monitor
      use usg_mesh_data, only : num_nodes, num_cells, num_cells_loc,   &
                                nodes, cells, num_nodes_per_cell,      &
                                num_node_layers, num_nodes_per_layer,  &
                                num_cell_layers, num_cells_per_layer,  &
                                num_nodes_gbl, num_cells_gbl,          &
                                cell_type, node_to_layer_node,         &
                                cell_to_layer_cell,                    &
                                b_use_node_matids, node_matids,        &
                                b_use_cell_matids, cell_matids,        &
                                is_boundary_cell_gbl,                  &
                                is_boundary_node_gbl,                  &
                                cell_projection

      use file_unit, only : lun_get, lun_free

      use petsc_mpi_common, only : petsc_mpi_finalize

      implicit none
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdmplex.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscdmplex.h>
#endif

      !c local variables
      integer :: icnt, iprogress, iratio, ifile, info_debug
      integer :: inodelabel(10)
      integer, allocatable :: dmplex_cells(:)
      real*8, allocatable :: dmplex_verts(:)
      character(2) :: strtemp
      character(256) :: strtitle
      PetscInt :: i, ibit, icell, inode, ipoint, istart, iend, ivalue, &
                  itemp, ndim
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
      type(tDM) :: distributedMesh, cda
#else
      DM :: distributedMesh, cda
#endif
      DMLabel :: label_node_matids, label_cell_matids,                 &
                 label_vid_lg2g(32), label_cid_lg2g(32),               &
                 label_lvid_lg2g(32), label_lcid_lg2g(32)
      PetscSF :: migrationsf, dummy_sf
      PetscSection :: section, cs
      PetscPartitioner :: part
      PetscBool :: hasLabel
      PetscInt :: numFields, numBC
      PetscInt, target, dimension(1) ::  numComp
      PetscInt, target, dimension(4) ::  numDof
      PetscInt, target, dimension(1) ::  bcField
      DMLabel,  target, dimension(4) ::  labels

      DMLabel, pointer :: pLabels(:) => NULL()
      PetscInt, pointer :: pNumComp(:)
      PetscInt, pointer :: pNumDof(:)
      PetscInt, pointer :: pBcField(:)
      IS, target, dimension(1) ::   bcCompIS
      IS, target, dimension(1) ::   bcPointIS
      IS, pointer :: pBcCompIS(:)
      IS, pointer :: pBcPointIS(:)
      PetscErrorCode :: ierr

      integer, parameter :: i1k = 1000

      external :: checkerr

      info_debug = 0

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 8)
      if (rank == 0) then
        !write(*,'(a)') "Warning: PETSc 3.8 and earlier versions are not verified for MIN3P-HPC"
        write(ilog,'(a)') "Warning: PETSc 3.8 and earlier versions are not verified for MIN3P-HPC"
      end if
      !call petsc_mpi_finalize
      !stop
#endif

      if (b_enable_output .and. rank == 0) then
        write(*,'(a)') "Parallel domain decomposition, please wait ..."
      end if

      !c note: for 2D mesh in 3D, convert coordinates to 2D
      !c before passing to PETSc DMPlex
      if (cell_projection == projection_xyz) then
        ndim = 3
      else
        ndim = 2
      end if

      dmda_flow%dim = ndim

      !c disable interpolate feature for hexa mesh
      if (cell_type == cell_type_hexa) then
        interpolate = .false.
      end if

      if (rank == 0) then

        allocate(dmplex_cells(num_cells*num_nodes_per_cell), stat = ierr)
        call checkerr(ierr,'dmplex_cells',ilog)
        call memory_monitor(sizeof(dmplex_cells),'dmplex_cells',.false.)

        allocate(dmplex_verts(num_nodes*ndim), stat = ierr)
        call checkerr(ierr,'dmplex_verts',ilog)
        call memory_monitor(sizeof(dmplex_verts),'dmplex_verts',.false.)

        do icell = 1, num_cells
          do inode = 1, num_nodes_per_cell
            icnt = (icell-1)*num_nodes_per_cell+inode
            dmplex_cells(icnt) = cells(inode,icell)-1
          end do
        end do

        if (cell_projection == projection_xyz) then
          do inode = 1, num_nodes
            icnt = (inode-1)*ndim
            dmplex_verts(icnt + 1) = nodes(inode)%x
            dmplex_verts(icnt + 2) = nodes(inode)%y
            dmplex_verts(icnt + 3) = nodes(inode)%z
          end do
        else if (cell_projection == projection_xy) then
          do inode = 1, num_nodes
            icnt = (inode-1)*ndim
            dmplex_verts(icnt + 1) = nodes(inode)%x
            dmplex_verts(icnt + 2) = nodes(inode)%y
          end do
        else if (cell_projection == projection_yz) then
          do inode = 1, num_nodes
            icnt = (inode-1)*ndim
            dmplex_verts(icnt + 1) = nodes(inode)%y
            dmplex_verts(icnt + 2) = nodes(inode)%z
          end do
        else if (cell_projection == projection_xz) then
          do inode = 1, num_nodes
            icnt = (inode-1)*ndim
            dmplex_verts(icnt + 1) = nodes(inode)%x
            dmplex_verts(icnt + 2) = nodes(inode)%z
          end do
        end if

        !c Method 1: create DMPlex from cell list
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 17)
        call DMPlexCreateFromCellListPetsc(                            &
#else
        call DMPlexCreateFromCellList(                                 &
#endif
                                      Petsc_Comm_World,ndim,num_cells, &
                                      num_nodes,num_nodes_per_cell,    &
                                      interpolate,dmplex_cells,ndim,   &  !use Petsc_True to create intermediate mesh entities (faces, edges),
                                      dmplex_verts,dmda_flow%da,ierr)     !not work for prism for the current 3.8 version.
        CHKERRQ(ierr)

        !c Method 2: create DMPlex from Gmsh file
        !call DMPlexCreateGmshFromFile(Petsc_Comm_World,"stripf.msh",   &
        !                              interpolate, dmda_flow%da, ierr)
        !CHKERRQ(ierr)

        !if (b_enable_output .and. rank == 0) then
        !  write(*,'(a)') "--> DMPlex create from cell list, done."
        !end if

        call DMGetCoordinateDM(dmda_flow%da,cda,ierr)
        CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 10)  
        call DMGetSection(cda,cs,ierr)
        CHKERRQ(ierr)
#else
        call DMGetDefaultSection(cda,cs,ierr)
        CHKERRQ(ierr)
#endif

        call PetscSectionGetChart(cs,istart,iend,ierr)
        CHKERRQ(ierr)

        !c this part is time consuming for large dataset, output progress bar.

        !c add local to global cell id mapping
        !iprogress = istart/10
        !if (b_enable_output .and. rank == 0) then
        !  write(*,'(a,1x)',advance="no") "--> Map local to global cell id:"
        !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
        if (num_cells_gbl > i1k) then
          do ibit = 1, 32
            write(strtemp,'(i2)') ibit
            call DMCreateLabel(dmda_flow%da,"cid_lg2g"//trim(adjustl(strtemp)),&
                               ierr)
            CHKERRQ(ierr)

            call DMGetLabel(dmda_flow%da,"cid_lg2g"//trim(adjustl(strtemp)),   &
                            label_cid_lg2g(ibit), ierr)
            CHKERRQ(ierr)
          end do
        else
          call DMCreateLabel(dmda_flow%da,"cid_lg2g",ierr)
          CHKERRQ(ierr)

          call DMGetLabel(dmda_flow%da,"cid_lg2g",label_cid_lg2g(1), ierr)
          CHKERRQ(ierr)
        end if
#endif

        do ipoint = 0, istart-1

          !if (b_enable_output .and. rank == 0) then
          !  if (mod(ipoint,iprogress) == 0 .or. ipoint == istart-1) then
          !    write(*,'(f3.1,1x)',advance="no") (ipoint+1.0)/istart
          !  end if
          !end if

          icell = ipoint + 1

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          !c note: set label value with large number of different keys could take
          !c a lot of time. For large number of labels (e.g., > 1000) with different keys,
          !c the node index is converted to a 32-bit data and use 0 or 1 as the keys
          if (num_cells_gbl > i1k) then
            do ibit = 1, 32
              call DMLabelSetValue(label_cid_lg2g(ibit),ipoint,ibits(icell,ibit-1,1),ierr)
            end do
          else
            call DMLabelSetValue(label_cid_lg2g(1),ipoint,icell,ierr)
          end if
          CHKERRQ(ierr)
#endif
        end do

        !if (b_enable_output .and. rank == 0) then
        !  write(*,'(/,a)') "--> Map local to global cell id, done."
        !end if

        !c add local to global vertex id mapping
        !iprogress = (iend-istart)/10
        !if (b_enable_output .and. rank == 0) then
        !  write(*,'(a,1x)',advance="no") "--> Map local to global node id:"
        !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
        if (num_nodes_gbl > i1k) then
          do ibit = 1, 32
            write(strtemp,'(i2)') ibit
            call DMCreateLabel(dmda_flow%da,"vid_lg2g"//trim(adjustl(strtemp)),&
                               ierr)
            CHKERRQ(ierr)

            call DMGetLabel(dmda_flow%da,"vid_lg2g"//trim(adjustl(strtemp)),   &
                            label_vid_lg2g(ibit), ierr)
            CHKERRQ(ierr)
          end do
        else
          call DMCreateLabel(dmda_flow%da,"vid_lg2g",ierr)
          CHKERRQ(ierr)

          call DMGetLabel(dmda_flow%da,"vid_lg2g",label_vid_lg2g(1), ierr)
          CHKERRQ(ierr)
        end if
#endif

        do ipoint = istart, iend-1

          !if (b_enable_output .and. rank == 0) then
          !  if (mod(ipoint,iprogress) == 0 .or. ipoint == iend-1) then
          !    write(*,'(f3.1,1x)',advance="no") (ipoint-istart+1.0)/(iend-istart)
          !  end if
          !end if

          inode = ipoint-istart+1

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          !c note: set label value with large number of different keys could take
          !c a lot of time. For large number of labels (e.g., > 1000) with different keys,
          !c the node index is converted to a 32-bit data and use 0 or 1 as the keys
          if (num_nodes_gbl > i1k) then
            do ibit = 1, 32
              call DMLabelSetValue(label_vid_lg2g(ibit),ipoint,ibits(inode,ibit-1,1),ierr)
            end do
          else
            call DMLabelSetValue(label_vid_lg2g(1),ipoint,inode,ierr)
          end if
          CHKERRQ(ierr)
#endif
        end do

        !if (b_enable_output .and. rank == 0) then
        !  write(*,'(/,a)') "--> Map local to global vertex id, done."
        !end if

        !c add cell material id mapping
        if (b_use_cell_matids) then
          !iprogress = istart/10
          !if (b_enable_output .and. rank == 0) then
          !  write(*,'(a,1x)',advance="no") "--> Map cell material id:"
          !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          call DMCreateLabel(dmda_flow%da,"cell_matids",ierr)
          CHKERRQ(ierr)

          call DMGetLabel(dmda_flow%da,"cell_matids",label_cell_matids, ierr)
          CHKERRQ(ierr)
#endif

          do ipoint = 0, istart-1

            icell = ipoint+1

            !if (b_enable_output .and. rank == 0) then
            !  if (mod(ipoint,iprogress) == 0 .or. ipoint == istart-1) then
            !    write(*,'(f3.1,1x)',advance="no") icell*1.0/istart
            !  end if
            !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
            call DMLabelSetValue(label_cell_matids,ipoint,             &
                                 cell_matids(icell),ierr)
#else
            call DMPlexSetLabelValue(dmda_flow%da,"cell_matids",       &
                                     ipoint,cell_matids(icell),ierr)
#endif
            CHKERRQ(ierr)
          end do

          !if (b_enable_output .and. rank == 0) then
          !  write(*,'(/,a)') "--> Map cell material id, done."
          !end if
        end if

        !c add layered cells mapping, only work for layered prism and hexahedral mesh
        if (num_cell_layers > 0) then
          !iprogress = (iend-istart)/10
          !if (b_enable_output .and. rank == 0) then
          !  write(*,'(a,1x)',advance="no") "--> Map layered cell id:"
          !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          if (num_cells_gbl > i1k) then
            do ibit = 1, 32
              write(strtemp,'(i2)') ibit
              call DMCreateLabel(dmda_flow%da,"layer_cellids"//        &
                                 trim(adjustl(strtemp)),ierr)
              CHKERRQ(ierr)

              call DMGetLabel(dmda_flow%da,"layer_cellids"//           &
                              trim(adjustl(strtemp)),                  &
                              label_lcid_lg2g(ibit), ierr)
              CHKERRQ(ierr)
            end do
          else
            call DMCreateLabel(dmda_flow%da,'layer_cellids',ierr)
            CHKERRQ(ierr)

            call DMGetLabel(dmda_flow%da,'layer_cellids',              &
                            label_lcid_lg2g(1), ierr)
            CHKERRQ(ierr)
          end if
#endif

          do ipoint = 0, istart-1

            !if (b_enable_output .and. rank == 0) then
            !  if (mod(ipoint,iprogress) == 0 .or. ipoint == iend-1) then
            !    write(*,'(f3.1,1x)',advance="no") icell*1.0/(iend-istart)
            !  end if
            !end if

            icell = ipoint+1

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
            !c note: set label value with large number of different keys could take
            !c a lot of time. For large number of labels (e.g., > 1000) with different keys,
            !c the cell index is converted to a 32-bit data and use 0 or 1 as the keys
            if (num_cells_gbl > i1k) then
              do ibit = 1, 32
                call DMLabelSetValue(label_lcid_lg2g(ibit),ipoint,     &
                       ibits(cell_to_layer_cell(icell),ibit-1,1),ierr)
              end do
            else
              call DMLabelSetValue(label_lcid_lg2g(1),ipoint,          &
                     cell_to_layer_cell(icell),ierr)
            end if
            CHKERRQ(ierr)
#endif
          end do
        end if  !layered cell mapping        

        !c add node material id mapping
        if (b_use_node_matids) then

          !iprogress = (iend-istart)/10
          !if (b_enable_output .and. rank == 0) then
          !  write(*,'(a,1x)',advance="no") "--> Map node material id:"
          !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          call DMCreateLabel(dmda_flow%da,"node_matids",ierr)
          CHKERRQ(ierr)

          call DMGetLabel(dmda_flow%da,"node_matids",                  &
                          label_node_matids, ierr)
          CHKERRQ(ierr)
#endif

          do ipoint = istart, iend-1

            inode = ipoint-istart+1

            !if (b_enable_output .and. rank == 0) then
            !  if (mod(ipoint,iprogress) == 0 .or. ipoint == iend-1) then
            !    write(*,'(f3.1,1x)',advance="no") inode*1.0/(iend-istart)
            !  end if
            !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
            call DMLabelSetValue(label_node_matids,ipoint,             &
                                 node_matids(inode),ierr)
#else
            call DMPlexSetLabelValue(dmda_flow%da,"node_matids",       &
                                     ipoint,node_matids(inode),ierr)
#endif
            CHKERRQ(ierr)
          end do

          !if (b_enable_output .and. rank == 0) then
          !  write(*,'(/,a)') "--> Map node material id, done."
          !end if
        end if

        !c add layered nodes mapping, only work for layered prism and hexahedral mesh
        if (num_node_layers > 0) then
          !iprogress = (iend-istart)/10
          !if (b_enable_output .and. rank == 0) then
          !  write(*,'(a,1x)',advance="no") "--> Map layered node id:"
          !end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          if (num_nodes_gbl > i1k) then
            do ibit = 1, 32
              write(strtemp,'(i2)') ibit
              call DMCreateLabel(dmda_flow%da,"layer_nodeids"//        &
                                 trim(adjustl(strtemp)),ierr)
              CHKERRQ(ierr)

              call DMGetLabel(dmda_flow%da,"layer_nodeids"//           &
                              trim(adjustl(strtemp)),                  &
                              label_lvid_lg2g(ibit), ierr)
              CHKERRQ(ierr)
            end do
          else
            call DMCreateLabel(dmda_flow%da,'layer_nodeids',ierr)
            CHKERRQ(ierr)

            call DMGetLabel(dmda_flow%da,'layer_nodeids',              &
                            label_lvid_lg2g(1), ierr)
            CHKERRQ(ierr)
          end if
#endif

          do ipoint = istart, iend-1

            !if (b_enable_output .and. rank == 0) then
            !  if (mod(ipoint,iprogress) == 0 .or. ipoint == iend-1) then
            !    write(*,'(f3.1,1x)',advance="no") inode*1.0/(iend-istart)
            !  end if
            !end if

            inode = ipoint-istart+1

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
            !c note: set label value with large number of different keys could take
            !c a lot of time. For large number of labels (e.g., > 1000) with different keys,
            !c the node index is converted to a 32-bit data and use 0 or 1 as the keys
            if (num_nodes_gbl > i1k) then
              do ibit = 1, 32
                call DMLabelSetValue(label_lvid_lg2g(ibit),ipoint,     &
                       ibits(node_to_layer_node(inode),ibit-1,1),ierr)
              end do
            else
              call DMLabelSetValue(label_lvid_lg2g(1),ipoint,          &
                     node_to_layer_node(inode),ierr)
            end if
            CHKERRQ(ierr)
#endif
          end do
        end if  !layered node mapping

        call memory_monitor(-sizeof(dmplex_cells),'dmplex_cells',.false.)
        call memory_monitor(-sizeof(dmplex_verts),'dmplex_verts',.false.)
        deallocate(dmplex_cells)
        deallocate(dmplex_verts)
      else
        !c allocate dmplex_cells and dmplex_verts to avoid null space error in debug mode
        allocate(dmplex_cells(1), stat = ierr)
        call checkerr(ierr,'dmplex_cells',ilog)
        call memory_monitor(sizeof(dmplex_cells),'dmplex_cells',.false.)

        allocate(dmplex_verts(1), stat = ierr)
        call checkerr(ierr,'dmplex_verts',ilog)
        call memory_monitor(sizeof(dmplex_verts),'dmplex_verts',.false.)        

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 17)
        call DMPlexCreateFromCellListPetsc(                            &
#else
        call DMPlexCreateFromCellList(                                 &
#endif
                                      Petsc_Comm_World,ndim,0,0,       &
                                      num_nodes_per_cell,              &
                                      interpolate,dmplex_cells,ndim,   &  !use Petsc_True to create intermediate mesh entities (faces, edges),
                                      dmplex_verts,dmda_flow%da,ierr)     !not work for prism for the current 3.8 version.
        CHKERRQ(ierr)

        call memory_monitor(-sizeof(dmplex_cells),'dmplex_cells',.false.)
        call memory_monitor(-sizeof(dmplex_verts),'dmplex_verts',.false.)
        deallocate(dmplex_cells)
        deallocate(dmplex_verts)
      end if

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Create DMPlex from cell list, done"
      end if

      !c set partitioner if specified
#if (PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR >= 11)
      if (trim(partitioner_type) == "chaco" .or.                       &
          trim(partitioner_type) == "parmetis" .or.                    &
          trim(partitioner_type) == "ptscotch" .or.                    &
          trim(partitioner_type) == "shell" .or.                       &
          trim(partitioner_type) == "simple" .or.                      &
          trim(partitioner_type) == "gather") then

        call DMPlexGetPartitioner(dmda_flow%da,part,ierr)
        CHKERRQ(ierr)

        !Unknown reference for PETSc3.10.2 and earlier even though the function is there
        call PetscPartitionerSetType(part,trim(partitioner_type),ierr)
        CHKERRQ(ierr)
      else
        call DMPlexGetPartitioner(dmda_flow%da,part,ierr)
        CHKERRQ(ierr)

        call PetscPartitionerSetFromOptions(part,ierr)
        CHKERRQ(ierr)
      end if
#endif

      !c distribute mesh over processes
      call DMPlexDistribute(dmda_flow%da,stencil_width,                &
      !c DMPlexDistribute() SF argument need not be output (PETSC_NULL_SF),
      !c Fortran compilers generate an error when passing a constant to an output parameter,
      !c bug existed in V3.11.0 (PETSC_VERSION_SUBMINOR=0), bug was fixed in V3.11.1 (PETSC_VERSION_SUBMINOR=1)
#if (PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR == 11 && PETSC_VERSION_SUBMINOR == 0)
                            dummy_sf,                                  &
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                            PETSC_NULL_SF,                             &
#else
                            PETSC_NULL_OBJECT,                         &
#endif
                            distributedMesh,ierr)
      CHKERRQ(ierr)

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Distribute DMPlex from cell list, done"
      end if

      !c destroy original global mesh after distribution
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      if (distributedMesh /= PETSC_NULL_DM) then
#else
      if (distributedMesh /= PETSC_NULL_OBJECT) then
#endif
        call DMDestroy(dmda_flow%da,ierr)
        CHKERRQ(ierr)
        !c set the global mesh as distributed mesh
        dmda_flow%da = distributedMesh

        !do not destroy the parallel dm, this will free other objects
        !call DMDestroy(distributedMesh,ierr)
        !CHKERRQ(ierr)
      end if

#endif

    end subroutine solver_dd_create_dmplex

    !c set global and local node index map
    subroutine solver_dd_mapping_set_dmplex
#ifdef USG

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscdmplex.h>
#include <petsc/finclude/petscvec.h>
      use petscdmplex
      use petscvec
#endif
      use geometry_definition
      use phys, only : is_cell_based_perm_cond
      use gen, only : ilog, idbg, nprcs, rank, str_rank,               &
                      b_enable_output, prefix, l_prfx,                 &
                      mem_cur, mem_max, memory_monitor,                &
                      node_idx_g2lg, cell_idx_g2lg,                    &
                      node_idx_lg2l, node_idx_lg2g, node_idx_lg2pg,    &
                      node_idx_l2lg, cell_idx_lg2g, node_idx_vel_lg2g
      use m_heat_transport, only : heat_transport, decoupled_type_vs_heat
      use usg_mesh_data, only : num_nodes, num_cells, nodes, cells,    &
                                num_nodes_per_cell, cell_projection,   &
                                num_cells_rank, num_nodes,             &
                                num_nodes_with_ghost_rank,             &
                                num_nodes_with_ghost_gbl,              &
                                offset_nodes, offset_cells,            &
                                offset_nodes_with_ghost,               &
                                num_nodes_gbl, num_nodes_loc,          &
                                num_cells_gbl, num_cells_loc,          &
                                num_ghost_nodes_gbl,                   &
                                num_ghost_cells_gbl,                   &
                                num_node_layers, node_to_layer_node,   &
                                num_cell_layers, cell_to_layer_cell,   &
                                b_use_node_matids, node_matids,        &
                                b_use_cell_matids, cell_matids,        &
                                write_mesh_data_vtk_ascii,             &
                                write_mesh_data_vtk_ascii_matids
      use file_unit, only : lun_get, lun_free

      use petsc_mpi_common, only : petsc_mpi_finalize

      implicit none

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#include <petsc/finclude/petscdmdef.h>
#include <petsc/finclude/petscdm.h>
#include <petsc/finclude/petscdmda.h>
#include <petsc/finclude/petscdmda.h90>
#include <petsc/finclude/petscdmplex.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#include <finclude/petscdmdef.h>
#include <finclude/petscdm.h>
#include <finclude/petscdmda.h>
#include <finclude/petscdmda.h90>
#include <finclude/petscdmplex.h>
#endif

      !c local variables
      integer :: icell, inode, inode_loc, ivtex, icnt, ifile,          &
                 ibit, ibitvalue, num_tmp, info_debug
      character(2) :: strtemp
      character(256) :: strtitle
      PetscInt :: ipoint, istart, iend, ivalue, irank, itmp,           &
                  icl, pstart, pend, ndim
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
      type(tDM) :: distributedMesh, cda
#else
      DM :: distributedMesh, cda
#endif
      Vec :: gc, vec_global, vec_natural, vec_natural_loc
      IS :: globalvtx
      PetscScalar, pointer :: coords(:)
      PetscScalar, pointer :: vecpointer(:), vec_tmp_pointer(:)
      PetscSection ::  cs
      PetscViewer :: viewer
      PetscErrorCode :: ierr
      PetscSF :: sf
      PetscInt :: nroots,nleaves,nconesize,idof,dof,off
      PetscInt, pointer :: array(:)
      PetscInt, pointer :: gmine(:)
      PetscInt, pointer :: cone(:)
      PetscInt, pointer :: nClosure(:)
!c PetscSFNode is used in PETSc-dev (3.8+) version or PETSc-3.9.0 above version
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
      type(PetscSFNode), pointer :: gremote(:)
#endif

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR <= 4)
      PetscInt, pointer :: idx(:)
#else
      ISLocalToGlobalMapping :: ltogm
      PetscInt :: ltog(1)
      PetscOffset :: idltog
#endif

      integer, parameter :: i1k = 1000

      external :: checkerr

      info_debug = 0

      ndim = dmda_flow%dim

      !c get local mesh DM and set coordinates

      call DMGetCoordinatesLocal(dmda_flow%da,gc,ierr)
      CHKERRQ(ierr)

      call DMGetCoordinateDM(dmda_flow%da,cda,ierr)
      CHKERRQ(ierr)

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 10)  
      call DMGetSection(cda,cs,ierr)
      CHKERRQ(ierr)
#else
      call DMGetDefaultSection(cda,cs,ierr)
      CHKERRQ(ierr)
#endif

      call PetscSectionGetChart(cs,istart,iend,ierr)
      CHKERRQ(ierr)

      !c set local number of nodes and cells
      num_nodes = iend-istart
      num_cells = istart

      allocate(node_idx_g2lg(num_nodes_gbl), stat = ierr)
      call checkerr(ierr,'node_idx_g2lg',ilog)
      node_idx_g2lg = 0
      call memory_monitor(sizeof(node_idx_g2lg),'node_idx_g2lg',.true.)

      !c allocate memory space for local node and global node mapping
      if (allocated(nodes)) then
        call memory_monitor(-sizeof(nodes),'nodes',.false.)
        deallocate(nodes)
      end if
      allocate(nodes(num_nodes), stat = ierr)
      call checkerr(ierr,'nodes',ilog)
      call memory_monitor(sizeof(nodes),'nodes',.true.)

      allocate(node_idx_lg2g(num_nodes), stat = ierr)
      call checkerr(ierr,'node_idx_lg2g',ilog)
      node_idx_lg2g = 0
      call memory_monitor(sizeof(node_idx_lg2g),'node_idx_lg2g',.true.)

      allocate(node_idx_lg2l(num_nodes), stat = ierr)
      call checkerr(ierr,'node_idx_lg2l',ilog)
      node_idx_lg2l = 0
      call memory_monitor(sizeof(node_idx_lg2l),'node_idx_lg2l',.true.)

      allocate(node_idx_lg2pg(num_nodes), stat = ierr)
      call checkerr(ierr,'node_idx_lg2pg',ilog)
      node_idx_lg2pg = 0
      call memory_monitor(sizeof(node_idx_lg2pg),'node_idx_lg2pg',.true.)

      !allocate(node_idx_lb2pg(num_nodes), stat = ierr)
      !call checkerr(ierr,'node_idx_lb2pg',ilog)
      !node_idx_lb2pg = -1

      !c get coordinates array
      call VecGetArrayF90(gc,coords,ierr)
      CHKERRQ(ierr)

      do ipoint = istart, iend-1

        call PetscSectionGetDof(cs,ipoint,dof,ierr)
        CHKERRQ(ierr)

        call PetscSectionGetOffset(cs,ipoint,off,ierr)
        CHKERRQ(ierr)

        inode = ipoint-istart+1

        if (cell_projection == projection_xyz) then
          nodes(inode)%x = coords(off+1)
          nodes(inode)%y = coords(off+2)
          nodes(inode)%z = coords(off+3)
        else if (cell_projection == projection_xy) then
          nodes(inode)%x = coords(off+1)
          nodes(inode)%y = coords(off+2)
          nodes(inode)%z = 0.0d0
        else if (cell_projection == projection_yz) then
          nodes(inode)%x = 0.0d0
          nodes(inode)%y = coords(off+1)
          nodes(inode)%z = coords(off+2)
        else if (cell_projection == projection_xz) then
          nodes(inode)%x = coords(off+1)
          nodes(inode)%y = 0.0d0
          nodes(inode)%z = coords(off+2)
        end if

      end do

      call VecRestoreArrayF90(gc,coords,ierr)
      CHKERRQ(ierr)

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Set DMPlex nodes coordinates, done"
      end if
      
      !c add local to global vertex id mapping for marked nodes
      do ipoint = istart, iend-1
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
        if (num_nodes_gbl > i1k) then
          ivalue = 0
          do ibit = 1, 32
            write(strtemp,'(i2)') ibit
            call DMGetLabelValue(dmda_flow%da,"vid_lg2g"//trim(adjustl(strtemp)),&
                                 ipoint,ibitvalue,ierr)
            if (ibitvalue > 0) then
              ivalue = ibset(ivalue,ibit-1)
            end if
          end do
        else
          call DMGetLabelValue(dmda_flow%da,"vid_lg2g",ipoint,ivalue,ierr)
        end if
#endif
        CHKERRQ(ierr)
        inode = ipoint-istart+1
        if (ivalue > 0) then
          node_idx_lg2g(inode) = ivalue
          node_idx_g2lg(ivalue) = inode
        end if
      end do

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Set DMPlex boundary node label, done"
      end if

      !c set local mesh and global mesh mapping
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 10)
      call DMGetGlobalSection(cda,cs,ierr)
      CHKERRQ(ierr)
#else
      call DMGetDefaultGlobalSection(cda,cs,ierr)
      CHKERRQ(ierr)
#endif

      num_nodes_loc = 0

      do ipoint = istart, iend-1
        call DMPlexGetPointGlobal(cda,ipoint,pstart,pend,ierr)
        CHKERRQ(ierr)
        if (pend >= 0) then
          num_nodes_loc = num_nodes_loc + 1
        end if
      end do

      !c allocate memory space for local node and global node mapping
      allocate(node_idx_l2lg(num_nodes_loc), stat = ierr)
      call checkerr(ierr,'node_idx_l2lg',ilog)
      node_idx_l2lg = 0
      call memory_monitor(sizeof(node_idx_l2lg),'node_idx_l2lg',.true.)

      inode_loc = 0

      do ipoint = istart, iend-1
        call DMPlexGetPointGlobal(cda,ipoint,pstart,pend,ierr)
        CHKERRQ(ierr)

        inode = ipoint-istart+1
        if (pend >= 0) then
          inode_loc = inode_loc + 1
        end if

#ifdef DEBUG
        if (info_debug > 0) then
          write(idbg,'(5(a,1x,i6,1x))') "dmplex inode",inode,          &
                "inode_loc",inode_loc,"ipoint",ipoint,                 &
                "pstart",pstart,"pend",pend
        end if
#endif

        if (pend >= 0) then
          node_idx_lg2l(inode) = inode_loc
          node_idx_lg2pg(inode) = pend/ndim
          node_idx_l2lg(inode_loc) = inode
        else
          node_idx_lg2l(inode) = -1
          node_idx_lg2pg(inode) = (-pend-1)/ndim
        end if
      end do

      if (nprcs > 1) then
        if (any(node_idx_lg2l(num_nodes_loc+1:num_nodes) > 0)) then
          if (rank == 0 .and. b_enable_output) then
            write(ilog,*) "Warning: ghost nodes numbering not supported by hdf5"
            write(ilog,'(a)') "Warning: ghost nodes numbering not supported by hdf5"
          end if
        end if
      end if

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Set DMPlex local-global node mapping, done"
      end if

      !c get number of local cells b
      if (nprcs > 1) then
        call DMGetPointSF(dmda_flow%da,sf,ierr)
        CHKERRQ(ierr)

!c PetscSFNode is used in PETSc-dev (3.8+) version or PETSc-3.9.0 above version
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 9)
        call PetscSFGetGraph(sf,nroots,nleaves,gmine,gremote,ierr)
        CHKERRQ(ierr)
#endif

        !c with interpolation, edges and faces are also shared, 
        !c without interpolation, only vertices and cells are shared        
        if (interpolate) then
          num_cells_loc = num_cells
          do ipoint = 1, nleaves
            if (gmine(ipoint) < istart) then
              num_cells_loc = num_cells_loc - 1
            end if
          end do
        else
          num_cells_loc = num_cells+num_nodes-nleaves-num_nodes_loc
        end if
      else
        num_cells_loc = num_cells
      end if

      !c set number of local owned cells to each rank, make it public for all processors
      allocate(num_cells_rank(nprcs), stat = ierr)
      call checkerr(ierr,'num_cells_rank',ilog)
      num_cells_rank = 0
      call memory_monitor(sizeof(num_cells_rank),'num_cells_rank',.true.)

      call MPI_Allgather(num_cells_loc, 1, MPI_INTEGER4,               &
                         num_cells_rank, 1, MPI_INTEGER4,              &
                         Petsc_Comm_World, ierr)
      CHKERRQ(ierr)

      !c set number of nodes including ghost nodes to each rank, make it public for all processors
      allocate(num_nodes_with_ghost_rank(nprcs), stat = ierr)
      call checkerr(ierr,'num_nodes_with_ghost_rank',ilog)
      num_nodes_with_ghost_rank = 0
      call memory_monitor(sizeof(num_nodes_with_ghost_rank),           &
                          'num_nodes_with_ghost_rank',.true.)

      call MPI_Allgather(num_nodes, 1, MPI_INTEGER4,                   &
                         num_nodes_with_ghost_rank, 1, MPI_INTEGER4,   &
                         Petsc_Comm_World, ierr)
      CHKERRQ(ierr)

      !c set offset value for nodes and cells
      if (nprcs > 1) then
        offset_nodes = node_idx_lg2pg(1)-1

        offset_cells = 0
        if (rank > 0) then
          do irank = 1, rank
            offset_cells = offset_cells + num_cells_rank(irank)
          end do
        end if

        offset_nodes_with_ghost = 0
        if (rank > 0) then
          do irank = 1, rank
            offset_nodes_with_ghost = offset_nodes_with_ghost +        &
                                      num_nodes_with_ghost_rank(irank)
          end do
        end if

      else
        offset_nodes = 0
        offset_cells = 0
        offset_nodes_with_ghost = 0
      end if

      if (allocated(cells)) then
        call memory_monitor(-sizeof(cells),'cells',.false.)
        deallocate(cells)
      end if
      allocate(cells(num_nodes_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'cells',ilog)
      call memory_monitor(sizeof(cells),'cells',.true.)

      allocate(cell_idx_lg2g(num_cells), stat = ierr)
      call checkerr(ierr,'cell_idx_lg2g',ilog)
      cell_idx_lg2g = 0
      call memory_monitor(sizeof(cell_idx_lg2g),'cell_idx_lg2g',.true.)

      allocate(cell_idx_g2lg(num_cells_gbl), stat = ierr)
      call checkerr(ierr,'cell_idx_g2lg',ilog)
      cell_idx_g2lg = 0
      call memory_monitor(sizeof(cell_idx_g2lg),'cell_idx_g2lg',.true.)


      !c add local to global cell id mapping
      do ipoint = 0, istart-1

        icell = ipoint + 1

        if (interpolate) then

          call DMPlexGetTransitiveClosure(dmda_flow%da,ipoint,PETSC_TRUE,nClosure,ierr)
          CHKERRQ(ierr)

          ivtex = 0
          do icl = 1,size(nClosure),2
            if (nClosure(icl) >= istart .and. nClosure(icl) < iend) then
              ivtex = ivtex + 1
              cells(ivtex,ipoint+1) = nClosure(icl) - istart + 1
            end if
          end do
          call DMPlexRestoreTransitiveClosure(dmda_flow%da,ipoint,PETSC_TRUE,nClosure,ierr)
          CHKERRQ(ierr)

        else
          call DMPlexGetCone(dmda_flow%da,ipoint,cone,ierr)
          CHKERRQ(ierr)

          do ivtex = 1, num_nodes_per_cell
            cells(:,ipoint+1) = cone - istart + 1
          end do

          call DMPlexRestoreCone(dmda_flow%da,ipoint,cone,ierr)
          CHKERRQ(ierr)
        end if

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
        if (num_cells_gbl > i1k) then
          ivalue = 0
          do ibit = 1, 32
            write(strtemp,'(i2)') ibit
            call DMGetLabelValue(dmda_flow%da,"cid_lg2g"//trim(adjustl(strtemp)),&
                                 ipoint,ibitvalue,ierr)
            if (ibitvalue > 0) then
              ivalue = ibset(ivalue,ibit-1)
            end if
          end do
        else
          call DMGetLabelValue(dmda_flow%da,"cid_lg2g",ipoint,ivalue,ierr)
        end if
#endif
        CHKERRQ(ierr)

        if (ivalue > 0) then
          cell_idx_lg2g(icell) = ivalue
          cell_idx_g2lg(ivalue) = icell
        end if
      end do

      num_ghost_nodes_gbl = 0
      num_ghost_cells_gbl = 0
      num_nodes_with_ghost_gbl = 0
      if (nprcs > 1) then
        num_tmp = num_nodes - num_nodes_loc
        call MPI_Allreduce(num_tmp,num_ghost_nodes_gbl,1,MPI_INTEGER4, &
                           MPI_SUM,Petsc_Comm_World,ierr)
        CHKERRQ(ierr)

        num_tmp = num_cells - num_cells_loc
        call MPI_Allreduce(num_tmp,num_ghost_cells_gbl,1,MPI_INTEGER4, &
                           MPI_SUM,Petsc_Comm_World,ierr)
        CHKERRQ(ierr)

        call MPI_Allreduce(num_nodes,num_nodes_with_ghost_gbl,1,       &
                           MPI_INTEGER4,MPI_SUM,Petsc_Comm_World,ierr)
        CHKERRQ(ierr)

        if (rank == 0 .and. b_enable_output) then
          write(*,'(2(a,1x,i0,1x))')                                   &
                "Total number of ghost nodes / total number of nodes:",&
                num_ghost_nodes_gbl,"/",num_nodes_gbl
          write(*,'(2(a,1x,i0,1x))')                                   &
                "Total number of ghost cells / total number of cells:",&
                num_ghost_cells_gbl,"/",num_cells_gbl

          write(ilog,'(2(a,1x,i0,1x))')                                &
                "Total number of ghost nodes / total number of nodes:",&
                num_ghost_nodes_gbl,"/",num_nodes_gbl
          write(ilog,'(2(a,1x,i0,1x))')                                &
                "Total number of ghost cells / total number of cells:",&
                num_ghost_cells_gbl,"/",num_cells_gbl
        end if
      end if

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Set DMPlex local-global cell mapping, done"
      end if

      !c add cell material id mapping
      if (b_use_cell_matids) then
        if (allocated(cell_matids)) then
          call memory_monitor(-sizeof(cell_matids),'cell_matids',.false.)
          deallocate(cell_matids, stat = ierr)
          call checkerr(ierr,'cell_matids',ilog)
        end if

        allocate(cell_matids(num_cells), stat = ierr)
        call checkerr(ierr,'cell_matids',ilog)
        call memory_monitor(sizeof(cell_matids),'cell_matids',.true.)

        do ipoint = 0, istart-1
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          call DMGetLabelValue(dmda_flow%da,"cell_matids",ipoint,      &
                               cell_matids(ipoint+1),ierr)
#endif
          CHKERRQ(ierr)
        end do

        if (rank == 0 .and. b_enable_output) then
          write(*,'(a)') "Set DMPlex cell material id, done"
        end if

      end if

      !c add layered cells mapping, only work for layered prism and hexahedral mesh
      if (num_cell_layers > 0) then

        if (allocated(cell_to_layer_cell)) then
          call memory_monitor(-sizeof(cell_to_layer_cell),'cell_to_layer_cell',.false.)
          deallocate(cell_to_layer_cell, stat = ierr)
          call checkerr(ierr,'cell_to_layer_cell',ilog)
        end if

        allocate(cell_to_layer_cell(num_cells), stat = ierr)
        call checkerr(ierr,'cell_to_layer_cell',ilog)
        call memory_monitor(sizeof(cell_to_layer_cell),'cell_to_layer_cell',.true.)

        do ipoint = 0, istart-1

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          if (num_cells_gbl > i1k) then
            ivalue = 0
            do ibit = 1, 32
              write(strtemp,'(i2)') ibit
              call DMGetLabelValue(dmda_flow%da,"layer_cellids"//      &
                                   trim(adjustl(strtemp)),&
                                   ipoint,ibitvalue,ierr)
              if (ibitvalue > 0) then
                ivalue = ibset(ivalue,ibit-1)
              end if
            end do
          else
            call DMGetLabelValue(dmda_flow%da,"layer_cellids",         &
                                 ipoint,ivalue,ierr)
          end if
#endif
          CHKERRQ(ierr)
          icell = ipoint+1
          if (ivalue > 0) then
            cell_to_layer_cell(icell) = ivalue
          end if
        end do

        if (rank == 0 .and. b_enable_output) then
          write(*,'(a)') "Set DMPlex layered cell id, done"
        end if
      end if      

      !c add node material id mapping
      if (b_use_node_matids) then
        if (allocated(node_matids)) then
          call memory_monitor(-sizeof(node_matids),'node_matids',.false.)
          deallocate(node_matids, stat = ierr)
          call checkerr(ierr,'node_matids',ilog)
        end if

        allocate(node_matids(num_nodes), stat = ierr)
        call checkerr(ierr,'node_matids',ilog)
        call memory_monitor(sizeof(node_matids),'node_matids',.true.)

        do ipoint = istart, iend-1
          inode = ipoint-istart+1
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          call DMGetLabelValue(dmda_flow%da,"node_matids",ipoint,      &
                               node_matids(inode),ierr)
#endif
          CHKERRQ(ierr)
        end do

        if (rank == 0 .and. b_enable_output) then
          write(*,'(a)') "Set DMPlex node material id, done"
        end if

      end if

      !c add layered nodes mapping, only work for layered prism and hexahedral mesh
      if (num_node_layers > 0) then

        if (allocated(node_to_layer_node)) then
          call memory_monitor(-sizeof(node_to_layer_node),'node_to_layer_node',.false.)
          deallocate(node_to_layer_node, stat = ierr)
          call checkerr(ierr,'node_to_layer_node',ilog)
        end if

        allocate(node_to_layer_node(num_nodes), stat = ierr)
        call checkerr(ierr,'node_to_layer_node',ilog)
        call memory_monitor(sizeof(node_to_layer_node),'node_to_layer_node',.true.)

        do ipoint = istart, iend-1

#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 7)
          if (num_nodes_gbl > i1k) then
            ivalue = 0
            do ibit = 1, 32
              write(strtemp,'(i2)') ibit
              call DMGetLabelValue(dmda_flow%da,"layer_nodeids"//      &
                                   trim(adjustl(strtemp)),&
                                   ipoint,ibitvalue,ierr)
              if (ibitvalue > 0) then
                ivalue = ibset(ivalue,ibit-1)
              end if
            end do
          else
            call DMGetLabelValue(dmda_flow%da,"layer_nodeids",         &
                                 ipoint,ivalue,ierr)
          end if
#endif
          CHKERRQ(ierr)
          inode = ipoint-istart+1
          if (ivalue > 0) then
            node_to_layer_node(inode) = ivalue
          end if
        end do

        if (rank == 0 .and. b_enable_output) then
          write(*,'(a)') "Set DMPlex layered node id, done"
        end if
      end if

      if (rank == 0 .and. b_enable_output) then
        write(*,'(a)') "Set DMPlex local to global mapping, done"
      end if

#ifdef DEBUG
      if (info_debug > 0) then

        write(*,'(a,1x,i6,1x,2(a,1x,3(i6,1x)))') "rank",rank,          &
              "num of nodes",num_nodes_loc,num_nodes,num_nodes_gbl,    &
              "num of cells",num_cells_loc,num_cells,num_cells_gbl

        write(idbg,'(a,1x,i6,1x,2(a,1x,3(i6,1x)))') "rank",rank,       &
              "num of nodes",num_nodes_loc,num_nodes,num_nodes_gbl,    &
              "num of cells",num_cells_loc,num_cells,num_cells_gbl

        do inode = 1, num_nodes
          write(idbg,'(4(a,1x,i6,1x))') "node",inode,                  &
                "lg2l",node_idx_lg2l(inode),                           &
                "lg2g",node_idx_lg2g(inode),                           &
                "lg2pg",node_idx_lg2pg(inode)
        end do

        !c output using distributed local mesh file
        ifile = lun_get()
        strtitle = "distributed mesh data"
        open(ifile,file=prefix(:l_prfx)//'_o'//                        &
             trim(adjustl(str_rank))//'.loc.vtk',status='unknown',     &
             form='formatted')
        call write_mesh_data_vtk_ascii(ifile,trim(strtitle))
        !c output node and cell material ids
        call write_mesh_data_vtk_ascii_matids(ifile)

        close(ifile)
        call lun_free(ifile)

        !c output using PETScViewer
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
        call PetscViewerCreate(Petsc_Comm_World,viewer,ierr)
        CHKERRQ(ierr)

        call PetscViewerSetType(viewer,PETSCVIEWERVTK,ierr)
        CHKERRQ(ierr)

        call PetscViewerFileSetMode(viewer,FILE_MODE_WRITE,ierr)
        CHKERRQ(ierr)

        call PetscViewerFileSetName(viewer,prefix(:l_prfx)//'_o.vtk',ierr)
        CHKERRQ(ierr)

        call DMView(dmda_flow%da,viewer,ierr)
        CHKERRQ(ierr)

        call PetscViewerDestroy(viewer,ierr)
        CHKERRQ(ierr)
#endif

      end if
#endif

      !c copy dmda_flow mesh parameter to decoupled heat transport
      if(heat_transport .and. decoupled_type_vs_heat > 1) then
        dmda_heat = dmda_flow
      end if

      return

990   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'Error when creating DMPlex from cell list'
        write(*,*) 'SIMULATION TERMINATED'
        write(*,*) 'Error when creating DMPlex from cell list'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

#endif
    end subroutine solver_dd_mapping_set_dmplex

end module solver_dd
    
#endif
