!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/solver/solver.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!>
!> module solver
!>
!> This module includes functions reading parallel solver configuration file
!> and do solver initialization, as well as control of matrix and rhs output.
!>
!> written by:      Danyang Su
!>
!> last modified:   Danyang Su - May. 28, 2018
!>

module solver

  use gen
  use chem
  use file_unit, only : lun_get
    
#ifdef OPENMP
  use omp_lib
#endif

  implicit none

  integer*4 :: ierr
    
  external :: CheckErr



contains


!> initialize solver
subroutine initsolver(str_file_in)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
  use petscsys
#endif
#endif

#ifdef PARDISO
  use solver_pardiso, only : pardiso_initialize_common, pardiso_initialize_flow, &
      pardiso_initialize_heat, pardiso_initialize_react, numofthreads_pardiso,   &
      max_refine_itersteps_flow, max_refine_itersteps_heat,                      &
      max_refine_itersteps_react, npivotpertubation_flow,                        &
      npivotpertubation_heat, npivotpertubation_react, i_cgs_criterion_flow,     &
      i_cgs_criterion_heat, i_cgs_criterion_react
#endif

#ifdef PETSC
  use solver_snes_common, only : strKSPType_flow, rtol_flow, abstol_flow,        &
      dtol_flow, maxits_flow, strKSPType_heat, rtol_heat, abstol_heat,           &
      dtol_heat, maxits_heat, strKSPType_react, rtol_react, abstol_react,        &
      dtol_react, strKSPNormType_flow, strKSPNormType_heat,                      &
      strKSPNormType_react, maxits_react, strPCType_flow,                        &
      strKSPConvergenceType_flow, strPCType_heat, strKSPConvergenceType_heat,    &
      strPCType_react, strKSPConvergenceType_react, b_use_petsc_default_flow,    &
      b_use_petsc_default_heat, b_use_petsc_default_react,                       &
      pc_factor_shift_flow, pc_factor_shift_heat, pc_factor_shift_react,         &
      pc_factor_level_flow, pc_factor_level_heat, pc_factor_level_react,         &
      b_check_norm_flow, b_check_norm_heat, b_check_norm_react,                  &
      b_form_initial_guess_flow, b_form_initial_guess_heat,                      &
      b_form_initial_guess_react,                                                &
      b_initial_guess_nonzero_flow, b_reuse_preconditioner_flow,                 &
      b_initial_guess_nonzero_heat, b_reuse_preconditioner_heat,                 &
      b_initial_guess_nonzero_react, b_reuse_preconditioner_react,               &
      stencil_width, partitioner_type, interpolate
#endif

#ifdef LIS
  use solver_lis_common, only : lis_default_flow, lis_options_flow,            &
      lis_maxit_flow, lis_abstol_flow, lis_default_heat, lis_options_heat,     &
      lis_maxit_heat, lis_abstol_heat, lis_default_react, lis_options_react,   &
      lis_maxit_react, lis_abstol_react
                                 
#endif

  use file_utility, only : readnextline

  implicit none
    
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
    PetscErrorCode :: ierrcode
    PetscInt :: petsc_version_num_major
    PetscInt :: petsc_version_num_minor
    PetscInt :: petsc_version_num_subminor
#endif
#endif
    
    character(len=*), intent(in) :: str_file_in
    character(2048) :: str_file
    
    character(2048) :: strbuffer
    integer :: numthreads_sys, numthreads_set
    
    logical :: bstat
    integer :: istat
    integer :: i
    
#ifndef PETSC
#ifndef OPENMP
    numofthreads_global = 1
    nthreads = 1
    rank = 0
#ifndef LIS
    return
#endif
#endif
#endif

#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
    call PetscGetVersionNumber(petsc_version_num_major,                &
                               petsc_version_num_minor,                &
                               petsc_version_num_subminor,             &
                               PETSC_NULL_INTEGER,ierrcode)
#endif
#endif
    
    bstat = .false.
    !isolvercfg = 81
    isolvercfg = lun_get()
    
    if(trim(adjustl(str_solvercfg)) /= "") then
      str_file = trim(adjustl(str_file_in))
      inquire(file = trim(adjustl(str_file)), exist = bstat)
      if (bstat) then
        goto 100
      end if
    end if
    
! The following solver.cfg path is for benchmarking test.        
#ifdef SOLVER_CFG_LOCAL        
    str_file = "solver.cfg"
    inquire(file = trim(adjustl(str_file)), exist = bstat)
    if (bstat) then
      goto 100
    end if
#endif

#ifdef SOLVER_CFG_BENCHMARK
    !str_file = "D:\dsu\ResearchAtUBC\Benchmarking\benchmarking_min3p_thcm_p_ws209\solver.cfg"
    !str_file = "D:\dsu\ResearchAtUBC\Benchmarking\benchmarking_min3p_thcm_p_pardiso\solver.cfg"
    str_file = "D:\dsu\Benchmarks\RunAndCheck_min3p_thcm_p_ws209\solver.cfg"
    inquire(file = trim(adjustl(str_file)), exist = bstat)
    if (bstat) then
      goto 100
    end if
#endif

100 continue

    if (bstat) then
        
      !Read from configuration file
      if (rank == 0 .and. b_enable_output) then
        write(ilog,'(72a)') ('*', i = 1, 72)
        write(ilog,'(2a)') 'solver configuration'
        write(ilog,'(72a/)') ('*', i = 1, 72)
        write(ilog,'(2a)') "Reading solver configuration from ",       &
              trim(adjustl(str_file))

#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 11)
        write(ilog,'(a,2(i0,a1),i0)') "PETSc version: V",              &
              petsc_version_num_major,".",                             &
              petsc_version_num_minor,".",                             &
              petsc_version_num_subminor
#endif
        write(ilog,'(a,i6)') "Number of processors used by MPI:  ", nprcs
#endif
      end if
        
      open(isolvercfg, file = trim(adjustl(str_file)), iostat = istat)
        
      if (istat /= 0) then
        if (rank == 0 .and. b_enable_output) then
          write(ilog,'(2a)') "Error in opening file: ", trim(adjustl(str_file))
        end if
        return
      else

#ifdef PETSC
        b_use_petsc_default_flow = .false.
        b_use_petsc_default_heat = .false.
        b_use_petsc_default_react = .false.
#endif

#ifdef LIS
        lis_default_flow = .false.
        lis_default_heat = .false.
        lis_default_react = .false.
#endif

        do while(readnextline(isolvercfg, strbuffer))

          select case (trim(strbuffer))
            ! Block:  Golbal solver setting
            case ("global: use min3p input parameters first")
              b_min3p_input_param_first = .true.

            case ("solver type")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_solver_type
#ifdef PETSC
                if (nprcs > 1 .and. i_solver_type < 2) then
                  i_solver_type = 2
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Solver type is forced to : ", i_solver_type
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Solver type is : ", i_solver_type
                  end if
                end if
#elif LIS
                if (nprcs > 1 .and. i_solver_type < 3) then
                  i_solver_type = 3
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Solver type is forced to : ", i_solver_type
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Solver type is : ", i_solver_type
                  end if
                end if
#else
                if (i_solver_type > 0) then
                  i_solver_type = 0
                end if
                if(rank == 0) then
                  write(ilog,'(a,i6)') "Solver type is forced to: ", i_solver_type
                end if
#endif

#ifndef PETSC
                if (i_solver_type == 2) then
                  i_solver_type = 0
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "PETSc is not found, ",  &
                          "solver type is reforced to: ",          &
                          i_solver_type
                  end if
                end if
#endif

#ifndef LIS
                if (i_solver_type == 3) then
#ifdef PETSC
                  i_solver_type = 2
#else
                  i_solver_type = 0
#endif
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "LIS is missing, ",      &
                          "solver type is forced to: ",            &
                          i_solver_type
                  end if
                end if
#endif

                i_solver_type_flow = i_solver_type
                i_solver_type_heat = i_solver_type
                i_solver_type_react = i_solver_type
                !write(i_solver_type,'(a)') trim(strbuffer)
              end if
                        
            case ("solver type flow")

              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_solver_type_flow
#ifdef PETSC
                if (nprcs > 1 .and. i_solver_type_flow < 2) then
                  i_solver_type_flow = 2
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Flow solver type is forced to: ", i_solver_type_flow
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Flow solver type is: ", i_solver_type_flow
                  end if
                end if
#elif LIS
                if (nprcs > 1 .and. i_solver_type_flow < 3) then
                  i_solver_type_flow = 3
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Flow solver type is forced to: ", i_solver_type_flow
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Flow solver type is: ", i_solver_type_flow
                  end if
                end if

#else
                if (i_solver_type_flow > 0) then
                  i_solver_type_flow = 0
                end if
                if(rank == 0) then
                  write(ilog,'(a,i6)') "Flow solver type is forced to: ", i_solver_type_flow
                end if
#endif

#ifndef PETSC
                if (i_solver_type_flow == 2) then
                  i_solver_type_flow = 0
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "PETSc is not found, ",  &
                          "flow solver type is reforced to: ",     &
                          i_solver_type_flow
                  end if
                end if
#endif

#ifndef LIS
                if (i_solver_type_flow == 3) then
#ifdef PETSC
                  i_solver_type_flow = 2
#else
                  i_solver_type_flow = 0
#endif
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "LIS is missing, ",      &
                          "flow solver type is forced to: ",       &
                          i_solver_type_flow
                  end if
                end if
#endif

              end if

            case ("solver type heat transport")

              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_solver_type_heat
#ifdef PETSC
                if (nprcs > 1 .and. i_solver_type_heat < 2) then
                  i_solver_type_heat = 2
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Heat solver type is forced to: ",    &
                         i_solver_type_heat
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Heat solver type is: ", i_solver_type_heat
                  end if
                end if
#elif LIS
                if (nprcs > 1 .and. i_solver_type_heat < 3) then
                  i_solver_type_heat = 3
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Heat solver type is forced to: ",    &
                          i_solver_type_heat
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Heat solver type is: ", i_solver_type_heat
                  end if
                end if

#else
                if (i_solver_type_heat > 0) then
                  i_solver_type_heat = 0
                end if
                if(rank == 0) then
                  write(ilog,'(a,i6)') "Heat solver type is forced to: ",      &
                        i_solver_type_heat
                end if
#endif

#ifndef PETSC
                if (i_solver_type_heat == 2) then
                  i_solver_type_heat = 0
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "PETSc is not found, ",  &
                          "heat solver type is reforced to: ",     &
                          i_solver_type_heat
                  end if
                end if
#endif

#ifndef LIS
                if (i_solver_type_heat == 3) then
#ifdef PETSC
                  i_solver_type_heat = 2
#else
                  i_solver_type_heat = 0
#endif
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "LIS is missing, ",      &
                          "heat solver type is forced to: ",       &
                          i_solver_type_heat
                  end if
                end if
#endif

              end if
                        
            case ("solver type reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_solver_type_react
#ifdef PETSC
                if (nprcs > 1 .and. i_solver_type_react < 2) then
                  i_solver_type_react = 2
                  if(rank == 0) then
                    write(ilog,'(a,i6)')                                       &
                          "Reactive transport solver type is forced to: ",     &
                          i_solver_type_react
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)')                                       &
                          "Reactive transport solver type is: ",               &
                          i_solver_type_react
                  end if
                end if
#elif LIS
                if (nprcs > 1 .and. i_solver_type_react < 3) then
                  i_solver_type_react = 3
                  if(rank == 0) then
                    write(ilog,'(a,i6)')                                       &
                          "Reactive transport solver type is forced to: ",     &
                          i_solver_type_react
                  end if
                else
                  if(rank == 0) then
                    write(ilog,'(a,i6)')                                       &
                          "Reactive transport solver type is: ",               &
                          i_solver_type_react
                  end if
                end if

#else
                if (i_solver_type_react > 0) then
                  i_solver_type_react = 0
                end if
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Reactive transport solver type is forced to: ",       &
                        i_solver_type_react
                end if
#endif

#ifndef PETSC
                if (i_solver_type_react == 2) then
                  i_solver_type_react = 0
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "PETSc is not found, ",              &
                          "reactive transport solver type is reforced to: ",   &
                          i_solver_type_react
                  end if
                end if
#endif

#ifndef LIS
                if (i_solver_type_react == 3) then
#ifdef PETSC
                  i_solver_type_react = 2
#else
                  i_solver_type_react = 0
#endif
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "LIS is missing, ",                  &
                          "reactive transport flow solver type is forced to: ",&
                          i_solver_type_react
                  end if
                end if
#endif
              end if
                        
#ifdef OPENMP                        
            case ("global: use number of threads from mpi")
#ifdef PETSC
              b_use_mpi_nprcs_omp_nthreads = .true.
              numofthreads_global = nthreads_per_proc

              if(rank == 0) then
                write(ilog,'(a,i6)')                                           &
                      "global number of threads will be reset by mpi calling ",&
                      nthreads_per_proc
              end if
#endif
                        
                        
            case ("global: number of threads")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofthreads_global
                if(rank == 0) then
                  write(ilog,'(a,i6)') "global number of threads: ",           &
                                       numofthreads_global
                end if
#ifdef PARDISO
                numofthreads_pardiso = numofthreads_global
#endif
                numofthreads_matrix_flow = numofthreads_global
                numofthreads_matrix_heat = numofthreads_global
                numofthreads_matrix_react = numofthreads_global
                numofthreads_ws209 = numofthreads_global
                numofloops_thred_global = numofthreads_global

              end if

            case ("global: number of loops threshold")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_global
                if(rank == 0) then
                  write(ilog,'(a,i6)') "global number of loops threshold: ",   &
                                       numofloops_thred_global
                end if
              end if
                            
            ! Block:  Matrix assembly setting for flow problem
            case ("matrix assembly: type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_matrix_assembly_type_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)') "Type of matrix assembly in flow is: ", &
                                  i_matrix_assembly_type_flow
                end if
              end if

            case ("matrix assembly: number of threads in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofthreads_matrix_flow
#ifdef PETSC
                if(b_use_mpi_nprcs_omp_nthreads) then
                  numofthreads_matrix_flow = nthreads_per_proc
                end if
#endif
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Number of threads for matrix assembly in flow is: ",  &
                        numofthreads_matrix_flow
                end if
              end if
                        
            case ("matrix assembly: schedule type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_schedule_type_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Schedule type in matrix assembly in flow is: ",       &
                        i_schedule_type_flow
                end if
              end if

            case ("matrix assembly: chunk size factor in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_chunksize_factor_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Chunk size factor for matrix assembly in flow is: ",  &
                        i_chunksize_factor_flow
                end if
              end if


            ! Block:  Matrix assembly setting for heat transport problem
            case ("matrix assembly: type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_matrix_assembly_type_heat
                if(rank == 0) then
                  write(ilog,'(2a,i6)') "Type of matrix assembly in ",         &
                        "heat transport is: ",i_matrix_assembly_type_heat
                end if
              end if

            case ("matrix assembly: number of threads in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofthreads_matrix_heat
#ifdef PETSC
                if(b_use_mpi_nprcs_omp_nthreads) then
                  numofthreads_matrix_heat = nthreads_per_proc
                end if
#endif
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "Number of threads for matrix assembly in ",           &
                        "heat transport is: ",numofthreads_matrix_heat
                end if
              end if
                        
            case ("matrix assembly: schedule type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_schedule_type_heat
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "Schedule type in matrix assembly in ",                &
                        "heat transport is: ",i_schedule_type_heat
                end if
              end if

            case ("matrix assembly: chunk size factor in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_chunksize_factor_heat
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "Chunk size factor for matrix assembly in ",           &
                        "heat transport is: ",i_chunksize_factor_heat
                end if
              end if

            ! Block:  Matrix assembly setting for reactive transport problem  
            case ("matrix assembly: type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_matrix_assembly_type_react
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Type of matrix assembly in reactive transport is: ",  &
                        i_matrix_assembly_type_react
                end if
                i_matrix_assembly_type_jacrt = i_matrix_assembly_type_react
                i_matrix_assembly_type_jacbrt = i_matrix_assembly_type_react
              end if
                        
            case ("matrix assembly: type in reactive transport jacrt")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_matrix_assembly_type_jacrt
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                   "Type of matrix assembly in reactive transport jacrt is: ", &
                   i_matrix_assembly_type_jacrt
                end if
              end if

            case ("matrix assembly: type in reactive transport jacbrt")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_matrix_assembly_type_jacbrt
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                   "Type of matrix assembly in reactive transport jacbrt is: ",&
                   i_matrix_assembly_type_jacbrt
                end if
              end if
                        
            case ("matrix assembly: number of threads in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofthreads_matrix_react
#ifdef PETSC
                if(b_use_mpi_nprcs_omp_nthreads) then
                    numofthreads_matrix_react = nthreads_per_proc
                end if
#endif
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "Number of threads for matrix assembly ",              &
                        "in reactive transport is: ", numofthreads_matrix_react
                end if
              end if
                        
            case ("matrix assembly: schedule type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_schedule_type_react
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "Schedule type in matrix assembly ",                   &
                        "in reactive transport is: ", i_schedule_type_react
                end if
              end if

            case ("matrix assembly: chunk size factor in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_chunksize_factor_react
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "Chunk size factor for matrix assembly ",              &
                        "in reactive transport is: ", i_chunksize_factor_react
                end if
              end if
                    
                    ! Block:  Pardiso solver setting
#ifdef PARDISO
            case ("pardiso: solver test with ws209")
              b_solver_test_pardiso = .true.
              if(rank == 0) then
                write(ilog,'(a,l2)') "pardiso solver test: ", b_solver_test_pardiso
              end if
              if(.not.b_enable_output) then
                  b_solver_test_pardiso = .false.
              end if
            case ("pardiso: number of threads")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofthreads_pardiso
#ifdef PETSC
                if(b_use_mpi_nprcs_omp_nthreads) then
                    numofthreads_pardiso = nthreads_per_proc
                end if
#endif
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Number of threads for Pardiso is: ",                  &
                        numofthreads_pardiso
                end if
              end if
            case ("pardiso: max iterative refinement steps in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) max_refine_itersteps_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "maximum iterative refinement steps in flow: ",        &
                        max_refine_itersteps_flow
                end if
                !write(numofmaxitersteps, *) trim(strbuffer)
              end if
            case ("pardiso: max iterative refinement steps in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) max_refine_itersteps_heat
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "maximum iterative refinement steps in ",              &
                        "heat transport: ",max_refine_itersteps_heat
                end if
                !write(numofmaxitersteps, *) trim(strbuffer)
              end if              
            case ("pardiso: max iterative refinement steps in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                  read(strbuffer, *) max_refine_itersteps_react
                  if(rank == 0) then
                    write(ilog,'(2a,i6)')                                      &
                          "maximum iterative refinement steps ",               &
                          "in reactive transport: ", max_refine_itersteps_react
                  end if
                  !write(numofmaxitersteps, *) trim(strbuffer)
              end if
            case ("pardiso: pivoting perturbation in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                  read(strbuffer, *) npivotpertubation_flow
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "pivoting perturbation in flow: ",    &
                          npivotpertubation_flow
                  end if
                  !write(npivotpertubation, *) trim(strbuffer)
              end if
            case ("pardiso: pivoting perturbation in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                  read(strbuffer, *) npivotpertubation_heat
                  if(rank == 0) then
                    write(ilog,'(2a,i6)') "pivoting perturbation in ",         &
                          "heat transport: ",npivotpertubation_heat
                  end if
                  !write(npivotpertubation, *) trim(strbuffer)
              end if
            case ("pardiso: pivoting perturbation in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) npivotpertubation_react
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "pivoting perturbation in reactive transport: ",       &
                        npivotpertubation_react
                end if
                !write(npivotpertubation, *) trim(strbuffer)
              end if

            case ("pardiso: cgs criterion in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_cgs_criterion_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)') "Preconditioned CGS in flow: ",         &
                        i_cgs_criterion_flow
                end if
              end if

            case ("pardiso: cgs criterion in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_cgs_criterion_heat
                if(rank == 0) then
                  write(ilog,'(2a,i6)') "Preconditioned CGS in ",              &
                        "heat transport: ",i_cgs_criterion_heat
                end if
              end if

            case ("pardiso: cgs criterion in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_cgs_criterion_react
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Preconditioned CGS in reactive transport: ",          &
                        i_cgs_criterion_react
                end if
                !write(npivotpertubation, *) trim(strbuffer)
              end if
                        
            case ("pardiso: maximum solver iteration in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) n_max_iteration_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)') "maximum solver iteration in flow: ",   &
                        n_max_iteration_flow
                end if
              end if

            case ("pardiso: maximum solver iteration in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) n_max_iteration_heat
                if(rank == 0) then
                  write(ilog,'(2a,i6)') "maximum solver iteration in ",        &
                        "heat transport: ",n_max_iteration_heat
                end if
              end if

            case ("pardiso: maximum solver iteration in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) n_max_iteration_react
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "maximum solver iteration in reactive transport: ",    &
                        n_max_iteration_react
                end if
              end if

            case ("pardiso: maximum residual in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) r_max_residual_flow
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)') "maximum residual in flow: ",    &
                        r_max_residual_flow
                end if
              end if

            case ("pardiso: maximum residual in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) r_max_residual_heat
                if(rank == 0) then
                  write(ilog,'(2a,1pe15.6e3)') "maximum residual in ",         &
                        "heat transport: ",r_max_residual_heat
                end if
              end if
                        
            case ("pardiso: maximum residual in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) r_max_residual_react
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                        "maximum residual in reactive transport: ",            &
                        r_max_residual_react
                end if
              end if

            case ("pardiso: symbolic factorization type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_symfactor_type_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Symbolic factorization type in flow is: ",            &
                        i_symfactor_type_flow
                end if
              end if

            case ("pardiso: symbolic factorization type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_symfactor_type_heat
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Symbolic factorization type in heat transport is: ",  &
                        i_symfactor_type_heat
                end if
              end if

            case ("pardiso: symbolic factorization type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) i_symfactor_type_react
                if(rank == 0) then
                  write(ilog,'(2a,i6)') "Symbolic factorization type ",        &
                        "in reactive transport is: ", i_symfactor_type_react
                end if
              end if
#endif

#endif

                    ! Block:  PETSc solver setting
#ifdef PETSC
            case ("petsc: solver test with ws209")
              b_solver_test_petsc = .true.
              if(rank == 0) then
                write(ilog,'(a,l2)') "petsc solver test: ", b_solver_test_petsc
              end if
              if(.not. b_enable_output) then
                  b_solver_test_petsc = .false.
              end if

            case ("petsc: stencil width")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) stencil_width
                if(rank == 0) then
                  write(ilog,'(a,i6)') "PETSc stencil width: ", stencil_width
                end if
              end if

            case ("petsc: create faces and edges in the mesh")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) interpolate
                if(rank == 0) then
                  write(ilog,'(a,l1)')                                 &
                        "PETSc create faces and edges in the mesh: ",  &
                        interpolate
                end if
              end if

            case ("petsc: partitioner type")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) partitioner_type
                if(rank == 0) then
                  write(ilog,'(2a)') "PETSc partitioner type: ",trim(partitioner_type)
                end if
              end if

            case ("petsc: use default configuration in flow")
              b_use_petsc_default_flow = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc use default configuration for flow problem"
              end if

            case ("petsc: ksp type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strKSPType_flow
                if(rank == 0) then
                  write(ilog,'(2a)') "PETSc Krylov method for flow problem: ", &
                        trim(strKSPType_flow)
                end if
              end if

            case ("petsc: preconditioner type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strPCType_flow
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "PETSc preconditioner type for flow problem: ",        &
                        trim(strPCType_flow)
                end if
              end if

            case ("petsc: factorization level in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) pc_factor_level_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "PETSc factorization level for flow problem: ",        &
                        pc_factor_level_flow
                end if
              end if

            case ("petsc: ksp convergence criteria type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strKSPConvergenceType_flow
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "PETSc convergence criteria for flow problem: ",       &
                        trim(strKSPConvergenceType_flow)
                end if
              end if

            case ("petsc: ksp set initial guess nonzero in flow")
              b_initial_guess_nonzero_flow = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc use nonzero initial guess for flow problem."
              end if

            case ("petsc: ksp form initial guess in flow")
              b_form_initial_guess_flow = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc form initial guess for flow problem."
              end if

            case ("petsc: ksp reuse preconditioner in flow")
              b_reuse_preconditioner_flow = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc reuse preconditioner for flow problem."
              end if

            case ("petsc: check direct solver norm in flow")
              b_check_norm_flow = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc check direct solver norm in flow."
              end if

            !case ("petsc: ksp norm type in flow")
            !  if(readnextline(isolvercfg, strbuffer)) then
            !      read(strbuffer, *) strKSPNormType_flow
            !      if(rank == 0) then
            !        write(ilog, *) "PETSc KSP norm type for flow problem: ",   &
            !              trim(strKSPNormType_flow)
            !      end if
            !  end if

            case ("petsc: pc factor shift type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                  read(strbuffer, *) pc_factor_shift_flow
                  if(rank == 0) then
                    write(ilog,'(2a)') "PETSc PC factor shift type in flow: ", &
                          trim(pc_factor_shift_flow)
                  end if
              end if

            case ("petsc: relative convergence tolerance in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) rtol_flow
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                        "PETSc relative convergence tolerance in flow: ",      &
                        rtol_flow
                end if
              end if

            case ("petsc: absolute convergence tolerance in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) abstol_flow
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                        "PETSc absolute convergence tolerance in flow: ",      &
                        abstol_flow
                end if
              end if

            case ("petsc: divergence tolerance in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) dtol_flow
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                        "PETSc divergence tolerance in flow: ", dtol_flow
                end if
              end if

            case ("petsc: maximum number of iterations in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) maxits_flow
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "PETSc maximum number of iterations in flow: ",        &
                        maxits_flow
                end if
              end if

            case ("petsc: use default configuration in heat transport")
              b_use_petsc_default_heat = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "PETSc use default configuration for ",     &
                                   "heat transport problem"
              end if

            case ("petsc: ksp type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strKSPType_heat
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "PETSc Krylov method for heat transport problem: ",    &
                        trim(strKSPType_heat)
                end if
              end if

            case ("petsc: preconditioner type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strPCType_heat
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                      "PETSc preconditioner type for heat transport problem: ",&
                      trim(strPCType_heat)
                end if
              end if

            case ("petsc: factorization level in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) pc_factor_level_heat
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                      "PETSc factorization level for heat transport problem: ",&
                      pc_factor_level_heat
                end if
              end if

            case ("petsc: ksp convergence criteria type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strKSPConvergenceType_heat
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                     "PETSc convergence criteria for heat transport problem: ",&
                     trim(strKSPConvergenceType_heat)
                end if
              end if

            case ("petsc: ksp set initial guess nonzero in heat transport")
              b_initial_guess_nonzero_heat = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "PETSc use nonzero initial guess for ",     &
                      "heat transport problem."
              end if

            case ("petsc: ksp form initial guess in heat transport")
              b_form_initial_guess_heat = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc form initial guess for heat transport problem."
              end if

            case ("petsc: ksp reuse preconditioner in heat transport")
              b_reuse_preconditioner_heat = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc reuse preconditioner for heat transport problem."
              end if

            case ("petsc: check direct solver norm in heat transport")
              b_check_norm_heat = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc check direct solver norm in heat transport."
              end if

            !case ("petsc: ksp norm type in heat transport")
            !  if(readnextline(isolvercfg, strbuffer)) then
            !      read(strbuffer, *) strKSPNormType_heat
            !      if(rank == 0) then
            !        write(ilog, *) "PETSc KSP norm type for heat transport problem: ",   &
            !              trim(strKSPNormType_heat)
            !      end if
            !  end if

            case ("petsc: pc factor shift type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                  read(strbuffer, *) pc_factor_shift_heat
                  if(rank == 0) then
                    write(ilog,'(2a)') "PETSc PC factor shift type in heat transport: ", &
                          trim(pc_factor_shift_heat)
                  end if
              end if

            case ("petsc: relative convergence tolerance in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) rtol_heat
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                    "PETSc relative convergence tolerance in heat transport: ",&
                    rtol_heat
                end if
              end if

            case ("petsc: absolute convergence tolerance in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) abstol_heat
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                    "PETSc absolute convergence tolerance in heat transport: ",&
                    abstol_heat
                end if
              end if

            case ("petsc: divergence tolerance in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) dtol_heat
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                        "PETSc divergence tolerance in heat transport: ",      &
                        dtol_heat
                end if
              end if

            case ("petsc: maximum number of iterations in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) maxits_heat
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                    "PETSc maximum number of iterations in heat transport: ",  &
                    maxits_heat
                end if
              end if

            case ("petsc: use default configuration in reactive transport")
              b_use_petsc_default_react = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "PETSc use default configuration ",         &
                      "for reactive transport problem."
              end if

            case ("petsc: ksp type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strKSPType_react
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "PETSc Krylov method for reactive transport problem: ",&
                        trim(strKSPType_react)
                end if
              end if

            case ("petsc: preconditioner type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strPCType_react
                if(rank == 0) then
                  write(ilog,'(3a)') "PETSc preconditioner type for ",         &
                        "reactive transport problem: ", trim(strPCType_react)
                end if
              end if

            case ("petsc: factorization level in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) pc_factor_level_react
                if(rank == 0) then
                  write(ilog,'(2a,i6)') "PETSc factorization level for ",      &
                        "reactive transport problem: ", pc_factor_level_react
                end if
              end if

            case ("petsc: ksp convergence criteria type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) strKSPConvergenceType_react
                if(rank == 0) then
                  write(ilog,'(3a)') "PETSc convergence criteria for ",        &
                        "reactive transport problem: ",                        &
                        trim(strKSPConvergenceType_react)
                end if
              end if

            case ("petsc: ksp set initial guess nonzero in reactive transport")
              b_initial_guess_nonzero_react = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "PETSc use nonzero initial guess for ",     &
                                   "reactive transport problem."
              end if

            case ("petsc: ksp form initial guess in reactive transport")
              b_form_initial_guess_react = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "PETSc form initial guess for ",            &
                                   "reactive transport problem."
              end if

            case ("petsc: ksp reuse preconditioner in reactive transport")
              b_reuse_preconditioner_react = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "PETSc reuse preconditioner for ",          &
                                   "reactive transport problem."
              end if

            case ("petsc: check direct solver norm in reactive transport")
              b_check_norm_react = .true.
              if(rank == 0) then
                write(ilog,'(a)') "PETSc check direct solver norm in reactive transport."
              end if

            !case ("petsc: ksp norm type in reactive transpor")
            !  if(readnextline(isolvercfg, strbuffer)) then
            !      read(strbuffer, *) strKSPNormType_react
            !      if(rank == 0) then
            !        write(ilog, *) "PETSc KSP norm type for reactive transport problem: ", &
            !                       trim(strKSPNormType_react)
            !      end if
            !  end if

            case ("petsc: pc factor shift type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) pc_factor_shift_react
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "PETSc PC factor shift type in reactive transport: ",  &
                        trim(pc_factor_shift_react)
                end if
              end if

            case ("petsc: relative convergence tolerance in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) rtol_react
                if(rank == 0) then
                  write(ilog,'(2a,1pe15.6e3)')                                 &
                     "PETSc relative convergence tolerance in ",               &
                     "reactive transport: ", rtol_react
                end if
              end if

            case ("petsc: absolute convergence tolerance in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) abstol_react
                if(rank == 0) then
                  write(ilog,'(2a,1pe15.6e3)')                                 &
                     "PETSc absolute convergence tolerance in ",               &
                     "reactive transport: ", abstol_react
                end if
              end if

            case ("petsc: divergence tolerance in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) dtol_react
                if(rank == 0) then
                  write(ilog,'(a,1pe15.6e3)')                                  &
                     "PETSc divergence tolerance in reactive transport: ",     &
                     dtol_react
                end if
              end if

            case ("petsc: maximum number of iterations in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) maxits_react
                if(rank == 0) then
                  write(ilog,'(2a,i6)')                                        &
                        "PETSc maximum number of iterations in ",              &
                        "reactive transport: ", maxits_react
                end if
              end if
#endif

#ifdef LIS
            case ("lis: solver test with ws209")
              b_solver_test_lis = .true.
              if(rank == 0) then
                write(ilog,'(a,l2)') "lis solver test: ", b_solver_test_lis
              end if
              if(.not. b_enable_output) then
                  b_solver_test_lis = .false.
              end if

            case ("lis: use default configuration in flow")
              lis_default_flow = .true.
              if(rank == 0) then
                write(ilog,'(a)') "LIS use default configuration for flow problem"
              end if

            case ("lis: ksp type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_flow = trim(lis_options_flow)//" -i "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)') "LIS solver method for flow problem: ", trim(strbuffer)
                end if
              end if

            case ("lis: preconditioner type in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_flow = trim(lis_options_flow)//" -p "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "LIS solver preconditioner type for flow problem: ",   &
                        trim(strbuffer)
                end if
              end if

            case ("lis: solver precision in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_flow = trim(lis_options_flow)//" -f "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)') "LIS solver precision for flow problem: ",&
                                 trim(strbuffer)
                end if
              end if

            case ("lis: convergence tolerance in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) lis_abstol_flow
                lis_options_flow = trim(lis_options_flow)//" -tol "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "LIS convergence tolerance for flow problem: ",        &
                        trim(strbuffer)
                end if
              end if

            case ("lis: maximum number of iterations in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) lis_maxit_flow
                lis_options_flow = trim(lis_options_flow)//" -maxiter "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "LIS maximum number of iterations for flow problem: ", &
                        trim(strbuffer)
                end if
              end if

            case ("lis: solver options in flow")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_flow = trim(lis_options_flow)//" "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "LIS other solver options for flow problem: ",         &
                        trim(strbuffer)
                end if
              end if

            case ("lis: use default configuration in heat transport")
              lis_default_heat = .true.
              if(rank == 0) then
                write(ilog,'(a)') "LIS use default configuration for heat transport problem"
              end if

            case ("lis: ksp type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_heat = trim(lis_options_heat)//" -i "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)') "LIS solver method for heat transport problem: ", &
                                     trim(strbuffer)
                end if
              end if

            case ("lis: preconditioner type in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_heat = trim(lis_options_heat)//" -p "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                                   &
                    "LIS solver preconditioner type for heat transport problem: ",     &
                    trim(strbuffer)
                end if
              end if

            case ("lis: solver precision in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_heat = trim(lis_options_heat)//" -f "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)') "LIS solver precision for heat transport problem: ",&
                                 trim(strbuffer)
                end if
              end if

            case ("lis: convergence tolerance in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) lis_abstol_heat
                lis_options_heat = trim(lis_options_heat)//" -tol "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                                   &
                    "LIS convergence tolerance for heat transport problem: ",          &
                    trim(strbuffer)
                end if
              end if

            case ("lis: maximum number of iterations in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) lis_maxit_heat
                lis_options_heat = trim(lis_options_heat)//" -maxiter "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                                   &
                    "LIS maximum number of iterations for heat transport problem: ",   &
                    trim(strbuffer)
                end if
              end if

            case ("lis: solver options in heat transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_heat = trim(lis_options_heat)//" "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                                   &
                        "LIS other solver options for heat transport problem: ",       &
                        trim(strbuffer)
                end if
              end if

            case ("lis: use default configuration in reactive transport")
              lis_default_react = .true.
              if(rank == 0) then
                write(ilog,'(2a)') "LIS use default configuration for ",       &
                                   "reactive transport problem"
              end if

            case ("lis: ksp type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_react = trim(lis_options_react)//" -i "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(2a)')                                           &
                        "LIS solver method for reactive transport problem: ",  &
                        trim(strbuffer)
                end if
              end if

            case ("lis: preconditioner type in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_react = trim(lis_options_react)//" -p "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(3a)') "LIS solver preconditioner type for ",    &
                        "reactive transport problem: ", trim(strbuffer)
                end if
              end if

            case ("lis: solver precision in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_react = trim(lis_options_react)//" -f "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(3a)') "LIS solver precision for ",              &
                        "reactive transport problem: ", trim(strbuffer)
                end if
              end if

            case ("lis: convergence tolerance in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) lis_abstol_react
                lis_options_react = trim(lis_options_react)//" -tol "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(3a)') "LIS convergence tolerance for ",         &
                        "reactive transport problem: ", trim(strbuffer)
                end if
              end if

            case ("lis: maximum number of iterations in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) lis_maxit_react
                lis_options_react = trim(lis_options_react)//" -maxiter "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(3a)') "LIS maximum number of iterations for ",  &
                        "reactive transport problem: ", trim(strbuffer)
                end if
              end if
            case ("lis: solver options in reactive transport")
              if(readnextline(isolvercfg, strbuffer)) then
                lis_options_react = trim(lis_options_react)//" "//trim(strbuffer)
                if(rank == 0) then
                  write(ilog,'(3a)') "LIS other solver options for ",          &
                        "reactive transport problem: ", trim(strbuffer)
                end if
              end if

 
#endif

            ! Block:  ws209 solver setting
            case ("ws209: number of threads")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofthreads_ws209
#ifdef PETSC
                if(b_use_mpi_nprcs_omp_nthreads) then
                    numofthreads_ws209 = nthreads_per_proc
                end if
#endif  
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                         &
                        "Number of threads for WS209 Solver is: ",             &
                        numofthreads_ws209
                end if
              end if

            ! Block:  Output setting
            case ("output runtime statistics analysis")
              if(rank == 0) then
                write(ilog,'(a)') "output runtime statistics analysis: true"
              end if
              b_prtfile = .true.
            case ("output sparse matrix data set and rhs")
              if(rank == 0) then
                write(ilog,'(a)') "output sparse matrix data set and rhs: true"
              end if
              b_output_matrix = .true.
            case ("output sparse matrix data set and rhs using petsc")
              if(rank == 0) then
                write(ilog,'(a)') "output sparse matrix data set and rhs using petsc: true"
              end if
              b_output_matrix_petsc = .true.
            case ("output sparse matrix data set and rhs at timestep")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) itimestep_output_matrix
                if(rank == 0) then
                  write(ilog,'(a,i6)')                                        &
                        "output sparse matrix data set and rhs at timestep: ",&
                        itimestep_output_matrix
                end if
              end if
            case ("output matrix format selection")
              if(readnextline(isolvercfg, strbuffer)) then
                  read(strbuffer, *) itype_matrix_format
                  if(rank == 0) then
                    write(ilog,'(a,i6)') "Output matrix format is: ", itype_matrix_format
                  end if
              end if
            case ("output condition number")
              if (rank == 0 .and. b_enable_output) then
                write(ilog,'(a)') "output condition number: true"
              end if
              if(b_enable_output)  then
                b_output_condition_number = .true.
              else
                b_output_condition_number = .false.
              end if
                        
            ! Debug input only
#ifdef OPENMP
            case ("mbalrt: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_1
              end if

            case ("mbalrt: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_2
              end if

            case ("mbalrt: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_3
              end if

            case ("mbalrt: number of threads 4")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_4
              end if

            case ("mbalrt: number of threads 5")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_5
              end if

            case ("mbalrt: number of threads 6")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_6
              end if

            case ("mbalrt: number of threads 7")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_7
              end if

            case ("mbalrt: number of threads 8")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_8
              end if

            case ("mbalrt: number of threads 9")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_9
              end if

            case ("mbalrt: number of threads 10")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_10
              end if

            case ("mbalrt: number of threads 11")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalrt_11
              end if

            case ("msysrt: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysrt_1
              end if

            case ("msysrt: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysrt_2
              end if

            case ("msysrt: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysrt_3
              end if

            case ("msysrt: number of threads 4")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysrt_4
              end if

            case ("msysrt: number of threads 5")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysrt_5
              end if

            case ("msysrt: number of threads 6")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysrt_6
              end if

            case ("mbal_mcd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mcd_1
              end if

            case ("mbal_mcd: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mcd_2
              end if

            case ("mbal_mcd: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mcd_3
              end if

            case ("infcrtdd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrtdd_1
              end if

            case ("infcrtdd: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrtdd_2
              end if

            case ("infcrtdd: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrtdd_3
              end if

            case ("infcrt_a: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_a_1
              end if

            case ("infcrt_a: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_a_2
              end if

            case ("infcrt_a: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_a_3
              end if

            case ("infcrt_g: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_g_1
              end if

            case ("infcrt_g: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_g_2
              end if

            case ("infcrt_mcd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_mcd_1
              end if

            case ("infcrt_mcd: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcrt_mcd_2
              end if

            case ("diffcoff_mcd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_diffcoff_mcd_1
              end if

            case ("i2upfind: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_i2upfind_1
              end if

            case ("i2upfind_heat: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_i2upfind_heat_1
              end if

            case ("ddtds: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_ddtds_1
              end if

            case ("ddtds_energybal: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_ddtds_energybal_1
              end if

            case ("ddtds_energybal: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_ddtds_energybal_2
              end if

            case ("comp_bc_ice: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_comp_bc_ice_1
              end if

            case ("comp_bc_ice: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_comp_bc_ice_2
              end if

            case ("timeloop: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_timeloop_1
              end if

            case ("infheat_c: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infheat_c_1
              end if

            case ("infheat_d: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infheat_d_1
              end if

            case ("infevap: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infevap_1
              end if

            case ("updatedd_ener: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatedd_ener_1
              end if

            case ("updatedd_ener: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatedd_ener_2
              end if

            case ("updatedd_ener: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatedd_ener_3
              end if

            case ("updatedd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatedd_1
              end if

            case ("updatedd: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatedd_2
              end if

            case ("ddvsflow: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_ddvsflow_1
              end if

            case ("seepfdd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_seepfdd_1
              end if
 
            case ("tstepvs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_tstepvs_1
              end if

            case ("updatevs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatevs_1
              end if

            case ("updatevs: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_updatevs_2
              end if

            case ("seepface: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_seepface_1
              end if

            case ("soilparm: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_soilparm_1
              end if

            case ("msysdd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysdd_1
              end if

            case ("msysdd: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysdd_2
              end if

            case ("msysdd: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysdd_3
              end if

            case ("msysvs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_msysvs_1
              end if

            case ("mbalvs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalvs_1
              end if

            case ("mbalvs: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalvs_2
              end if

            case ("mbalvs: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbalvs_3
              end if

            case ("energysys: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_energysys_1
              end if

            case ("energy_bal: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_energy_bal_1
              end if

            case ("energy_bal: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_energy_bal_2
              end if

            case ("velodd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_velodd_1
              end if

            case ("nexttime: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_nexttime_1
              end if

            case ("nexttime: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_nexttime_2
              end if

            case ("infcvs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_infcvs_1
              end if

            case ("xyzcoord: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_xyzcoord_1
              end if

            case ("cvolume: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_cvolume_1
              end if

            case ("iajavs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_iajavs_1
              end if

            case ("iajavs: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_iajavs_2
              end if

            case ("iajavs_dp: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_iajavs_dp_1
              end if

            case ("iajavs_ener: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_iajavs_ener_1
              end if

            case ("iajavs_ener: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_iajavs_ener_2
              end if

            case ("matrix_uti: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_matrix_uti_1
              end if

            case ("initpppm: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initpppm_1
              end if

            case ("initppvs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initppvs_1
              end if

            case ("initppvs: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initppvs_2
              end if

            case ("initppdd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initppdd_1
              end if

            case ("initppenergybal: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initppeb_1
              end if

            case ("initppenergybal: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initppeb_2
              end if

            case ("initicvs: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initicvs_1
              end if

            case ("initsatw: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initsatw_1
              end if


            case ("initsatw: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initsatw_2
              end if

            case ("initsatw: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initsatw_3
              end if

            case ("initicener: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initicener_1
              end if

            case ("initprob: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initprob_1
              end if

            case ("initprob: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initprob_2
              end if

            case ("initicrt: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initicrt_1
              end if

            case ("initicdd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_initicdd_1
              end if

            case ("restart_r: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_restart_1
              end if

            case ("batreac: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_batreac_1
              end if

            case ("batreac: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_batreac_2
              end if

            case ("intpolt: number of threads")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_intpolt
              end if

            case ("mbaldd: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbaldd_1
              end if

            case ("mbaldd: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbaldd_2
              end if

            case ("mbaldd: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbaldd_3
              end if

            case ("mbaldd: number of threads 4")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_mbaldd_4
              end if

            case ("gasbub: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_gasbub_1
              end if

            case ("gasbub: number of threads 2")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_gasbub_2
              end if

            case ("gasbub: number of threads 3")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_gasbub_3
              end if

            case ("gasbub: number of threads 4")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_gasbub_4
              end if

            case ("gasbub: number of threads 5")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_gasbub_5
              end if

            case ("rateh2o: number of threads 1")
              if(readnextline(isolvercfg, strbuffer)) then
                read(strbuffer, *) numofloops_thred_rateh2o_1
              end if
#endif                        
            case default
              !if(rank == 0) then
              !  if(rank == 0) then
              !    write(ilog, *) "unknown instruction ignored: ", trim(strbuffer)
              !  end if
              !end if
              continue
          end select
                
        end do
        close(isolvercfg)
      end if

        !set back to default configuration parameters if required
#ifdef PETSC
      if (b_use_petsc_default_flow) then
        pc_factor_shift_flow = "none"
        rtol_flow = 1.0e-5
        abstol_flow = 1.0e-30
        dtol_flow = 1.0e5
        maxits_flow = 50000
      end if

      if (b_use_petsc_default_heat) then
        pc_factor_shift_heat = "none"
        rtol_heat = 1.0e-5
        abstol_heat = 1.0e-30
        dtol_heat = 1.0e5
        maxits_heat = 50000
      end if

      if (b_use_petsc_default_react) then
        pc_factor_shift_react = "none"
        rtol_react = 1.0e-5
        abstol_react = 1.0e-30
        dtol_react = 1.0e5
        maxits_react = 50000
      end if
#endif
    else
      if(rank == 0) then  
        write(ilog,'(2a)') "Parallel Solver configuration file is missing. ",  &
              "Default configurations and command line options are used."
      end if
#ifdef PETSC
      b_use_petsc_default_flow = .true.
      b_use_petsc_default_heat = .true.
      b_use_petsc_default_react = .true.
      b_prtfile = .true.
#endif

#ifdef LIS
      lis_default_flow = .true.
      lis_default_heat = .true.
      lis_default_react = .true.
      b_prtfile = .true.
#endif
    end if
    
    call initsolver_final

end subroutine initsolver

!> initialize solver
subroutine initsolver_default

#ifdef PARDISO
    use solver_pardiso, only :  numofthreads_pardiso, max_refine_itersteps_flow, &
        max_refine_itersteps_heat, max_refine_itersteps_react,                   &
        npivotpertubation_flow, npivotpertubation_heat, npivotpertubation_react, &
        i_cgs_criterion_flow, i_cgs_criterion_heat,i_cgs_criterion_react
#endif

#ifdef PETSC
    use solver_snes_common, only : strKSPType_flow, rtol_flow, abstol_flow,      &
        dtol_flow, maxits_flow, strKSPType_heat, rtol_heat, abstol_heat,         &
        dtol_heat, maxits_heat, strKSPType_react, rtol_react, abstol_react,      &
        dtol_react, strKSPNormType_flow, strKSPNormType_heat,                    &
        strKSPNormType_react, maxits_react, strPCType_flow, strPCType_heat,      &
        strKSPConvergenceType_flow, strKSPConvergenceType_heat, strPCType_react, &
        strKSPConvergenceType_react,                                             &
        pc_factor_shift_flow, pc_factor_shift_heat, pc_factor_shift_react,       &
        b_use_petsc_default_flow, b_use_petsc_default_heat,                      &
        b_use_petsc_default_react, b_form_initial_guess_flow,                    &
        b_form_initial_guess_heat, b_form_initial_guess_react,                   &
        b_check_norm_flow, b_check_norm_heat, b_check_norm_react,                &
        b_initial_guess_nonzero_flow, b_reuse_preconditioner_flow,               &
        b_initial_guess_nonzero_heat, b_reuse_preconditioner_heat,               &
        b_initial_guess_nonzero_react, b_reuse_preconditioner_react,             &
        b_set_preconditioner_flow, b_set_preconditioner_heat,                    &
        b_set_preconditioner_react, stencil_width, partitioner_type, interpolate
#endif

#ifdef LIS
    use solver_lis_common, only : lis_default_flow, lis_options_flow,            &
        lis_maxit_flow, lis_abstol_flow, lis_default_heat, lis_options_heat,   &
        lis_maxit_heat, lis_abstol_heat, lis_default_react,                    &
        lis_options_react, lis_maxit_react, lis_abstol_react
                                 
#endif


    implicit none

    integer :: numthreads_sys, numthreads_set

    integer :: i

#ifndef PETSC
#ifndef OPENMP
    numofthreads_global = 1
    nthreads = 1
    rank = 0
#ifndef LIS
    return
#endif
#endif
#endif

    !initialize parameters
    b_min3p_input_param_first = .false.
    b_use_mpi_nprcs_omp_nthreads = .false.

#ifdef OPENMP
    numofthreads_global = omp_get_max_threads()
    nthreads = numofthreads_global
#endif

    if(numofthreads_global < 1) then
      nthreads = 1
      numofthreads_global = 1
    end if

    numofloops_thred_global = 1

#ifdef OPENMP
    i_matrix_assembly_type_flow = 1
    i_matrix_assembly_type_heat = 1
    i_matrix_assembly_type_react = 1
    i_matrix_assembly_type_jacrt = 1
    i_matrix_assembly_type_jacbrt = 1
#else
    i_matrix_assembly_type_flow = 0
    i_matrix_assembly_type_heat = 0
    i_matrix_assembly_type_react = 0
    i_matrix_assembly_type_jacrt = 0
    i_matrix_assembly_type_jacbrt = 0
#endif
    numofthreads_matrix_flow = numofthreads_global
    numofthreads_matrix_heat = numofthreads_global
    numofthreads_matrix_react = numofthreads_global
    i_schedule_type_flow = 0
    i_schedule_type_heat = 0
    i_schedule_type_react = 0
    i_chunksize_factor_flow = 0
    i_chunksize_factor_heat = 0
    i_chunksize_factor_react = 0

#ifdef PETSC
    i_solver_type = 2
    i_solver_type_flow = 2
    i_solver_type_heat = 2
    i_solver_type_react = 2
#else
    i_solver_type = 0
    i_solver_type_flow = 0
    i_solver_type_heat = 0
    i_solver_type_react = 0
#endif

#ifdef PARDISO
    b_solver_test_pardiso = .false.
    numofthreads_pardiso = numofthreads_global
    max_refine_itersteps_flow = 9
    max_refine_itersteps_heat = 9
    max_refine_itersteps_react = 9
    npivotpertubation_flow = 13
    npivotpertubation_heat = 13
    npivotpertubation_react = 13
    i_cgs_criterion_flow = 0
    i_cgs_criterion_heat = 0
    i_cgs_criterion_react = 0
#endif

#ifdef PETSC
    stencil_width = 1
    partitioner_type = ""
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 13)
    interpolate = .true.
#else
    interpolate = .false.
#endif

    b_use_petsc_default_flow = .true.
    b_use_petsc_default_heat = .true.
    b_use_petsc_default_react = .true.
    
    b_form_initial_guess_flow = .false.
    b_initial_guess_nonzero_flow = .false.
    b_reuse_preconditioner_flow = .false.
    b_set_preconditioner_flow = .false.
    
    b_form_initial_guess_heat = .false.
    b_initial_guess_nonzero_heat = .false.
    b_reuse_preconditioner_heat = .false.
    b_set_preconditioner_heat = .false.

    b_form_initial_guess_react = .false.
    b_initial_guess_nonzero_react = .false.
    b_reuse_preconditioner_react = .false.
    b_set_preconditioner_react = .false.
    
    b_check_norm_flow = .false.
    b_check_norm_heat = .false.
    b_check_norm_react = .false.
    
    
    b_solver_test_petsc = .false.

    strKSPType_flow = "kspgmres"
    strPCType_flow = "pcbjacobi"
    strKSPConvergenceType_flow = "kspdefault"
    !strKSPNormType_flow = "ksp_norm_preconditioned"
    pc_factor_shift_flow = "none"
    rtol_flow       = 1.0E-5
    abstol_flow     = 1.0E-30
    dtol_flow       = 1.0E5
    maxits_flow     = 50000

    strKSPType_heat = "kspgmres"
    strPCType_heat = "pcbjacobi"
    strKSPConvergenceType_heat = "kspdefault"
    !strKSPNormType_heat = "ksp_norm_preconditioned"
    pc_factor_shift_heat = "none"
    rtol_heat       = 1.0E-5
    abstol_heat     = 1.0E-30
    dtol_heat       = 1.0E5
    maxits_heat     = 50000

    strKSPType_react = "kspgmres"
    strPCType_react = "pcbjacobi"
    strKSPConvergenceType_react = "kspdefault"
    !strKSPNormType_react = "ksp_norm_preconditioned"
    pc_factor_shift_react = "none"
    rtol_react       = 1.0E-5
    abstol_react     = 1.0E-30
    dtol_react       = 1.0E5
    maxits_react     = 50000
#endif

#ifdef LIS
    b_solver_test_lis = .false.

    lis_maxit_flow = 5000
    lis_abstol_flow = 1.0E-20
    lis_options_flow = ""

    lis_maxit_heat = 5000
    lis_abstol_heat = 1.0E-20
    lis_options_heat = ""

    lis_maxit_react = 5000
    lis_abstol_react = 1.0E-20
    lis_options_react = ""
#endif

    n_max_iteration_flow = 9
    n_max_iteration_heat = 9
    n_max_iteration_react = 9
    r_max_residual_flow = 1.0E-8
    r_max_residual_heat = 1.0E-8
    r_max_residual_react = 1.0E-8
    i_symfactor_type_flow = 0
    i_symfactor_type_heat = 0
    i_symfactor_type_react = 0

    numofthreads_ws209 = 1

    b_prtfile = .false.
    b_output_matrix = .false.
    b_output_matrix_petsc = .false.
    itimestep_output_matrix = -1
    itype_matrix_format = 1
    b_output_condition_number = .false.

#ifdef OPENMP
    numofloops_thred_mbalrt_1  = numofloops_thred_global
    numofloops_thred_mbalrt_2  = numofloops_thred_global
    numofloops_thred_mbalrt_3  = numofloops_thred_global
    numofloops_thred_mbalrt_4  = numofloops_thred_global
    numofloops_thred_mbalrt_5  = numofloops_thred_global
    numofloops_thred_mbalrt_6  = numofloops_thred_global
    numofloops_thred_mbalrt_7  = numofloops_thred_global
    numofloops_thred_mbalrt_8  = numofloops_thred_global
    numofloops_thred_mbalrt_9  = numofloops_thred_global
    numofloops_thred_mbalrt_10 = numofloops_thred_global
    numofloops_thred_mbalrt_11 = numofloops_thred_global

    numofloops_thred_msysrt_1  = numofloops_thred_global
    numofloops_thred_msysrt_2  = numofloops_thred_global
    numofloops_thred_msysrt_3  = numofloops_thred_global
    numofloops_thred_msysrt_4  = numofloops_thred_global
    numofloops_thred_msysrt_5  = numofloops_thred_global
    numofloops_thred_msysrt_6  = numofloops_thred_global

    numofloops_thred_mcd_1     = numofloops_thred_global
    numofloops_thred_mcd_2     = numofloops_thred_global
    numofloops_thred_mcd_3     = numofloops_thred_global

    numofloops_thred_infcrtdd_1 = numofloops_thred_global
    numofloops_thred_infcrtdd_2 = numofloops_thred_global
    numofloops_thred_infcrtdd_3 = numofloops_thred_global

    numofloops_thred_infcrt_a_1 = numofloops_thred_global
    numofloops_thred_infcrt_a_2 = numofloops_thred_global
    numofloops_thred_infcrt_a_3 = numofloops_thred_global

    numofloops_thred_infcrt_g_1 = numofloops_thred_global
    numofloops_thred_infcrt_g_2 = numofloops_thred_global

    numofloops_thred_infcrt_mcd_1 = numofloops_thred_global
    numofloops_thred_infcrt_mcd_2 = numofloops_thred_global

    numofloops_thred_diffcoff_mcd_1 = numofloops_thred_global

    numofloops_thred_i2upfind_1 = numofloops_thred_global

    numofloops_thred_i2upfind_heat_1 = numofloops_thred_global

    numofloops_thred_ddtds_1 = numofloops_thred_global

    numofloops_thred_ddtds_energybal_1 = numofloops_thred_global
    numofloops_thred_ddtds_energybal_2 = numofloops_thred_global

    numofloops_thred_comp_bc_ice_1 = numofloops_thred_global
    numofloops_thred_comp_bc_ice_2 = numofloops_thred_global

    numofloops_thred_timeloop_1    = numofloops_thred_global

    numofloops_thred_infheat_c_1   = numofloops_thred_global

    numofloops_thred_infheat_d_1   = numofloops_thred_global

    numofloops_thred_infevap_1 = numofloops_thred_global

    numofloops_thred_updatedd_1 = numofloops_thred_global
    numofloops_thred_updatedd_2 = numofloops_thred_global

    numofloops_thred_updatedd_ener_1 = numofloops_thred_global
    numofloops_thred_updatedd_ener_2 = numofloops_thred_global
    numofloops_thred_updatedd_ener_3 = numofloops_thred_global

    numofloops_thred_ddvsflow_1  = numofloops_thred_global

    numofloops_thred_seepfdd_1   = numofloops_thred_global

    numofloops_thred_tstepvs_1   = numofloops_thred_global

    numofloops_thred_updatevs_1  = numofloops_thred_global
    numofloops_thred_updatevs_2  = numofloops_thred_global

    numofloops_thred_seepface_1  = numofloops_thred_global

    numofloops_thred_soilparm_1  = numofloops_thred_global

    numofloops_thred_msysdd_1 = numofloops_thred_global
    numofloops_thred_msysdd_2 = numofloops_thred_global
    numofloops_thred_msysdd_3 = numofloops_thred_global

    numofloops_thred_msysvs_1  = numofloops_thred_global

    numofloops_thred_mbalvs_1  = numofloops_thred_global
    numofloops_thred_mbalvs_2  = numofloops_thred_global
    numofloops_thred_mbalvs_3  = numofloops_thred_global

    numofloops_thred_energysys_1  = numofloops_thred_global

    numofloops_thred_energy_bal_1 = numofloops_thred_global
    numofloops_thred_energy_bal_2 = numofloops_thred_global

    numofloops_thred_velodd_1 = numofloops_thred_global

    numofloops_thred_nexttime_1 = numofloops_thred_global
    numofloops_thred_nexttime_2 = numofloops_thred_global

    numofloops_thred_infcvs_1 = numofloops_thred_global

    numofloops_thred_xyzcoord_1  = numofloops_thred_global

    numofloops_thred_cvolume_1 = numofloops_thred_global

    numofloops_thred_iajavs_1 = numofloops_thred_global
    numofloops_thred_iajavs_2 = numofloops_thred_global

    numofloops_thred_iajavs_dp_1 = numofloops_thred_global

    numofloops_thred_iajavs_ener_1 = numofloops_thred_global
    numofloops_thred_iajavs_ener_2 = numofloops_thred_global

    numofloops_thred_matrix_uti_1 = numofloops_thred_global

    numofloops_thred_initpppm_1     = numofloops_thred_global

    numofloops_thred_initppvs_1     = numofloops_thred_global
    numofloops_thred_initppvs_2     = numofloops_thred_global

    numofloops_thred_initppdd_1     = numofloops_thred_global

    numofloops_thred_initppeb_1     = numofloops_thred_global
    numofloops_thred_initppeb_2     = numofloops_thred_global

    numofloops_thred_initicvs_1     = numofloops_thred_global

    numofloops_thred_initsatw_1     = numofloops_thred_global
    numofloops_thred_initsatw_2     = numofloops_thred_global
    numofloops_thred_initsatw_3     = numofloops_thred_global

    numofloops_thred_initicener_1   = numofloops_thred_global

    numofloops_thred_initprob_1     = numofloops_thred_global
    numofloops_thred_initprob_2     = numofloops_thred_global

    numofloops_thred_initicrt_1     = numofloops_thred_global

    numofloops_thred_initicdd_1     = numofloops_thred_global

    numofloops_thred_restart_1      = numofloops_thred_global

    numofloops_thred_batreac_1      = numofloops_thred_global
    numofloops_thred_batreac_2      = numofloops_thred_global

    numofloops_thred_intpolt        = numofloops_thred_global

    numofloops_thred_mbaldd_1       = numofloops_thred_global
    numofloops_thred_mbaldd_2       = numofloops_thred_global
    numofloops_thred_mbaldd_3       = numofloops_thred_global
    numofloops_thred_mbaldd_4       = numofloops_thred_global
    
    numofloops_thred_rateh2o_1      = numofloops_thred_global
#endif

end subroutine initsolver_default

!>
!>
!>
subroutine initsolver_final

#ifdef PARDISO
    use solver_pardiso, only :  numofthreads_pardiso,                  &
                                pardiso_initialize_common,             &
                                pardiso_initialize_flow,               &
                                pardiso_initialize_heat,               &
                                pardiso_initialize_react
#endif

#ifdef LIS
    use solver_lis_common, only : lis_default_flow, lis_options_flow,  &
                                  lis_maxit_flow, lis_abstol_flow,     &
                                  lis_default_heat, lis_options_heat,  &
                                  lis_maxit_heat, lis_abstol_heat,     &
                                  lis_default_react, lis_options_react,&
                                  lis_maxit_react, lis_abstol_react

#endif

    implicit none
    
    logical :: bstat
    character(72) :: strbuffer
    
    bstat = .false.

    !Set nthreads
#ifdef OPENMP
    nthreads = numofthreads_global
    if (i_solver_type_flow == 0 .or. i_solver_type_heat == 0 .or.      &
        i_solver_type_react == 0) then
      if(nthreads < numofthreads_ws209) then
        nthreads = numofthreads_ws209
      end if
    end if
#ifdef PARDISO
    if (i_solver_type_flow == 1 .or. i_solver_type_heat == 1 .or.      &
        i_solver_type_react == 1) then
      if(nthreads < numofthreads_pardiso) then
        nthreads = numofthreads_pardiso
      end if
    end if
#endif

    if(i_matrix_assembly_type_flow > 0) then
      if(nthreads < numofthreads_matrix_flow) then
        nthreads = numofthreads_matrix_flow
      end if
    end if
    
    if(i_matrix_assembly_type_heat > 0) then
      if(nthreads < numofthreads_matrix_heat) then
        nthreads = numofthreads_matrix_heat
      end if
    end if

    if(i_matrix_assembly_type_react > 0) then
      if(nthreads < numofthreads_matrix_react) then
        nthreads = numofthreads_matrix_react
      end if
    end if    
#endif
   
    if (i_solver_type_flow == 1 .or. (i_solver_type_flow == 0 .and.    &
        b_solver_test_pardiso .eqv. .true.)) then
#ifdef PARDISO   
      call pardiso_initialize_flow
      bstat = .true.
#else
      i_solver_type_flow = 0
      if(rank == 0) then
        write(*,'(2a)') "The program is compiled without the environment of ", &
                        "Pardiso, use the default solver ws209 instead."
      end if
#endif
    end if

    if (i_solver_type_heat == 1 .or. (i_solver_type_heat == 0 .and.    &
        b_solver_test_pardiso .eqv. .true.)) then
#ifdef PARDISO   
      call pardiso_initialize_heat
      bstat = .true.
#else
      i_solver_type_heat = 0
      if(rank == 0) then
        write(*,'(2a)') "The program is compiled without the environment of ", &
                        "Pardiso, use the default solver ws209 instead."
      end if
#endif
    end if    
    
    if (i_solver_type_react == 1 .or. (i_solver_type_react == 0 .and.  &
        b_solver_test_pardiso .eqv. .true.)) then
#ifdef PARDISO   
      call pardiso_initialize_react
      bstat = .true.
#else
      i_solver_type_react = 0
      if(rank == 0) then
        write(*,'(2a)') "The program is compiled without the environment of ", &
                       "Pardiso, use the default solver ws209 instead."
      end if
#endif
    end if

#ifndef PETSC
    if (i_solver_type_flow == 2 .or. i_solver_type_heat == 2 .or.      &
        i_solver_type_react == 2) then
      if (rank == 0) then
        write(*,'(a)') "Error: PETSc is required for PETSc solver"
        write(ilog,'(a)') "Error: PETSc is required for PETSc solver"
      end if
    end if
#endif

#ifdef LIS
    if (i_solver_type_flow == 3 .and. lis_default_flow) then
#ifdef OPENMP
      if (index(lis_options_flow,"-omp_num_threads") < 1) then
        write(strbuffer,*) numofthreads_global
        lis_options_flow = trim(lis_options_flow)//" -omp_num_threads "//trim(strbuffer)
      end if
#endif
      lis_options_flow = trim(lis_options_flow)//" -p ilu"

      write(strbuffer,*) lis_abstol_flow
      lis_options_flow = trim(lis_options_flow)//" -tol "//trim(strbuffer)

      write(strbuffer,*) lis_maxit_flow
      lis_options_flow = trim(lis_options_flow)//" -maxiter "//trim(strbuffer)
    end if

    if (i_solver_type_heat == 3 .and. lis_default_heat) then
#ifdef OPENMP
      if (index(lis_options_heat,"-omp_num_threads") < 1) then
        write(strbuffer,*) numofthreads_global
        lis_options_heat = trim(lis_options_heat)//" -omp_num_threads "//trim(strbuffer)
      end if
#endif
      lis_options_heat = trim(lis_options_heat)//" -p ilu"

      write(strbuffer,*) lis_abstol_heat
      lis_options_heat = trim(lis_options_heat)//" -tol "//trim(strbuffer)

      write(strbuffer,*) lis_maxit_heat
      lis_options_heat = trim(lis_options_heat)//" -maxiter "//trim(strbuffer)
    end if

    if (i_solver_type_react == 3 .and. lis_default_react) then
#ifdef OPENMP
      if (index(lis_options_react,"-omp_num_threads") < 1) then
        write(strbuffer,*) numofthreads_global
        lis_options_react = trim(lis_options_react)//" -omp_num_threads "//trim(strbuffer)
      end if
#endif
      lis_options_react = trim(lis_options_react)//" -p ilu"

      write(strbuffer,*) lis_abstol_react
      lis_options_react = trim(lis_options_react)//" -tol "//trim(strbuffer)

      write(strbuffer,*) lis_maxit_react
      lis_options_react = trim(lis_options_react)//" -maxiter "//trim(strbuffer)
    end if
#endif

#ifndef LIS
    if (i_solver_type_flow == 3 .or. i_solver_type_heat == 3 .or.      &
        i_solver_type_react == 3) then
      if (rank == 0) then
        write(*,'(a)') "Error: LIS is required for PETSc solver"
        write(ilog,'(a)') "Error: LIS is required for PETSc solver"
      end if
    end if
#endif
    
    if (bstat) then
#ifdef PARDISO
        call pardiso_initialize_common
#else
        if(rank == 0) then
          write(*,'(2a)') "The program is compiled without the environment of ", &
                          "Pardiso, use the default solver ws209 instead."
        end if
#endif
    end if

end subroutine initsolver_final

!>
!> read solver parameters from commands, including PETSc command
!> e.g., -log_view -flow_ksp_gmres_restart 300 -flow_pc_type asm 
!> -flow_pc_factor_shift_type nonzero -flow_sub_pc_type ilu 
!> -flow_sub_pc_factor_shift_type nonzero -flow_ksp_max_it 1000 
!> -react_ksp_gmres_restart 300 -react_pc_type asm 
!> -react_pc_factor_shift_type nonzero -react_sub_pc_type ilu 
!> -react_sub_pc_factor_shift_type nonzero -react_ksp_max_it 1000 
!> -heat_ksp_gmres_restart 300 -heat_pc_type asm 
!> -heat_pc_factor_shift_type nonzero -heat_sub_pc_type ilu 
!> -heat_sub_pc_factor_shift_type nonzero -heat_ksp_max_it 1000
!>
subroutine solver_get_args()

    use file_utility, only : makelowercase

#ifdef PARDISO
    use solver_pardiso, only :  numofthreads_pardiso, max_refine_itersteps_flow, &
        max_refine_itersteps_heat, max_refine_itersteps_react,                   &
        npivotpertubation_flow, npivotpertubation_heat, npivotpertubation_react, &
        i_cgs_criterion_flow, i_cgs_criterion_heat, i_cgs_criterion_react
#endif

#ifdef PETSC
    use solver_snes_common, only : strKSPType_flow, rtol_flow, abstol_flow,    &
        dtol_flow, maxits_flow, strKSPType_heat, rtol_heat, abstol_heat,       &
        dtol_heat, maxits_heat, strKSPType_react, rtol_react, abstol_react,    &
        dtol_react, strKSPNormType_flow, strKSPNormType_heat,                  &
        strKSPNormType_react, maxits_react,                                    &
        strPCType_flow, strKSPConvergenceType_flow,                            &
        strPCType_heat, strKSPConvergenceType_heat,                            &
        strPCType_react, strKSPConvergenceType_react,                          &
        pc_factor_shift_flow, pc_factor_shift_heat, pc_factor_shift_react,     &
        pc_factor_level_flow, pc_factor_level_heat, pc_factor_level_react,     &
        b_use_petsc_default_flow, b_use_petsc_default_heat,                    &
        b_use_petsc_default_react, b_check_norm_flow, b_check_norm_heat,       &
        b_check_norm_react, b_form_initial_guess_flow,                         &
        b_form_initial_guess_heat, b_form_initial_guess_react,                 &
        b_initial_guess_nonzero_flow, b_reuse_preconditioner_flow,             &
        b_initial_guess_nonzero_heat, b_reuse_preconditioner_heat,             &
        b_initial_guess_nonzero_react, b_reuse_preconditioner_react,           &
        stencil_width, partitioner_type, interpolate
#endif

#ifdef LIS
    use solver_lis_common, only : lis_default_flow, lis_options_flow,          &
                                  lis_maxit_flow, lis_abstol_flow,             &
                                  lis_default_heat, lis_options_heat,          &
                                  lis_maxit_heat, lis_abstol_heat,             &
                                  lis_default_react, lis_options_react,        &
                                  lis_maxit_react, lis_abstol_react
                                 
#endif


    implicit none

    integer :: i
    character(len=256) :: arg, arg_pre
    character(len=72) :: strbuffer

    !initialize some input arguments that can be read from both input file and solver configuration file
    b_solver_cfg_arg = .false.
    call initsolver_default

    if(command_argument_count() == 0 .and. prefix == '') then
      read(*,'(a256)') prefix
      return
    end if

    !i = 0 -> program name
    !i = 1 -> input file name
    call get_command_argument(0, arg)
    if(rank == 0) then
      write(*, '(1x,2a)') "Program path: ", trim(arg)
    end if

    if (prefix == '') then
      call get_command_argument(1, arg)
      !Check if the first parameter is command, which begins with "-"
      if(arg(1:1) /= "-") then
        if(rank == 0) then
          write(*, '(1x,2a)') "Input file name: ", trim(arg)
        end if
        prefix = arg
      end if
    end if

    if(command_argument_count() < 2) then
      return
    end if

    arg_pre = ""
    if(arg(1:1) == "-") then
      i = 1
    else
      i = 2
    end if
      
#ifdef PETSC
    b_use_petsc_default_flow = .false.
    b_use_petsc_default_heat = .false.
    b_use_petsc_default_react = .false.
    b_check_norm_flow = .false.
    b_check_norm_heat = .false.
    b_check_norm_react = .false.
#endif

    do
      call get_command_argument(i, arg)
      call makelowercase(arg)

      select case (trim(arg_pre))

        case ("-solver_configuration_file")
          str_solvercfg = trim(arg)
          if (rank == 0) then
            write (*,'(2a)') "solver configuration file: ", trim(arg)
          end if
          b_solver_cfg_arg = .true.
          return

        case ("-input_file")
          prefix = trim(arg)
          if(rank == 0) then
            write(*, '(2a)') "Input file name: ", trim(arg)
          end if

        case ("-solver_type")
          read(arg, *) i_solver_type
#ifdef PETSC
          if (nprcs > 1 .and. i_solver_type < 2) then
            i_solver_type = 2
            if(rank == 0) then
              write(*,'(a,i6)') "Solver type is forced to: ", i_solver_type
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Solver type is: ", i_solver_type
            end if
          end if
#elif LIS
          if (nprcs > 1 .and. i_solver_type < 3) then
            i_solver_type = 3
            if(rank == 0) then
              write(*,'(a,i6)') "Solver type is forced to: ", i_solver_type
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Solver type is: ", i_solver_type
            end if
          end if
#else
          if (i_solver_type > 0) then
            i_solver_type = 0
          end if
          if(rank == 0) then
            write(*,'(a,i6)') "Solver type is forced to: ", i_solver_type
          end if
#endif

#ifndef PETSC
          if (i_solver_type == 2) then
            i_solver_type = 0
            if(rank == 0) then
              write(ilog,'(2a,i6)') "PETSc is not found, ",        &
                    "solver type is reforced to: ",                &
                    i_solver_type
            end if
          end if
#endif

#ifndef LIS
          if (i_solver_type == 3) then
#ifdef PETSC
            i_solver_type = 2
#else
            i_solver_type = 0
#endif

            if(rank == 0) then
              write(ilog,'(2a,i6)') "LIS is missing, ",            &
                    "solver type is forced to: ",                  &
                    i_solver_type
            end if
          end if
#endif

          i_solver_type_flow = i_solver_type
          i_solver_type_heat = i_solver_type
          i_solver_type_react = i_solver_type

        case ("-solver_type_flow")
          read(arg, *) i_solver_type_flow
#ifdef PETSC
          if (nprcs > 1 .and. i_solver_type_flow < 2) then
            i_solver_type_flow = 2
            if(rank == 0) then
              write(*,'(a,i6)') "Flow solver type is forced to: ", i_solver_type_flow
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Flow solver type is: ", i_solver_type_flow
            end if
          end if
#elif LIS
          if (nprcs > 1 .and. i_solver_type_flow < 3) then
            i_solver_type_flow = 3
            if(rank == 0) then
              write(*,'(a,i6)') "Flow solver type is forced to: ", i_solver_type_flow
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Flow solver type is: ", i_solver_type_flow
            end if
          end if
#else
          if (i_solver_type_flow > 0) then
            i_solver_type_flow = 0
          end if
          if(rank == 0) then
            write(*,'(a,i6)') "Flow solver type is forced to: ", i_solver_type_flow
          end if
#endif

#ifndef PETSC
          if (i_solver_type_flow == 2) then
            i_solver_type_flow = 0
            if(rank == 0) then
              write(ilog,'(2a,i6)') "PETSc is not found, ",        &
                    "flow solver type is reforced to: ",           &
                    i_solver_type_flow
            end if
          end if
#endif

#ifndef LIS
          if (i_solver_type_flow == 3) then
#ifdef PETSC
            i_solver_type_flow = 2
#else
            i_solver_type_flow = 0
#endif
            if(rank == 0) then
              write(ilog,'(2a,i6)') "LIS is missing, ",            &
                    "flow solver type is forced to: ",             &
                    i_solver_type_flow
            end if
          end if
#endif

        case ("-solver_type_heat")
          read(arg, *) i_solver_type_heat
#ifdef PETSC
          if (nprcs > 1 .and. i_solver_type_heat < 2) then
            i_solver_type_heat = 2
            if(rank == 0) then
              write(*,'(a,i6)') "Heat transport solver type is forced to: ", i_solver_type_heat
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Heat transport solver type is: ", i_solver_type_heat
            end if
          end if
#elif LIS
          if (nprcs > 1 .and. i_solver_type_heat < 3) then
            i_solver_type_heat = 3
            if(rank == 0) then
              write(*,'(a,i6)') "Heat transport solver type is forced to: ", i_solver_type_heat
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Heat transport solver type is: ", i_solver_type_heat
            end if
          end if
#else
          if (i_solver_type_heat > 0) then
            i_solver_type_heat = 0
          end if
          if(rank == 0) then
            write(*,'(a,i6)') "Heat transport solver type is forced to: ", i_solver_type_heat
          end if
#endif

#ifndef PETSC
          if (i_solver_type_heat == 2) then
            i_solver_type_heat = 0
            if(rank == 0) then
              write(ilog,'(2a,i6)') "PETSc is not found, ",        &
                    "flow solver type is reforced to: ",           &
                    i_solver_type_heat
            end if
          end if
#endif

#ifndef LIS
          if (i_solver_type_heat == 3) then
#ifdef PETSC
            i_solver_type_heat = 2
#else
            i_solver_type_heat = 0
#endif
            if(rank == 0) then
              write(ilog,'(2a,i6)') "LIS is missing, ",            &
                    "flow solver type is forced to: ",             &
                    i_solver_type_heat
            end if
          end if
#endif

        case ("-solver_type_react")
          read(arg, *) i_solver_type_react
#ifdef PETSC
          if (nprcs > 1 .and. i_solver_type_react < 2) then
            i_solver_type_react = 2
            if(rank == 0) then
              write(*,'(a,i6)') "Reactive transport solver type is forced to: ", &
                                i_solver_type_react
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Reactive transport solver type is: ",           &
                                 i_solver_type_react
            end if
          end if
#elif LIS
          if (nprcs > 1 .and. i_solver_type_react < 3) then
            i_solver_type_react = 3
            if(rank == 0) then
              write(*,'(a,i6)') "Reactive transport solver type is forced to: ", &
                                i_solver_type_react
            end if
          else
            if(rank == 0) then
              write(*,'(a,i6)') "Reactive transport solver type is: ",           &
                                i_solver_type_react
            end if
          end if

#else
          if (i_solver_type_react > 0) then
            i_solver_type_react = 0
          end if
          if(rank == 0) then
            write(*,'(a,i6)') "Reactive transport solver type is forced to: ",   &
                              i_solver_type_react
          end if
#endif

#ifndef PETSC
          if (i_solver_type_react == 2) then
            i_solver_type_react = 0
            if(rank == 0) then
              write(ilog,'(2a,i6)') "PETSc is not found, ",            &
                    "reactive transport solver type is reforced to: ", &
                    i_solver_type_react
            end if
          end if
#endif

#ifndef LIS
          if (i_solver_type_react == 3) then
#ifdef PETSC
            i_solver_type_react = 2
#else
            i_solver_type_react = 0
#endif
            if(rank == 0) then
              write(ilog,'(2a,i6)') "LIS is missing, ",                  &
                    "reactive transport flow solver type is forced to: ",&
                    i_solver_type_react
            end if
          end if
#endif

#ifdef OPENMP

        case ("-use_numofthreads_from_mpi")
#ifdef PETSC
          b_use_mpi_nprcs_omp_nthreads = .true.
          numofthreads_global = nthreads_per_proc
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "global number of threads will be reset by mpi calling ",    &
                  nthreads_per_proc
          end if
#endif

        case ("-numofthreads_global")
         read(arg, *) numofthreads_global
         if(rank == 0) then
           write(*,'(a,i6)') "global number of threads: ", numofthreads_global
         end if
#ifdef PARDISO
         numofthreads_pardiso = numofthreads_global
#endif
         numofthreads_matrix_flow = numofthreads_global
         numofthreads_matrix_heat = numofthreads_global
         numofthreads_matrix_react = numofthreads_global
         numofthreads_ws209 = numofthreads_global
         numofloops_thred_global = numofthreads_global

        case ("-numofloops_thred_global")
          read(arg, *) numofloops_thred_global
          if(rank == 0) then
            write(*,'(a,i6)') "global number of loops threshold: ",    &
                              numofloops_thred_global
          end if

        ! Block:  Matrix assembly setting for flow
        case ("-matrix_assembly_type_flow")
          read(arg, *) i_matrix_assembly_type_flow
          if(rank == 0) then
            write(*,'(a,i6)') "Type of matrix assembly in flow is: ", &
                  i_matrix_assembly_type_flow
          end if

        case ("-numofthreads_matrix_flow")
          read(arg, *) numofthreads_matrix_flow
#ifdef PETSC
          if(b_use_mpi_nprcs_omp_nthreads) then
            numofthreads_matrix_flow = nthreads_per_proc
          end if
#endif
          if(rank == 0) then
            write(*,'(a,i6)')                                          &
                  "Number of threads for matrix assembly in flow is: ",&
                  numofthreads_matrix_flow
          end if

        case ("-schedule_type_flow")
          read(arg, *) i_schedule_type_flow
          if(rank == 0) then
            write(*,'(a,i6)') "Schedule type in matrix assembly in flow is: ", &
                  i_schedule_type_flow
          end if

        case ("-chunksize_factor_flow")
          read(arg, *) i_chunksize_factor_flow
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Chunk size factor for matrix assembly in flow is: ",        &
                  i_chunksize_factor_flow
          end if

        ! Block:  Matrix assembly setting for heat transport
        case ("-matrix_assembly_type_heat")
          read(arg, *) i_matrix_assembly_type_heat
          if(rank == 0) then
            write(*,'(a,i6)') "Type of matrix assembly in heat transport is: ", &
                  i_matrix_assembly_type_heat
          end if

        case ("-numofthreads_matrix_heat")
          read(arg, *) numofthreads_matrix_heat
#ifdef PETSC
          if(b_use_mpi_nprcs_omp_nthreads) then
            numofthreads_matrix_heat = nthreads_per_proc
          end if
#endif
          if(rank == 0) then
            write(*,'(a,i6)')                                          &
                  "Number of threads for matrix assembly in heat transport is: ",&
                  numofthreads_matrix_heat
          end if

        case ("-schedule_type_heat")
          read(arg, *) i_schedule_type_heat
          if(rank == 0) then
            write(*,'(a,i6)') "Schedule type in matrix assembly in heat transport is: ", &
                  i_schedule_type_heat
          end if

        case ("-chunksize_factor_heat")
          read(arg, *) i_chunksize_factor_heat
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Chunk size factor for matrix assembly in heat transport is: ",        &
                  i_chunksize_factor_heat
          end if

        ! Block:  Matrix assembly setting for reactive transport 
        case ("-matrix_assembly_type_react")
          read(arg, *) i_matrix_assembly_type_react
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Type of matrix assembly in reactive transport is: ",        &
                  i_matrix_assembly_type_react
          end if
          i_matrix_assembly_type_jacrt = i_matrix_assembly_type_react
          i_matrix_assembly_type_jacbrt = i_matrix_assembly_type_react

        case ("-matrix_assembly_type_jacrt")
          read(arg, *) i_matrix_assembly_type_jacrt
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Type of matrix assembly in reactive transport jacrt is: ",  &
                  i_matrix_assembly_type_jacrt
          end if

        case ("-matrix_assembly_type_jacbrt")
          read(arg, *) i_matrix_assembly_type_jacbrt
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Type of matrix assembly in reactive transport jacbrt is: ", &
                  i_matrix_assembly_type_jacbrt
          end if

        case ("-numofthreads_matrix_react")
          read(arg, *) numofthreads_matrix_react
#ifdef PETSC
          if(b_use_mpi_nprcs_omp_nthreads) then
            numofthreads_matrix_react = nthreads_per_proc
          end if
#endif
          if(rank == 0) then
            write(*,'(2a,i6)') "Number of threads for matrix assembly in ",    &
                  "reactive transport is: ", numofthreads_matrix_react
          end if

        case ("-schedule_type_react")
          read(arg, *) i_schedule_type_react
          if(rank == 0) then
            write(*,'(2a,i6)') "Schedule type in matrix assembly in ",         &
                  "reactive transport is: ", i_schedule_type_react
          end if

        case ("-chunksize_factor_react")
          read(arg, *) i_chunksize_factor_react
          if(rank == 0) then
            write(*,'(2a,i6)') "Chunk size factor for matrix assembly in ",    &
                  "reactive transport is: ", i_chunksize_factor_react
          end if

        ! Block:  Pardiso solver setting
#ifdef PARDISO
        case ("-solver_test_pardiso")
          b_solver_test_pardiso = .true.
          if(rank == 0) then
            write(*,'(a,l2)') "pardiso solver test: ", b_solver_test_pardiso
          end if

        case ("-numofthreads_pardiso")
          read(arg, *) numofthreads_pardiso
#ifdef PETSC
          if(b_use_mpi_nprcs_omp_nthreads) then
              numofthreads_pardiso = nthreads_per_proc
          end if
#endif
          if(rank == 0) then
            write(*,'(a,i6)') "Number of threads for Pardiso is: ",            &
                              numofthreads_pardiso
          end if

        case ("-max_refine_itersteps_flow")
          read(arg, *) max_refine_itersteps_flow
          if(rank == 0) then
            write(*,'(a,i6)') "maximum iterative refinement steps in flow: ",  &
                  max_refine_itersteps_flow
          end if

        case ("-max_refine_itersteps_heat")
          read(arg, *) max_refine_itersteps_heat
          if(rank == 0) then
            write(*,'(2a,i6)') "maximum iterative refinement steps in ",       &
                  "heat transport: ",max_refine_itersteps_heat
          end if

        case ("-max_refine_itersteps_react")
          read(arg, *) max_refine_itersteps_react
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "maximum iterative refinement steps in reactive transport: ",&
                  max_refine_itersteps_react
          end if

        case ("-npivotpertubation_flow")
          read(arg, *) npivotpertubation_flow
          if(rank == 0) then
            write(*,'(a,i6)') "pivoting perturbation in flow: ",               &
                              npivotpertubation_flow
          end if

        case ("-npivotpertubation_heat")
          read(arg, *) npivotpertubation_heat
          if(rank == 0) then
            write(*,'(a,i6)') "pivoting perturbation in heat transport: ",     &
                              npivotpertubation_heat
          end if

        case ("-npivotpertubation_react")
          read(arg, *) npivotpertubation_react
          if(rank == 0) then
            write(*,'(a,i6)') "pivoting perturbation in reactive transport: ", &
                  npivotpertubation_react
          end if

        case ("-cgs_criterion_flow")
          read(arg, *) i_cgs_criterion_flow
          if(rank == 0) then
            write(*,'(a,i6)') "Preconditioned CGS in flow: ", i_cgs_criterion_flow
          end if

        case ("-cgs_criterion_heat")
          read(arg, *) i_cgs_criterion_heat
          if(rank == 0) then
            write(*,'(a,i6)') "Preconditioned CGS in heat transport: ",        &
                              i_cgs_criterion_heat
          end if          

        case ("-cgs_criterion_react")
          read(arg, *) i_cgs_criterion_react
          if(rank == 0) then
            write(*,'(a,i6)') "Preconditioned CGS in reactive transport: ",    &
                  i_cgs_criterion_react
          end if

        case ("-max_iteration_flow")
          read(arg, *) n_max_iteration_flow
          if(rank == 0) then
            write(*,'(a,i6)') "maximum solver iteration in flow: ",            &
                              n_max_iteration_flow
          end if

        case ("-max_iteration_heat")
          read(arg, *) n_max_iteration_heat
          if(rank == 0) then
            write(*,'(a,i6)') "maximum solver iteration in heat transport: ",  &
                              n_max_iteration_heat
          end if

        case ("-max_iteration_react")
          read(arg, *) n_max_iteration_react
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "maximum solver iteration in reactive transport: ",          &
                  n_max_iteration_react
          end if

        case ("-max_residual_flow")
          read(arg, *) r_max_residual_flow
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)') "maximum residual in flow: ",             &
                                     r_max_residual_flow
          end if

        case ("-max_residual_heat")
          read(arg, *) r_max_residual_heat
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)') "maximum residual in heat transport: ",   &
                                     r_max_residual_heat
          end if

        case ("-max_residual_react")
          read(arg, *) r_max_residual_react
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)')                                           &
                  "maximum residual in reactive transport: ",                  &
                  r_max_residual_react
          end if

        case ("-symfactor_type_flow")
          read(arg, *) i_symfactor_type_flow
          if(rank == 0) then
            write(*,'(a,i6)') "Symbolic factorization type in flow is: ",      &
                              i_symfactor_type_flow
          end if

        case ("-symfactor_type_heat")
          read(arg, *) i_symfactor_type_heat
          if(rank == 0) then
            write(*,'(2a,i6)') "Symbolic factorization type in ",              &
                              "heat transport is: ", i_symfactor_type_heat
          end if

        case ("-symfactor_type_react")
          read(arg, *) i_symfactor_type_react
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Symbolic factorization type in reactive transport is: ",    &
                  i_symfactor_type_react
          end if
#endif

#endif

          ! Block:  PETSc solver setting
#ifdef PETSC
        case ("-solver_test_petsc")
          b_solver_test_petsc = .true.
          if(rank == 0) then
            write(*,'(a,l2)') "petsc solver test: ", b_solver_test_petsc
          end if

        case ("-stencil_width")
          read(arg, *) stencil_width
          if(rank == 0) then
            write(*,'(a,i6)') "PETSc stencil width: ", stencil_width
          end if

        case ("-interpolate")
          read(arg, *) interpolate
          if(rank == 0) then
            write(*,'(a,l1)')                                          &
                  "PETSc: create faces and edges in the mesh: ",       &
                  interpolate
          end if

        case ("-partitioner_type")
          read(arg, *) partitioner_type
          if(rank == 0) then
            write(*,'(2a)') "PETSc partitioner type: ", trim(partitioner_type)
          end if

        case ("-use_petsc_default_flow")
          b_use_petsc_default_flow = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc use default configuration for flow problem"
          end if

        case ("-ksptype_flow")
          read(arg, *) strKSPType_flow
          if(rank == 0) then
            write(*,'(2a)') "PETSc Krylov method for flow problem: ",          &
                            trim(strKSPType_flow)
          end if

        case ("-pctype_flow")
          read(arg, *) strPCType_flow
          if(rank == 0) then
            write(*,'(2a)') "PETSc preconditioner type for flow problem: ",    &
                 trim(strPCType_flow)
          end if

        case ("-pcfactor_level_flow")
          read(arg, *) pc_factor_level_flow
          if(rank == 0) then
            write(*,'(a,i6)') "PETSc factorization level for flow problem: ",  &
                 pc_factor_level_flow
          end if

        case ("-ksp_initial_guess_nonzero_flow")
          b_initial_guess_nonzero_flow = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc use nonzero initial guess for flow problem."
          end if

        case ("-ksp_form_initial_guess_flow")
          b_form_initial_guess_flow = .true.
          if(rank == 0) then
            write(ilog,'(a)') "PETSc form initial guess for flow problem."
          end if

        case ("-ksp_reuse_preconditioner_flow")
          b_reuse_preconditioner_flow = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc reuse preconditioner for flow problem."
          end if

        case ("-ksp_check_norm_flow")
          b_check_norm_flow = .true.
          if(rank == 0) then
            write(ilog,'(a)') "PETSc check direct solver norm in flow."
          end if

        case ("-kspconvergencetype_flow")
          read(arg, *) strKSPConvergenceType_flow
          if(rank == 0) then
            write(*,'(2a)') "PETSc convergence criteria for flow problem: ",   &
                 trim(strKSPConvergenceType_flow)
          end if

        case ("-pc_factor_shift_type_flow")
          read(arg, *) pc_factor_shift_flow
          if(rank == 0) then
            write(*,'(2a)') "PETSc PC factor shift type in flow: ",            &
                            trim(pc_factor_shift_flow)
          end if

        case ("-rtol_flow")
          read(arg, *) rtol_flow
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)')                                           &
                  "PETSc relative convergence tolerance in flow: ", rtol_flow
          end if

        case ("-abstol_flow")
          read(arg, *) abstol_flow
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)')                                           &
                  "PETSc absolute convergence tolerance in flow: ", abstol_flow
          end if

        case ("-dtol_flow")
          read(arg, *) dtol_flow
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)') "PETSc divergence tolerance in flow: ",   &
                                     dtol_flow
          end if

        case ("-maxits_flow")
          read(arg, *) maxits_flow
          if(rank == 0) then
            write(*,'(a,i6)') "PETSc Maximum number of iterations in flow: ",  &
                              maxits_flow
          end if

        case ("-use_petsc_default_heat")
          b_use_petsc_default_heat = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc use default configuration for heat transport problem"
          end if

        case ("-ksptype_heat")
          read(arg, *) strKSPType_heat
          if(rank == 0) then
            write(*,'(2a)') "PETSc Krylov method for heat transport problem: ",          &
                            trim(strKSPType_heat)
          end if

        case ("-pctype_heat")
          read(arg, *) strPCType_heat
          if(rank == 0) then
            write(*,'(2a)') "PETSc preconditioner type for heat transport problem: ",    &
                 trim(strPCType_heat)
          end if

        case ("-pcfactor_level_heat")
          read(arg, *) pc_factor_level_heat
          if(rank == 0) then
            write(*,'(a,i6)') "PETSc factorization level for heat transport problem: ",  &
                 pc_factor_level_heat
          end if

        case ("-ksp_initial_guess_nonzero_heat")
          b_initial_guess_nonzero_heat = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc use nonzero initial guess for heat transport problem."
          end if

        case ("-ksp_form_initial_guess_heat")
          b_form_initial_guess_heat = .true.
          if(rank == 0) then
            write(ilog,'(a)') "PETSc form initial guess for heat transport problem."
          end if

        case ("-ksp_reuse_preconditioner_heat")
          b_reuse_preconditioner_heat = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc reuse preconditioner for heat transport problem."
          end if

        case ("-ksp_check_norm_heat")
          b_check_norm_heat = .true.
          if(rank == 0) then
            write(ilog,'(a)') "PETSc check direct solver norm in heat transport."
          end if

        case ("-kspconvergencetype_heat")
          read(arg, *) strKSPConvergenceType_heat
          if(rank == 0) then
            write(*,'(2a)') "PETSc convergence criteria for heat transport problem: ",   &
                 trim(strKSPConvergenceType_heat)
          end if

        case ("-pc_factor_shift_type_heat")
          read(arg, *) pc_factor_shift_heat
          if(rank == 0) then
            write(*,'(2a)') "PETSc PC factor shift type in heat transport: ",            &
                            trim(pc_factor_shift_heat)
          end if

        case ("-rtol_heat")
          read(arg, *) rtol_heat
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)')                                                     &
                  "PETSc relative convergence tolerance in heat transport: ", rtol_heat
          end if

        case ("-abstol_heat")
          read(arg, *) abstol_heat
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)')                                                     &
                  "PETSc absolute convergence tolerance in heat transport: ", abstol_heat
          end if

        case ("-dtol_heat")
          read(arg, *) dtol_heat
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)') "PETSc divergence tolerance in heat transport: ",   &
                                     dtol_heat
          end if

        case ("-maxits_heat")
          read(arg, *) maxits_heat
          if(rank == 0) then
            write(*,'(a,i6)') "PETSc Maximum number of iterations in heat transport: ",  &
                              maxits_heat
          end if

        case ("-use_petsc_default_react")
          b_use_petsc_default_react = .true.
          if(rank == 0) then
            write(*,'(a)') "PETSc use default configuration for reactive transport problem."
          end if

        case ("-ksptype_react")
          read(arg, *) strKSPType_react
          if(rank == 0) then
            write(*,'(2a)')                                                    &
                  "PETSc Krylov method for reactive transport problem: ",      &
                  trim(strKSPType_react)
          end if

        case ("-pctype_react")
          read(arg, *) strPCType_react
          if(rank == 0) then
            write(*,'(2a)')                                                    &
                  "PETSc preconditioner type for reactive transport problem: ",&
                  trim(strPCType_react)
          end if

        case ("-pcfactor_level_react")
          read(arg, *) pc_factor_level_react
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "PETSc factorization level for reactive transport problem: ",&
                  pc_factor_level_react
          end if

        case ("-ksp_initial_guess_nonzero_react")
          b_initial_guess_nonzero_react = .true.
          if(rank == 0) then
            write(*,'(2a)') "PETSc use nonzero as initial guess for ",         &
                            "reactive transport problem."
          end if

        case ("-ksp_form_initial_guess_react")
          b_form_initial_guess_react = .true.
          if(rank == 0) then
            write(ilog,'(2a)') "PETSc form initial guess for ",                &
                               "reactive transport problem."
          end if

        case ("-ksp_reuse_preconditioner_react")
          b_reuse_preconditioner_react = .true.
          if(rank == 0) then
            write(*,'(2a)') "PETSc reuse preconditioner for ",                 &
                            "reactive transport problem."
          end if

        case ("-ksp_check_norm_react")
          b_check_norm_react = .true.
          if(rank == 0) then
            write(ilog,'(a)') "PETSc check direct solver norm in reactive transport."
          end if

        case ("-kspconvergencetype_react")
          read(arg, *) strKSPConvergenceType_react
          if(rank == 0) then
            write(*,'(3a)') "PETSc convergence criteria for ",                 &
                  "reactive transport problem: ",                              &
                  trim(strKSPConvergenceType_react)
          end if

        case ("-pc_factor_shift_type_react")
          read(arg, *) pc_factor_shift_react
          if(rank == 0) then
            write(*,'(2a)')                                                    &
                  "PETSc PC factor shift type in reactive transport: ",        &
                  trim(pc_factor_shift_react)
          end if

        case ("-rtol_react")
          read(arg, *) rtol_react
          if(rank == 0) then
            write(*,'(2a,1pe15.6e3)')                                          &
                  "PETSc relative convergence tolerance in ",                  &
                  "reactive transport: ", rtol_react
          end if

        case ("-abstol_react")
          read(arg, *) abstol_react
          if(rank == 0) then
            write(*,'(2a,1pe15.6e3)')                                          &
                  "PETSc absolute convergence tolerance in ",                  &
                  "reactive transport: ", abstol_react
          end if

        case ("-dtol_react")
          read(arg, *) dtol_react
          if(rank == 0) then
            write(*,'(a,1pe15.6e3)')                                           &
                  "PETSc divergence tolerance in reactive transport: ",        &
                  dtol_react
          end if

        case ("-maxits_react")
          read(arg, *) maxits_react
          if(rank == 0) then
            write(*,'(a,i6)')                                                  &
                  "Maximum number of iterations in reactive transport: ",      &
                  maxits_react
          end if
#endif

#ifdef LIS
        case ("-lis_solver_test")
          b_solver_test_lis = .true.
          if(rank == 0) then
            write(ilog,'(a,l2)') "lis solver test: ", b_solver_test_lis
          end if
          if(.not. b_enable_output) then
            b_solver_test_lis = .false.
          end if

        case ("-lis_flow_use_default")
          lis_default_flow = .true.
          if(rank == 0) then
            write(ilog,'(a)') "LIS use default configuration for flow problem"
          end if

        case ("lis_flow_ksp_type")
          read(arg, *) strbuffer
          lis_options_flow = trim(lis_options_flow)//" -i "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)') "LIS solver method for flow problem: ", trim(strbuffer)
          end if
  
        case ("lis_flow_pc_type")
          read(arg, *) strbuffer
          lis_options_flow = trim(lis_options_flow)//" -p "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)')                                                 &
                  "LIS solver preconditioner type for flow problem: ",         &
                  trim(strbuffer)
          end if

        case ("lis_flow_solver_precision")
          read(arg, *) strbuffer
          lis_options_flow = trim(lis_options_flow)//" -f "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)') "LIS solver precision for flow problem: ",      &
                               trim(strbuffer)
          end if
 
        case ("lis_flow_tol")
          read(arg, *) strbuffer
          read(strbuffer, *) lis_abstol_flow
          lis_options_flow = trim(lis_options_flow)//" -tol "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)') "LIS convergence tolerance for flow problem: ", &
                               trim(strbuffer)
          end if
 
        case ("lis_flow_maxiter")
          read(arg, *) strbuffer
          read(strbuffer, *) lis_maxit_flow
          lis_options_flow = trim(lis_options_flow)//" -maxiter "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)')                                                 &
                  "LIS maximum number of iterations for flow problem: ",       &
                  trim(strbuffer)
          end if

        case ("-lis_heat_use_default")
          lis_default_heat = .true.
          if(rank == 0) then
            write(ilog,'(a)') "LIS use default configuration for heat transport problem"
          end if

        case ("lis_heat_ksp_type")
          read(arg, *) strbuffer
          lis_options_heat = trim(lis_options_heat)//" -i "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)') "LIS solver method for heat transport problem: ", trim(strbuffer)
          end if
  
        case ("lis_heat_pc_type")
          read(arg, *) strbuffer
          lis_options_heat = trim(lis_options_heat)//" -p "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)')                                                           &
                  "LIS solver preconditioner type for heat transport problem: ",         &
                  trim(strbuffer)
          end if

        case ("lis_heat_solver_precision")
          read(arg, *) strbuffer
          lis_options_heat = trim(lis_options_heat)//" -f "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)') "LIS solver precision for heat transport problem: ",      &
                               trim(strbuffer)
          end if
 
        case ("lis_heat_tol")
          read(arg, *) strbuffer
          read(strbuffer, *) lis_abstol_heat
          lis_options_heat = trim(lis_options_heat)//" -tol "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)') "LIS convergence tolerance for heat transport problem: ", &
                               trim(strbuffer)
          end if
 
        case ("lis_heat_maxiter")
          read(arg, *) strbuffer
          read(strbuffer, *) lis_maxit_heat
          lis_options_heat = trim(lis_options_heat)//" -maxiter "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)')                                                           &
                  "LIS maximum number of iterations for heat transport problem: ",       &
                  trim(strbuffer)
          end if

        case ("-lis_react_use_default")
          lis_default_react = .true.
          if(rank == 0) then
            write(ilog,'(2a)') "LIS use default configuration for ",           &
                               "reactive transport problem"
          end if

        case ("lis_react_ksp_type")
          read(arg, *) strbuffer
          lis_options_react = trim(lis_options_react)//" -i "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(2a)')                                                 &
                  "LIS solver method for reactive transport problem: ",        &
                  trim(strbuffer)
          end if
  
        case ("lis_react_pc_type")
          read(arg, *) strbuffer
          lis_options_react = trim(lis_options_react)//" -p "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(3a)') "LIS solver preconditioner type for ",          &
                  "reactive transport problem: ", trim(strbuffer)
          end if

        case ("lis_react_solver_precision")
          read(arg, *) strbuffer
          lis_options_react = trim(lis_options_react)//" -f "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(3a)') "LIS solver precision for ",                    &
                               "reactive transport problem: ", trim(strbuffer)
          end if
 
        case ("lis_react_tol")
          read(arg, *) strbuffer
          read(strbuffer, *) lis_abstol_react
          lis_options_react = trim(lis_options_react)//" -tol "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(3a)') "LIS convergence tolerance for ",               &
                               "reactive transport problem: ", trim(strbuffer)
          end if
 
        case ("lis_react_maxiter")
          read(arg, *) strbuffer
          read(strbuffer, *) lis_maxit_react
          lis_options_react = trim(lis_options_react)//" -maxiter "//trim(strbuffer)
          if(rank == 0) then
            write(ilog,'(3a)') "LIS maximum number of iterations for ",        &
                               "reactive transport problem: ", trim(strbuffer)
          end if

#endif


        ! Block:  ws209 solver setting
        case ("-numofthreads_ws209")
          read(arg, *) numofthreads_ws209
#ifdef PETSC
          if(b_use_mpi_nprcs_omp_nthreads) then
              numofthreads_ws209 = nthreads_per_proc
          end if
#endif
          if(rank == 0) then
            write(*,'(a,i6)') "Number of threads for WS209 Solver is: ",       &
                              numofthreads_ws209
          end if

        ! Block:  Output setting
        case ("-output_runtime")
            if(rank == 0) then
              write(*,'(a)') "output runtime statistics analysis: true"
            end if
            b_prtfile = .true.
        case ("-output_matrix")
            if(rank == 0) then
              write(*,'(a)') "output sparse matrix data set and rhs: true"
            end if
            b_output_matrix = .true.

        case ("-output_matrix_timestep")
            read(arg, *) itimestep_output_matrix
            if(rank == 0) then
              write(*,'(a,i6)')                                             &
                    "output sparse matrix data set and rhs at timestep: ",  &
                    itimestep_output_matrix
            end if

        case ("-type_matrix_format")
            read(arg, *) itype_matrix_format
            if(rank == 0) then
              write(*,'(a,i6)') "Output matrix format is: ", itype_matrix_format
            end if

        case ("-output_condition_number")
            if (rank == 0) then
              write(*,'(a)') "output condition number: true"
            end if
            b_output_condition_number = .true.

        case default
          continue

      end select

      if (len_trim(arg) == 0) then
        exit
      end if

      arg_pre = arg
      i = i+1
    end do

    call initsolver_final

end subroutine solver_get_args

!> release solver
subroutine releasesolver

#ifdef PARDISO
    use solver_pardiso, only : pardiso_release_memory
#endif
    
    implicit none
    
#ifdef PARDISO    
    if (i_solver_type == 1 .or. i_solver_type_flow == 1 .or.           &
        i_solver_type_react == 1 .or.                                  &
        b_solver_test_pardiso .eqv. .true.) then
      call pardiso_release_memory
    end if
#endif

end subroutine releasesolver

!> allocate memory for parallel variables used in the model
subroutine mem_solver

    implicit none
    
    !integer*4 :: ierr
    !
    !external :: CheckErr
    !
#ifdef OPENMP          
    allocate (string_omp(numofthreads_global), stat = ierr)
    string_omp = ""
    call checkerr(ierr,'string_omp',ilog)
    call memory_monitor(sizeof(string_omp),'string_omp',.true.)

    allocate (maxvol_omp(numofthreads_global), stat = ierr)
    maxvol_omp = 0
    call checkerr(ierr,'maxvol_omp',ilog)
    call memory_monitor(sizeof(maxvol_omp),'maxvol_omp',.true.)

    allocate (maxval_omp(numofthreads_global), stat = ierr)
    maxval_omp = 0
    call checkerr(ierr,'maxval_omp',ilog)
    call memory_monitor(sizeof(maxval_omp),'maxval_omp',.true.)

    allocate (maxvol_omp2(numofthreads_global), stat = ierr)
    maxvol_omp2 = 0
    call checkerr(ierr,'maxvol_omp2',ilog)
    call memory_monitor(sizeof(maxvol_omp2),'maxvol_omp2',.true.)

    allocate (maxval_omp2(numofthreads_global), stat = ierr)
    maxval_omp2 = 0
    call checkerr(ierr,'maxval_omp2',ilog)
    call memory_monitor(sizeof(maxval_omp2),'maxval_omp2',.true.)

    allocate(bflag_omp1(numofthreads_global), stat = ierr)
    bflag_omp1 = .false.
    call checkerr(ierr,'bflag_omp1',ilog)
    call memory_monitor(sizeof(bflag_omp1),'bflag_omp1',.true.)

    allocate(bflag_omp2(numofthreads_global), stat = ierr)
    bflag_omp2 = .false.
    call checkerr(ierr,'bflag_omp2',ilog)
    call memory_monitor(sizeof(bflag_omp2),'bflag_omp2',.true.)

    allocate(bflag_omp3(numofthreads_global), stat = ierr)
    bflag_omp3 = .false.
    call checkerr(ierr,'bflag_omp3',ilog)
    call memory_monitor(sizeof(bflag_omp3),'bflag_omp3',.true.)

#endif

    !allocate global shared variables that
    allocate(cec(nthreads),stat=ierr)
    cec = 0.0d0
    call checkerr(ierr,'cec',ilog)
    call memory_monitor(sizeof(cec),'cec',.true.)


    allocate(conc_mol_avg(nthreads),stat=ierr)
    conc_mol_avg = 0.0d0
    call checkerr(ierr,'conc_mol_avg',ilog)
    call memory_monitor(sizeof(conc_mol_avg),'conc_mol_avg',.true.)

    allocate(delt_lc(nthreads),stat=ierr)
    delt_lc = 0.0d0
    call checkerr(ierr,'delt_lc',ilog)
    call memory_monitor(sizeof(delt_lc),'delt_lc',.true.)

    allocate(dhad(nthreads),stat=ierr)
    dhad = 0.0d0
    call checkerr(ierr,'dhad',ilog)
    call memory_monitor(sizeof(dhad),'dhad',.true.)

    allocate(dhbd(nthreads),stat=ierr)
    dhbd = 0.0d0
    call checkerr(ierr,'dhbd',ilog)
    call memory_monitor(sizeof(dhbd),'dhbd',.true.)

    allocate(iter_lc(nthreads),stat=ierr)
    iter_lc = 0
    call checkerr(ierr,'iter_lc',ilog)
    call memory_monitor(sizeof(iter_lc),'iter_lc',.true.)

    allocate(ittot_lc(nthreads),stat=ierr)
    ittot_lc = 0
    call checkerr(ierr,'ittot_lc',ilog)
    call memory_monitor(sizeof(ittot_lc),'ittot_lc',.true.)

    allocate(ntstp_lc(nthreads),stat=ierr)
    ntstp_lc = 0
    call checkerr(ierr,'ntstp_lc',ilog)
    call memory_monitor(sizeof(ntstp_lc),'ntstp_lc',.true.)

    allocate(sion1(nthreads),stat=ierr)
    sion1 = 0.0d0
    call checkerr(ierr,'sion1',ilog)
    call memory_monitor(sizeof(sion1),'sion1',.true.)

    allocate(update_activity(nthreads),stat=ierr)
    update_activity = ''
    call checkerr(ierr,'update_activity',ilog)
    call memory_monitor(sizeof(update_activity),'update_activity',.true.)

end subroutine

end module solver
