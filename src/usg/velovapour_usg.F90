!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/velovapour_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine velovapour_usg
!c -------------------
!c
!c compute average interfacial velocities in x,y,z directions 
!c for rectangular, cartesian finite volume discretization
!c
!c
!c written by:     Danyang Su     - Oct 15, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           cinfvs(nn)         = influence coefficient               + -
!c                                (variably saturated flow) 
!c           dimcv(3,nn)        = dimension of cells in x,y,z         + -
!c                                direction
!c           pressure(nn)       = fluid pressure                      + -
!c           density(nn)        = density                             + -
!c           viscosity(nn)      = viscosity                           + -
!c           relperm(nn)        = relative permeability               + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           idbg               = output for debugging information    + -
!c           ilog               = unit number, logbook                + -
!c           ivel               = unit number, average interfacial    + -
!c                                velocities
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes           + -
!c                                in x direction
!c           nvy                = number of control volumes           + -
!c                                in y direction
!c           nvz                = number of control volumes           + -
!c                                in z direction
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           half_cells         = .true.  -> half cells on boundary   + -
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           aread(3,12)        = A_ij/d_ij for current "pseudo
!c                                dispersion element" associated
!c                                with control volume ivol, up to 4
!c                                entries for each dimension
!c           areai              = interfacial area
!c           dflux              = interfacial flux
!c           eps                = constant
!c           r0                 = constant
!c           rhalf              = constant
!c           vel(3)             = average interfacial velocities
!c           gacc               = gravitational acceleration [m s^-2]
!c           dvolcoef           = relperm/viscosity for var_sat flow
!c                              = 1.0/viscosity for fully_sat flow
!c
!c           integer*4:
!c           ----------
!c           cvpair(3,12,2)     = pointers to connected control 
!c                                volumes in each pair for each 
!c                                dimension
!c           i1                 = pointer (connectivity list)
!c           i1sav              = pointer (connectivity list)
!c           idim               = pointer (dimensions)
!c           idim2              = pointer (dimensions)
!c           idim3              = pointer (dimensions)
!c           ipair              = counter (control volume pairs in
!c                                         dimension)
!c           ivol               = pointer (control volume i)
!c           jvol               = pointer (connected control volume j)
!c           ivol2              = counter (control volumes)
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           npair(3)           = number of control volume pairs
!c                                in dimension
!c
!c           character:
!c           ----------
!c           iups               = upstream pointer
!c
!c external: cliqdisp  = find control volume pairs for computation of 
!c                       average interfacial velocities
!c ----------------------------------------------------------------------
#ifdef USG
      subroutine velovapour_usg
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use phys
      use writeversion
      use m_heat_transport, only : ups_heat
      use file_unit, only : lun_get, lun_free
      use dens, only : density
      use math_common
      use geometry
      use usg_mesh_data
      
      use gradient_usg, only : gradient_cross_diff
      use diff_vapour_usg_mod, only : diff_vapour_usg
      use usg_face_utility, only : usg_face_utility_cinfevap_t,        &
                                   usg_face_utility_cinfevap_pa
#ifdef PETSC
#ifdef PETSC_HDF
      use hdf5
      use hdf5_usg
#endif
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC_HDF
      integer :: hdf5_ierr                   ! HDF5 error code
      integer(HID_T) :: file_id              ! File identifier
      integer(HID_T) :: group_id             ! Group identifier
      integer(HID_T) :: plist_id             ! Property list identifier
      integer :: ixmf                        ! XMF file id
#endif

      integer :: i, icon, ivol, jvol, kvol, idvol, icell, istart, iend,&
                 idvol_r, iedge_r, icell2, jtemp, ncell, ndvol, nvel,  &
                 l_sufx, ierr
    
      real*8 :: cvolfacearea, rswitch
      type(point), allocatable :: vels_loc(:)

      real*8 :: rho_av, por_av, sg_av, tortuosity
      
      real*8 :: flux_temp_hls_corr(num_edge_dvols,num_edge_maxcells),   &
                flux_flow_hls_corr(num_edge_dvols,num_edge_maxcells)

      real*8 :: grad_weights(num_crossdifficv_max)

      type(point) :: grad_temp_locs(num_crossdifficv_max),              &
                     grad_flow_locs(num_crossdifficv_max)
      
      type(point) :: grad_temp_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_flow_mids(num_edge_dvols,num_edge_maxcells)
      
      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols),       &
                             grad_temp_hls_loc(num_edge_dvols)

      real*8 :: cinfevap_pa_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfevap_pa_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfevap_t_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfevap_t_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: tortuosity_vap
      external tortuosity_vap

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmall = 1.0d-10,   &
                           r2 = 2.0d0, r3 = 3.0d0,                     &
                           rhalf = 0.5d0, rsmallarea = 1.0d-8

      character*5 suffix
      character*256 strbuffer
      character*256 :: strfilename, strfilename_result, strfilename_mesh

      external :: checkerr

      l_sufx = 0

      if (igstime.lt.10) then

        !write(icnv,'(i1)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i1)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:1)
          l_sufx = 3
        else
          l_sufx = 1
        end if

      elseif (igstime.ge.10.and.igstime.lt.100) then

        !write(icnv,'(i2)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i2)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:2)
          l_sufx = 4
        else
          l_sufx = 2
        end if

      elseif (igstime.ge.100.and.igstime.lt.1000) then

        !write(icnv,'(i3)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i3)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:3)
          l_sufx = 5
        else
          l_sufx = 3
        end if

      elseif (igstime.gt.1000) then
        if (rank == 0) then
          write(ilog,'(/a)')'error in input file'
          write(ilog,'(a)')'max. number of output times exceeded'
          write(ilog,'(a)')'abnormal exit in routine velovapour_usg'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

      end if

!c  ---------------------------------------------------------------------
!c  calculate velocity for nodes based on the interfacial flux
!c  ---------------------------------------------------------------------
      allocate(vels_loc(ncon_usg*num_edge_dvols*num_edge_maxcells), stat = ierr)
      call checkerr(ierr,'velovapour_usg-vels_loc',ilog)
      call memory_monitor(sizeof(vels_loc),'vels_loc',.true.)

      do ivol = 1, nngl           !loop over all volumes

        istart = iavs(ivol)+1     !pointer - start of row
        iend = iavs(ivol+1)-1     !pointer - end of row

        icon = 0                  !counter (connections)
        nvel = 0

        do jtemp = istart, iend   !loop over all connections
          jvol = javs(jtemp)
          icon = icon+1           !counter (connections)
          
          ncell = janumcell(jtemp)

          rho_av = rhalf * (density(ivol) + density(jvol))
          por_av = rhalf * (pornew(ivol) + pornew(jvol))
          sg_av  = rhalf * (sgnew(ivol) + sgnew(jvol))

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
          grad_temp_mids = vector_zero
          flux_temp_hls_corr = r0

          call gradient_cross_diff(jtemp,ivol,jvol,tempnew,            &
                        grad_temp_locs,grad_temp_mids,                 &
                        grad_weights,flux_temp_hls_corr,               &
                        grad_temp_hls_loc)

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
          grad_flow_mids = vector_zero
          flux_flow_hls_corr = r0

          call gradient_cross_diff(jtemp,ivol,jvol,hhead,              &
                        grad_flow_locs,grad_flow_mids,                 &
                        grad_weights,flux_flow_hls_corr,               &
                        grad_flow_hls_loc)

          if (evaporation) then
            if (split_divdensv) then
              call usg_face_utility_cinfevap_t(ivol,jvol,jtemp,        &
                       cinfevap_t_usg_loc,cinfevap_t_usg_cross_loc)
              call usg_face_utility_cinfevap_pa(ivol,jvol,jtemp,       &
                       cinfevap_pa_usg_loc,cinfevap_pa_usg_cross_loc)
            else
              call usg_face_utility_cinfevap_pa(ivol,jvol,jtemp,       &
                       cinfevap_pa_usg_loc,cinfevap_pa_usg_cross_loc)
            end if
          end if

!c calculate the flux at the interface
          tortuosity = tortuosity_vap(pornew(ivol),pornew(jvol),       &
                                      sgnew(ivol),sgnew(jvol))

          if (split_divdensv) then
            do icell = 1, janumcell(jtemp)
              icell2 = jacell(icell,jtemp)
              if (icell2 > 0) then
                do idvol = 1, num_edge_dvols
                  call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,   &
                                               idvol_r,iedge_r,rswitch)
                  cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,     &
                                                  icell2)
                  if(cvolfacearea > rsmallarea) then
                    nvel = nvel + 1
                    vels_loc(nvel) =                                              &
                         CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)*(           &
                         diff_vapour_usg(uvsnew(ivol),uvsnew(jvol),1,1,           &
                              grad_flow_mids(idvol:idvol,icell:icell),            &
                              flux_flow_hls_corr(idvol:idvol,icell:icell),        &
                              r1,r1,r1,r1,r1,r1,                                  &
                              cinfevap_pa_usg_loc(idvol:idvol,icell:icell),       &
                              cinfevap_pa_usg_cross_loc(idvol:idvol,icell:icell), &
                              r1,r1,tortuosity,ups_heat,.false.) +                &
                         diff_vapour_usg(tempnew(ivol),tempnew(jvol),1,1,         &
                              grad_temp_mids(idvol:idvol,icell:icell),            &
                              flux_temp_hls_corr(idvol:idvol,icell:icell),        &
                              r1,r1,r1,r1,r1,r1,                                  &
                              cinfevap_t_usg_loc(idvol:idvol,icell:icell),        &
                              cinfevap_t_usg_cross_loc(idvol:idvol,icell:icell),  &
                              r1,r1,tortuosity,ups_heat,.false.)/cvolfacearea/    &
                              rho_av/sg_av/por_av)
                  end if
                end do
              end if
            end do
          else
            do icell = 1, janumcell(jtemp)
              icell2 = jacell(icell,jtemp)
              if (icell2 > 0) then
                do idvol = 1, num_edge_dvols
                  call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,   &
                                             idvol_r,iedge_r,rswitch)
                  cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)
                  if(cvolfacearea > rsmallarea) then
                    nvel = nvel + 1
                    vels_loc(nvel) =                                              &
                         CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)*(           &
                         diff_vapour_usg(densvnew(ivol),densvnew(jvol),1,1,       &
                              grad_flow_mids(idvol:idvol,icell:icell),            &
                              flux_flow_hls_corr(idvol:idvol,icell:icell),        &
                              r1,r1,r1,r1,r1,r1,                                  &
                              cinfevap_pa_usg_loc(idvol:idvol,icell:icell),       &
                              cinfevap_pa_usg_cross_loc(idvol:idvol,icell:icell), &
                              r1,r1,tortuosity,ups_heat,.false.)/cvolfacearea/    &
                              rho_av/sg_av/por_av)
                  end if
                end do
              end if
            end do
          end if

        end do                    !loop over all connections

        if (grad_average_weighting == 2) then
          vels(ivol) = math_common_min(nvel,vels_loc(1:nvel))
        else if (grad_average_weighting == 1) then
          vels(ivol) = math_common_harmonic(nvel,vels_loc(1:nvel))
        else if (grad_average_weighting == 0) then
          vels(ivol) = math_common_arithmetic(nvel,vels_loc(1:nvel))
        end if

      end do                      !loop over all volumes

      call memory_monitor(-sizeof(vels_loc),'vels_loc',.true.)
      deallocate(vels_loc)

      !c file for result and mesh
      !c note: binary output using separated file for each subdomain is
      !c deprecated for unstructured grid version
      if (b_output_binary) then
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'.velvap'
        if (b_output_separate_mesh_result) then
          strfilename_mesh = prefix(:l_prfx)//'_domain.h5'
          strfilename_result = trim(strfilename)//'.h5'
        else
          strfilename_mesh = trim(strfilename)//'.h5'
          strfilename_result = trim(strfilename)//'.h5'
        end if
      else
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//          &
                      trim(adjustl(str_rank))//'.velvap'
      end if

!c  ---------------------------------------------------------------------
!c  open file for nodal values
!c  ---------------------------------------------------------------------
      if (b_output_binary) then

#ifdef PETSC_HDF
        !c open corresponding xmf file to be loaded by paraview
        if (rank == 0) then
          ixmf = lun_get()
          open(ixmf,file=trim(strfilename)//'.xmf',status='unknown',   &
               form='formatted')
        end if

        !c initialize fortran interface
        call h5open_f(hdf5_ierr)

        !c setup file access property list with parallel I/O access
        call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
        call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,            &
                                MPI_INFO_NULL, hdf5_ierr)
        !c create the file collectively
        call h5fcreate_f(strfilename_result, H5F_ACC_TRUNC_F, file_id, &
                         hdf5_ierr, access_prp = plist_id)

        !c write attribute
        call hdf5_usg_write_attribute(file_id)

        if (.not. b_output_separate_mesh_result) then
          !c write mesh data
          call hdf5_usg_write_mesh_data(file_id)
        end if

        !c open corresponding xmf file for mesh and domain decomposition
        if (rank == 0) then
          call hdf5_usg_write_xmf_initialize(ixmf)
          call hdf5_usg_write_xmf_mesh(ixmf,strfilename_mesh,          &
                    cell_type,num_cells_gbl,num_nodes_gbl,             &
                    num_nodes_per_cell)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_rank",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_rank",            &
                    "Scalar","Cell",num_cells_gbl,1)

          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_lg2g",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_lg2g",            &
                    "Scalar","Cell",num_cells_gbl,1)

          if (b_use_node_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","vertices_matid",      &
                      "Scalar","Node",num_nodes_gbl,1)
          end if
          if (b_use_cell_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","cells_matid",         &
                      "Scalar","Cell",num_cells_gbl,1)
          end if
        end if

        !c create a group for the mesh data set
        strbuffer = "results"
        !c create and open a group
        call h5gcreate_f(file_id,strbuffer,group_id,hdf5_ierr,         &
                         OBJECT_NAMELEN_DEFAULT_F)
#endif
      else
        open(ivelvap,file=trim(strfilename)//'.vtk',status='unknown',  &
             form='formatted')
      end if

      if (rank == 0) then

        if (steady_flow) then

          write(ifls,'(/2a/72a)')'Flow variables, steady ',            &
                                 'state solution',('-',i=1,72)

        else

          write(ifls,'(/a,1pe15.6e3,1x,a,/72a)')                       &
                'Flow variables, T = ',time_io,time_unit,('-',i=1,72)

        end if

        write(ifls,'(/a/)') prefix(:l_prfx)//'_'//                     &
                            suffix(:l_sufx)//'.velvap.vtk'

        write(ifls,'(2a)')                                             &
              'column   entry                           ','unit'
        write(ifls,'(2a)')                                             &
              '1        x                               ','m'
        write(ifls,'(2a)')                                             &
              '2        y                               ','m'
        write(ifls,'(2a)')                                             &
              '3        z                               ','m'
        write(ifls,'(2a)')                                             &
              '4        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '5        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '6        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '7        v                               ','m/d'

      end if


!c  title and mesh variables
      if (.not. b_output_binary) then
        if (steady_flow) then
          call write_mesh_data_vtk_ascii(ivelvap,                      &
                     "Flow variables, steady state")
        else if (transient_flow) then
          write(strbuffer,'(a,1x,1pe15.6e3,1x,a)')                     &
                "Flow variables, solution time = ",time_io,time_unit
          call write_mesh_data_vtk_ascii(ivelvap,trim(adjustl(strbuffer)))
        end if
        write(ivelvap,'(a,1x,i12)') "POINT_DATA",nngl
      end if

      !c write velocity vector
      if (b_output_binary) then
#ifdef PETSC_HDF
        allocate(realbuffer(num_nodes*3), stat = ierr)
        call checkerr(ierr,'velovapour_usg-realbuffer',ilog)
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)

        do ivol = 1, num_nodes
          realbuffer((ivol-1)*3+1) = vels(ivol)%x
          realbuffer((ivol-1)*3+2) = vels(ivol)%y
          realbuffer((ivol-1)*3+3) = vels(ivol)%z
        end do
        call hdf5_usg_write_group_data_vec(group_id,"velocity",3,      &
                  num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
        if (rank == 0) then
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,   &
                    "results","velocity","Vector","Node",num_nodes_gbl,3)
        end if
        call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
        deallocate(realbuffer)
#endif
      else
        write(ivelvap,'(a)') "VECTORS velocity double"
        do ivol = 1, nngl
          write(ivelvap,'(3(1pe15.6e3,1x))') vels(ivol)%x,vels(ivol)%y,&
                                             vels(ivol)%z
        end do
      end if

!c  ---------------------------------------------------------------------
!c  close files
!c  ---------------------------------------------------------------------
      if (b_output_binary) then
#ifdef PETSC_HDF
        !c close group
        call h5gclose_f(group_id,hdf5_ierr)

        !c close file
        call h5pclose_f(plist_id, hdf5_ierr)
        call h5fclose_f(file_id, hdf5_ierr)

        !c close FORTRAN interface
        call h5close_f(hdf5_ierr)

        !c close xmf file
        if (rank == 0) then
          call hdf5_usg_write_xmf_finalize(ixmf)
          close(ixmf)
          call lun_free(ixmf)
        end if
#endif
      else
        close(ivelvap)
      end if

      return
      end
#endif
