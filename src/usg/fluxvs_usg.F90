!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/fluxvs_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c module mod_fluxvs_usg
!c ----------------------
!c
!c compute water flux for variably saturated conditions
!c
!c written by:      Danyang Su - Aug. 4, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           ------- 
!c           hhead_i            = hydraulic head in control volume i  + -
!c                                currently considered
!c           hhead_j            = hydraulic head in control volume j  + -
!c           relperm_i          = relative permeability in control    + -
!c                                volume i
!c           relperm_j          = relative permeability in control    + -
!c                                volume j
!c           cinfvs             = influence coefficient of linked     + -
!c                                interfacial area
!c           cinfvs_cross       = influence coefficient of linked     + -
!c                                interfacial area
!c                                (cross-diffusion term)
!c           fluxvs             = water flux at interface             * +
!c 
!c           logical:
!c           --------
!c           upstream           = .true.  -> upstream weighting of    + -
!c                                           relative permeabilities 
!c           character:
!c           ----------
!c           iups               = upstream pointer                    + -
!c
!c common:   -
!c           
!c local:    real*8:
!c           -------
!c           rhalf              = constant
!c
!c external: -
!c ----------------------------------------------------------------------
 
#ifdef USG
    module mod_fluxvs_usg

    implicit none

    contains

    !>
    !> calculate flux term without vector decomposition
    !>
    real*8 function fluxvs_usg_test(upstream,node_i,node_j,ndvol,ncell,   &
                               grad_mids,flux_corr,                    &
                               bcellbased,nrelp,relps,                 &
                               iups,cinfvs,cinfvs_cross)

      use geometry
      use gen, only : b_use_cross_diffusion_flow, b_use_hls_correction,&
                      b_mpfa_upstream
 
      implicit none
      
      type(point) :: node_i, node_j
      integer :: ndvol, ncell, nrelp
      logical :: bcellbased
      real*8 :: cinfvs(ndvol,ncell)
      real*8 :: flux_corr(ndvol,ncell)
      real*8 :: relps(nrelp)
      type(point) :: cinfvs_cross(ndvol,ncell)
      type(point) :: grad_mids(ndvol,ncell)

      logical upstream
      character*1 iups
      
      !local variables
      integer :: i, j
      real*8 :: relperm, acos_grad_edge
      real*8 :: fluxvs_direct, fluxvs_cross, fluxvs_upstream
      type(point) :: vector_edge

      real*8, parameter :: rhalf = 0.5d0, r0 = 0.0d0, pi = 3.141592653589793d0

      relperm = 0.0d0

!c  compute interfacial flux
      fluxvs_direct = 0.0d0

      vector_edge = node_j - node_i

      if (.not.bcellbased) then
        do i = 1, ncell
          do j = 1, ndvol

            acos_grad_edge = geometry_angle(vector_edge,grad_mids(j,i))

            if (upstream) then
              if (acos_grad_edge > pi*rhalf) then
                relperm = relps(2)                     !jvol
              else
                relperm = relps(1)                     !ivol
              end if
            else
              relperm = (relps(1)+relps(2))*rhalf
            end if

            fluxvs_direct = fluxvs_direct + relperm*cinfvs(j,i)*     &
                            (grad_mids(j,i).dot.vector_edge)
          end do
        end do
      else
        do i = 1, ncell
          do j = 1, ndvol
            fluxvs_direct = fluxvs_direct + relps(i)*cinfvs(j,i)*    &
                            (grad_mids(j,i).dot.vector_edge)
          end do
        end do
      end if


      fluxvs_cross = 0.0d0
      if (b_use_cross_diffusion_flow) then
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_upstream = cinfvs_cross(j,i).dot.grad_mids(j,i)

              if (upstream .and. b_mpfa_upstream) then
                if (fluxvs_upstream > r0) then
                  fluxvs_cross = fluxvs_cross + relps(2)*fluxvs_upstream
                else
                  fluxvs_cross = fluxvs_cross + relps(1)*fluxvs_upstream
                end if
              else
                fluxvs_cross = fluxvs_cross + relperm*fluxvs_upstream
              end if
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_cross = fluxvs_cross + relps(i)*                  &
                             (cinfvs_cross(j,i).dot.grad_mids(j,i))
            end do
          end do
        end if
      end if

      fluxvs_usg_test = fluxvs_direct + fluxvs_cross
 
      return
    end function fluxvs_usg_test    

    !>
    !> calculate flux term
    !>
    real*8 function fluxvs_usg(upstream,hhead_i,hhead_j,ndvol,ncell,   &
                               grad_mids,flux_corr,                    &
                               bcellbased,nrelp,relps,                 &
                               iups,cinfvs,cinfvs_cross)

      use geometry
      use gen, only : b_use_cross_diffusion_flow, b_use_hls_correction,&
                      b_mpfa_upstream
 
      implicit none
      
      real*8 :: hhead_i, hhead_j
      integer :: ndvol, ncell, nrelp
      logical :: bcellbased
      real*8 :: cinfvs(ndvol,ncell)
      real*8 :: flux_corr(ndvol,ncell)
      real*8 :: relps(nrelp)
      type(point) :: cinfvs_cross(ndvol,ncell)
      type(point) :: grad_mids(ndvol,ncell)

      logical upstream
      character*1 iups
      
      !local variables
      integer :: i, j
      real*8 :: relperm
      real*8 :: fluxvs_direct, fluxvs_cross, fluxvs_upstream

      real*8, parameter :: rhalf = 0.5d0, r0 = 0.0d0

      relperm = 0.0d0


!c  upstream or centered weighting for relative permeabilities
      if (.not.bcellbased) then
        if (upstream) then                         !upstream weighting
          if (iups.eq.'i') then
            relperm = relps(1)                     !ivol
          elseif (iups.eq.'j') then
            relperm = relps(2)                     !jvol
          end if
        else                                       !centered weighting
          relperm = (relps(1)+relps(2))*rhalf
        end if
      end if

!c  compute interfacial flux
      fluxvs_direct = 0.0d0
      if (b_use_hls_correction) then
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_direct = fluxvs_direct + relperm*cinfvs(j,i)*     &
                              (hhead_j-hhead_i-flux_corr(j,i))
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_direct = fluxvs_direct + relps(i)*cinfvs(j,i)*    &
                              (hhead_j-hhead_i-flux_corr(j,i))
            end do
          end do
        end if
      else
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_direct = fluxvs_direct + relperm*cinfvs(j,i)*     &
                                     (hhead_j-hhead_i)
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_direct = fluxvs_direct + relps(i)*cinfvs(j,i)*    &
                                     (hhead_j-hhead_i)
            end do
          end do
        end if
      end if

      fluxvs_cross = 0.0d0
      if (b_use_cross_diffusion_flow) then
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_upstream = cinfvs_cross(j,i).dot.grad_mids(j,i)

              if (upstream .and. b_mpfa_upstream) then
                if (fluxvs_upstream > r0) then
                  fluxvs_cross = fluxvs_cross + relps(2)*fluxvs_upstream
                else
                  fluxvs_cross = fluxvs_cross + relps(1)*fluxvs_upstream
                end if
              else
                fluxvs_cross = fluxvs_cross + relperm*fluxvs_upstream
              end if
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_cross = fluxvs_cross + relps(i)*                  &
                             (cinfvs_cross(j,i).dot.grad_mids(j,i))
            end do
          end do
        end if
      end if

      fluxvs_usg = fluxvs_direct + fluxvs_cross
 
      return
    end function fluxvs_usg

    !>
    !> calculate flux term over the control volume ivol
    !> This function is used in velocity reconstruction from control volume interface to node.
    !>
    type(point) function fluxvs_cvol_usg(upstream,hhead_i,hhead_j,     &
                                ndvol,ncell,grad_mids,flux_corr,       &
                                bcellbased,nrelp,relps,iups,           &
                                cinfvs,cinfvs_cross,cvf2node)

      use geometry
      use gen, only : b_use_cross_diffusion_flow, b_use_hls_correction,&
                      b_mpfa_upstream

      implicit none

      real*8 :: hhead_i, hhead_j
      integer :: ndvol, ncell, nrelp
      logical :: bcellbased
      real*8 :: cinfvs(ndvol,ncell)
      real*8 :: flux_corr(ndvol,ncell)
      real*8 :: relps(nrelp)
      type(point) :: cinfvs_cross(ndvol,ncell)
      type(point) :: grad_mids(ndvol,ncell)
      type(point) :: cvf2node(ndvol,ncell)

      logical upstream
      character*1 iups

      !local variables
      integer :: i, j
      real*8 :: relperm
      real*8 :: fluxvs_upstream
      type(point) :: vel_cvol

      real*8, parameter :: rhalf = 0.5d0, r0 = 0.0d0

      vel_cvol = vector_zero

      relperm = 0.0d0


!c  upstream or centered weighting for relative permeabilities
      if (.not.bcellbased) then
        if (upstream) then                         !upstream weighting
          if (iups.eq.'i') then
            relperm = relps(1)                     !ivol
          elseif (iups.eq.'j') then
            relperm = relps(2)                     !jvol
          end if
        else                                       !centered weighting
          relperm = (relps(1)+relps(2))*rhalf
        end if
      end if

!c  compute interfacial flux
      if (b_use_hls_correction) then
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              vel_cvol = vel_cvol + cvf2node(j,i)*(relperm*cinfvs(j,i)*      &
                                    (hhead_j-hhead_i-flux_corr(j,i)))
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              vel_cvol = vel_cvol + cvf2node(j,i)*(relps(i)*cinfvs(j,i)*     &
                              (hhead_j-hhead_i-flux_corr(j,i)))
            end do
          end do
        end if
      else
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              vel_cvol = vel_cvol + cvf2node(j,i)*(relperm*cinfvs(j,i)*      &
                                     (hhead_j-hhead_i))
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              vel_cvol = vel_cvol + cvf2node(j,i)*(relps(i)*cinfvs(j,i)*     &
                                     (hhead_j-hhead_i))
            end do
          end do
        end if
      end if


      if (b_use_cross_diffusion_flow) then
        if (.not.bcellbased) then
          do i = 1, ncell
            do j = 1, ndvol
              fluxvs_upstream = cinfvs_cross(j,i).dot.grad_mids(j,i)

              if (upstream .and. b_mpfa_upstream) then
                if (fluxvs_upstream > r0) then
                  vel_cvol = vel_cvol + cvf2node(j,i)*(relps(2)*fluxvs_upstream)
                else
                  vel_cvol = vel_cvol + cvf2node(j,i)*(relps(1)*fluxvs_upstream)
                end if
              else
                vel_cvol = vel_cvol + cvf2node(j,i)*(relperm*fluxvs_upstream)
              end if
            end do
          end do
        else
          do i = 1, ncell
            do j = 1, ndvol
              vel_cvol = vel_cvol + cvf2node(j,i)*(relps(i)*                 &
                                   (cinfvs_cross(j,i).dot.grad_mids(j,i)))
            end do
          end do
        end if
      end if

      fluxvs_cvol_usg = vel_cvol

      return
    end function fluxvs_cvol_usg

    !>
    !> calculate velocity term
    !>
    type(point) function fluxvs_vel_usg_tend(upstream, bcellbased,     &
                         nrelp, relps, iups,cond_mid, grad_mid, fnorm)

      use geometry
      use gen, only : b_mpfa_upstream

      implicit none

      logical :: upstream, bcellbased
      integer :: nrelp
      real*8 :: relps(nrelp)
      character*1 iups
      type(point) :: cond_mid, grad_mid, fnorm

      !c local varialbe
      real*8 :: relperm, fluxvs_upstream
      type(point) :: vel
      real*8, parameter :: rhalf = 0.5d0, r0 = 0.0d0

!c  upstream or centered weighting for relative permeabilities
      if (bcellbased) then
        relperm = relps(1)
      else
        if (upstream) then                         !upstream weighting
          if (iups.eq.'i') then
            relperm = relps(1)                     !ivol
          elseif (iups.eq.'j') then
            relperm = relps(2)                     !jvol
          end if
        else                                       !centered weighting
          relperm = (relps(1)+relps(2))*rhalf
        end if
      end if

!c  compute interfacial flux
      if (upstream .and. b_mpfa_upstream .and. .not. bcellbased) then

        vel = -(cond_mid.times.grad_mid)
        fluxvs_upstream = geometry_vector_cos(vel,fnorm)

!c  note, velocity direction is reversed when calling this function
        if (fluxvs_upstream > r0) then
          fluxvs_vel_usg_tend = (cond_mid.times.grad_mid)*relps(1)
        else
          fluxvs_vel_usg_tend = (cond_mid.times.grad_mid)*relps(2)
        end if
      else
        fluxvs_vel_usg_tend = (cond_mid.times.grad_mid)*relperm
      end if

      return
    end function fluxvs_vel_usg_tend

    !>
    !> calculate velocity term
    !>
    type(point) function fluxvs_vel_usg_tenf(upstream, bcellbased,     &
                                             nrelp, relps, iups,       &
                                             conf_mid, grad_mid, fnorm)

      use geometry
      use gen, only : b_mpfa_upstream

      implicit none

      logical :: upstream, bcellbased
      integer :: nrelp
      real*8 :: relps(nrelp)
      character*1 iups      
      type(tensor) :: conf_mid
      type(point) :: grad_mid, fnorm

      !c local varialbe
      real*8 :: relperm, fluxvs_upstream
      type(point) :: vel
      real*8, parameter :: rhalf = 0.5d0, r0 = 0.0d0

!c  upstream or centered weighting for relative permeabilities
      if (bcellbased) then
        relperm = relps(1)
      else
        if (upstream) then                         !upstream weighting
          if (iups.eq.'i') then
            relperm = relps(1)                     !ivol
          elseif (iups.eq.'j') then
            relperm = relps(2)                     !jvol
          end if
        else                                       !centered weighting
          relperm = (relps(1)+relps(2))*rhalf
        end if
      end if

!c  compute interfacial flux
      if (upstream .and. b_mpfa_upstream .and. .not. bcellbased) then

        vel = -(conf_mid.cross.grad_mid)
        fluxvs_upstream = geometry_vector_cos(vel,fnorm)

!c  note, velocity direction is reversed when calling this function
        if (fluxvs_upstream > r0) then
          fluxvs_vel_usg_tenf = (conf_mid.cross.grad_mid)*relps(1)
        else
          fluxvs_vel_usg_tenf = (conf_mid.cross.grad_mid)*relps(2)
        end if
      else
        fluxvs_vel_usg_tenf = (conf_mid.cross.grad_mid)*relperm
      end if

      return
    end function fluxvs_vel_usg_tenf

    end module mod_fluxvs_usg
#endif
