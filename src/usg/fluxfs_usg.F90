!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/fluxfs_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function fluxfs_usg
!c ------------------------
!c
!c compute water flux for fully saturated conditions
!c
!c written by:      Danyang Su - Aug. 4, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           hhead_i            = hydraulic head in control volume i  + -
!c           hhead_j            = hydraulic head in control volume j  + -
!c           cinfvs             = influence coefficient of linked     + -
!c                                interfacial area
!c          cinfvs_cross        = influence coefficient of linked     + -
!c                                interfacial area
!c                                (cross diffusion term)
!c           fluxfs             = water flux at current interface     * +
!c
!c common:   -
!c           
!c local:    -
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
    module mod_fluxfs_usg

    implicit none

    contains
    !>
    !> calculate flux term
    !>
    real*8 function fluxfs_usg(hhead_i,hhead_j,ndvol, ncell,           &
                           grad_mids,flux_corr,cinfvs,cinfvs_cross)

      use geometry
      use gen, only : b_use_cross_diffusion_flow, b_use_hls_correction
      
      implicit none
 
      real*8 :: hhead_i, hhead_j
      integer :: ndvol, ncell
      real*8 :: cinfvs(ndvol,ncell)
      real*8 :: flux_corr(ndvol,ncell)
      type(point) :: grad_mids(ndvol,ncell), cinfvs_cross(ndvol,ncell)

      !c local varialbe
      integer :: i, j
      real*8 :: fluxfs_direct, fluxfs_cross

!c  compute interfacial flux
      if (b_use_hls_correction) then
        fluxfs_direct = 0.0d0
        do i = 1, ncell
          do j = 1, ndvol
            fluxfs_direct = fluxfs_direct + cinfvs(j,i)*               &
                            (hhead_j-hhead_i-flux_corr(j,i))
          end do
        end do
      else
        fluxfs_direct = (hhead_j-hhead_i) * sum(cinfvs)
      end if

      fluxfs_cross = 0.0d0
      if (b_use_cross_diffusion_flow) then
        do i = 1, ncell
          do j = 1, ndvol
            fluxfs_cross = fluxfs_cross + (cinfvs_cross(j,i).dot.grad_mids(j,i))
          end do
        end do
      end if

      fluxfs_usg = fluxfs_direct + fluxfs_cross
 
      return
    end function fluxfs_usg

    !>
    !> calculate flux term over the control volume ivol
    !> This function is used in velocity reconstruction from control volume interface to node.
    !>
    type(point) function fluxfs_cvol_usg(hhead_i,hhead_j,ndvol, ncell, &
                             grad_mids,flux_corr,cinfvs,cinfvs_cross,  &
                             cvf2node)

      use geometry
      use gen, only : b_use_cross_diffusion_flow, b_use_hls_correction

      implicit none

      real*8 :: hhead_i, hhead_j
      integer :: ndvol, ncell
      real*8 :: cinfvs(ndvol,ncell)
      real*8 :: flux_corr(ndvol,ncell)
      type(point) :: grad_mids(ndvol,ncell)
      type(point) :: cinfvs_cross(ndvol,ncell)
      type(point) :: cvf2node(ndvol,ncell)


      !c local varialbe
      integer :: i, j
      type(point) :: vel_cvol

      vel_cvol = vector_zero

!c  compute interfacial flux
      if (b_use_hls_correction) then
        do i = 1, ncell
          do j = 1, ndvol
            vel_cvol = vel_cvol + cvf2node(j,i)*(cinfvs(j,i)*          &
                                  (hhead_j-hhead_i-flux_corr(j,i)))
          end do
        end do
      else
        do i = 1, ncell
          do j = 1, ndvol
            vel_cvol = vel_cvol + cvf2node(j,i)*(cinfvs(j,i)*          &
                                  (hhead_j-hhead_i))
          end do
        end do
      end if

      if (b_use_cross_diffusion_flow) then
        do i = 1, ncell
          do j = 1, ndvol
            vel_cvol = vel_cvol + cvf2node(j,i)*(cinfvs_cross(j,i).dot.grad_mids(j,i))
          end do
        end do
      end if

      fluxfs_cvol_usg = vel_cvol

      return
    end function fluxfs_cvol_usg

    !>
    !> calculate velocity term
    !>
    type(point) function fluxfs_vel_usg_tend(cond_mid, grad_mid)

      use geometry

      implicit none

      type(point) :: cond_mid, grad_mid

!c  compute interfacial flux
      fluxfs_vel_usg_tend = cond_mid.times.grad_mid

      return
    end function fluxfs_vel_usg_tend

    !>
    !> calculate velocity term
    !>
    type(point) function fluxfs_vel_usg_tenf(conf_mid, grad_mid)

      use geometry

      implicit none

      type(tensor) :: conf_mid
      type(point) :: grad_mid

!c  compute interfacial flux
      fluxfs_vel_usg_tenf = conf_mid.cross.grad_mid

      return
    end function fluxfs_vel_usg_tenf

    end module mod_fluxfs_usg
#endif
