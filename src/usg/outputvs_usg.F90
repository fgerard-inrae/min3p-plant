!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/outputvs_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine outputvs
!c -------------------
!c
!c write contour data for variably saturated flow simulation to output
!c file
!c
!c written by:      Danyang Su- Aug. 2, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c   
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           cinfvs(njavs)      = influence coefficients              + -
!c                                (variably saturated flow)
!c           cvol(nn)           = nodal volumes                       + -
!c           dimcv(3,nn)        = dimension of control volumes        + -
!c           elevmax            = max. elevation of solution domain   + -
!c           hhead(nn)          = hydraulic head                      + -
!c           sgnew(nn)          = gaseous phase saturation            + - 
!c                                - new time level
!c           sanew(nn)          = aqueous phase saturation            + - 
!c                                - new time level
!c           relperm(nn)        = relative permeability               + -
!c           time_io            = current solution time (I/O units)   + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           ifls               = unit number, file information       + -
!c           ilog               = unit number, log book               + -
!c           igsp               = unit number, flow variables         + -
!c           igstime            = pointer to next output time for     + -
!c                                contour data
!c           icnv               = unit number, data conversion        + -
!c           ivel               = unit number, average interfacial    + -
!c                                             velocities
!c           itec               = i-index for tecplot                 + -
!c           jtec               = j-index for tecplot                 + -
!c           ktec               = k-index for tecplot                 + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           mtime              = current time step                   + -
!c           njavs              = number of global connections        + -
!c           nn                 = number of control volumes           + -
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c
!c           logical:
!c           --------
!c           depth_output       = .true.  -> output in terms of       + -
!c                                           depth instead of
!c                                           elevation
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c           half_cells         = .true.  -> half cells on boundary   + -
!c           initial_condition  = .true.  -> output of initial        + -
!c                                           contour data
!c                                .false. -> output contour data
!c                                           for steady state or
!c                                           transient solutions
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           steady_flow        = .true.  -> steady state flow        + -
!c           upstream           = .true.  -> upstream weighting       + -
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient conditions for    
!c                                           variably saturated flow 
!c                                           simulation
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           problem_title      = problem title                       + -
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c
!c
!c local:    real*8:
!c           ------- 
!c           phead              = pressure head
!c           qroot              = root water uptake for current
!c                                control volume
!c           theta_a            = aqueous phase content         
!c           theta_g            = gas phase content
!c           r0                 = constant         
!c           r1                 = constant
!c           zout               = output for z-coordinate in terms
!c                                depth or elevation
!c
!c           integer*4:
!c           ----------
!c           inode              = counter (control volumes)
!c           l_sufx             = length of file suffix
!c
!c           character:
!c           ---------- 
!c           suffix             = file suffix
!c
!c external: velocity  = average interfacial velocities
!c           zoutput   = assign depth coordinate in terms of depth
!c                       or elevation
!c --------------------------------------------------------------------------
#ifdef USG
      subroutine outputvs_usg
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use biol
      use phys
      use writeversion
      use file_unit, only : lun_get, lun_free
#ifdef PETSC
#ifdef PETSC_HDF
      use hdf5
      use hdf5_usg
#endif
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      use geometry
      use usg_mesh_data
      use gradient_usg, only : gradient_green_gauss_tri,               &
                               gradient_green_gauss_tetra,             &
                               gradient_least_square_cvol

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC_HDF
      integer :: hdf5_ierr                   ! HDF5 error code
      integer(HID_T) :: file_id              ! File identifier
      integer(HID_T) :: group_id             ! Group identifier
      integer(HID_T) :: plist_id             ! Property list identifier
#endif
      
      integer :: i, icell, inode, izn, ixmf, l_sufx, ierr

      real*8 :: rootwat, evapo, qroot, transp, soilevapo
      
      type(point) :: grad

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rm1 = -1.0d0

      character*5 :: suffix
      character*256 :: strbuffer
      character*256 :: strfilename, strfilename_result, strfilename_mesh

      external :: rootwat, evapo, checkerr

      l_sufx = 0

      if (b_output_restart) then
        suffix = "r"
        l_sufx = 1
      else
        if (igstime.lt.10) then

          !write(icnv,'(i1)') igstime
          !rewind(icnv)
          !read(icnv,'(a3)') suffix
          write(suffix,'(i1)') igstime
          if (tran_steady_flow) then
            suffix = "o_"//suffix(:1)
            l_sufx = 3
          else
            l_sufx = 1
          end if

        elseif (igstime.ge.10.and.igstime.lt.100) then

          !write(icnv,'(i2)') igstime
          !rewind(icnv)
          !read(icnv,'(a3)') suffix
          write(suffix,'(i2)') igstime
          if (tran_steady_flow) then
            suffix = "o_"//suffix(:2)
            l_sufx = 4
          else
            l_sufx = 2
          end if

        elseif (igstime.ge.100.and.igstime.lt.1000) then

          !write(icnv,'(i3)') igstime
          !rewind(icnv)
          !read(icnv,'(a3)') suffix
          write(suffix,'(i3)') igstime
          if (tran_steady_flow) then
            suffix = "o_"//suffix(:3)
            l_sufx = 5
          else
            l_sufx = 3
          end if

        elseif (igstime.gt.1000) then
          if (rank == 0) then
            write(ilog,'(/a)')'error in input file'
            write(ilog,'(a)')'max. number of output times exceeded'
            write(ilog,'(a)')'abnormal exit in routine outputrt'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if
      end if

      !c file for result and mesh
      !c note: binary output using separated file for each subdomain is
      !c deprecated for unstructured grid version
      if (b_output_binary) then
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'.gsp'
        if (b_output_separate_mesh_result) then
          strfilename_result = trim(strfilename)//'.h5'
          strfilename_mesh = prefix(:l_prfx)//'_domain.h5'
        else
          strfilename_result = trim(strfilename)//'.h5'
          strfilename_mesh = strfilename_result
        end if
      else
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//          &
                      trim(adjustl(str_rank))//'.gsp'
      end if

      !c separate mesh data from results data
#ifdef PETSC_HDF
      if (b_output_separate_mesh_result .and. initial_condition .and.  &
          b_output_binary) then
        !c initialize fortran interface
        call h5open_f(hdf5_ierr)

        !c setup file access property list with parallel I/O access
        call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
        call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,            &
                                MPI_INFO_NULL, hdf5_ierr)
        !c create the file collectively
        call h5fcreate_f(strfilename_mesh, H5F_ACC_TRUNC_F, file_id,   &
                         hdf5_ierr, access_prp = plist_id)

        !c write attribute
        call hdf5_usg_write_attribute(file_id)

        !c write mesh data
        call hdf5_usg_write_mesh_data(file_id)

        !c close file
        call h5pclose_f(plist_id, hdf5_ierr)
        call h5fclose_f(file_id, hdf5_ierr)

        !c close FORTRAN interface
        call h5close_f(hdf5_ierr)

        !c open corresponding xmf file to be loaded by paraview
        if (rank == 0) then
          ixmf = lun_get()
          open(ixmf,file=prefix(:l_prfx)//'_domain.xmf',               &
               status='unknown', form='formatted')

          call hdf5_usg_write_xmf_initialize(ixmf)
          call hdf5_usg_write_xmf_mesh(ixmf,strfilename_mesh,          &
                    cell_type,num_cells_gbl,num_nodes_gbl,             &
                    num_nodes_per_cell)
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,     &
                    "domain","vertices_rank","Scalar","Node",          &
                    num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,     &
                    "domain","cells_rank","Scalar","Cell",             &
                    num_cells_gbl,1)

          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,     &
                    "domain","vertices_lg2g","Scalar","Node",          &
                    num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,     &
                    "domain","cells_lg2g","Scalar","Cell",             &
                    num_cells_gbl,1)

          if (b_use_node_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,   &
                      "domain","vertices_matid","Scalar","Node",       &
                      num_nodes_gbl,1)
          end if
          if (b_use_cell_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,   &
                      "domain","cells_matid","Scalar","Cell",          &
                      num_cells_gbl,1)
          end if
          call hdf5_usg_write_xmf_finalize(ixmf)
          close(ixmf)
          call lun_free(ixmf)
        end if
      end if
#endif

!c  ---------------------------------------------------------------------
!c  open file for nodal values
!c  --------------------------------------------------------------------- 
      if (b_output_binary) then

#ifdef PETSC_HDF
        !c open corresponding xmf file to be loaded by paraview
        if (rank == 0) then
          ixmf = lun_get()
          open(ixmf,file=trim(strfilename)//'.xmf',status='unknown',   &
               form='formatted')
        end if

        !c initialize fortran interface
        call h5open_f(hdf5_ierr)

        !c setup file access property list with parallel I/O access
        call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
        call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,            &
                                MPI_INFO_NULL, hdf5_ierr)
        !c create the file collectively
        call h5fcreate_f(strfilename_result, H5F_ACC_TRUNC_F, file_id, &
                         hdf5_ierr, access_prp = plist_id)

        !c write attribute
        call hdf5_usg_write_attribute(file_id)

        if (.not. b_output_separate_mesh_result) then
          !c write mesh data
          call hdf5_usg_write_mesh_data(file_id)
        end if

        !c open corresponding xmf file for mesh and domain decomposition
        if (rank == 0) then
          call hdf5_usg_write_xmf_initialize(ixmf)
          call hdf5_usg_write_xmf_mesh(ixmf,strfilename_mesh,          &
                    cell_type,num_cells_gbl,num_nodes_gbl,             &
                    num_nodes_per_cell)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_rank",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_rank",            &
                    "Scalar","Cell",num_cells_gbl,1)

          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,     &
                    "domain","vertices_lg2g","Scalar","Node",          &
                    num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_mesh,     &
                    "domain","cells_lg2g","Scalar","Cell",             &
                    num_cells_gbl,1)

          if (b_use_node_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","vertices_matid",      &
                      "Scalar","Node",num_nodes_gbl,1)
          end if
          if (b_use_cell_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","cells_matid",         &
                      "Scalar","Cell",num_cells_gbl,1)
          end if
        end if

        !c create a group for the mesh data set
        strbuffer = "results"
        !c create and open a group
        call h5gcreate_f(file_id,strbuffer,group_id,hdf5_ierr,         &
                         OBJECT_NAMELEN_DEFAULT_F)
#endif
      else
        open(igsp,file=trim(strfilename)//'.vtk',status='unknown',     &
             form='formatted')
      end if
      
      if (rank == 0) then
                                                                       
        if (initial_condition) then
                                                                         
          write(ifls,'(/2a/72a)')'Flow variables, initial ',           &
                                 'condition',('-',i=1,72)
                                                                        
        elseif (steady_flow) then
                                                                        
          write(ifls,'(/2a/72a)')'Flow variables, steady ',            &
                                 'state solution',('-',i=1,72)
                                                                        
        else
                                                                        
          write(ifls,'(/a,1pe15.6e3,1x,a,/72a)')                       &
                'Flow variables, T = ',time_io,time_unit,('-',i=1,72)
                                                                        
        end if
                                                                        
        write(ifls,'(/a/)') prefix(:l_prfx)//'_'//                     &
                            suffix(:l_sufx)//'.gsp.vtk'
                                                                        
        write(ifls,'(2a)')                                             &
              'column   entry                           ','unit'        
        write(ifls,'(2a)')                                             &
              '1        x                               ','m'           
        write(ifls,'(2a)')                                             &
              '2        y                               ','m'           
        write(ifls,'(2a)')                                             &
              '3        z                               ','m'           
        write(ifls,'(2a)')                                             &
              '4        hydraulic head                  ','m'           
        write(ifls,'(2a)')                                             &
              '5        pressure head                   ','m'           
        write(ifls,'(2a)')                                             &
              '6        water saturation                ','-'           
        write(ifls,'(2a)')                                             &
              '7        water content                   ','-'
        if (variably_saturated) then
          write(ifls,'(2a)')                                           &
              '8        air saturation                  ','-'
          write(ifls,'(2a)')                                           &
              '9        air content                     ','-'
          write(ifls,'(2a)')                                           &
              '10       total root water uptake         ','m^3/d'
          write(ifls,'(2a)')                                           &
              '11       root water uptake               ','m^3/d'
          write(ifls,'(2a)')                                           &
              '12       evaporation uptake              ','m^3/d'
        end if

        if (grad_method == grad_method_gg .or. grad_method == grad_method_ls) then
          write(ifls,'(2a)')                                           &
     &        '13       gradient_x                      ','-'
          write(ifls,'(2a)')                                           &
     &        '14       gradient_y                      ','-'
          write(ifls,'(2a)')                                           &
     &        '15       gradient_z                      ','-'
        end if
      
      end if

      !c allocate buffer
      if (b_output_binary) then
        allocate(realbuffer(num_nodes), stat = ierr)
        call checkerr(ierr,'outputvs_usg-realbuffer',ilog)
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)
      end if

!c  title and mesh variables
      if (.not. b_output_binary) then
        if (initial_condition) then
          call write_mesh_data_vtk_ascii(igsp,                         &
                     "Flow variables, initial condition")
        else
          if (steady_flow) then
            call write_mesh_data_vtk_ascii(igsp,                       &
                       "Flow variables, steady state")
          else if (transient_flow) then
            write(strbuffer,'(a,1x,1pe15.6e3,1x,a)')                   &
                  "Flow variables, solution time = ",time_io,time_unit
            call write_mesh_data_vtk_ascii(igsp,trim(adjustl(strbuffer)))
          end if
        end if
        write(igsp,'(a,1x,i12)') "POINT_DATA",num_nodes
      end if

      if (.not.initial_condition) then
        if (fully_saturated) then
          do inode = 1, num_nodes
            hhead(inode) = uvsnew(inode)
          end do
        elseif (variably_saturated) then
          do inode = 1, num_nodes
            hhead(inode) = uvsnew(inode)+zg(inode)
          end do
        end if
      end if

      !c write hydraulic head
      if (b_output_binary) then
#ifdef PETSC_HDF
        call hdf5_usg_write_group_data_1d(group_id,"h_w",              &
                  num_nodes_loc,num_nodes_gbl,offset_nodes,hhead)

        if (rank == 0) then
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,   &
                    "results","h_w","Scalar","Node",num_nodes_gbl,1)
        end if
#endif
      else
        write(igsp,'(a)') "SCALARS h_w double"
        write(igsp,'(a)') "LOOKUP_TABLE default"
        do inode = 1, num_nodes
          write(igsp,ascii_fmt) hhead(inode)
        end do
      end if

      !c write pressure head
      if (b_output_binary) then
#ifdef PETSC_HDF
        if (fully_saturated) then
          realbuffer = uvsnew-zg
          call hdf5_usg_write_group_data_1d(group_id,"ph_w",           &
                    num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
        else
          call hdf5_usg_write_group_data_1d(group_id,"ph_w",            &
                    num_nodes_loc,num_nodes_gbl,offset_nodes,uvsnew)
        end if
        if (rank == 0) then
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,   &
                    "results","ph_w","Scalar","Node",num_nodes_gbl,1)
        end if
#endif
      else
        write(igsp,'(a)') "SCALARS ph_w double"
        write(igsp,'(a)') "LOOKUP_TABLE default"
        if (fully_saturated) then
          do inode = 1, num_nodes
            write(igsp,ascii_fmt) uvsnew(inode)-zg(inode)
          end do
        else
          do inode = 1, num_nodes
            write(igsp,ascii_fmt) uvsnew(inode)
          end do
        end if
      end if

      !c write saturation
      if (b_output_binary) then
#ifdef PETSC_HDF
        call hdf5_usg_write_group_data_1d(group_id,"s_a",              &
                  num_nodes_loc,num_nodes_gbl,offset_nodes,sanew)
        if (rank == 0) then
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,   &
                    "results","s_a","Scalar","Node",num_nodes_gbl,1)
        end if
#endif
      else
        write(igsp,'(a)') "SCALARS s_a double"
        write(igsp,'(a)') "LOOKUP_TABLE default"
        do inode = 1, num_nodes
          write(igsp,ascii_fmt) sanew(inode)
        end do
      end if

      !c write saturation
      if (b_output_binary) then
#ifdef PETSC_HDF
        realbuffer = pornew*sanew
        call hdf5_usg_write_group_data_1d(group_id,"theta_a",          &
                  num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
        if (rank == 0) then
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,   &
                    "results","theta_a","Scalar","Node",num_nodes_gbl,1)
        end if
#endif
      else
        write(igsp,'(a)') "SCALARS theta_a double"
        write(igsp,'(a)') "LOOKUP_TABLE default"
        do inode = 1, num_nodes
          write(igsp,ascii_fmt) pornew(inode)*sanew(inode)
        end do
      end if

      if (variably_saturated) then
        if (b_output_binary) then
#ifdef PETSC_HDF
          do inode = 1, num_nodes
            realbuffer(inode) = r1 - sanew(inode)
          end do
          call hdf5_usg_write_group_data_1d(group_id,"s_g",            &
                    num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
          if (rank == 0) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result, &
                      "results","s_g","Scalar","Node",num_nodes_gbl,1)
          end if
#endif
        else
          write(igsp,'(a)') "SCALARS s_g double"
          write(igsp,'(a)') "LOOKUP_TABLE default"
          do inode = 1, num_nodes
            sgnew(inode) = r1 - sanew(inode)
            write(igsp,ascii_fmt) sgnew(inode)
          end do
        end if

        if (b_output_binary) then
#ifdef PETSC_HDF
          realbuffer = pornew*sgnew
          call hdf5_usg_write_group_data_1d(group_id,"theta_g",        &
                    num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
          if (rank == 0) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result, &
                      "results","theta_g","Scalar","Node",num_nodes_gbl,1)
          end if
#endif
        else
          write(igsp,'(a)') "SCALARS theta_g double"
          write(igsp,'(a)') "LOOKUP_TABLE default"
          do inode = 1, num_nodes
            write(igsp,ascii_fmt) pornew(inode)*sgnew(inode)
          end do
        end if

        if (root_uptake .or. pure_evap) then
          !c total root water uptake
          if (b_output_binary) then
            do inode = 1, num_nodes
              if (root_uptake) then
                transp = cvol(inode)*rootwat(sanew,inode,rsum_vprop)
              else
                transp = r0
              end if

              soilevapo = r0
              if (soilhydrfunc_field) then
                if (h1dry_vol(inode).gt.r0) then
                  soilevapo = cvol(inode)*evapo(sanew,inode)
                end if
              else
                izn = mpropvs(inode)
                if (h1dry(izn).gt.r0) then
                  soilevapo = cvol(inode)*evapo(sanew,inode)
                end if
              end if
              realbuffer(inode) = transp + soilevapo
            end do
#ifdef PETSC_HDF
            call hdf5_usg_write_group_data_1d(group_id,"q_root",       &
                      num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
            if (rank == 0) then
              call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,&
                        "results","q_root","Scalar","Node",num_nodes_gbl,1)
            end if
#endif
          else
            write(igsp,'(a)') "SCALARS q_root double"
            write(igsp,'(a)') "LOOKUP_TABLE default"
            do inode = 1, num_nodes
              if (root_uptake) then
                transp = cvol(inode)*rootwat(sanew,inode,rsum_vprop)
              else
                transp = r0
              end if

              soilevapo = r0
              if (soilhydrfunc_field) then
                if (h1dry_vol(inode).gt.r0) then
                  soilevapo = cvol(inode)*evapo(sanew,inode)
                end if
              else
                izn = mpropvs(inode)
                if (h1dry(izn).gt.r0) then
                  soilevapo = cvol(inode)*evapo(sanew,inode)
                end if
              end if
              qroot = transp + soilevapo
              write(igsp,ascii_fmt) qroot
            end do
          end if

          !c root water uptake
          if (b_output_binary) then
            do inode = 1, num_nodes
              if (root_uptake) then
                transp = cvol(inode)*rootwat(sanew,inode,rsum_vprop)
              else
                transp = r0
              end if
              realbuffer(inode) = transp
            end do
#ifdef PETSC_HDF
            call hdf5_usg_write_group_data_1d(group_id,"rootwat",       &
                      num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
            if (rank == 0) then
              call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,&
                        "results","rootwat","Scalar","Node",num_nodes_gbl,1)
            end if
#endif
          else
            write(igsp,'(a)') "SCALARS rootwat double"
            write(igsp,'(a)') "LOOKUP_TABLE default"
            do inode = 1, num_nodes
              transp = cvol(inode)*rootwat(sanew,inode,rsum_vprop)
              write(igsp,ascii_fmt) transp
            end do
          end if
        end if

        !c soil evaporation
        if (b_output_binary) then
          do inode = 1, num_nodes
            soilevapo = r0
            if (soilhydrfunc_field) then
              if (h1dry_vol(inode).gt.r0) then
                soilevapo = cvol(inode)*evapo(sanew,inode)
              end if
            else
              izn = mpropvs(inode)
              if (h1dry(izn).gt.r0) then
                soilevapo = cvol(inode)*evapo(sanew,inode)
              end if
            end if
            realbuffer(inode) = soilevapo
          end do
#ifdef PETSC_HDF
          call hdf5_usg_write_group_data_1d(group_id,"soilevapo",      &
                    num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
          if (rank == 0) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result, &
                      "results","soilevapo","Scalar","Node",num_nodes_gbl,1)
          end if
#endif
        else
          write(igsp,'(a)') "SCALARS soilevapo double"
          write(igsp,'(a)') "LOOKUP_TABLE default"
          do inode = 1, num_nodes
            soilevapo = r0
            if (soilhydrfunc_field) then
              if (h1dry_vol(inode).gt.r0) then
                soilevapo = cvol(inode)*evapo(sanew,inode)
              end if
            else            
              izn = mpropvs(inode)
              if (h1dry(izn).gt.r0) then
                soilevapo = cvol(inode)*evapo(sanew,inode)
              end if
            end if
            write(igsp,ascii_fmt) soilevapo
          end do
        end if
      end if

      !c release buffer
      if (b_output_binary) then
        call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
        deallocate(realbuffer)
      end if

      !c write flow gradient
      if (grad_method == grad_method_gg .or. grad_method == grad_method_ls) then

        if (b_output_binary) then
#ifdef PETSC_HDF
          allocate(realbuffer(num_nodes*3), stat = ierr)
          call checkerr(ierr,'outputvs_usg-realbuffer',ilog)
          call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)


          if (variably_saturated) then
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                do inode = 1, num_nodes
                  call gradient_green_gauss_tetra(inode,hhead,grad)
                  grad = grad*rm1
                  realbuffer((inode-1)*3+1) = grad%x
                  realbuffer((inode-1)*3+2) = grad%y
                  realbuffer((inode-1)*3+3) = grad%z
                end do
              else
                do inode = 1, num_nodes
                  call gradient_green_gauss_tri(inode,hhead,grad)
                  grad = grad*rm1
                  realbuffer((inode-1)*3+1) = grad%x
                  realbuffer((inode-1)*3+2) = grad%y
                  realbuffer((inode-1)*3+3) = grad%z
                end do
              end if
            else if(grad_method == grad_method_ls) then
              do inode = 1, num_nodes
                call gradient_least_square_cvol(inode,hhead,grad)
                grad = grad*rm1
                realbuffer((inode-1)*3+1) = grad%x
                realbuffer((inode-1)*3+2) = grad%y
                realbuffer((inode-1)*3+3) = grad%z
              end do
            end if
          else if (fully_saturated) then
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                do inode = 1, num_nodes
                  call gradient_green_gauss_tetra(inode,uvsnew,grad)
                  grad = grad*rm1
                  realbuffer((inode-1)*3+1) = grad%x
                  realbuffer((inode-1)*3+2) = grad%y
                  realbuffer((inode-1)*3+3) = grad%z
                end do
              else
                do inode = 1, num_nodes
                  call gradient_green_gauss_tri(inode,uvsnew,grad)
                  grad = grad*rm1
                  realbuffer((inode-1)*3+1) = grad%x
                  realbuffer((inode-1)*3+2) = grad%y
                  realbuffer((inode-1)*3+3) = grad%z
                end do
              end if
            else if(grad_method == grad_method_ls) then
              do inode = 1, num_nodes
                call gradient_least_square_cvol(inode,uvsnew,grad)
                grad = grad*rm1
                realbuffer((inode-1)*3+1) = grad%x
                realbuffer((inode-1)*3+2) = grad%y
                realbuffer((inode-1)*3+3) = grad%z
              end do
            end if
          end if

          call hdf5_usg_write_group_data_vec(group_id,"gradient",3,    &
                    num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
          if (rank == 0) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result, &
                      "results","gradient","Vector","Node",num_nodes_gbl,3)
          end if

          call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
          deallocate(realbuffer)
#endif

        else
          write(igsp,'(a)') "VECTORS gradient double"

          if (variably_saturated) then
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                do inode = 1, num_nodes
                  call gradient_green_gauss_tetra(inode,hhead,grad)
                  grad = grad*rm1
                  write(igsp,'(3(1pe15.6e3,1x))') grad%x,grad%y,grad%z
                end do
              else
                do inode = 1, num_nodes
                  call gradient_green_gauss_tri(inode,hhead,grad)
                  grad = grad*rm1
                  write(igsp,'(3(1pe15.6e3,1x))') grad%x,grad%y,grad%z
                end do
              end if
            else if(grad_method == grad_method_ls) then
              do inode = 1, num_nodes
                call gradient_least_square_cvol(inode,hhead,grad)
                grad = grad*rm1
                write(igsp,'(3(1pe15.6e3,1x))') grad%x,grad%y,grad%z
              end do
            end if
          else if (fully_saturated) then
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                do inode = 1, num_nodes
                  call gradient_green_gauss_tetra(inode,uvsnew,grad)
                  grad = grad*rm1
                  write(igsp,'(3(1pe15.6e3,1x))') grad%x,grad%y,grad%z
                end do
              else
                do inode = 1, num_nodes
                  call gradient_green_gauss_tri(inode,uvsnew,grad)
                  grad = grad*rm1
                  write(igsp,'(3(1pe15.6e3,1x))') grad%x,grad%y,grad%z
                end do
              end if
            else if(grad_method == grad_method_ls) then
              do inode = 1, num_nodes
                call gradient_least_square_cvol(inode,uvsnew,grad)
                grad = grad*rm1
                write(igsp,'(3(1pe15.6e3,1x))') grad%x,grad%y,grad%z
              end do
            end if
          end if
        end if
      end if

!c  ---------------------------------------------------------------------
!c  close files
!c  ---------------------------------------------------------------------
      if (b_output_binary) then
#ifdef PETSC_HDF
        !c close group
        call h5gclose_f(group_id,hdf5_ierr)

        !c close file
        call h5pclose_f(plist_id, hdf5_ierr)
        call h5fclose_f(file_id, hdf5_ierr)

        !c close FORTRAN interface
        call h5close_f(hdf5_ierr)

        !c close xmf file
        if (rank == 0) then
          call hdf5_usg_write_xmf_finalize(ixmf)
          close(ixmf)
          call lun_free(ixmf)
        end if
#endif
      else
        close(igsp)
      end if

      if (.not.initial_condition) then
        call velocity_usg
      end if

      !Keep the file unit, this will be used later
      !call lun_free(igsp)
      !if (.not.initial_condition) then
      !  call lun_free(ivel)
      !end if

      return
      end
#endif
