!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/gradient_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!


! --------------------------------------------------------------------
!> Module of gradient reconstruction for unstructured grid
!>
!> Module description: Gradient reconstruction based on Green-Gauss theory
!>                     and Least Squares method
!>                     Gradient reconstruction based on high order
!>                     Least Squares method
!>
!> Written by:    Danyang Su - Sept. 09, 2016
!>
!> Last modified:
!>
!> Notes:
! --------------------------------------------------------------------

#ifdef USG
module gradient_usg

  use usg_mesh_data

  use math_common

  use geometry

  use gen

  implicit none

  !>
  !> interfaces of Green-Gauss gradient reconstruction method over single control volume
  !>
  interface gradient_green_gauss_tri
    module procedure gradient_gg_tri_cvol
    module procedure gradient_gg_tri_cvol_inc_kvol
  end interface gradient_green_gauss_tri

  !>
  !> interfaces of Green-Gauss gradient reconstruction method over single control volume
  !>
  interface gradient_dd_green_gauss_tri
    module procedure gradient_density_gg_tri_cvol
    module procedure gradient_density_gg_tri_cvol_inc_kvol
    module procedure gradient_density_gg_tri_cvol_inc2_kvol
  end interface gradient_dd_green_gauss_tri

  !>
  !> interfaces of Green-Gauss gradient reconstruction method of concentration over single control volume
  !>
  interface gradient_conc_green_gauss_tri
    module procedure gradient_conc_gg_tri_cvol
    module procedure gradient_conc_gg_tri_cvol_inc_kvol

    module procedure gradient_mcd_gg_tri_cvol
    module procedure gradient_mcd_gg_tri_cvol_inc_kvol
  end interface gradient_conc_green_gauss_tri

  !>
  !> interfaces of Green-Gauss gradient reconstruction method over single control volume
  !>
  interface gradient_green_gauss_tetra
    module procedure gradient_gg_tetra_cvol
  end interface gradient_green_gauss_tetra

  !>
  !> interfaces of Green-Gauss gradient reconstruction method over single control volume
  !>
  interface gradient_dd_green_gauss_tetra
    module procedure gradient_density_gg_tetra_cvol
    module procedure gradient_density_gg_tetra_cvol_inc_kvol
    module procedure gradient_density_gg_tetra_cvol_inc2_kvol
  end interface gradient_dd_green_gauss_tetra

  !>
  !> interfaces of Green-Gauss gradient reconstruction method of concentration over single control volume
  !>
  interface gradient_conc_green_gauss_tetra
    module procedure gradient_conc_gg_tetra_cvol
    module procedure gradient_conc_gg_tetra_cvol_inc_kvol

    module procedure gradient_mcd_gg_tetra_cvol
    module procedure gradient_mcd_gg_tetra_cvol_inc_kvol
   end interface gradient_conc_green_gauss_tetra

  !>
  !> interfaces of Least-square gradient reconstruction method over single control volume
  !>
  interface gradient_least_square_cvol
    module procedure gradient_ls_cvol
    module procedure gradient_ls_cvol_inc_kvol    
  end interface gradient_least_square_cvol

  !>
  !> interfaces of Least-square gradient reconstruction method over single control volume
  !>
  interface gradient_dd_least_square_cvol
    module procedure gradient_density_ls_cvol
    module procedure gradient_density_ls_cvol_inc
    module procedure gradient_density_ls_cvol_inc_kvol
    module procedure gradient_density_ls_cvol_inc2_kvol
  end interface gradient_dd_least_square_cvol

  !>
  !> interfaces of Least-square gradient reconstruction method of concentration over single control volume
  !>
  interface gradient_conc_least_square_cvol
    module procedure gradient_conc_ls_cvol
    module procedure gradient_conc_ls_cvol_inc_kvol

    module procedure gradient_mcd_ls_cvol
    module procedure gradient_mcd_ls_cvol_inc_kvol
  end interface gradient_conc_least_square_cvol

  !>
  !> interfaces of high order Least-square gradient reconstruction method over single control volume
  !>
  interface gradient_hls_cvol
    module procedure gradient_hls_cvol_1
  end interface gradient_hls_cvol

  !>
  !> interfaces of high order Least-square gradient reconstruction method of concentration over single control volume
  !>
  interface gradient_conc_hls_cvol
    module procedure gradient_conc_hls_cvol_1
    module procedure gradient_mcd_hls_cvol_1
  end interface gradient_conc_hls_cvol

  !>
  !> interfaces of high order Least-square gradient reconstruction method over single control volume
  !>
  interface gradient_dd_hls_cvol
    module procedure gradient_density_hls_cvol
  end interface gradient_dd_hls_cvol

  !>
  !> interface of cell based velocity reconstruction
  !>
  interface gradient_least_square_cell
    module procedure gradient_least_square_cell_1
  end interface gradient_least_square_cell

  !>
  !> interface of gradient reconstruction method based on spatial interpolation
  !>
  interface gradient_cell_green_gauss
    module procedure gradient_cell_green_gauss_val1d
    module procedure gradient_cell_green_gauss_val2d
  end interface gradient_cell_green_gauss

  contains

  !***********************************************************************************
  !********************Green-Gauss Gradient reconstruction****************************
  !**************************for triangle cells***************************************
  !***********************************************************************************

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh
  !> over control volume
  !>
  subroutine gradient_gg_tri_cvol(ivol, vals, gradient)

    use gen, only : iavs, javs, jacell, cvol

    implicit none

    integer, intent(in) :: ivol
    real*8, allocatable, intent(in) :: vals(:)
    type(point) :: gradient


    !c local variables
    integer :: i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: rhalf = 0.5d0

    call math_common_zero(gradient)

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell1 > 0 .and. icell2 > 0) then
        gradient = gradient + (scalednorm1+ scalednorm2)*              &
                   ((vals(ivol)+vals(jvol))/2.0d0)
      else if(icell1 < 1) then
        gradient = gradient +                                          &
                   scalednorm1*((5.0d0*vals(ivol)+vals(jvol))/6.0d0) + &
                   scalednorm2*((vals(ivol)+vals(jvol))/2.0d0)
      else if(icell2 < 1) then
        gradient = gradient +                                          &
                   scalednorm2*((5.0d0*vals(ivol)+vals(jvol))/6.0d0) + &
                   scalednorm1*((vals(ivol)+vals(jvol))/2.0d0)
      end if
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_gg_tri_cvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh
  !> with increment over control volume
  !>
  subroutine gradient_gg_tri_cvol_inc_kvol(ivol, vals, kvol, inc, gradient)

    use gen, only : iavs, javs, jacell, cvol

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, allocatable, intent(in) :: vals(:)
    real*8, intent(in) :: inc
    type(point) :: gradient


    !c local variables
    integer :: i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: val_ivol, val_jvol
    real*8 :: rswitch1, rswitch2
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: rhalf = 0.5d0


    call math_common_zero(gradient)

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (ivol == kvol) then
        val_ivol = vals(ivol) + inc
        val_jvol = vals(jvol)
      else if (jvol == kvol) then
        val_ivol = vals(ivol)
        val_jvol = vals(jvol) + inc
      else
        val_ivol = vals(ivol)
        val_jvol = vals(jvol)
      end if

      if (icell1 > 0 .and. icell2 > 0) then
        gradient = gradient + (scalednorm1+scalednorm2)*               &
                   ((val_ivol + val_jvol)/2.0d0)
      else if(icell1 < 1) then
        gradient = gradient +                                          &
            scalednorm1*((5.0d0*val_ivol + val_jvol)/6.0d0)+           &
            scalednorm2*((val_ivol + val_jvol)/2.0d0)
      else if(icell2 < 1) then
        gradient = gradient +                                          &
            scalednorm2*((5.0d0*val_ivol + val_jvol)/6.0d0)+           &
            scalednorm1*((val_ivol + val_jvol)/2.0d0)
      end if
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_gg_tri_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh over control volume
  !>
  subroutine gradient_mcd_gg_tri_cvol(ivol, nsize, cnew_vals, cx_vals, &
                                      grad_totc, grad_elec)

    use gen, only : iavs, javs, jacell, cvol

    implicit none

    integer, intent(in) :: ivol, nsize
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: grad_totc(nsize), grad_elec(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol, idvol_r1, idvol_r2,          &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    real*8 :: delta_vals(nsize)
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    external :: totdyvisc, elecmigration

    grad_totc = vector_zero 
    grad_elec = vector_zero

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if


      !c fickian diffusion of MCD
      call totdyvisc(ivol,jvol,cnew_vals(:,ivol),cx_vals(:,ivol),      &
                     cnew_vals(:,jvol),cx_vals(:,jvol),                &
                     delta_vals(:))
      do i = 1, nsize
        if (icell1 > 0 .and. icell2 > 0) then
          grad_totc(i) = grad_totc(i) + (scalednorm1+scalednorm2)*     &
                         (delta_vals(i)/2.0d0)
        else if(icell1 < 1) then
          grad_totc(i) = grad_totc(i) +                                &
                        scalednorm1*(delta_vals(i)/6.0d0) +            &
                        scalednorm2*(delta_vals(i)/2.0d0)
        else if(icell2 < 1) then
          grad_totc(i) = grad_totc(i) +                                &
                        scalednorm2*(delta_vals(i)/6.0d0) +            &
                        scalednorm1*(delta_vals(i)/2.0d0)
        end if
      end do

      !c electrochemical migration of MCD
      call elecmigration(ivol,jvol,cnew_vals(:,ivol),cx_vals(:,ivol),  &
                         cnew_vals(:,jvol),cx_vals(:,jvol),            &
                         delta_vals(:))
      do i = 1, nsize
        if (icell1 > 0 .and. icell2 > 0) then
          grad_elec(i) = grad_elec(i) + (scalednorm1+scalednorm2)*     &
                         (delta_vals(i)/2.0d0)
        else if(icell1 < 1) then
          grad_elec(i) = grad_elec(i) +                                &
                        scalednorm1*(delta_vals(i)/6.0d0) +            &
                        scalednorm2*(delta_vals(i)/2.0d0)
        else if(icell2 < 1) then
          grad_elec(i) = grad_elec(i) +                                &
                        scalednorm2*(delta_vals(i)/6.0d0) +            &
                        scalednorm1*(delta_vals(i)/2.0d0)
        end if
      end do              
    end do

    do i = 1, nsize
      grad_totc(i) = grad_totc(i) / cvol(ivol)
    end do

    do i = 1, nsize
      grad_elec(i) = grad_elec(i) / cvol(ivol)
    end do

  end subroutine gradient_mcd_gg_tri_cvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh over control volume
  !>
  subroutine gradient_mcd_gg_tri_cvol_inc_kvol(ivol,nsize,cnew_vals,cx_vals,   &
                                               kvol,cinc,cxinc,grad_totc,grad_elec)

    use gen, only : iavs, javs, jacell, cvol

    implicit none

    integer, intent(in) :: ivol, nsize,kvol
    real*8, intent(in) :: cinc(:), cxinc(:)
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: grad_totc(nsize), grad_elec(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    real*8 :: delta_vals(nsize)
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    grad_totc = vector_zero 
    grad_elec = vector_zero

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      !c fickian diffusion of MCD
      if (ivol == kvol) then
        call totdyvisc(ivol,jvol,cinc(:),cxinc(:),                     &
                       cnew_vals(:,ivol),cx_vals(:,ivol),              &
                       delta_vals(:))
      else if (jvol == kvol) then
        call totdyvisc(ivol,jvol,cnew_vals(:,jvol),cx_vals(:,jvol),    &
                       cinc(:),cxinc(:),delta_vals(:))
      end if

      if (ivol == kvol .or. jvol == kvol) then
        do i = 1, nsize
          if (icell1 > 0 .and. icell2 > 0) then
            grad_totc(i) = grad_totc(i) +                              &
                           (scalednorm1+scalednorm2)*                  &
                           (delta_vals(i)/2.0d0)
          else if(icell1 < 1) then
            grad_totc(i) = grad_totc(i) +                              &
                           scalednorm1*(delta_vals(i)/6.0d0) +         &
                           scalednorm2*(delta_vals(i)/2.0d0)
          else if(icell2 < 1) then
            grad_totc(i) = grad_totc(i) +                              &
                           scalednorm2*(delta_vals(i)/6.0d0) +         &
                           scalednorm1*(delta_vals(i)/2.0d0)
          end if
        end do
      end if

      !c electrochemical migration of MCD
      if (ivol == kvol) then
        call elecmigration(ivol,jvol,cinc(:),cxinc(:),                 &
                           cnew_vals(:,ivol),cx_vals(:,ivol),          &
                           delta_vals(:))
      else if (jvol == kvol) then
        call elecmigration(ivol,jvol,cnew_vals(:,jvol),cx_vals(:,jvol),&
                           cinc(:),cxinc(:),delta_vals(:))
      end if

      if (ivol == kvol .or. jvol == kvol) then
        do i = 1, nsize
          if (icell1 > 0 .and. icell2 > 0) then
            grad_elec(i) = grad_elec(i) +                              &
                           (scalednorm1+scalednorm2)*                  &
                           (delta_vals(i)/2.0d0)
          else if(icell1 < 1) then
            grad_elec(i) = grad_elec(i) +                              &
                           scalednorm1*(delta_vals(i)/6.0d0) +         &
                           scalednorm2*(delta_vals(i)/2.0d0)
          else if(icell2 < 1) then
            grad_elec(i) = grad_elec(i) +                              &
                           scalednorm2*(delta_vals(i)/6.0d0) +         &
                           scalednorm1*(delta_vals(i)/2.0d0)
          end if
        end do
      end if

    end do

    do i = 1, nsize
      grad_totc(i) = grad_totc(i) / cvol(ivol)
    end do

    do i = 1, nsize
      grad_elec(i) = grad_elec(i) / cvol(ivol)
    end do

  end subroutine gradient_mcd_gg_tri_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh over control volume
  !>
  subroutine gradient_conc_gg_tri_cvol(ivol, nsize, vals, gradient)

    use gen, only : iavs, javs, jacell, cvol

    implicit none

    integer, intent(in) :: ivol, nsize
    real*8, allocatable, intent(in) :: vals(:,:)
    type(point) :: gradient(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol, idvol_r1, idvol_r2,          &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: rhalf = 0.5d0

    do i =1, nsize
      call math_common_zero(gradient(i))
    end do

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,      &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*&
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*   &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),       &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,      &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*&
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*   &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),       &
                                      cell_projection,.false.)*rhalf
      end if

      do i = 1, nsize
        if (icell1 > 0 .and. icell2 > 0) then
          gradient(i) = gradient(i) + (scalednorm1+scalednorm2)*     &
                        ((vals(i,ivol)+vals(i,jvol))/2.0d0)
        else if(icell1 < 1) then
          gradient(i) = gradient(i) +                                &
                        scalednorm1*                                 &
                        ((5.0d0*vals(i,ivol)+vals(i,jvol))/6.0d0) +  &
                        scalednorm2*                                 &
                        ((vals(i,ivol)+vals(i,jvol))/2.0d0)
        else if(icell2 < 1) then
          gradient(i) = gradient(i) +                                &
                        scalednorm2*                                 &
                        ((5.0d0*vals(i,ivol)+vals(i,jvol))/6.0d0) +  &
                        scalednorm1*                                 &
                        ((vals(i,ivol)+vals(i,jvol))/2.0d0)
        end if
      end do
    end do

    do i = 1, nsize
      gradient(i) = gradient(i) / cvol(ivol)
    end do

  end subroutine gradient_conc_gg_tri_cvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh
  !> with increment over control volume
  !>
  subroutine gradient_conc_gg_tri_cvol_inc_kvol(ivol, nsize, kvol, dtc, gradient)

    use gen, only : iavs, javs, jacell, cvol

    implicit none

    integer, intent(in) :: ivol, nsize, kvol
    real*8, intent(in) :: dtc(nsize)
    type(point) :: gradient(nsize)


    !c local variables
    integer :: i, i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: inc_kvol
    real*8 :: rswitch1, rswitch2
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0


    do i = 1, nsize
      call math_common_zero(gradient(i))
    end do

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      do i = 1, nsize
        if (ivol == kvol .or. jvol == kvol) then
          if (icell1 > 0 .and. icell2 > 0) then
            gradient(i) = gradient(i) + (scalednorm1+scalednorm2)*     &
                          (dtc(i)/2.0d0)
          else if(icell1 < 1) then
            if (ivol == kvol) then
              gradient(i) = gradient(i) +                              &
                            scalednorm1*(5.0d0*dtc(i)/6.0d0) +         &
                            scalednorm2*(dtc(i)/2.0d0)
            else if (jvol == kvol) then
              gradient(i) = gradient(i) +                              &
                            scalednorm1*(dtc(i)/6.0d0) +               &
                            scalednorm2*(dtc(i)/2.0d0)
            end if
          else if(icell2 < 1) then
            if (ivol == kvol) then
              gradient(i) = gradient(i) +                              &
                            scalednorm2*(5.0d0*dtc(i)/6.0d0) +         &
                            scalednorm1*(dtc(i)/2.0d0)
            else if (jvol == kvol) then
              gradient(i) = gradient(i) +                              &
                            scalednorm2*(dtc(i)/6.0d0) +               &
                            scalednorm1*(dtc(i)/2.0d0)
            end if
          end if
        end if     
      end do
    end do

    do i = 1, nsize
      gradient(i) = gradient(i) / cvol(ivol)
    end do

  end subroutine gradient_conc_gg_tri_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_gg_tri_cvol(ivol, gradient)

    use gen, only : iavs, javs, jacell, cvol, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol
    type(point) :: gradient


    !c local variables
    integer :: i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    real*8 :: rho_g_h, delta_p
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*              &
                      (nodes(jvol)%z-nodes(ivol)%z)
      delta_p = uvsnew(jvol) - uvsnew(ivol) + rho_g_h

      if (icell1 > 0 .and. icell2 > 0) then
        gradient = gradient +                                          &
                   (scalednorm1+scalednorm2)*(delta_p/2.0d0)
      else if(icell1 < 1) then
        gradient = gradient +                                          &
                   scalednorm1*(delta_p/6.0d0) +                       &
                   scalednorm2*(delta_p/2.0d0)
      else if(icell2 < 1) then
        gradient = gradient +                                          &
                   scalednorm2*(delta_p/6.0d0) +                       &
                   scalednorm1*(delta_p/2.0d0)
      end if

    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_density_gg_tri_cvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient,
  !> thus the increment is treated as the pressure difference
  !>
  subroutine gradient_density_gg_tri_cvol_inc_kvol(ivol, kvol, uvsinc, gradient)

    use gen, only : iavs, javs, jacell, cvol, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, intent(in) :: uvsinc
    type(point) :: gradient


    !c local variables
    integer :: i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    real*8 :: rho_g_h, delta_p
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*              &
                      (nodes(jvol)%z-nodes(ivol)%z)

      if (ivol == kvol) then
        delta_p = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
      else if (jvol == kvol) then
        delta_p = (uvsnew(jvol)+uvsinc) - uvsnew(ivol) + rho_g_h
      else
        delta_p = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
      end if


      if (icell1 > 0 .and. icell2 > 0) then
        gradient = gradient +                                          &
                   (scalednorm1+scalednorm2)*(delta_p/2.0d0)
      else if(icell1 < 1) then
        gradient = gradient +                                          &
                   scalednorm1*(delta_p/6.0d0) +                       &
                   scalednorm2*(delta_p/2.0d0)
      else if(icell2 < 1) then
        gradient = gradient +                                          &
                   scalednorm2*(delta_p/6.0d0) +                       &
                   scalednorm1*(delta_p/2.0d0)
      end if
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_density_gg_tri_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient,
  !> thus the increment is treated as the pressure difference
  !>
  subroutine gradient_density_gg_tri_cvol_inc2_kvol(ivol, kvol, uvsinc, deninc, gradient)

    use gen, only : iavs, javs, jacell, cvol, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol,kvol
    real*8, intent(in) :: uvsinc,deninc
    type(point) :: gradient


    !c local variables
    integer :: i1, istart, iend, jvol, idvol_r1, idvol_r2,             &
               iedge_r1, iedge_r2, icell1, icell2
    real*8 :: rswitch1, rswitch2
    real*8 :: rho_g_h, delta_p
    type(point) :: scalednorm1, scalednorm2
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      icell1 = jacell(1,i1)
      icell2 = jacell(2,i1)

      if (icell1 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell1,idvol_r1,        &
                                   iedge_r1,rswitch1)
        scalednorm1 = CellCvolFaceUnitNorm(idvol_r1,iedge_r1,icell1)*  &
                      (CellCvolFaceArea(idvol_r1,iedge_r1,icell1)*     &
                      rswitch1)
      else
        scalednorm1 = geometry_normal(nodes(jvol),nodes(ivol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (icell2 > 0) then
        call get_cell_edge_cvol_id(1,ivol,jvol,icell2,idvol_r2,        &
                                   iedge_r2,rswitch2)
        scalednorm2 = CellCvolFaceUnitNorm(idvol_r2,iedge_r2,icell2)*  &
                      (CellCvolFaceArea(idvol_r2,iedge_r2,icell2)*     &
                      rswitch2)
      else
        scalednorm2 = geometry_normal(nodes(ivol),nodes(jvol),         &
                                      cell_projection,.false.)*rhalf
      end if

      if (ivol == kvol) then
        rho_g_h = rhalf*(density(ivol)+deninc+density(jvol))*gacc*     &
                        (nodes(jvol)%z-nodes(ivol)%z)
        delta_p = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
      else if (jvol == kvol) then
        rho_g_h = rhalf*(density(ivol)+deninc+density(jvol))*gacc*     &
                        (nodes(jvol)%z-nodes(ivol)%z)
        delta_p = (uvsnew(jvol)+uvsinc) - uvsnew(ivol) + rho_g_h
      else
        rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*            &
                        (nodes(jvol)%z-nodes(ivol)%z)
        delta_p = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
      end if      

      if (icell1 > 0 .and. icell2 > 0) then
        gradient = gradient +                                          &
                   (scalednorm1+scalednorm2)*(delta_p/2.0d0)
      else if(icell1 < 1) then
        gradient = gradient +                                          &
                   scalednorm1*(delta_p/6.0d0) +                       &
                   scalednorm2*(delta_p/2.0d0)
      else if(icell2 < 1) then
        gradient = gradient +                                          &
                   scalednorm2*(delta_p/6.0d0) +                       &
                   scalednorm1*(delta_p/2.0d0)
      end if
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_density_gg_tri_cvol_inc2_kvol

  !***********************************************************************************
  !********************Green-Gauss Gradient reconstruction****************************
  !**************************for tetrahedra cells*************************************
  !********* !!!! THIS PART IS NOT STRICT, NEED FURTHER MODIFICATION !!!! ************
  !***********************************************************************************
  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh
  !> with increment over control volume
  !>
  subroutine gradient_gg_tetra_cvol(ivol, vals, gradient, kvol_opt, inc_opt)

    use gen, only : cvol

    implicit none

    integer, intent(in) :: ivol
    real*8, allocatable, intent(in) :: vals(:)
    integer, intent(in), optional :: kvol_opt
    real*8, intent(in), optional :: inc_opt
    type(point) :: gradient


    !c local variables
    integer :: icell, inode, cindex, jvol, kvol
    real*8 :: inc, val
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0

    if (present(inc_opt)) then
      inc = inc_opt
    else
      inc = r0
    end if

    if (present(kvol_opt)) then
      kvol = kvol_opt
    else
      kvol = ivol
    end if

    call math_common_zero(gradient)

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1
        if (jvol == kvol) then
          val = vals(jvol)+inc
        else
          val = vals(jvol)
        end if
        gradient = gradient + scaledinwardnorm*(val/r12)
      end do
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_gg_tetra_cvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !>
  subroutine gradient_mcd_gg_tetra_cvol(ivol, nsize, cnew_vals, cx_vals,       &
                                        grad_totc, grad_elec)

    use gen, only : cvol

    implicit none

    integer, intent(in) :: ivol, nsize
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: grad_totc(nsize), grad_elec(nsize)

    !c local variables
    integer :: i, icell, inode, cindex, jvol
    real*8 :: val
    real*8 :: delta_vals(nsize)
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0

    grad_totc = vector_zero 
    grad_elec = vector_zero

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1

        !c electrochemical migration of MCD
        call totdyvisc(ivol,jvol,cnew_vals(:,ivol),cx_vals(:,ivol),    &
                       cnew_vals(:,jvol),cx_vals(:,jvol),              &
                       delta_vals(:))
        do i = 1, nsize
          val = delta_vals(i)
          grad_totc(i) = grad_totc(i) + scaledinwardnorm*(val/r12)
        end do 

        !c fickian diffusion of MCD
        call elecmigration(ivol,jvol,cnew_vals(:,ivol),cx_vals(:,ivol),&
                           cnew_vals(:,jvol),cx_vals(:,jvol),          &
                           delta_vals(:))
        do i = 1, nsize
          val = delta_vals(i)
          grad_elec(i) = grad_elec(i) + scaledinwardnorm*(val/r12)
        end do 

      end do
    end do

    do i = 1, nsize
      grad_totc(i) = grad_totc(i) / cvol(ivol)
    end do

    do i = 1, nsize
      grad_elec(i) = grad_elec(i) / cvol(ivol)
    end do

  end subroutine gradient_mcd_gg_tetra_cvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !>
  subroutine gradient_mcd_gg_tetra_cvol_inc_kvol(ivol,nsize,cnew_vals, &
                          cx_vals,kvol,cinc,cxinc,grad_totc,grad_elec)

    use gen, only : cvol

    implicit none

    integer, intent(in) :: ivol,nsize,kvol
    real*8, intent(in) :: cinc(:), cxinc(:)
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: grad_totc(nsize), grad_elec(nsize)

    !c local variables
    integer :: i, icell, inode, cindex, jvol
    real*8 :: val
    real*8 :: delta_vals(nsize)
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0

    grad_totc = vector_zero
    grad_elec = vector_zero

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1

        !c fickian diffusion of MCD
        if (ivol == kvol) then
          call totdyvisc(ivol,jvol,cinc(:),cxinc(:),                   &
                         cnew_vals(:,ivol),cx_vals(:,ivol),            &
                         delta_vals(:))
        else if (jvol == kvol) then
          call totdyvisc(ivol,jvol,cnew_vals(:,jvol),cx_vals(:,jvol),  &
                         cinc(:),cxinc(:),delta_vals(:))
        end if

        if (ivol == kvol .or. jvol == kvol) then
          do i = 1, nsize
            val = delta_vals(i)
            grad_totc(i) = grad_totc(i) + scaledinwardnorm*(val/r12)
          end do
        end if

        !c electrochemical migration of MCD
        if (ivol == kvol) then
          call elecmigration(ivol,jvol,cinc(:),cxinc(:),               &
                             cnew_vals(:,ivol),cx_vals(:,ivol),        &
                             delta_vals(:))
        else if (jvol == kvol) then
          call elecmigration(ivol,jvol,cnew_vals(:,jvol),cx_vals(:,jvol),&
                             cinc(:),cxinc(:),delta_vals(:))
        end if

        if (ivol == kvol .or. jvol == kvol) then
          do i = 1, nsize
            val = delta_vals(i)
            grad_elec(i) = grad_elec(i) + scaledinwardnorm*(val/r12)
          end do
        end if

      end do
    end do

    do i = 1, nsize
      grad_totc(i) = grad_totc(i) / cvol(ivol)
    end do

    do i = 1, nsize
      grad_elec(i) = grad_elec(i) / cvol(ivol)
    end do

  end subroutine gradient_mcd_gg_tetra_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !>
  subroutine gradient_conc_gg_tetra_cvol(ivol, nsize, vals, gradient)

    use gen, only : cvol

    implicit none

    integer, intent(in) :: ivol, nsize
    real*8, allocatable, intent(in) :: vals(:,:)
    type(point) :: gradient(nsize)

    !c local variables
    integer :: i, icell, inode, cindex, jvol
    real*8 :: val
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0

    do i =1, nsize
      call math_common_zero(gradient(i))
    end do

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1
        do i = 1, nsize
          val = vals(i,jvol)
          gradient(i) = gradient(i) + scaledinwardnorm*(val/r12)
        end do
      end do
    end do

    do i = 1, nsize
      gradient(i) = gradient(i) / cvol(ivol)
    end do

  end subroutine gradient_conc_gg_tetra_cvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !>
  subroutine gradient_conc_gg_tetra_cvol_inc_kvol(ivol, nsize, kvol, dtc, gradient)

    use gen, only : cvol

    implicit none

    integer, intent(in) :: ivol, nsize, kvol
    real*8, intent(in) :: dtc(nsize)
    type(point) :: gradient(nsize)

    !c local variables
    integer :: i, icell, inode, cindex, jvol
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0

    do i =1, nsize
      call math_common_zero(gradient(i))
    end do

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        if (ivol == kvol .or. jvol == kvol) then
          scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1
          do i = 1, nsize          
            gradient(i) = gradient(i) + scaledinwardnorm*(dtc(i)/r12)         
          end do
        end if
      end do
    end do

    do i = 1, nsize
      gradient(i) = gradient(i) / cvol(ivol)
    end do

  end subroutine gradient_conc_gg_tetra_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_gg_tetra_cvol(ivol, gradient, uvsinc_opt)

    use gen, only : gacc, uvsnew, cvol
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol
    real*8, intent(in), optional :: uvsinc_opt
    type(point) :: gradient


    !c local variables
    integer :: icell, inode, cindex, jvol
    real*8 :: val
    real*8 :: rho_g_h, delta_p, uvsinc
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0,  rhalf = 0.5d0

    call math_common_zero(gradient)

    if (present(uvsinc_opt)) then
      uvsinc = uvsinc_opt
    else
      uvsinc = r0
    end if

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1
        if (ivol == jvol) then
          val = r0
        else
          rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*    &
                    (nodes(jvol)%z-nodes(ivol)%z)
          val = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
        end if
        gradient = gradient + scaledinwardnorm*(val/r12)
      end do
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_density_gg_tetra_cvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_gg_tetra_cvol_inc_kvol(ivol, kvol, uvsinc, gradient)

    use gen, only : gacc, uvsnew, cvol
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, intent(in) :: uvsinc
    type(point) :: gradient


    !c local variables
    integer :: icell, inode, cindex, jvol
    real*8 :: val
    real*8 :: rho_g_h, delta_p
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0,  rhalf = 0.5d0

    call math_common_zero(gradient)

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1
        if (ivol == jvol) then
          val = r0
        else
          rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*          &
                    (nodes(jvol)%z-nodes(ivol)%z)
          if (jvol == kvol) then
            val = uvsnew(jvol) + uvsinc - uvsnew(ivol) + rho_g_h
          else
            val = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
          end if

          if (ivol == kvol) then
            val = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
          else if (jvol == kvol) then
            val = (uvsnew(jvol)+uvsinc) - uvsnew(ivol) + rho_g_h
          else
            val = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
          end if

        end if
        gradient = gradient + scaledinwardnorm*(val/r12)
      end do
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_density_gg_tetra_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_gg_tetra_cvol_inc2_kvol(ivol, kvol, uvsinc, deninc, gradient)

    use gen, only : gacc, uvsnew, cvol
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, intent(in) :: uvsinc, deninc
    type(point) :: gradient


    !c local variables
    integer :: icell, inode, cindex, jvol
    real*8 :: val
    real*8 :: rho_g_h, delta_p
    type(point) :: scaledinwardnorm
    real*8, parameter :: r0 = 0.0d0, r12 = 12.0d0, r_1 = -1.0d0,  rhalf = 0.5d0

    call math_common_zero(gradient)

    do icell = 1, node_num_cells(ivol)
      cindex = node_cells(icell,ivol)
      do inode = 1, num_nodes_per_cell
        jvol = cells(inode,cindex)
        scaledinwardnorm = CellFaceScaledNorm(inode,cindex)*r_1
        if (ivol == jvol) then
          val = r0
        else
          if (ivol == kvol) then
            rho_g_h = rhalf*(density(ivol)+density(jvol)+deninc)*gacc* &
                      (nodes(jvol)%z-nodes(ivol)%z)
            val = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
          else if (jvol == kvol) then
            rho_g_h = rhalf*(density(ivol)+density(jvol)+deninc)*gacc* &
                      (nodes(jvol)%z-nodes(ivol)%z)
            val = (uvsnew(jvol)+uvsinc) - uvsnew(ivol) + rho_g_h
          else
            rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc* &
                      (nodes(jvol)%z-nodes(ivol)%z)
            val = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
          end if

        end if
        gradient = gradient + scaledinwardnorm*(val/r12)
      end do
    end do

    gradient = gradient / cvol(ivol)

  end subroutine gradient_density_gg_tetra_cvol_inc2_kvol

  !***********************************************************************************
  !********************Least-Square Gradient reconstruction***************************
  !***********************************************************************************

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !>
  subroutine gradient_ls_cvol(ivol, vals, gradient)

    use gen, only : iavs, javs, jaedgelen

    implicit none

    integer, intent(in) :: ivol
    real*8, allocatable, intent(in) :: vals(:)
    type(point) :: gradient

    !c local variables
    integer :: i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, b1, b2, b3

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)

      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z
      duij = vals(jvol) - vals(ivol)
      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*grad_ls_matrices(ivol)%bcoef11 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef13

    gradient%y = b1*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef22 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef23

    gradient%z = b1*grad_ls_matrices(ivol)%bcoef13 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef23 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef33

  end subroutine gradient_ls_cvol

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !>
  subroutine gradient_ls_cvol_inc_kvol(ivol, vals, kvol, inc, gradient)

    use gen, only : iavs, javs, jaedgelen

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, allocatable, intent(in) :: vals(:)
    real*8, intent(in) :: inc
    type(point) :: gradient

    !c local variables
    integer :: i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, b1, b2, b3

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      if (ivol == kvol) then
        duij = vals(jvol) - (vals(ivol)+inc)
      else if (jvol == kvol) then
        duij = (vals(jvol)+inc) - vals(ivol)
      else
        duij = vals(jvol) - vals(ivol)
      end if

      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*grad_ls_matrices(ivol)%bcoef11 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef13

    gradient%y = b1*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef22 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef23

    gradient%z = b1*grad_ls_matrices(ivol)%bcoef13 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef23 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef33

  end subroutine gradient_ls_cvol_inc_kvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !>
  subroutine gradient_mcd_ls_cvol(ivol, nsize, cnew_vals, cx_vals,     &
                                  grad_totc, grad_elec)

    use gen, only : iavs, javs, jaedgelen

    implicit none

    integer, intent(in) :: ivol, nsize
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: grad_totc(nsize), grad_elec(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij
    real*8 :: delta_vals(nsize)
    real*8, allocatable :: b1(:), b2(:), b3(:)

    grad_totc = vector_zero 
    grad_elec = vector_zero

    allocate(b1(nsize))
    allocate(b2(nsize))
    allocate(b3(nsize))

    !c fickian diffusion of MCD
    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1  

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      !c fickian diffusion of MCD
      call totdyvisc(ivol,jvol,cnew_vals(:,ivol),cx_vals(:,ivol),      &
                     cnew_vals(:,jvol),cx_vals(:,jvol),                &
                     delta_vals(:))

      do i = 1, nsize
        duij = delta_vals(i)
        b1(i) = b1(i) + wij2*duij*dxij
        b2(i) = b2(i) + wij2*duij*dyij
        b3(i) = b3(i) + wij2*duij*dzij
      end do
    end do

    do i = 1, nsize
      grad_totc(i)%x = b1(i)*grad_ls_matrices(ivol)%bcoef11 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef13

      grad_totc(i)%y = b1(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef22 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef23

      grad_totc(i)%z = b1(i)*grad_ls_matrices(ivol)%bcoef13 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef23 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef33
    end do

    !c electrochemical migration of MCD
    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1  

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      !c electrochemical migration of MCD
      call elecmigration(ivol,jvol,cnew_vals(:,ivol),cx_vals(:,ivol),  &
                         cnew_vals(:,jvol),cx_vals(:,jvol),            &
                         delta_vals(:))

      do i = 1, nsize
        duij = delta_vals(i)
        b1(i) = b1(i) + wij2*duij*dxij
        b2(i) = b2(i) + wij2*duij*dyij
        b3(i) = b3(i) + wij2*duij*dzij
      end do
    end do

    do i = 1, nsize
      grad_elec(i)%x = b1(i)*grad_ls_matrices(ivol)%bcoef11 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef13

      grad_elec(i)%y = b1(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef22 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef23

      grad_elec(i)%z = b1(i)*grad_ls_matrices(ivol)%bcoef13 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef23 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef33
    end do    

    deallocate(b1)
    deallocate(b2)
    deallocate(b3)

  end subroutine gradient_mcd_ls_cvol

  !>
  !> Green-Gauss gradient reconstruction method for tetrahedra mesh over control volume
  !>
  subroutine gradient_mcd_ls_cvol_inc_kvol(ivol,nsize,cnew_vals,cx_vals,       &
                                           kvol,cinc,cxinc,grad_totc,grad_elec)

    use gen, only : iavs, javs, jaedgelen

    implicit none

    integer, intent(in) :: ivol, nsize, kvol
    real*8, intent(in) :: cinc(:), cxinc(:)
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: grad_totc(nsize), grad_elec(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij
    real*8 :: delta_vals(nsize)
    real*8, allocatable :: b1(:), b2(:), b3(:)
    real*8, parameter :: r0 = 0.0d0

    grad_totc = vector_zero
    grad_elec = vector_zero

    allocate(b1(nsize))
    allocate(b2(nsize))
    allocate(b3(nsize))

    !c fickian diffusion of MCD
    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0    

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1
    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      !c fickian diffusion of MCD
      if (ivol == kvol) then
        call totdyvisc(ivol,jvol,cinc(:),cxinc(:),                     &
                       cnew_vals(:,ivol),cx_vals(:,ivol),              &
                       delta_vals(:))
      else if (jvol == kvol) then
        call totdyvisc(ivol,jvol,cnew_vals(:,jvol),cx_vals(:,jvol),    &
                       cinc(:),cxinc(:),delta_vals(:))
      end if

      if (ivol == kvol .or. jvol == kvol) then
        do i = 1, nsize   
          duij = delta_vals(i)
          b1(i) = b1(i) + wij2*duij*dxij
          b2(i) = b2(i) + wij2*duij*dyij
          b3(i) = b3(i) + wij2*duij*dzij
        end do
      end if
    end do

    do i = 1, nsize
      grad_totc(i)%x = b1(i)*grad_ls_matrices(ivol)%bcoef11 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef13

      grad_totc(i)%y = b1(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef22 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef23

      grad_totc(i)%z = b1(i)*grad_ls_matrices(ivol)%bcoef13 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef23 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef33
    end do

    !c electrochemical migration of MCD
    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0    

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1
    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      !c electrochemical migration of MCD
      if (ivol == kvol) then
        call elecmigration(ivol,jvol,cinc(:),cxinc(:),                 &
                           cnew_vals(:,ivol),cx_vals(:,ivol),          &
                           delta_vals(:))
      else if (jvol == kvol) then
        call elecmigration(ivol,jvol,cnew_vals(:,jvol),cx_vals(:,jvol),&
                           cinc(:),cxinc(:),delta_vals(:))
      end if

      if (ivol == kvol .or. jvol == kvol) then
        do i = 1, nsize
          duij = delta_vals(i)
          b1(i) = b1(i) + wij2*duij*dxij
          b2(i) = b2(i) + wij2*duij*dyij
          b3(i) = b3(i) + wij2*duij*dzij
        end do
      end if
    end do

    do i = 1, nsize
      grad_elec(i)%x = b1(i)*grad_ls_matrices(ivol)%bcoef11 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef13

      grad_elec(i)%y = b1(i)*grad_ls_matrices(ivol)%bcoef12 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef22 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef23

      grad_elec(i)%z = b1(i)*grad_ls_matrices(ivol)%bcoef13 +          &
                       b2(i)*grad_ls_matrices(ivol)%bcoef23 +          &
                       b3(i)*grad_ls_matrices(ivol)%bcoef33
    end do

    deallocate(b1)
    deallocate(b2)
    deallocate(b3)

  end subroutine gradient_mcd_ls_cvol_inc_kvol

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !>
  subroutine gradient_conc_ls_cvol(ivol, nsize, vals, gradient)

    use gen, only : iavs, javs, jaedgelen

    implicit none

    integer, intent(in) :: ivol, nsize
    real*8, allocatable, intent(in) :: vals(:,:)
    type(point) :: gradient(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij
    real*8, allocatable :: b1(:), b2(:), b3(:)

    do i = 1, nsize
      call math_common_zero(gradient(i))
    end do

    allocate(b1(nsize))
    b1 = 0.0d0
    allocate(b2(nsize))
    b2 = 0.0d0
    allocate(b3(nsize))
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1
    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      do i = 1, nsize
        duij = vals(i,jvol) - vals(i,ivol)
        b1(i) = b1(i) + wij2*duij*dxij
        b2(i) = b2(i) + wij2*duij*dyij
        b3(i) = b3(i) + wij2*duij*dzij
      end do
    end do

    do i = 1, nsize
      gradient(i)%x = b1(i)*grad_ls_matrices(ivol)%bcoef11 +           &
                      b2(i)*grad_ls_matrices(ivol)%bcoef12 +           &
                      b3(i)*grad_ls_matrices(ivol)%bcoef13

      gradient(i)%y = b1(i)*grad_ls_matrices(ivol)%bcoef12 +           &
                      b2(i)*grad_ls_matrices(ivol)%bcoef22 +           &
                      b3(i)*grad_ls_matrices(ivol)%bcoef23

      gradient(i)%z = b1(i)*grad_ls_matrices(ivol)%bcoef13 +           &
                      b2(i)*grad_ls_matrices(ivol)%bcoef23 +           &
                      b3(i)*grad_ls_matrices(ivol)%bcoef33
    end do

    deallocate(b1)
    deallocate(b2)
    deallocate(b3)

  end subroutine gradient_conc_ls_cvol

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !> with increment over control volume
  !>
  subroutine gradient_conc_ls_cvol_inc_kvol(ivol, nsize, kvol, dtc, gradient)

    use gen, only : iavs, javs, jaedgelen

    implicit none

    integer, intent(in) :: ivol, nsize, kvol
    real*8 :: dtc(nsize)
    type(point) :: gradient(nsize)

    !c local variables
    integer :: i, i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, inc_kvol
    real*8, allocatable :: b1(:), b2(:), b3(:)

    do i = 1, nsize
      call math_common_zero(gradient(i))
    end do

    allocate(b1(nsize))
    b1 = 0.0d0
    allocate(b2(nsize))
    b2 = 0.0d0
    allocate(b3(nsize))
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1
    do i1 = istart, iend
      jvol = javs(i1)

      if (ivol == kvol .or. jvol == kvol) then
        if(grad_spatial_weighting) then
          wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
        else
          wij2 = 1.0d0
        end if
        dxij = nodes(jvol)%x - nodes(ivol)%x
        dyij = nodes(jvol)%y - nodes(ivol)%y
        dzij = nodes(jvol)%z - nodes(ivol)%z

        do i = 1, nsize
          if (ivol == kvol) then
            duij = -dtc(i)
          else if (jvol == kvol) then
            duij = dtc(i)
          else 
            cycle
          end if
          b1(i) = b1(i) + wij2*duij*dxij
          b2(i) = b2(i) + wij2*duij*dyij
          b3(i) = b3(i) + wij2*duij*dzij
        end do
      end if

    end do

    do i = 1, nsize
      gradient(i)%x = b1(i)*grad_ls_matrices(ivol)%bcoef11 +           &
                      b2(i)*grad_ls_matrices(ivol)%bcoef12 +           &
                      b3(i)*grad_ls_matrices(ivol)%bcoef13

      gradient(i)%y = b1(i)*grad_ls_matrices(ivol)%bcoef12 +           &
                      b2(i)*grad_ls_matrices(ivol)%bcoef22 +           &
                      b3(i)*grad_ls_matrices(ivol)%bcoef23

      gradient(i)%z = b1(i)*grad_ls_matrices(ivol)%bcoef13 +           &
                      b2(i)*grad_ls_matrices(ivol)%bcoef23 +           &
                      b3(i)*grad_ls_matrices(ivol)%bcoef33
    end do

    deallocate(b1)
    deallocate(b2)
    deallocate(b3)

  end subroutine gradient_conc_ls_cvol_inc_kvol

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_ls_cvol(ivol, gradient)

    use gen, only : iavs, javs, jaedgelen, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol
    type(point) :: gradient

    !c local variables
    integer :: i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, b1, b2, b3
    real*8 :: rho_g_h
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*dzij
      duij = uvsnew(jvol) - uvsnew(ivol) + rho_g_h

      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*grad_ls_matrices(ivol)%bcoef11 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef13

    gradient%y = b1*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef22 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef23

    gradient%z = b1*grad_ls_matrices(ivol)%bcoef13 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef23 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef33

  end subroutine gradient_density_ls_cvol

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_ls_cvol_inc(ivol, uvsinc, gradient)

    use gen, only : iavs, javs, jaedgelen, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol
    real*8, intent(in) :: uvsinc
    type(point) :: gradient

    !c local variables
    integer :: i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, b1, b2, b3
    real*8 :: rho_g_h
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*dzij
      duij = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h

      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*grad_ls_matrices(ivol)%bcoef11 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef13

    gradient%y = b1*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef22 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef23

    gradient%z = b1*grad_ls_matrices(ivol)%bcoef13 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef23 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef33

  end subroutine gradient_density_ls_cvol_inc

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient
  !>
  subroutine gradient_density_ls_cvol_inc_kvol(ivol, kvol, uvsinc, gradient)

    use gen, only : iavs, javs, jaedgelen, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, intent(in) :: uvsinc
    type(point) :: gradient

    !c local variables
    integer :: i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, b1, b2, b3
    real*8 :: rho_g_h
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*dzij

      if (ivol == kvol) then
        duij = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
      else if (jvol == kvol) then
        duij = (uvsnew(jvol)+uvsinc) - uvsnew(ivol) + rho_g_h
      else
        duij = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
      end if      

      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*grad_ls_matrices(ivol)%bcoef11 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef13

    gradient%y = b1*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef22 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef23

    gradient%z = b1*grad_ls_matrices(ivol)%bcoef13 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef23 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef33

  end subroutine gradient_density_ls_cvol_inc_kvol

  !>
  !> Least-square gradient reconstruction method for triangle mesh over control volume
  !> Note: for density dependent problem, the delta pressure is used in calculating gradient,
  !> thus the increment is treated as the pressure difference
  !>
  subroutine gradient_density_ls_cvol_inc2_kvol(ivol, kvol, uvsinc, deninc, gradient)

    use gen, only : iavs, javs, jaedgelen, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, kvol
    real*8, intent(in) :: uvsinc, deninc
    type(point) :: gradient

    !c local variables
    integer :: i1, istart, iend, jvol
    real*8 :: wij2, dxij, dyij, dzij, duij, b1, b2, b3
    real*8 :: rho_g_h
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    istart = iavs(ivol)+1
    iend = iavs(ivol+1)-1

    do i1 = istart, iend
      jvol = javs(i1)
      if(grad_spatial_weighting) then
        wij2 = 1.0d0/jaedgelen(i1)**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if
      dxij = nodes(jvol)%x - nodes(ivol)%x
      dyij = nodes(jvol)%y - nodes(ivol)%y
      dzij = nodes(jvol)%z - nodes(ivol)%z

      if (ivol == kvol) then
        rho_g_h = rhalf*(density(ivol)+density(jvol)+deninc)*gacc*dzij
        duij = uvsnew(jvol) - (uvsnew(ivol)+uvsinc) + rho_g_h
      else if (jvol == kvol) then
        rho_g_h = rhalf*(density(ivol)+density(jvol)+deninc)*gacc*dzij
        duij = (uvsnew(jvol)+uvsinc) - uvsnew(ivol) + rho_g_h
      else
        rho_g_h = rhalf*(density(ivol)+density(jvol))*gacc*dzij
        duij = uvsnew(jvol) - uvsnew(ivol) + rho_g_h
      end if

      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*grad_ls_matrices(ivol)%bcoef11 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef13

    gradient%y = b1*grad_ls_matrices(ivol)%bcoef12 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef22 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef23

    gradient%z = b1*grad_ls_matrices(ivol)%bcoef13 +                   &
                 b2*grad_ls_matrices(ivol)%bcoef23 +                   &
                 b3*grad_ls_matrices(ivol)%bcoef33

  end subroutine gradient_density_ls_cvol_inc2_kvol

  !***********************************************************************************
  !***************High order Least-Square Gradient reconstruction*********************
  !***********************************************************************************
  !>
  !> calculate ax=b -> x = pinv(a)*b
  !>
  subroutine gradient_hls_matxbvals(matpinv, weighting, bvals, vwork)

    implicit none

    real*8, intent(in) :: matpinv(:,:)
    real*8, intent(in) :: weighting(:)
    real*8, intent(in) :: bvals(:)
    real*8, intent(inout) :: vwork(:)

    !c local variable
    integer :: irow, icol, nrow, ncol

    nrow = size(matpinv,1)
    ncol = size(matpinv,2)

    do icol = 1, ncol
      vwork(icol) = 0.0d0
      do irow = 1, nrow
        vwork(icol) = vwork(icol) + matpinv(irow,icol)*bvals(irow)*weighting(irow)
      end do
    end do

  end subroutine gradient_hls_matxbvals

  !>
  !> calculate truncation error for second and higher order term
  !>
  function gradient_hls_taylor_eps_2d(ngrads, xvals, dxn, dyn, dxp, dyp) result(eps)

    implicit none

    integer, intent(in) :: ngrads
    real*8, intent(in) :: xvals(ngrads)
    real*8, intent(in) :: dxn, dyn, dxp, dyp
    real*8 :: eps

    real*8, parameter :: r0 = 0.0d0, r2 = 2.0d0, r3 = 3.0d0, r6 = 6.0d0

    eps = r0

    if (ngrads > 3) then
      eps = eps + ((xvals(4)*dxn**2 + xvals(5)*dyn**2 +                    &
                    r2*xvals(6)*dxn*dyn) -                                 &
                   (xvals(4)*dxp**2 + xvals(5)*dyp**2 +                    &
                    r2*xvals(6)*dxp*dyp))/r2
    end if

    if (ngrads > 6) then
      eps = eps + ((xvals(7)*dxn**3 + xvals(8)*dyn**3 +                    &
                    r3*xvals(9)*dxn*dxn*dyn+r3*xvals(10)*dxn*dyn*dyn)-     &
                   (xvals(7)*dxp**3 + xvals(8)*dyp**3 +                    &
                    r3*xvals(9)*dxp*dxp*dyp+r3*xvals(10)*dxp*dyp*dyp))/r6
    end if

  end function gradient_hls_taylor_eps_2d

  !>
  !> calculate truncation error for second and higher order term
  !>
  function gradient_hls_taylor_eps_3d(ngrads, xvals, dxn, dyn, dzn,        &
                                      dxp, dyp, dzp) result(eps)

    implicit none

    integer, intent(in) :: ngrads
    real*8, intent(in) :: xvals(ngrads)
    real*8, intent(in) :: dxn, dyn, dzn, dxp, dyp, dzp
    real*8 :: eps

    real*8, parameter :: r0 = 0.0d0, r2 = 2.0d0, r3 = 3.0d0, r6 = 6.0d0

    eps = r0

    if (ngrads > 4) then
      eps = eps + ((xvals(5)*dxn**2 + xvals(6)*dyn**2 + xvals(7)*dzn**2 +  &
                    r2*xvals(8)*dxn*dyn + r2*xvals(9)*dxn*dzn +            &
                    r2*xvals(10)*dyn*dzn) -                                &
                   (xvals(5)*dxp**2 + xvals(6)*dyp**2 + xvals(7)*dzp**2 +  &
                    r2*xvals(8)*dxp*dyp + r2*xvals(9)*dxp*dzp +            &
                    r2*xvals(10)*dyp*dzp))/r2
    end if

    if (ngrads > 10) then
      eps = eps + ((xvals(11)*dxn**3 + xvals(12)*dyn**3 + xvals(13)*dzn**3 + &
                    r3*xvals(14)*dxn*dxn*dyn + r3*xvals(15)*dxn*dxn*dzn +    &
                    r3*xvals(16)*dyn*dyn*dxn + r3*xvals(17)*dyn*dyn*dzn +    &
                    r3*xvals(18)*dzn*dzn*dxn + r3*xvals(19)*dzn*dzn*dyn)-    &
                   (xvals(11)*dxp**3 + xvals(12)*dyp**3 + xvals(13)*dzp**3 + &
                    r3*xvals(14)*dxp*dxp*dyp + r3*xvals(15)*dxp*dxp*dzp +    &
                    r3*xvals(16)*dyp*dyp*dxp + r3*xvals(17)*dyp*dyp*dzp +    &
                    r3*xvals(18)*dzp*dzp*dxp + r3*xvals(19)*dzp*dzp*dyp))/r6
    end if

  end function gradient_hls_taylor_eps_3d


  !>
  !> retrieve gradient in space from the temporary array for a single cell
  !>
  subroutine gradient_hls_retrieve_grad(iplane, ngrads, dxn, dyn, dzn,       &
                                        dxp, dyp, dzp, grad_work, grad)

    implicit none

    integer, intent(in) :: iplane, ngrads
    real*8, intent(in) :: dxn, dyn, dzn, dxp, dyp, dzp
    real*8, intent(in) :: grad_work(ngrads)
    type(grad_hls_term) :: grad

    real*8, parameter :: r0 = 0.0d0

    if (iplane == projection_xy) then
      !c grad%var = grad_work(1)
      grad%grad = math_common_set_vector(grad_work(2),grad_work(3),r0)
      grad%eps = gradient_hls_taylor_eps_2d(ngrads, grad_work,              &
                          dxn, dyn, dxp, dyp)
    else if (iplane == projection_yz) then
      !c grad%var = grad_work(1)
      grad%grad = math_common_set_vector(r0,grad_work(2),grad_work(3))
      grad%eps = gradient_hls_taylor_eps_2d(ngrads, grad_work,              &
                          dyn, dzn, dyp, dzp)
    else if (iplane == projection_xz) then
      !c grad%var = grad_work(1)
      grad%grad = math_common_set_vector(grad_work(2),r0,grad_work(3))
      grad%eps = gradient_hls_taylor_eps_2d(ngrads, grad_work,              &
                          dxn, dzn, dxp, dzp)
    else if (iplane == projection_xyz) then
      !c grad%var = grad_work(1)
      grad%grad = math_common_set_vector(grad_work(2),grad_work(3),grad_work(4))
      grad%eps = gradient_hls_taylor_eps_3d(ngrads, grad_work,              &
                          dxn, dyn, dzn, dxp, dyp, dzp)
    end if

  end subroutine gradient_hls_retrieve_grad


  !>
  !> Least-square gradient reconstruction method for triangle mesh over single control volume
  !>
  subroutine gradient_hls_cvol_1(ivol, jvol, icell, vals, grads, kvol_opt, inc_opt)

    use gen, only : njavs, iavs, janumcell, jacell

    implicit none
    integer, intent(in) :: ivol, jvol, icell
    real*8, allocatable, intent(in) :: vals(:)
    type(grad_hls_term) :: grads(num_edge_dvols)
    integer, intent(in), optional :: kvol_opt
    real*8, intent(in), optional :: inc_opt

    !c local variables
    integer :: ngrads
    integer :: j, istart2, iend2, idvol, jvol2, jtemp2, kvol,          &
               idvol_r, iedge_r, iptn, iptp
    real*8 :: inc, cvolfacearea
    real*8 :: dxn, dyn, dzn, dxp, dyp, dzp
    real*8 :: bvals(cell_ajd_max_nodes)
    real*8 :: xvals(grad_hls_min_nodes)
    real*8 :: grad_work(grad_hls_min_nodes)
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    if (present(kvol_opt)) then
      kvol = kvol_opt
    else
      kvol = ivol
    end if

    if (present(inc_opt)) then
      inc = inc_opt
    else
      inc = r0
    end if

    grads(:)%grad = vector_zero
    grads(:)%eps = r0

    ngrads = grad_hls_min_nodes

    !c calculate gradient vector and store them to a temporary array
    if (icell > 0) then

      istart2 = cell_adj_nodes_ia(icell)
      iend2 = cell_adj_nodes_ia(icell+1)-1
      j = 0
      do jtemp2 = istart2, iend2
        j = j + 1
        jvol2 = cell_adj_nodes_ja(jtemp2)
        if (jvol2 == kvol) then
          bvals(j) = vals(jvol2) + inc
        else
          bvals(j) = vals(jvol2)
        end if
      end do

      do idvol = 1, num_edge_dvols

        call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r)

        cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

        if (cvolfacearea > rsmallarea) then
          call gradient_hls_matxbvals(                                 &
                    grad_hls_matrices(idvol_r,iedge_r,icell)%coef,     &
                    grad_hls_matrices(idvol_r,iedge_r,icell)%weighting,&
                    bvals(1:j),grad_work(1:ngrads))

          if (idvol == idvol_r) then
            iptn = 1
            iptp = 2
          else
            iptn = 2
            iptp = 1
          end if
          dxn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%x
          dyn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%y
          dzn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%z
          dxp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%x
          dyp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%y
          dzp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%z

          call gradient_hls_retrieve_grad(cell_projection,             &
                        ngrads, dxn, dyn, dzn, dxp, dyp, dzp,          &
                        grad_work(1:ngrads),grads(idvol))
        end if
      end do
    end if

  end subroutine gradient_hls_cvol_1

  !>
  !> Least-square gradient reconstruction method for triangle mesh over single control volume
  !>
  subroutine gradient_conc_hls_cvol_1(nsize, ivol, jvol, icell,        &
                      vals, grads, dtc_opt)

    use gen, only : nngl, njavs, iavs, janumcell, jacell

    implicit none
    integer, intent(in) :: nsize, ivol, jvol, icell
    real*8,  intent(in) :: vals(nsize,nngl)
    type(grad_hls_term) :: grads(nsize,num_edge_dvols)
    real*8, intent(in), optional :: dtc_opt(nsize)

    !c local variables
    integer :: ngrads
    integer :: j, istart2, iend2, idvol, jtemp2, ic, jvol2,            &
               idvol_r, iedge_r, iptn, iptp
    real*8 :: cvolfacearea
    real*8 :: dxn, dyn, dzn, dxp, dyp, dzp
    real*8 :: bvals(cell_ajd_max_nodes)
    real*8 :: xvals(grad_hls_min_nodes)
    real*8 :: grad_work_n(grad_hls_min_nodes,num_edge_dvols,nsize)
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmallarea = 1.0d-8

    grads(:,:)%grad = vector_zero
    grads(:,:)%eps = r0

    ngrads = grad_hls_min_nodes

    !c calculate gradient vector and store them to a temporary array
    if (icell > 0) then
      istart2 = cell_adj_nodes_ia(icell)
      iend2 = cell_adj_nodes_ia(icell+1)-1

      do ic = 1, nsize
        j = 0
        do jtemp2 = istart2, iend2
          j = j + 1
          jvol2 = cell_adj_nodes_ja(jtemp2)
          if (present(dtc_opt)) then
            if (jvol2 == ivol) then              
              bvals(j) = dtc_opt(ic)
            else
              bvals(j) = r0
            end if
          else
            bvals(j) = vals(ic,jvol2)
          end if
        end do

        do idvol = 1, num_edge_dvols
          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r)

          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if (cvolfacearea > rsmallarea) then
            call gradient_hls_matxbvals(                               &
                    grad_hls_matrices(idvol_r,iedge_r,icell)%coef,     &
                    grad_hls_matrices(idvol_r,iedge_r,icell)%weighting,&
                    bvals(1:j),grad_work_n(1:ngrads,idvol,ic))
          end if
        end do
      end do

      do idvol = 1, num_edge_dvols
        call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r)

        cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

        if (cvolfacearea > rsmallarea) then

          if (idvol == idvol_r) then
            iptn = 1
            iptp = 2
          else
            iptn = 2
            iptp = 1
          end if

          dxn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%x
          dyn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%y
          dzn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%z
          dxp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%x
          dyp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%y
          dzp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%z

          do ic = 1, nsize
            call gradient_hls_retrieve_grad(cell_projection,           &
                        ngrads, dxn, dyn, dzn, dxp, dyp, dzp,          &
                        grad_work_n(1:ngrads,idvol,ic),               &
                        grads(ic,idvol))
          end do

        end if
      end do

    end if

  end subroutine gradient_conc_hls_cvol_1

  !>
  !> high order least-square gradient reconstruction method for MCD
  !>
  subroutine gradient_mcd_hls_cvol_1(nsize, ivol, jvol, icell,         &
                      cnew_vals, cx_vals, grad_totc, grad_elec,        &
                      cinc_opt, cxinc_opt)

    use gen, only : nngl, njavs, iavs, janumcell, jacell

    implicit none
    integer, intent(in) :: nsize, ivol, jvol, icell
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(grad_hls_term) :: grad_totc(nsize,num_edge_dvols),            &
                           grad_elec(nsize,num_edge_dvols)
    real*8, intent(in), optional :: cinc_opt(:), cxinc_opt(:)

    !c local variables
    integer :: ngrads
    integer :: j, istart2, iend2, idvol, jtemp2, ic, jvol2,            &
               idvol_r, iedge_r, iptn, iptp, iloop
    real*8 :: cvolfacearea
    real*8 :: dxn, dyn, dzn, dxp, dyp, dzp
    real*8 :: bvals(cell_ajd_max_nodes)
    real*8 :: xvals(grad_hls_min_nodes)
    real*8 :: grad_work_n(grad_hls_min_nodes,num_edge_dvols,nsize)
    real*8, allocatable :: delta_vals(:,:)
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmallarea = 1.0d-8

    grad_totc(:,:)%grad = vector_zero
    grad_totc(:,:)%eps = r0

    grad_elec(:,:)%grad = vector_zero
    grad_elec(:,:)%eps = r0

    ngrads = grad_hls_min_nodes

    !c calculate gradient vector and store them to a temporary array
    if (icell > 0) then
      istart2 = cell_adj_nodes_ia(icell)
      iend2 = cell_adj_nodes_ia(icell+1)-1

      allocate(delta_vals(nsize,iend2-istart2+1))

      do iloop = 1, 2
        j = 0
        do jtemp2 = istart2, iend2
          j = j + 1
          jvol2 = cell_adj_nodes_ja(jtemp2)

          if (present(cinc_opt) .and. present(cxinc_opt)) then
            if (iloop == 1) then
              !c fickian diffusion of MCD
              call totdyvisc(ivol,jvol2,cinc_opt(:),cxinc_opt(:),              &
                             cnew_vals(:,ivol),cx_vals(:,ivol),                &
                             delta_vals(:,j))
            else if (iloop == 2) then
              !c electrochemical migration of MCD
              call elecmigration(ivol,jvol2,cinc_opt(:),cxinc_opt(:),          &
                                 cnew_vals(:,ivol),cx_vals(:,ivol),            &
                                 delta_vals(:,j))
            end if
          else
            if (iloop == 1) then
              !c fickian diffusion of MCD
              call totdyvisc(ivol,jvol2,cnew_vals(:,ivol),cx_vals(:,ivol),     &
                             cnew_vals(:,jvol2),cx_vals(:,jvol2),              &
                             delta_vals(:,j))
            else if (iloop == 2) then
              !c electrochemical migration of MCD
              call elecmigration(ivol,jvol2,cnew_vals(:,ivol),cx_vals(:,ivol), &
                                 cnew_vals(:,jvol2),cx_vals(:,jvol2),          &
                                 delta_vals(:,j))
            end if
          end if

        end do

        do ic = 1, nsize
          j = 0
          do jtemp2 = istart2, iend2
            j = j + 1
            bvals(j) = delta_vals(ic,j)
          end do

          do idvol = 1, num_edge_dvols
            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r)

            cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

            if (cvolfacearea > rsmallarea) then
              call gradient_hls_matxbvals(                               &
                      grad_hls_matrices(idvol_r,iedge_r,icell)%coef,     &
                      grad_hls_matrices(idvol_r,iedge_r,icell)%weighting,&
                      bvals(1:j),grad_work_n(1:ngrads,idvol,ic))
            end if
          end do
        end do

        do idvol = 1, num_edge_dvols
          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r)

          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if (cvolfacearea > rsmallarea) then

            if (idvol == idvol_r) then
              iptn = 1
              iptp = 2
            else
              iptn = 2
              iptp = 1
            end if

            dxn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%x
            dyn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%y
            dzn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%z
            dxp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%x
            dyp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%y
            dzp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%z

            do ic = 1, nsize
              if (iloop == 1) then
                call gradient_hls_retrieve_grad(cell_projection,       &
                            ngrads, dxn, dyn, dzn, dxp, dyp, dzp,      &
                            grad_work_n(1:ngrads,idvol,ic),           &
                            grad_totc(ic,idvol))
              else if (iloop == 2) then
                call gradient_hls_retrieve_grad(cell_projection,       &
                            ngrads, dxn, dyn, dzn, dxp, dyp, dzp,      &
                            grad_work_n(1:ngrads,idvol,ic),           &
                            grad_elec(ic,idvol))
              end if
            end do

          end if
        end do
      end do

    end if

  end subroutine gradient_mcd_hls_cvol_1

  !>
  !> Least-square gradient reconstruction method for triangle mesh over single control volume
  !>
  subroutine gradient_density_hls_cvol(ivol, jvol, icell, vals,        &
                      dens, grads, val_inc, dens_inc)

    use gen, only : njavs, iavs, janumcell, jacell, gacc

    implicit none
    integer, intent(in) :: ivol, jvol, icell
    real*8, allocatable, intent(in) :: vals(:), dens(:)
    type(grad_hls_term) :: grads(num_edge_dvols)
    real*8, intent(in) :: val_inc, dens_inc

    !c local variables
    integer :: ngrads
    integer :: j, istart2, iend2, idvol, jtemp2, jvol2,                &
               idvol_r, iedge_r, iptn, iptp
    real*8 :: rho_g_h, cvolfacearea
    real*8 :: dxn, dyn, dzn, dxp, dyp, dzp
    real*8 :: bvals(cell_ajd_max_nodes)
    real*8 :: xvals(grad_hls_min_nodes)
    real*8 :: grad_work(grad_hls_min_nodes)
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, rsmallarea = 1.0d-8

    ngrads = grad_hls_min_nodes

    grads(:)%grad = vector_zero
    grads(:)%eps = r0

    !c calculate gradient vector and store them to a temporary array
    if (icell > 0) then
      istart2 = cell_adj_nodes_ia(icell)
      iend2 = cell_adj_nodes_ia(icell+1)-1
      j = 0
      do jtemp2 = istart2, iend2
        j = j + 1
        jvol2 = cell_adj_nodes_ja(jtemp2)
        rho_g_h = rhalf*(dens(jvol2)+dens(ivol)+dens_inc)*gacc*         &
                        (nodes(jvol2)%z-nodes(ivol)%z)
        if (jvol2 == ivol) then
          bvals(j) = vals(jvol2) - (vals(ivol)+val_inc) + rho_g_h
        else
          bvals(j) = vals(jvol2) - vals(ivol) + rho_g_h
        end if
      end do

      do idvol = 1, num_edge_dvols
        call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r)

        cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

        if (cvolfacearea > rsmallarea) then
          call gradient_hls_matxbvals(                                 &
                    grad_hls_matrices(idvol_r,iedge_r,icell)%coef,     &
                    grad_hls_matrices(idvol_r,iedge_r,icell)%weighting,&
                    bvals(1:j),grad_work(1:ngrads))

          if (idvol == idvol_r) then
            iptn = 1
            iptp = 2
          else
            iptn = 2
            iptp = 1
          end if

          dxn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%x
          dyn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%y
          dzn = edge_face2nodes_vec(iptn,idvol_r,iedge_r,icell)%z
          dxp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%x
          dyp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%y
          dzp = edge_face2nodes_vec(iptp,idvol_r,iedge_r,icell)%z

          call gradient_hls_retrieve_grad(cell_projection,             &
                        ngrads, dxn, dyn, dzn, dxp, dyp, dzp,          &
                        grad_work(1:ngrads),grads(idvol))
        end if
      end do
    end if

  end subroutine gradient_density_hls_cvol

  !***********************************************************************************
  !********************Green-Gauss Gradient reconstruction****************************
  !**************************for tetrahedra cells*************************************
  !********* !!!! THIS PART IS BASED ON Nishikawa 2010, BUT ENCOUNTER !!!! ***********
  !********* !!!! CONVERENCE PROBLEM, NEED FURTHER CHECK ON ALGORITHM !!!! ***********
  !********* !!!!             Deleted on Oct. 09, 2018                !!!! ***********
  !***********************************************************************************


  !***********************************************************************************
  !******************Gradient reconstruction for cell center**************************
  !***********************using least squares method**********************************

  !>
  !> least square gradient reconstruction at cell center
  !>
  subroutine gradient_least_square_cell_1(icell, vals, gradient)

    implicit none

    integer, intent(in) :: icell
    real*8, allocatable, intent(in) :: vals(:)
    type(point) :: gradient
    
    !c local variables
    !c local variables
    integer :: i, ivol
    real*8 :: val_cell, wij2, dxij, dyij, dzij, duij, b1, b2, b3

    call math_common_zero(gradient)

    b1 = 0.0d0
    b2 = 0.0d0
    b3 = 0.0d0

    !c spatial interpolation of value at cell center
    val_cell = usg_mesh_data_interpolate(icell,vals)

    do i = 1, num_nodes_per_cell

      ivol = cells(i,icell)

      if(grad_spatial_weighting) then
        wij2 = 1.0d0/geometry_veclength(CellCenter(icell)-nodes(ivol))
        wij2 = wij2**grad_spatial_factor
      else
        wij2 = 1.0d0
      end if

      dxij = nodes(ivol)%x - CellCenter(icell)%x
      dyij = nodes(ivol)%y - CellCenter(icell)%y
      dzij = nodes(ivol)%z - CellCenter(icell)%z
      duij = vals(ivol) - val_cell

      b1 = b1 + wij2*duij*dxij
      b2 = b2 + wij2*duij*dyij
      b3 = b3 + wij2*duij*dzij
    end do

    gradient%x = b1*CellNodeInversDistMatrix(icell)%bcoef11 +          &
                 b2*CellNodeInversDistMatrix(icell)%bcoef12 +          &
                 b3*CellNodeInversDistMatrix(icell)%bcoef13

    gradient%y = b1*CellNodeInversDistMatrix(icell)%bcoef12 +          &
                 b2*CellNodeInversDistMatrix(icell)%bcoef22 +          &
                 b3*CellNodeInversDistMatrix(icell)%bcoef23

    gradient%z = b1*CellNodeInversDistMatrix(icell)%bcoef13 +          &
                 b2*CellNodeInversDistMatrix(icell)%bcoef23 +          &
                 b3*CellNodeInversDistMatrix(icell)%bcoef33

  end subroutine gradient_least_square_cell_1

  !>
  !> edge based gradient 
  !>
  function gradient_edge_based(ivol,jvol,ic,vals) result(gradient)

    implicit none

    integer, intent(in) :: ivol, jvol, ic
    real*8, allocatable, intent(in) :: vals(:,:)
    type(point) :: gradient

    !c local variable
    type(point) :: edge
    
    edge = nodes(jvol) - nodes(ivol)

    gradient = edge*(vals(ic,jvol)-vals(ic,ivol))

  end function gradient_edge_based

  !>
  !> gradient reconstruction for cross diffusion term for general purpose
  !>
  subroutine gradient_cross_diff(i1,ivol,jvol,value_r,grad_locs,       &
             grad_mids,grad_weights,flux_hls_corr,grad_hls_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: i1, ivol, jvol
    real*8, allocatable :: value_r(:)
    real*8 :: grad_weights(num_crossdifficv_max),                      &
              flux_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: grad_locs(num_crossdifficv_max),                    &
                   grad_mids(num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(num_edge_dvols)

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol

    ncell = janumcell(i1)
    if (grad_method == grad_method_cgg) then
      call gradient_cell_green_gauss(i1,ivol,jvol,value_r,grad_mids)
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if
          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_green_gauss_tetra(kvol,value_r,grad_locs(idvol))
              else
                call gradient_green_gauss_tri(kvol,value_r,grad_locs(idvol))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_least_square_cvol(kvol,value_r,grad_locs(idvol))
            end if
            grad_weights(idvol) = jacrossdiffweight(idvol,icell,i1)
          end do
          if (grad_average_weighting == 2) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_min(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 1) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_harmonic(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 0) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_arithmetic(ndvol,                         &
                 grad_locs(1:ndvol),grad_weights(1:ndvol))
          end if
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_green_gauss_tetra(ivol,value_r,grad_locs(1))
            call gradient_green_gauss_tetra(jvol,value_r,grad_locs(2))
          else
            call gradient_green_gauss_tri(ivol,value_r,grad_locs(1))
            call gradient_green_gauss_tri(jvol,value_r,grad_locs(2))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_least_square_cvol(ivol,value_r,grad_locs(1))
          call gradient_least_square_cvol(jvol,value_r,grad_locs(2))
        end if
        grad_weights(1) = jagradweight(i1)
        grad_weights(2) = 1.0d0-jagradweight(i1)
        if (grad_average_weighting == 2) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_min(2,grad_locs(1:2))
        else if (grad_average_weighting == 1) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_harmonic(2,grad_locs(1:2))
        else if (grad_average_weighting == 0) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_arithmetic(2,                               &
               grad_locs(1:2),grad_weights(1:2))
        end if
      end if
    else
      do icell = 1, janumcell(i1)
        call gradient_hls_cvol(ivol,jvol,jacell(icell,i1),             &
                value_r,grad_hls_loc(1:num_edge_dvols))
        grad_mids(1:num_edge_dvols,icell) =                            &
             grad_hls_loc(1:num_edge_dvols)%grad
        flux_hls_corr(1:num_edge_dvols,icell) =                        &
             grad_hls_loc(1:num_edge_dvols)%eps
      end do
    end if

  end subroutine gradient_cross_diff

  !>
  !> gradient reconstruction for cross diffusion term for general purpose
  !>
  subroutine gradient_cross_diff_inc(i1,ivol,jvol,dinc,value_r,        &
             grad_locs,grad_mids,grad_weights,flux_hls_corr,grad_hls_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: i1, ivol, jvol
    real*8, intent(in) :: dinc
    real*8, allocatable :: value_r(:)
    real*8 :: grad_weights(num_crossdifficv_max),                      &
              flux_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: grad_locs(num_crossdifficv_max),                    &
                   grad_mids(num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(num_edge_dvols)

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_cell_green_gauss(i1,ivol,jvol,value_r,grad_mids,dinc)
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if
          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_green_gauss_tetra(kvol,value_r,grad_locs(idvol),ivol,dinc)
              else
                call gradient_green_gauss_tri(kvol,value_r,ivol,dinc,grad_locs(idvol))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_least_square_cvol(kvol,value_r,ivol,dinc,grad_locs(idvol))
            end if
            grad_weights(idvol) = jacrossdiffweight(idvol,icell,i1)
          end do
          if (grad_average_weighting == 2) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_min(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 1) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_harmonic(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 0) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_arithmetic(ndvol,                         &
                 grad_locs(1:ndvol),grad_weights(1:ndvol))
          end if
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_green_gauss_tetra(ivol,value_r,grad_locs(1),ivol,dinc)
            call gradient_green_gauss_tetra(jvol,value_r,grad_locs(2),ivol,dinc)
          else
            call gradient_green_gauss_tri(ivol,value_r,ivol,dinc,grad_locs(1))
            call gradient_green_gauss_tri(jvol,value_r,ivol,dinc,grad_locs(2))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_least_square_cvol(ivol,value_r,ivol,dinc,grad_locs(1))
          call gradient_least_square_cvol(jvol,value_r,ivol,dinc,grad_locs(2))
        end if
        grad_weights(1) = jagradweight(i1)
        grad_weights(2) = 1.0d0-jagradweight(i1)
        if (grad_average_weighting == 2) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_min(2,grad_locs(1:2))
        else if (grad_average_weighting == 1) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_harmonic(2,grad_locs(1:2))
        else if (grad_average_weighting == 0) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_arithmetic(2,                               &
               grad_locs(1:2),grad_weights(1:2))
        end if
      end if
    else
      do icell = 1, janumcell(i1)
        call gradient_hls_cvol(ivol,jvol,jacell(icell,i1),             &
                value_r,grad_hls_loc(1:num_edge_dvols),ivol,dinc)
        grad_mids(1:num_edge_dvols,icell) =                            &
             grad_hls_loc(1:num_edge_dvols)%grad
        flux_hls_corr(1:num_edge_dvols,icell) =                        &
             grad_hls_loc(1:num_edge_dvols)%eps
      end do
    end if

  end subroutine gradient_cross_diff_inc

  !>
  !> gradient reconstruction for cross diffusion term for density dependent flow problem
  !>
  subroutine gradient_cross_diff_dd(i1,ivol,jvol,grad_locs,            &
             grad_mids,grad_weights,flux_hls_corr,grad_hls_loc)

    use dens, only : density

    implicit none

    !c passed variables
    integer, intent(in) :: i1, ivol, jvol
    real*8 :: grad_weights(num_crossdifficv_max),                      &
              flux_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: grad_locs(num_crossdifficv_max),                    &
                   grad_mids(num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(num_edge_dvols)

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_dd_cell_green_gauss(i1,ivol,jvol,grad_mids,r0,r0) 
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if
          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_dd_green_gauss_tetra(kvol,grad_locs(idvol))
              else
                call gradient_dd_green_gauss_tri(kvol,grad_locs(idvol))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_dd_least_square_cvol(kvol,grad_locs(idvol))
            end if
            grad_weights(idvol) = jacrossdiffweight(idvol,icell,i1)
          end do
          if (grad_average_weighting == 2) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_min(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 1) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_harmonic(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 0) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_arithmetic(ndvol,                         &
                 grad_locs(1:ndvol),grad_weights(1:ndvol))
          end if                           
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_dd_green_gauss_tetra(ivol,grad_locs(1))
            call gradient_dd_green_gauss_tetra(jvol,grad_locs(2))
          else
            call gradient_dd_green_gauss_tri(ivol,grad_locs(1))
            call gradient_dd_green_gauss_tri(jvol,grad_locs(2))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_dd_least_square_cvol(ivol,grad_locs(1))
          call gradient_dd_least_square_cvol(jvol,grad_locs(2))
        end if  
        grad_weights(1) = jagradweight(i1)
        grad_weights(2) = 1.0d0-jagradweight(i1)
        if (grad_average_weighting == 2) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_min(2,grad_locs(1:2))
        else if (grad_average_weighting == 1) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_harmonic(2,grad_locs(1:2))
        else if (grad_average_weighting == 0) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_arithmetic(2,                               &
               grad_locs(1:2),grad_weights(1:2))
        end if
      end if
    else
      do icell = 1, ncell
        call gradient_dd_hls_cvol(ivol,jvol,                           &
               jacell(icell,i1),uvsnew,density,                        &
               grad_hls_loc(1:num_edge_dvols),r0,r0)
        grad_mids(1:num_edge_dvols,icell) =                            &
             grad_hls_loc(1:num_edge_dvols)%grad
        flux_hls_corr(1:num_edge_dvols,icell) =                        &
             grad_hls_loc(1:num_edge_dvols)%eps
      end do
    end if

  end subroutine gradient_cross_diff_dd

  !>
  !> gradient reconstruction for cross diffusion term for density dependent flow problem
  !>
  subroutine gradient_cross_diff_dd_inc(i1,ivol,jvol,dinc_vs,dinc_den, &
             grad_locs,grad_mids,grad_weights,flux_hls_corr,grad_hls_loc)

    use dens, only : density

    implicit none

    !c passed variables
    integer, intent(in) :: i1, ivol, jvol
    real*8, intent(in) :: dinc_vs, dinc_den
    real*8 :: grad_weights(num_crossdifficv_max),                     &
              flux_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: grad_locs(num_crossdifficv_max),                   &
                   grad_mids(num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(num_edge_dvols)

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_dd_cell_green_gauss(i1,ivol,jvol,grad_mids,        &
                                        dinc_vs,dinc_den) 
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if
          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_dd_green_gauss_tetra(kvol,ivol,          &
                     dinc_vs,dinc_den,grad_locs(idvol))
              else
                call gradient_dd_green_gauss_tri(kvol,ivol,            &
                     dinc_vs,dinc_den,grad_locs(idvol))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_dd_least_square_cvol(kvol,ivol,            &
                   dinc_vs,dinc_den,grad_locs(idvol))
            end if
            grad_weights(idvol) = jacrossdiffweight(idvol,icell,i1)
          end do
          if (grad_average_weighting == 2) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_min(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 1) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_harmonic(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 0) then
            grad_mids(1:num_edge_dvols,icell) =                        &
                 math_common_arithmetic(ndvol,                         &
                 grad_locs(1:ndvol),grad_weights(1:ndvol))
          end if                           
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_dd_green_gauss_tetra(ivol,ivol,              &
                 dinc_vs,dinc_den,grad_locs(1))
            call gradient_dd_green_gauss_tetra(jvol,ivol,              &
                 dinc_vs,dinc_den,grad_locs(2))
          else
            call gradient_dd_green_gauss_tri(ivol,ivol,                &
                 dinc_vs,dinc_den,grad_locs(1))
            call gradient_dd_green_gauss_tri(jvol,ivol,                &
                 dinc_vs,dinc_den,grad_locs(2))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_dd_least_square_cvol(ivol,ivol,                &
               dinc_vs,dinc_den,grad_locs(1))
          call gradient_dd_least_square_cvol(jvol,ivol,                &
               dinc_vs,dinc_den,grad_locs(2))
        end if
        grad_weights(1) = jagradweight(i1)
        grad_weights(2) = 1.0d0-jagradweight(i1)
        if (grad_average_weighting == 2) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_min(2,grad_locs(1:2))
        else if (grad_average_weighting == 1) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_harmonic(2,grad_locs(1:2))
        else if (grad_average_weighting == 0) then
          grad_mids(1:num_edge_dvols,1:ncell) =                        &
               math_common_arithmetic(2,                               &
               grad_locs(1:2),grad_weights(1:2))
        end if                         
      end if
    else
      do icell = 1, ncell
        call gradient_dd_hls_cvol(ivol,jvol,jacell(icell,i1),          &
             uvsnew,density,grad_hls_loc(1:num_edge_dvols),           &
             dinc_vs,dinc_den)
        grad_mids(1:num_edge_dvols,icell) =                            &
             grad_hls_loc(1:num_edge_dvols)%grad
        flux_hls_corr(1:num_edge_dvols,icell) =                        &
             grad_hls_loc(1:num_edge_dvols)%eps
      end do
    end if

  end subroutine gradient_cross_diff_dd_inc

  !>
  !> gradient reconstruction for cross diffusion term for reactive transport problem.
  !> nf is used in this gradient_cross_diff_rt but not in gradient_cross_diff_rt_inc
  !> because this function is also used for gradient of gnew with degree of freedom ng
  !>
  subroutine gradient_cross_diff_rt(i1,ivol,jvol,nf,value_rt,grad_ivol,&
             grad_jvol,grad_kvol,grad_hls_loc,grad_mids)

    implicit none

    !c passed variables
    integer, intent(in) :: i1, ivol, jvol, nf
    real*8, allocatable :: value_rt(:,:)
    type(point) :: grad_ivol(nf), grad_jvol(nf),                       &
                   grad_kvol(nf,num_nodes_per_cell,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(nf,num_edge_dvols,num_edge_maxcells)
    type(point) :: grad_mids(n,num_edge_dvols,num_edge_maxcells)


    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_cell_green_gauss(i1,ivol,jvol,value_rt,grad_mids)
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if

          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_conc_green_gauss_tetra(      &
                     kvol,nf,value_rt,                     &
                     grad_kvol(1:nf,idvol,icell))
              else
                call gradient_conc_green_gauss_tri(        &
                     kvol,nf,value_rt,                     &
                     grad_kvol(1:nf,idvol,icell))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_conc_least_square_cvol(        &
                    kvol,nf,value_rt,                      &
                    grad_kvol(1:nf,idvol,icell))
            end if
          end do
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_conc_green_gauss_tetra(          &
                 ivol,nf,value_rt,                         &
                 grad_ivol(1:nf))
            call gradient_conc_green_gauss_tetra(          &
                 jvol,nf,value_rt,                         &
                 grad_jvol(1:nf))
          else
            call gradient_conc_green_gauss_tri(            &
                 ivol,nf,value_rt,                         &
                 grad_ivol(1:nf))
            call gradient_conc_green_gauss_tri(            &
                 jvol,nf,value_rt,                         &
                 grad_jvol(1:nf))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_conc_least_square_cvol(            &
               ivol,nf,value_rt,                           &
               grad_ivol(1:nf))
          call gradient_conc_least_square_cvol(            &
               jvol,nf,value_rt,                           &
               grad_jvol(1:nf))
        end if
      end if
    else
      do icell = 1, ncell
        call gradient_conc_hls_cvol(nf,ivol,jvol,          &
                 jacell(icell,i1),value_rt,                &
                 grad_hls_loc(:,:,icell))
      end do
    end if

  end subroutine gradient_cross_diff_rt

  !>
  !> gradient reconstruction for cross diffusion term for reactive transport problem
  !>
  subroutine gradient_cross_diff_rt_inc(tid,i1,ivol,jvol,value_rt,     &
             value_dinc,grad_ivol,grad_jvol,grad_kvol,grad_hls_loc,    &
             grad_mids)

    implicit none

    !c passed variables
    integer, intent(in) :: tid, i1, ivol, jvol
    real*8, allocatable :: value_rt(:,:),value_dinc(:,:)
    type(point) :: grad_ivol(n), grad_jvol(n),                         &
                   grad_kvol(n,num_nodes_per_cell,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(n,num_edge_dvols,num_edge_maxcells)

    type(point) :: grad_mids(n,num_edge_dvols,num_edge_maxcells)

    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_cell_green_gauss(i1,ivol,jvol,value_rt,grad_mids,&
                                       value_dinc(1:n,tid))
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if

          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_conc_green_gauss_tetra(      &
                     kvol,n,ivol,value_dinc(1:n,tid),      &
                     grad_kvol(1:n,idvol,icell))
              else
                call gradient_conc_green_gauss_tri(        &
                     kvol,n,ivol,value_dinc(1:n,tid),      &
                     grad_kvol(1:n,idvol,icell))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_conc_least_square_cvol(        &
                    kvol,n,ivol,value_dinc(1:n,tid),       &
                    grad_kvol(1:n,idvol,icell))
            end if
          end do
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_conc_green_gauss_tetra(          &
                 ivol,n,ivol,value_dinc(1:n,tid),          &
                 grad_ivol(1:n))
            call gradient_conc_green_gauss_tetra(          &
                 jvol,n,ivol,value_dinc(1:n,tid),          &
                 grad_jvol(1:n))
          else
            call gradient_conc_green_gauss_tri(            &
                 ivol,n,ivol,value_dinc(1:n,tid),          &
                 grad_ivol(1:n))
            call gradient_conc_green_gauss_tri(            &
                 jvol,n,ivol,value_dinc(1:n,tid),          &
                 grad_jvol(1:n))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_conc_least_square_cvol(            &
               ivol,n,ivol,value_dinc(1:n,tid),            &
               grad_ivol(1:n))
          call gradient_conc_least_square_cvol(            &
               jvol,n,ivol,value_dinc(1:n,tid),            &
               grad_jvol(1:n))
        end if
      end if
    else
      do icell = 1, ncell
        call gradient_conc_hls_cvol(n,ivol,jvol,           &
                 jacell(icell,i1),value_rt,                &
                 grad_hls_loc(:,:,icell),                  &
                 value_dinc(1:n,tid))
      end do
    end if

  end subroutine gradient_cross_diff_rt_inc

  !>
  !> gradient reconstruction for cross diffusion term for multicomponent diffusion problem
  !>
  subroutine gradient_cross_diff_md(i1,ivol,jvol,grad_ivol,grad_jvol,  &
             grad_kvol,grad_e_ivol,grad_e_jvol,grad_e_kvol,            &
             grad_hls_loc,grad_e_hls_loc,gradient_totc, gradient_elec)

    implicit none

    !c passed variables
    integer, intent(in) :: i1, ivol, jvol
    type(point) :: grad_ivol(n), grad_jvol(n),                         &
                   grad_kvol(n,num_nodes_per_cell,num_edge_maxcells),  &
                   grad_e_ivol(n), grad_e_jvol(n),                     &
                   grad_e_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                   gradient_totc(n,num_edge_dvols,num_edge_maxcells),  &
                   gradient_elec(n,num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(n,num_edge_dvols,num_edge_maxcells), &
                           grad_e_hls_loc(n,num_edge_dvols,num_edge_maxcells)
    

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_mcd_cell_green_gauss(i1,ivol,jvol,cnew,cx,         &
                                         gradient_totc, gradient_elec)
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if

          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_conc_green_gauss_tetra(      &
                     kvol,n,cnew,cx,                       &
                     grad_kvol(1:n,idvol,icell),           &
                     grad_e_kvol(1:n,idvol,icell))
              else
                call gradient_conc_green_gauss_tri(        &
                     kvol,n,cnew,cx,                       &
                     grad_kvol(1:n,idvol,icell),           &
                     grad_e_kvol(1:n,idvol,icell))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_conc_least_square_cvol(        &
                   kvol,n,cnew,cx,                         &
                   grad_kvol(1:n,idvol,icell),             &
                   grad_e_kvol(1:n,idvol,icell))
            end if
          end do
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_conc_green_gauss_tetra(          &
                 ivol,n,cnew,cx,                           &
                 grad_ivol(1:n),                           &
                 grad_e_ivol(1:n))
            call gradient_conc_green_gauss_tetra(          &
                 jvol,n,cnew,cx,                           &
                 grad_jvol(1:n),                           &
                 grad_e_jvol(1:n))
          else
            call gradient_conc_green_gauss_tri(            &
                 ivol,n,cnew,cx,                           &
                 grad_ivol(1:n),                           &
                 grad_e_ivol(1:n))
            call gradient_conc_green_gauss_tri(            &
                 jvol,n,cnew,cx,                           &
                 grad_jvol(1:n),                           &
                 grad_e_jvol(1:n))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_conc_least_square_cvol(            &
               ivol,n,cnew,cx,                             &
               grad_ivol(1:n),                             &
               grad_e_ivol(1:n))
          call gradient_conc_least_square_cvol(            &
               jvol,n,cnew,cx,                             &
               grad_jvol(1:n),                             &
               grad_e_jvol(1:n))
        end if
      end if
    else
      do icell = 1, ncell
        call gradient_conc_hls_cvol(n,ivol,jvol,           &
                 jacell(icell,i1),cnew,cx,                 &
                 grad_hls_loc(:,:,icell),                 &
                 grad_e_hls_loc(:,:,icell))
      end do
    end if

  end subroutine gradient_cross_diff_md

  !>
  !> gradient reconstruction for cross diffusion term for multicomponent diffusion problem
  !>
  subroutine gradient_cross_diff_md_inc(tid,i1,ivol,jvol,              &
                      grad_ivol,grad_jvol,grad_kvol,                   &
                      grad_e_ivol,grad_e_jvol,grad_e_kvol,             &
                      grad_hls_loc,grad_e_hls_loc,                     &
                      gradient_totc,gradient_elec)

    use chem, only : cinc, cxinc

    implicit none

    !c passed variables
    integer, intent(in) :: tid, i1, ivol, jvol
    type(point) :: grad_ivol(n), grad_jvol(n),                         &
                   grad_kvol(n,num_nodes_per_cell,num_edge_maxcells),  &
                   grad_e_ivol(n), grad_e_jvol(n),                     &
                   grad_e_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                   gradient_totc(n,num_edge_dvols,num_edge_maxcells),  &
                   gradient_elec(n,num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(n,num_edge_dvols,num_edge_maxcells),  &
                           grad_e_hls_loc(n,num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      call gradient_mcd_cell_green_gauss(i1,ivol,jvol,cnew,cx,         &
                                         gradient_totc, gradient_elec, &
                                         cinc(:,tid),cxinc(:,tid))
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if

          do idvol = 1, ndvol
            kvol = jacrossdifficv(idvol,icell,i1)
            if(grad_method == grad_method_gg) then
              if (cell_projection == projection_xyz) then
                call gradient_conc_green_gauss_tetra(      &
                     kvol,n,cnew,cx,                       &
                     ivol,cinc(:,tid),cxinc(:,tid),        &
                     grad_kvol(1:n,idvol,icell),           &
                     grad_e_kvol(1:n,idvol,icell))
              else
                call gradient_conc_green_gauss_tri(        &
                     kvol,n,cnew,cx,                       &
                     ivol,cinc(:,tid),cxinc(:,tid),        &
                     grad_kvol(1:n,idvol,icell),           &
                     grad_e_kvol(1:n,idvol,icell))
              end if
            else if(grad_method == grad_method_ls) then
              call gradient_conc_least_square_cvol(        &
                   kvol,n,cnew,cx,                         &
                   ivol,cinc(:,tid),cxinc(:,tid),          &
                   grad_kvol(1:n,idvol,icell),             &
                   grad_e_kvol(1:n,idvol,icell))
            end if
          end do
        end do
      else
        if(grad_method == grad_method_gg) then
          if (cell_projection == projection_xyz) then
            call gradient_conc_green_gauss_tetra(          &
                 ivol,n,cnew,cx,                           &
                 ivol,cinc(:,tid),cxinc(:,tid),            &
                 grad_ivol(1:n),                           &
                 grad_e_ivol(1:n))
            call gradient_conc_green_gauss_tetra(          &
                 jvol,n,cnew,cx,                           &
                 ivol,cinc(:,tid),cxinc(:,tid),            &
                 grad_jvol(1:n),                           &
                 grad_e_jvol(1:n))
          else
            call gradient_conc_green_gauss_tri(            &
                 ivol,n,cnew,cx,                           &
                 ivol,cinc(:,tid),cxinc(:,tid),            &
                 grad_ivol(1:n),                           &
                 grad_e_ivol(1:n))
            call gradient_conc_green_gauss_tri(            &
                 jvol,n,cnew,cx,                           &
                 ivol,cinc(:,tid),cxinc(:,tid),            &
                 grad_jvol(1:n),                           &
                 grad_e_jvol(1:n))
          end if
        else if(grad_method == grad_method_ls) then
          call gradient_conc_least_square_cvol(            &
               ivol,n,cnew,cx,                             &
               ivol,cinc(:,tid),cxinc(:,tid),              &
               grad_ivol(1:n),                             &
               grad_e_ivol(1:n))
          call gradient_conc_least_square_cvol(            &
               jvol,n,cnew,cx,                             &
               ivol,cinc(:,tid),cxinc(:,tid),              &
               grad_jvol(1:n),                             &
               grad_e_jvol(1:n))
        end if
      end if
    else
      do icell = 1, ncell
        call gradient_conc_hls_cvol(n,ivol,jvol,           &
                 jacell(icell,i1),cnew,cx,                 &
                 grad_hls_loc(:,:,icell),                  &
                 grad_e_hls_loc(:,:,icell),                &
                 cinc(:,tid),cxinc(:,tid))
      end do
    end if

  end subroutine gradient_cross_diff_md_inc

  !>
  !> calculate gradient at center of two connected control volumes for reactive transport problem
  !>
  subroutine gradient_cross_diff_rt_average(ic,nf,i1,ivol,jvol,        &
             grad_ivol,grad_jvol,grad_kvol,grad_hls_loc,grad_weights,  &
             grad_locs,grad_mids,flux_hls_corr,grad_cgg)

    implicit none

    !c passed variables
    integer, intent(in) :: ic, nf, i1, ivol, jvol
    real*8 :: grad_weights(num_crossdifficv_max),                      &
              flux_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: grad_ivol(nf), grad_jvol(nf),                       &
                   grad_kvol(nf,num_nodes_per_cell,num_edge_maxcells), &
                   grad_locs(num_crossdifficv_max),                    &
                   grad_mids(num_edge_dvols,num_edge_maxcells),        &
                   grad_cgg(nf,num_edge_dvols,num_edge_maxcells)
    type(grad_hls_term) :: grad_hls_loc(nf,num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: icell, ncell, idvol, kvol, ndvol
    real*8, parameter :: r0 = 0.0d0

    ncell = janumcell(i1)

    if (grad_method == grad_method_cgg) then
      grad_mids(:,:) = grad_cgg(ic,:,:)
    else if (grad_method <= grad_method_ls) then
      if (b_grad_interpolate_cell) then
        do icell = 1, ncell
          ndvol = jacrossdifficvnum(icell,i1)
          if (ndvol == 0) then
            cycle
          end if
          do idvol = 1, ndvol
            grad_locs(idvol) =grad_kvol(ic,idvol,icell)
            grad_weights(idvol) = jacrossdiffweight(idvol,icell,i1)
          end do
  
          if (grad_average_weighting == 2) then
            grad_mids(1:num_edge_dvols,icell) =                  &
                 math_common_min(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 1) then
            grad_mids(1:num_edge_dvols,icell) =                  &
                 math_common_harmonic(ndvol,grad_locs(1:ndvol))
          else if (grad_average_weighting == 0) then
            grad_mids(1:num_edge_dvols,icell) =                  &
                 math_common_arithmetic(ndvol,                   &
                 grad_locs(1:ndvol),grad_weights(1:ndvol))
          end if
        end do
      else
        grad_locs(1) = grad_ivol(ic)
        grad_locs(2) = grad_jvol(ic)
        grad_weights(1) = jagradweight(i1)
        grad_weights(2) = 1.0d0-jagradweight(i1)
  
        if (grad_average_weighting == 2) then
          grad_mids(1:num_edge_dvols,1:ncell) =                    &
               math_common_min(2,grad_locs(1:2))
        else if (grad_average_weighting == 1) then
          grad_mids(1:num_edge_dvols,1:ncell) =                    &
               math_common_harmonic(2,grad_locs(1:2))
        else if (grad_average_weighting == 0) then
          grad_mids(1:num_edge_dvols,1:ncell) =                    &
               math_common_arithmetic(2,                           &
               grad_locs(1:2),grad_weights(1:2))
        end if
  
      end if
    else
      do icell = 1, ncell
        grad_mids(1:num_edge_dvols,icell) =                        &
             grad_hls_loc(ic,1:num_edge_dvols,icell)%grad
        flux_hls_corr(1:num_edge_dvols,icell) =                    &
             grad_hls_loc(ic,1:num_edge_dvols,icell)%eps
      end do
    end if

  end subroutine gradient_cross_diff_rt_average

  !>
  !> cell based Green-Gauss gradient reconstruction method, degree of freedom 1
  !>
  subroutine gradient_cell_green_gauss_val1d(jtemp, ivol, jvol, vals,  &
                                        gradient, inc_opt)

    use gen, only : janumcell, jacell, jaedgelen

    implicit none

    integer, intent(in) :: ivol, jvol, jtemp
    real*8, allocatable, intent(in) :: vals(:)
    type(point) :: gradient(num_edge_dvols,num_edge_maxcells)
    real*8, intent(in), optional :: inc_opt

    !c local variables
    integer :: i, j, k, itri, icell, jnode, iflag
    real*8 :: inc, val, totvol, rv
    type(point) :: grad

    gradient = vector_zero

    if (present(inc_opt)) then
      inc = inc_opt
    else
      inc = 0.0d0
    end if

    totvol = 0.0d0
    do i = 1, janumcell(jtemp)
      
      icell = jacell(i,jtemp)

      if (icell > 0) then
        if (cell_type == cell_type_tri .or. cell_type == cell_type_tetra) then
          
          grad = vector_zero

          if (cell_type == cell_type_tri) then
            rv = 2.0d0
          else if (cell_type == cell_type_tetra) then
            rv = 3.0d0
          end if

          do j = 1, num_nodes_per_cell
            jnode = cells(j,icell)
            if (jnode == ivol) then
              val = vals(jnode) + inc
            else
              val = vals(jnode)
            end if
            grad = grad - CellFaceScaledNorm(j,icell)*val
          end do

          if (b_cell_based_grad_itpl) then
            totvol = totvol + cell_volumes(icell)
            do k = 1, num_edge_dvols
              gradient(k,i) = gradient(k,i) + grad/rv
            end do
          else
            gradient(:,i) = grad/(cell_volumes(icell)*rv)
          end if
        else if (cell_type == cell_type_quad) then
          grad = vector_zero
          rv = 2.0d0

          iflag = 0
          do j = 1, 3
            if (CellsQuadTriNode(j,1,icell) == ivol .or.               &
                CellsQuadTriNode(j,1,icell) == jvol) then
              iflag = iflag + 1
              if (iflag == 2) then
                exit
              end if
            end if
          end do
          if (iflag == 2) then
            itri = 1
          else
            itri = 2
          end if

          do j = 1, 3
            jnode = CellsQuadTriNode(j,itri,icell)
            if (jnode == ivol) then
              val = vals(jnode) + inc
            else
              val = vals(jnode)
            end if
            grad = grad - CellsQuadTriFaceScaledNorm(j,itri,icell)*val
          end do
          if (b_cell_based_grad_itpl) then
            totvol = totvol + cells_trivol(itri,icell)
            do k = 1, num_edge_dvols
              gradient(k,i) = gradient(k,i) + grad/rv
            end do
          else
            gradient(:,i) = grad/(cells_trivol(itri,icell)*rv)
          end if
        end if        
      end if
 
    end do

    if (b_cell_based_grad_itpl) then
      gradient(:,:) = gradient(:,:)/totvol
    end if

  end subroutine gradient_cell_green_gauss_val1d

  !>
  !> cell based Green-Gauss gradient reconstruction method, degree of freedom n
  !>
  subroutine gradient_cell_green_gauss_val2d(jtemp, ivol, jvol, vals,  &
                                        gradient, inc_opt)

    use gen, only : janumcell, jacell, jaedgelen

    implicit none

    integer, intent(in) :: ivol, jvol, jtemp
    real*8, allocatable, intent(in) :: vals(:,:)
    type(point) :: gradient(n,num_edge_dvols,num_edge_maxcells)
    real*8, intent(in), optional :: inc_opt(n)

    !c local variables
    integer :: i, j, k, k2, itri, icell, jnode, iflag
    real*8 :: dvals(n), totvol, rv
    type(point) :: grad(n)

    gradient = vector_zero

    totvol = 0.0d0

    do i = 1, janumcell(jtemp)
      
      icell = jacell(i,jtemp)

      if (icell > 0) then
        if (cell_type == cell_type_tri .or. cell_type == cell_type_tetra) then
          
          grad = vector_zero

          if (cell_type == cell_type_tri) then
            rv = 2.0d0
          else if (cell_type == cell_type_tetra) then
            rv = 3.0d0
          end if

          do j = 1, num_nodes_per_cell
            jnode = cells(j,icell)

            if (present(inc_opt)) then
              if (jnode == ivol) then
                dvals(:) = inc_opt(:)
              else
                dvals(:) = 0.0
              end if
            else
              dvals(:) = vals(:,jnode)
            end if
           
            do k = 1, n
              grad(k) = grad(k) - CellFaceScaledNorm(j,icell)*dvals(k)
            end do
          end do
          
          if (b_cell_based_grad_itpl) then
            totvol = totvol + cell_volumes(icell)
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient(k,k2,i) = gradient(k,k2,i) + grad(k)/rv
              end do
            end do
          else
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient(k,k2,i) = grad(k)/(cell_volumes(icell)*rv)
              end do
            end do
          end if
        else if (cell_type == cell_type_quad) then
          grad = vector_zero
          rv = 2.0d0

          iflag = 0
          do j = 1, 3
            if (CellsQuadTriNode(j,1,icell) == ivol .or.               &
                CellsQuadTriNode(j,1,icell) == jvol) then
              iflag = iflag + 1
              if (iflag == 2) then
                exit
              end if
            end if
          end do
          if (iflag == 2) then
            itri = 1
          else
            itri = 2
          end if

          do j = 1, 3
            jnode = CellsQuadTriNode(j,itri,icell)

            if (present(inc_opt)) then
              if (jnode == ivol) then
                dvals(:) = inc_opt(:)
              else
                dvals(:) = 0.0
              end if
            else
              dvals(:) = vals(:,jnode)
            end if

            do k = 1, n
              grad(k) = grad(k) - CellsQuadTriFaceScaledNorm(j,itri,icell)*dvals(k)
            end do
          end do

          if (b_cell_based_grad_itpl) then
            totvol = totvol + cells_trivol(itri,icell)
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient(k,k2,i) = gradient(k,k2,i) + grad(k)/rv
              end do
            end do
          else
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient(k,k2,i) = grad(k)/(cells_trivol(itri,icell)*rv)
              end do
            end do
          end if
        end if        
      end if
 
    end do

    if (b_cell_based_grad_itpl) then
      do i = 1, janumcell(jtemp)
        gradient(:,:,i) = gradient(:,:,i)/totvol
      end do
    end if

  end subroutine gradient_cell_green_gauss_val2d

  !>
  !> cell-based Green-Gauss gradient reconstruction for density dependent flow
  !>
  subroutine gradient_dd_cell_green_gauss(jtemp, ivol, jvol, gradient, &
                                          uvsinc, deninc) 

    use gen, only : janumcell, jacell, jaedgelen, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(in) :: uvsinc, deninc
    type(point) :: gradient(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: i, j, k, itri, icell, jnode, iflag
    real*8 :: val, totvol, rv, rho_g_h, delta_p
    type(point) :: grad
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    gradient = vector_zero

    totvol = 0.0d0
    do i = 1, janumcell(jtemp)
      
      icell = jacell(i,jtemp)

      if (icell > 0) then
        if (cell_type == cell_type_tri .or. cell_type == cell_type_tetra) then
          
          grad = vector_zero

          if (cell_type == cell_type_tri) then
            rv = 2.0d0
          else if (cell_type == cell_type_tetra) then
            rv = 3.0d0
          end if

          do j = 1, num_nodes_per_cell
            jnode = cells(j,icell)
            if (jnode == ivol) then
              val = r0
            else
              val = uvsnew(jnode) - (uvsnew(ivol)+uvsinc) +            &
                    rhalf*(density(ivol)+deninc+density(jnode))*gacc*  &
                        (nodes(jnode)%z-nodes(ivol)%z)
              grad = grad - CellFaceScaledNorm(j,icell)*val
            end if            
          end do

          if (b_cell_based_grad_itpl) then
            totvol = totvol + cell_volumes(icell)
            do k = 1, num_edge_dvols
              gradient(k,i) = gradient(k,i) + grad/rv
            end do
          else
            gradient(:,i) = grad/(cell_volumes(icell)*rv)
          end if
        else if (cell_type == cell_type_quad) then
          grad = vector_zero
          rv = 2.0d0

          iflag = 0
          do j = 1, 3
            if (CellsQuadTriNode(j,1,icell) == ivol .or.               &
                CellsQuadTriNode(j,1,icell) == jvol) then
              iflag = iflag + 1
              if (iflag == 2) then
                exit
              end if
            end if
          end do
          if (iflag == 2) then
            itri = 1
          else
            itri = 2
          end if

          do j = 1, 3
            jnode = CellsQuadTriNode(j,itri,icell)
            if (jnode == ivol) then
              val = r0
            else
              val = uvsnew(jnode) - (uvsnew(ivol)+uvsinc) +            &
                    rhalf*(density(ivol)+deninc+density(jnode))*gacc*  &
                        (nodes(jnode)%z-nodes(ivol)%z)
              grad = grad - CellsQuadTriFaceScaledNorm(j,itri,icell)*val
            end if            
          end do
          if (b_cell_based_grad_itpl) then
            totvol = totvol + cells_trivol(itri,icell)
            do k = 1, num_edge_dvols
              gradient(k,i) = gradient(k,i) + grad/rv
            end do
          else
            gradient(:,i) = grad/(cells_trivol(itri,icell)*rv)
          end if
        end if        
      end if
 
    end do

    if (b_cell_based_grad_itpl) then
      gradient(:,:) = gradient(:,:)/totvol
    end if

  end subroutine gradient_dd_cell_green_gauss

  !>
  !> cell-based Green-Gauss gradient reconstruction for multi-component diffusion
  !>
  subroutine gradient_mcd_cell_green_gauss(jtemp, ivol, jvol,          &
                      cnew_vals, cx_vals, gradient_totc, gradient_elec,&
                      cinc, cxinc) 

    use gen, only : janumcell, jacell, jaedgelen, gacc, uvsnew
    use dens, only : density

    implicit none

    integer, intent(in) :: ivol, jvol, jtemp
    real*8, allocatable, intent(in) :: cnew_vals(:,:), cx_vals(:,:)
    type(point) :: gradient_totc(n,num_edge_dvols,num_edge_maxcells),      &
                   gradient_elec(n,num_edge_dvols,num_edge_maxcells)
    real*8, intent(in), optional :: cinc(:), cxinc(:)

    !c local variables
    integer :: i, j, k, k2, itri, icell, jnode, iflag
    real*8 :: dvals(n), totvol, rv
    type(point) :: grad_totc(n), grad_elec(n)
    real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0

    external :: totdyvisc, elecmigration

    gradient_totc = vector_zero
    gradient_elec = vector_zero
    totvol = 0.0d0

    do i = 1, janumcell(jtemp)
      
      icell = jacell(i,jtemp)

      if (icell > 0) then
        if (cell_type == cell_type_tri .or. cell_type == cell_type_tetra) then
          
          grad_totc = vector_zero
          grad_elec = vector_zero

          if (cell_type == cell_type_tri) then
            rv = 2.0d0
          else if (cell_type == cell_type_tetra) then
            rv = 3.0d0
          end if

          do j = 1, num_nodes_per_cell
            jnode = cells(j,icell)

            if (jnode == ivol) then
              dvals = r0
            else
              !c fickian diffusion of MCD
              if (present(cinc) .and. present(cxinc)) then
                call totdyvisc(ivol,jnode,cinc(:),cxinc(:),                    &
                               cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:)) 
              else
                call totdyvisc(ivol,jnode,cnew_vals(:,ivol),cx_vals(:,ivol),   &
                               cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:)) 
              end if
            end if
            do k = 1, n
              grad_totc(k) = grad_totc(k) - CellFaceScaledNorm(j,icell)*dvals(k)
            end do

            if (jnode == ivol) then
              dvals = r0
            else
              !c electrochemical migration of MCD
              if (present(cinc) .and. present(cxinc)) then
                call elecmigration(ivol,jnode,cinc(:),cxinc(:),                  &
                                   cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:)) 
              else
                call elecmigration(ivol,jnode,cnew_vals(:,ivol),cx_vals(:,ivol), &
                                   cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:)) 
              end if     
            end if            
            do k = 1, n
              grad_elec(k) = grad_elec(k) - CellFaceScaledNorm(j,icell)*dvals(k)
            end do  

          end do

          if (b_cell_based_grad_itpl) then
            totvol = totvol + cell_volumes(icell)
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient_totc(k,k2,i) = gradient_totc(k,k2,i) + grad_totc(k)/rv
                gradient_elec(k,k2,i) = gradient_elec(k,k2,i) + grad_elec(k)/rv
              end do
            end do
          else
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient_totc(k,k2,i) = grad_totc(k)/(cell_volumes(icell)*rv)
                gradient_elec(k,k2,i) = grad_elec(k)/(cell_volumes(icell)*rv)
              end do
            end do
          end if
        else if (cell_type == cell_type_quad) then
          grad_totc = vector_zero
          grad_elec = vector_zero
          rv = 2.0d0

          iflag = 0
          do j = 1, 3
            if (CellsQuadTriNode(j,1,icell) == ivol .or.               &
                CellsQuadTriNode(j,1,icell) == jvol) then
              iflag = iflag + 1
              if (iflag == 2) then
                exit
              end if
            end if
          end do
          if (iflag == 2) then
            itri = 1
          else
            itri = 2
          end if

          do j = 1, 3
            jnode = CellsQuadTriNode(j,itri,icell)

            if (jnode == ivol) then
              dvals = r0
            else
              !c fickian diffusion of MCD
              if (present(cinc) .and. present(cxinc)) then
                call totdyvisc(ivol,jnode,cinc(:),cxinc(:),                    &
                               cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:))
              else
                call totdyvisc(ivol,jnode,cnew_vals(:,ivol),cx_vals(:,ivol),   &
                               cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:))
              end if
            end if
            do k = 1, n
              grad_totc(k) = grad_totc(k) -                                    &
                             CellsQuadTriFaceScaledNorm(j,itri,icell)*dvals(k)
            end do

            if (jnode == ivol) then
              dvals = r0
            else
              !c electrochemical migration of MCD
              if (present(cinc) .and. present(cxinc)) then
                call elecmigration(ivol,jnode,cinc(:),cxinc(:),                  &
                                   cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:))
              else
                call elecmigration(ivol,jnode,cnew_vals(:,ivol),cx_vals(:,ivol), &
                                   cnew_vals(:,jnode),cx_vals(:,jnode),dvals(:))
              end if
            end if
            do k = 1, n
              grad_elec(k) = grad_elec(k) -                                    &
                             CellsQuadTriFaceScaledNorm(j,itri,icell)*dvals(k)
            end do  

          end do
          if (b_cell_based_grad_itpl) then
            totvol = totvol + cells_trivol(itri,icell)
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient_totc(k,k2,i) = gradient_totc(k,k2,i) + grad_totc(k)/rv
                gradient_elec(k,k2,i) = gradient_elec(k,k2,i) + grad_elec(k)/rv
              end do
            end do
          else
            do k = 1, n
              do k2 = 1, num_edge_dvols
                gradient_totc(k,k2,i) = grad_totc(k)/(cells_trivol(itri,icell)*rv)
                gradient_elec(k,k2,i) = grad_elec(k)/(cells_trivol(itri,icell)*rv)
              end do
            end do
          end if
        end if        
      end if
 
    end do

    if (b_cell_based_grad_itpl) then
      do i = 1, janumcell(jtemp)
        gradient_totc(:,:,i) = gradient_totc(:,:,i)/totvol
        gradient_elec(:,:,i) = gradient_elec(:,:,i)/totvol
      end do
    end if

  end subroutine gradient_mcd_cell_green_gauss

end module gradient_usg
#endif
