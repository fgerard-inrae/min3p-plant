!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 878 $
!> $Author: dsu $
!> $Date: 2024-02-14 20:08:49 -0800 (Wed, 14 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/usg_face_utility.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c module of interface utility for unstructured grid
!c ----------------------
!c
!c
!c written by:      Danyang Su - Apr. 21, 2017
!c
!c definition of variables:
!c
!c
!c
!c common:   -
!c
!c local:    -
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
module usg_face_utility

  use math_common
  use geometry
  use phys, only : dens_h2o, visc_h2o, is_cell_based_relp
  use chem, only : nc

  use usg_mesh_data, only : nodes, cells, cell_type, cvol_method,      &
                            grad_method, cell_projection,              &
                            grad_average_weighting,                    &
                            num_edge_dvols, num_edge_maxcells,         &
                            num_cells, num_edges_per_cell,             &
                            CellCvolFaceCenter,                        &
                            CellCvolFaceArea, CellCvolFaceUnitNorm,    &
                            CellCvolFace_cond,                         &
                            CellCvolFace_cond_tensor,                  &
                            CellCvolFace_disp_da,                      &
                            CellCvolFace_disp_da_ic,                   &
                            CellCvolFace_disp_da_tensor,               &
                            CellCvolFace_disp_da_ic_tensor,            &
                            CellCvolFace_disp_g,                       &
                            CellCvolFace_disp_mcd,                     &
                            CellCvolFace_disp_mcd_tensor,              &
                            CellCvolFace_evap_pa,                      &
                            CellCvolFace_evap_t,                       &
                            CellCvolFace_heat_c,                       &
                            CellCvolFace_heat_c_tensor,                &
                            CellCvolFace_heat_d,                       &
                            CellCvolFace_heat_d_tensor,                &
                            CellCvolFace_adv,                          &
                            is_boundary_node, get_cell_edge_cvol_id

  use gradient_usg, only : gradient_cross_diff, gradient_cross_diff_dd

  use dens, only : ups_flow, density, viscosity, av_dens_z,            &
                   density_dependence
  use m_heat_transport, only : ups_heat

  use mod_fluxvs_usg
  use mod_fluxfs_usg
  use mod_fluxdd_usg
  use mod_darcy_energybal_usg

  use gen, only : iavs, javs, isymvs, jacell, sec_per_days,            &
                  gacc, pornew, sanew, uvsnew, hhead, relperm,         &
                  upstream, fully_saturated, variably_saturated,       &
                  aperture, fractureFlowType,                          &
                  tau, tau_fac, assigned_tau,                          &
                  marchies, nngl, njavs, tortuosity_corr,              &
                  mpropvs,  mpropvs_cell, janumcell, jaedgelen,        &
                  diff_coff, type_tortuosity, harmonic_porosity,       &
                  type_averaging_De, sonew, discretization_type,       &
                  type_cond_perm, type_diff_coeff,                     &
                  type_diff_ic_coeff, type_disp_coeff,                 &
                  useAnisoTauCorr, useAnisoDispCorr, useAnisoCondCorr, &
                  useAnisoHeatDispCorr, useAnisoHeatCondCorr,          &
                  jacrossdiffweight, jaedgeunitdirection,              &
                  jacrossdifficv, jagradweight, num_crossdifficv_max,  &
                  jacrossdifficvnum,b_grad_interpolate_cell,           &
                  idbg, ilog, rank, b_enable_output

#ifdef PETSC
  use petsc_mpi_common, only : petsc_mpi_finalize
#endif

  implicit none

  contains

  !>
  !> control volume interface velocity for specified edge, with direction
  !>
  subroutine usg_face_utility_vel_flow(ivol,jvol,icell,jtemp,velsloc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, icell, jtemp
    type(point), intent(inout) :: velsloc(num_edge_dvols)

    !c local variables
    integer :: istart, iend, icell2, idvol, idvol_r, iedge_r, kvol,    &
               ncell, ndvol
    character*1 :: iups
    real*8 :: cvolfacearea, rswitch, length
    real*8 :: grad_weights(num_crossdifficv_max)
    real*8 :: flux_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: cond, fnorm, edge, grad_locs(num_crossdifficv_max), &
                   grad_flow_mids(num_edge_dvols,num_edge_maxcells)
    type(tensor) :: tenf_cond

    type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols)
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,           &
                         r3 = 3.0d0, rsmallarea = 1.0d-8

!c  consistent with upstream weighting
    if (upstream) then
      iups = 'i'                         !h_i >= h_j
      if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
        iups = 'j'
      end if
    end if

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
    grad_flow_mids = vector_zero
    flux_hls_corr = r0
    ncell = janumcell(jtemp)

    if (variably_saturated) then
      call gradient_cross_diff(jtemp,ivol,jvol,hhead,grad_locs,   &
       grad_flow_mids,grad_weights,flux_hls_corr,grad_flow_hls_loc)
    else if (fully_saturated) then
      call gradient_cross_diff(jtemp,ivol,jvol,uvsnew,grad_locs,  &
       grad_flow_mids,grad_weights,flux_hls_corr,grad_flow_hls_loc)
    end if

!c  calculate darcy flux between node pair

    if (variably_saturated) then
      if (is_cell_based_relp) then
        icell2 = jacell(icell,jtemp)
        if (icell2 > 0) then
          do idvol = 1, num_edge_dvols
            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,         &
                                       idvol_r,iedge_r,rswitch)
            cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)

            if(cvolfacearea > rsmallarea) then
              fnorm = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)*rswitch

              if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
                cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
                velsloc(idvol) = -fluxvs_vel_usg_tend(upstream,.true.,1, &
                                      (/relperm(icell2)/),iups,cond,     &
                                      grad_flow_mids(idvol,icell),fnorm)
              else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
                velsloc(idvol) = -fluxvs_vel_usg_tenf(upstream,.true.,1, &
                                      (/relperm(icell2)/),iups,tenf_cond,&
                                      grad_flow_mids(idvol,icell),fnorm)
              end if

            else
              velsloc(idvol) = vector_zero
            end if
          end do
        end if
      else
        icell2 = jacell(icell,jtemp)
        if (icell2 > 0) then
          do idvol = 1, num_edge_dvols
            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,         &
                                       idvol_r,iedge_r,rswitch)
            cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)            

            if(cvolfacearea > rsmallarea) then
              fnorm = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)*rswitch
              if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
                cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)                             
                velsloc(idvol) = -fluxvs_vel_usg_tend(upstream,.false.,2,&
                                      (/relperm(ivol),relperm(jvol)/),   &
                                      iups,cond,                         &
                                      grad_flow_mids(idvol,icell),fnorm)
              else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)                             
                velsloc(idvol) = -fluxvs_vel_usg_tenf(upstream,.false.,2,&
                                      (/relperm(ivol),relperm(jvol)/),   &
                                      iups,tenf_cond,                    &
                                      grad_flow_mids(idvol,icell),fnorm)
              end if
            else
              velsloc(idvol) = vector_zero
            end if
          end do
        end if
      end if
    elseif (fully_saturated) then
        icell2 = jacell(icell,jtemp)
        if (icell2 > 0) then
          do idvol = 1, num_edge_dvols
            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,         &
                                       idvol_r,iedge_r,rswitch)
            cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)
            
            if(cvolfacearea > rsmallarea) then
              if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
                cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
                velsloc(idvol) = -fluxfs_vel_usg_tend(cond,grad_flow_mids(idvol,icell))
              else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
                velsloc(idvol) = -fluxfs_vel_usg_tenf(tenf_cond,grad_flow_mids(idvol,icell))
              end if
            else
              velsloc(idvol) = vector_zero
            end if
          end do
        end if
    end if

  end subroutine usg_face_utility_vel_flow

  !>
  !> control volume interface velocity for specified edge, with direction
  !>
  subroutine usg_face_utility_vel_ddflow(ivol,jvol,icell,jtemp,velsloc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, icell, jtemp
    type(point), intent(inout) :: velsloc(num_edge_dvols)

    !c local variables
    integer :: istart, iend, icell2, idvol, idvol_r, iedge_r, kvol,    &
               ncell, ndvol
    real*8 :: delp_dd, delz_dd, rho_av, dvolcoef
    real*8 :: cvolfacearea, rswitch
    real*8 :: grad_weights(num_crossdifficv_max)
    real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: cond, grad_ddflow_locs(num_crossdifficv_max),       &
                   grad_ddflow_mids(num_edge_dvols,num_edge_maxcells)
    type(tensor) :: tenf_cond

    type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,           &
                         r3 = 3.0d0, rsmallarea = 1.0d-8, rhalf = 0.5d0

    delp_dd = uvsnew(jvol) - uvsnew(ivol)
    delz_dd = nodes(jvol)%z - nodes(ivol)%z

    rho_av = rhalf * (density(ivol) + density(jvol))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
    if (av_dens_z) then
      delp_dd=rho_av*(uvsnew(jvol)/density(jvol) -                     &
                      uvsnew(ivol)/density(ivol))
    end if

    delz_dd = delz_dd * rho_av * gacc
    delp_dd = delp_dd + delz_dd


!c  assign coefficients for upstream weighting
!c calculate water volume (not mass!!) fluxes
    if (is_cell_based_relp) then
      if (delp_dd .gt. r0) then
        dvolcoef = 1.0d0/viscosity(jvol)
      else
        dvolcoef = 1.0d0/viscosity(ivol)
      end if
    else
      if (delp_dd .gt. r0) then
        dvolcoef = relperm(jvol)/viscosity(jvol)
      else
        dvolcoef = relperm(ivol)/viscosity(ivol)
      end if
    end if


!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
    grad_ddflow_mids = vector_zero
    flux_ddflow_hls_corr = r0

    call gradient_cross_diff_dd(jtemp,ivol,jvol,grad_ddflow_locs,      &
                  grad_ddflow_mids,grad_weights,flux_ddflow_hls_corr,  &
                  grad_ddflow_hls_loc)

!c  find darcy flux between node pair
!c  find darcy volume (not mass) flux

    if (is_cell_based_relp) then
      icell2 = jacell(icell,jtemp)
      if (icell2 > 0) then
        do idvol = 1, num_edge_dvols
          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,           &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)          

          if(cvolfacearea > rsmallarea) then
            if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
              cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
              velsloc(idvol) = -fluxdd_vel_usg_tend(                   &
                                relperm(jacell(icell,jtemp))*dvolcoef, &
                                cond,grad_ddflow_mids(idvol,icell))
            else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
              tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
              velsloc(idvol) = -fluxdd_vel_usg_tenf(                   &
                                relperm(jacell(icell,jtemp))*dvolcoef, &
                                tenf_cond,grad_ddflow_mids(idvol,icell))
            end if
          else
            velsloc(idvol) = vector_zero
          end if
        end do
      end if
    else
      icell2 = jacell(icell,jtemp)
      if (icell2 > 0) then
        do idvol = 1, num_edge_dvols
          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,           &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)          

          if(cvolfacearea > rsmallarea) then
            if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
              cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
              velsloc(idvol) = -fluxdd_vel_usg_tend(dvolcoef,cond,     &
                                grad_ddflow_mids(idvol,icell))
            else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
              tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
              velsloc(idvol) = -fluxdd_vel_usg_tenf(dvolcoef,tenf_cond,&
                                grad_ddflow_mids(idvol,icell))
            end if
          else
            velsloc(idvol) = vector_zero
          end if
        end do
      end if
    end if

  end subroutine usg_face_utility_vel_ddflow

  !>
  !> control volume interface velocity for specified edge, with direction
  !>
  subroutine usg_face_utility_vel_heat_d(ivol,jvol,icell,jtemp,velsloc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, icell, jtemp
    type(point), intent(inout) :: velsloc(num_edge_dvols)

    !c local variables
    integer :: istart, iend, icell2, idvol, idvol_r, iedge_r, kvol,    &
               ncell, ndvol
    real*8 :: delp_dd, delz_dd, rho_av, dvolcoef
    real*8 :: cvolfacearea, rswitch
    real*8 :: grad_weights(num_crossdifficv_max)
    real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells)
    type(point) :: cond, grad_ddflow_locs(num_crossdifficv_max),       &
                   grad_ddflow_mids(num_edge_dvols,num_edge_maxcells)
    type(tensor) :: tenf_cond

    type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,           &
                         r3 = 3.0d0,rhalf = 0.5d0,rsmallarea = 1.0d-8

!c  find darcy volume (not mass) flux between node pair
    delp_dd = uvsnew(jvol) - uvsnew(ivol)
    delz_dd = nodes(jvol)%z - nodes(ivol)%z

    rho_av = rhalf * (density(ivol) + density(jvol))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
    if (av_dens_z) then
      delp_dd=rho_av*(uvsnew(jvol)/density(jvol) -                     &
                      uvsnew(ivol)/density(ivol))
    end if

    delz_dd = delz_dd * rho_av * gacc
    delp_dd = delp_dd + delz_dd

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
    grad_ddflow_mids = vector_zero
    flux_ddflow_hls_corr = r0
    
    call gradient_cross_diff_dd(jtemp,ivol,jvol,grad_ddflow_locs,      &
                  grad_ddflow_mids,grad_weights,flux_ddflow_hls_corr,  &
                  grad_ddflow_hls_loc)

!c  find darcy flux between node pair
    if (is_cell_based_relp) then
      icell2 = jacell(icell,jtemp)
      if (icell2 > 0) then
        do idvol = 1, num_edge_dvols
          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,           &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)
          
          if(cvolfacearea > rsmallarea) then
            if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
              cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
              velsloc(idvol) = darcy_energybal_vel_usg_tend(           &
                               delp_dd,delp_dd,1,1,                    &
                               r1,r1,viscosity(ivol),viscosity(jvol),  &
                               .true.,1,relperm(jacell(icell,jtemp)),  &
                               ups_heat,.false.,cond,                  &
                               grad_ddflow_mids(idvol,icell))
            else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
              tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
              velsloc(idvol) = darcy_energybal_vel_usg_tenf(           &
                               delp_dd,delp_dd,1,1,                    &
                               r1,r1,viscosity(ivol),viscosity(jvol),  &
                               .true.,1,relperm(jacell(icell,jtemp)),  &
                               ups_heat,.false.,tenf_cond,             &
                               grad_ddflow_mids(idvol,icell))
            end if
          else
            velsloc(idvol) = vector_zero
          end if
        end do
      end if
    else
      icell2 = jacell(icell,jtemp)
      if (icell2 > 0) then
        do idvol = 1, num_edge_dvols
          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,           &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)
          
          if(cvolfacearea > rsmallarea) then
            if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
              cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
              velsloc(idvol) = darcy_energybal_vel_usg_tend(             &
                               delp_dd,delp_dd,1,1,r1,r1,                &
                               viscosity(ivol),viscosity(jvol),.false.,2,&
                               (/relperm(ivol),relperm(jvol)/),          &
                               ups_heat,.false.,cond,                    &
                               grad_ddflow_mids(idvol,icell))
            else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
              tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
              velsloc(idvol) = darcy_energybal_vel_usg_tenf(             &
                               delp_dd,delp_dd,1,1,r1,r1,                &
                               viscosity(ivol),viscosity(jvol),.false.,2,&
                               (/relperm(ivol),relperm(jvol)/),          &
                               ups_heat,.false.,tenf_cond,               &
                               grad_ddflow_mids(idvol,icell))
            end if
          else
            velsloc(idvol) = vector_zero
          end if
        end do
      end if
    end if

  end subroutine usg_face_utility_vel_heat_d

  !>
  !> calculate influence coefficient (dispersion - aqueous phase)
  !>
  subroutine usg_face_utility_cinfrt_da(ivol,jvol,jtemp,              &
                 cinfrt_da_loc,cinfrt_da_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfrt_da_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfrt_da_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    type(tensor) :: tenf
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    tend = vector_zero
    cinfrt_da_loc = r0
    cinfrt_da_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow            
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch
            if (type_diff_coeff == 2 .or. type_disp_coeff == 2 .or.    &
                useAnisoTauCorr .or. useAnisoDispCorr) then
              tenf = CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell)
              
              !c to be further checked - cross diffusion term 
              tend%x = tenf%xx
              tend%y = tenf%yy
              tend%z = tenf%zz

              wtend = math_common_tensor_transpose(tenf).cross.ntend
            else
              tend  = CellCvolFace_disp_da(idvol_r,iedge_r,icell)
              wtend = tend.times.ntend
            end if

            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfrt_da_loc(idvol,icell1) = cvolfacearea*                &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c utend equal zero for isotropic media            
            utend = vector_zero

            !c (wtend-ntend*(wtend.dot.ntend)) can be close to zero

            if (type_diff_coeff == 2 .or. type_disp_coeff == 2 .or.    &
                useAnisoTauCorr .or. useAnisoDispCorr) then
              utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
            else
              if (cell_projection == projection_xyz) then
                if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              else if (cell_projection == projection_xy) then
                if (tend%x /= tend%y) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              else if (cell_projection == projection_yz) then
                if (tend%y /= tend%z) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              else if (cell_projection == projection_xz) then
                if (tend%x /= tend%z) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              end if
            end if

            if (utend == vector_zero) then
              cinfrt_da_cross_loc(idvol,icell1) = vector_zero
            else
              cinfrt_da_cross_loc(idvol,icell1) = utend*               &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfrt_da

  !>
  !> calculate influence coefficient (dispersion - aqueous phase)
  !>
  subroutine usg_face_utility_cinfrt_da_ic(ivol,jvol,jtemp,           &
                 cinfrt_da_ic_loc,cinfrt_da_ic_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfrt_da_ic_loc(nc,num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfrt_da_ic_cross_loc(nc,num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r, ic
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    type(tensor) :: tenf
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    tend = vector_zero
    cinfrt_da_ic_loc = r0
    cinfrt_da_ic_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            do ic = 1, nc
              !c anisotropic K
              !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
              !c A second order finite volume technique for simulating transport
              !c in anisotropic media,                                       &
              !c International Journal of Numerical Methods for Heat and Fluid Flow              
              ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch

              if (type_diff_coeff == 2 .or. type_disp_coeff == 2 .or.  &
                  useAnisoTauCorr .or. useAnisoDispCorr) then
                tenf = CellCvolFace_disp_da_ic_tensor(ic,idvol_r,iedge_r,icell)

                !c to be further checked - cross diffusion term 
                tend%x = tenf%xx
                tend%y = tenf%yy
                tend%z = tenf%zz

                wtend = math_common_tensor_transpose(tenf).cross.ntend
              else
                tend  = CellCvolFace_disp_da_ic(ic,idvol_r,iedge_r,icell)
                wtend = tend.times.ntend
              end if
              
              vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
              cinfrt_da_ic_loc(ic,idvol,icell1) = cvolfacearea*        &
                     ((wtend.dot.ntend)/(vtend.dot.ntend))

              !c utend equal zero for isotropic media
              utend = vector_zero

              !c (wtend-ntend*(wtend.dot.ntend)) can be close to zero

              if (type_diff_coeff == 2 .or. type_disp_coeff == 2 .or.  &
                  useAnisoTauCorr .or. useAnisoDispCorr) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              else
                if (cell_projection == projection_xyz) then
                  if (tend%x /= tend%y .or. tend%y /= tend%z) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                else if (cell_projection == projection_xy) then
                  if (tend%x /= tend%y) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                else if (cell_projection == projection_yz) then
                  if (tend%y /= tend%z) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                else if (cell_projection == projection_xz) then
                  if (tend%x /= tend%z) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                end if
              end if

              if (utend == vector_zero) then
                cinfrt_da_ic_cross_loc(ic,idvol,icell1) = vector_zero
              else
                cinfrt_da_ic_cross_loc(ic,idvol,icell1) =utend*        &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
              end if
            end do
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfrt_da_ic

  !>
  !> calculate influence coefficient - gas diffusion
  !>
  subroutine usg_face_utility_cinfrt_dg(ivol,jvol,jtemp,               &
                 cinfrt_dg_loc,cinfrt_dg_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfrt_dg_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfrt_dg_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    cinfrt_dg_loc = r0
    cinfrt_dg_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow
            tend  = CellCvolFace_disp_g(idvol_r,iedge_r,icell)
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch
            wtend = tend.times.ntend
            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfrt_dg_loc(idvol,icell1) = cvolfacearea*                &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c utend equal zero for isotropic media
            utend = vector_zero
            if (cell_projection == projection_xyz) then
              if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xy) then
              if (tend%x /= tend%y) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_yz) then
              if (tend%y /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xz) then
              if (tend%x /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            end if

            if (utend == vector_zero) then
              cinfrt_dg_cross_loc(idvol,icell1) = vector_zero
            else
              cinfrt_dg_cross_loc(idvol,icell1) = utend*               &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfrt_dg

  !>
  !> calculate influence coefficient - multicomponent diffusion
  !>
  subroutine usg_face_utility_cinfrt_mcd(ivol,jvol,jtemp,              &
                 cinfrt_mcd_loc,cinfrt_mcd_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfrt_mcd_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfrt_mcd_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    type(tensor) :: tenf
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    cinfrt_mcd_loc = r0
    cinfrt_mcd_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch            
            if (useAnisoTauCorr) then
              tenf = CellCvolFace_disp_mcd_tensor(idvol_r,iedge_r,icell)

              !c to be further checked - cross diffusion term 
              tend%x = tenf%xx
              tend%y = tenf%yy
              tend%z = tenf%zz

              wtend = math_common_tensor_transpose(tenf).cross.ntend
            else
              tend  = CellCvolFace_disp_mcd(idvol_r,iedge_r,icell)
              wtend = tend.times.ntend
            end if
            
            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfrt_mcd_loc(idvol,icell1) = cvolfacearea*               &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c utend equal zero for isotropic media
            utend = vector_zero

            if (useAnisoTauCorr) then
              utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
            else
              if (cell_projection == projection_xyz) then
                if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              else if (cell_projection == projection_xy) then
                if (tend%x /= tend%y) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              else if (cell_projection == projection_yz) then
                if (tend%y /= tend%z) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              else if (cell_projection == projection_xz) then
                if (tend%x /= tend%z) then
                  utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                end if
              end if
            end if

            if (utend == vector_zero) then
              cinfrt_mcd_cross_loc(idvol,icell1) = vector_zero
            else
              cinfrt_mcd_cross_loc(idvol,icell1) = utend*              &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfrt_mcd

  !>
  !> calculate influence coefficient - variable saturated flow
  !>
  subroutine usg_face_utility_cinfvs(ivol,jvol,jtemp,                  &
                 cinfvs_loc,cinfvs_cross_loc,permij_loc,cvf2node_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfvs_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfvs_cross_loc(num_edge_dvols,num_edge_maxcells)
    real*8, intent(inout), optional ::                                 &
        permij_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout), optional ::                            &
        cvf2node_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea, convk, vector_error,              &
              aperture_ij, viscosity_ij
    type(point) :: tend, ntend, wtend, utend, vtend, wtend_check
    type(tensor) :: tenf
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    tend = vector_zero
    cinfvs_loc = r0
    cinfvs_cross_loc = vector_zero
    if (present(permij_loc)) then
      permij_loc = r0
    end if

    if (present(cvf2node_loc)) then
      cvf2node_loc = vector_zero
    end if

    convk = visc_h2o/(dens_h2o * gacc)  !conductivity * convk = permeability

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then

            if (present(cvf2node_loc)) then
              cvf2node_loc(idvol,icell1) = CellCvolFaceCenter(idvol_r,iedge_r,icell)-nodes(ivol)
            end if

            if (fractureFlowType(ivol) == 1 .and.                      &
                fractureFlowType(jvol) == 1) then
              aperture_ij = (aperture(ivol)*pornew(ivol) +             &
                             aperture(jvol)*pornew(jvol))/2.0d0
              if (density_dependence) then
                viscosity_ij = (viscosity(ivol)+viscosity(jvol))/2.0d0
                cinfvs_loc(idvol,icell1) = aperture_ij**2/viscosity_ij/&
                                           jaedgelen(jtemp)/12.0d0*    &
                                           cvolfacearea
              else
                cinfvs_loc(idvol,icell1) = aperture_ij**2/visc_h2o/    &
                                           jaedgelen(jtemp)/12.0d0*    &
                                           dens_h2o*gacc*cvolfacearea 
              end if
              cinfvs_loc(idvol,icell1) = cinfvs_loc(idvol,icell1)*sec_per_days

              cinfvs_cross_loc(idvol,icell1) = vector_zero
            else

              !c anisotropic K
              !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
              !c A second order finite volume technique for simulating transport
              !c in anisotropic media,                                       &
              !c International Journal of Numerical Methods for Heat and Fluid Flow
              ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch

              if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
                tend  = CellCvolFace_cond(idvol_r,iedge_r,icell)
                wtend = tend.times.ntend
              else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                tenf = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell)
                !c to be further checked - cross diffusion term 
                tend%x = tenf%xx
                tend%y = tenf%yy
                tend%z = tenf%zz

                wtend = math_common_tensor_transpose(tenf).cross.ntend
              end if

              vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
              cinfvs_loc(idvol,icell1) = cvolfacearea*                 &
                                     ((wtend.dot.ntend)/(vtend.dot.ntend))

              if (present(permij_loc)) then
                permij_loc(idvol,icell1) = (wtend.dot.ntend)*convk
              end if            

              !c for advection/conduction, do not add rswitch here,
              !c due to the direction

              !c utend equal zero for isotropic media
              utend = vector_zero

              if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              else if (type_cond_perm == 1) then
                if (cell_projection == projection_xyz) then
                  if (tend%x /= tend%y .or. tend%y /= tend%z ) then                
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                else if (cell_projection == projection_xy) then
                  if (tend%x /= tend%y) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                else if (cell_projection == projection_yz) then
                  if (tend%y /= tend%z) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                else if (cell_projection == projection_xz) then
                  if (tend%x /= tend%z) then
                    utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
                  end if
                end if
              end if


              if (utend == vector_zero) then
                cinfvs_cross_loc(idvol,icell1) = vector_zero
              else
                cinfvs_cross_loc(idvol,icell1) = utend*                  &
                    (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)* &
                    (vtend.dot.utend)/(vtend.dot.ntend))))
              end if
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfvs

  !>
  !> calculate influence coefficient - evaporation
  !>
  subroutine usg_face_utility_cinfevap_pa(ivol,jvol,jtemp,             &
                 cinfevap_pa_loc,cinfevap_pa_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfevap_pa_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfevap_pa_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    cinfevap_pa_loc = r0
    cinfevap_pa_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow
            tend  = CellCvolFace_evap_pa(idvol_r,iedge_r,icell)
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch
            wtend = tend.times.ntend
            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfevap_pa_loc(idvol,icell1) = cvolfacearea*              &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c utend equal zero for isotropic media
            utend = vector_zero
            if (cell_projection == projection_xyz) then
              if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xy) then
              if (tend%x /= tend%y) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_yz) then
              if (tend%y /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xz) then
              if (tend%x /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            end if

            if (utend == vector_zero) then
              cinfevap_pa_cross_loc(idvol,icell1) = vector_zero
            else
              cinfevap_pa_cross_loc(idvol,icell1) = utend*             &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfevap_pa

  !>
  !> calculate influence coefficient - evaporation
  !>
  subroutine usg_face_utility_cinfevap_t(ivol,jvol,jtemp,              &
                 cinfevap_t_loc,cinfevap_t_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfevap_t_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfevap_t_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    cinfevap_t_loc = r0
    cinfevap_t_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow
            tend  = CellCvolFace_evap_t(idvol_r,iedge_r,icell)
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch
            wtend = tend.times.ntend
            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfevap_t_loc(idvol,icell1) = cvolfacearea*               &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c utend equal zero for isotropic media
            utend = vector_zero
            if (cell_projection == projection_xyz) then
              if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xy) then
              if (tend%x /= tend%y) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_yz) then
              if (tend%y /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xz) then
              if (tend%x /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            end if

            if (utend == vector_zero) then
              cinfevap_t_cross_loc(idvol,icell1) = vector_zero
            else
              cinfevap_t_cross_loc(idvol,icell1) = utend*              &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfevap_t

  !>
  !> calculate influence coefficient - convection of heat transport
  !>
  subroutine usg_face_utility_cinfheat_c(ivol,jvol,jtemp,              &
                 cinfheat_c_loc,cinfheat_c_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfheat_c_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfheat_c_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    type(tensor) :: tenf
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    tend = vector_zero
    cinfheat_c_loc = r0
    cinfheat_c_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch
            if (useAnisoHeatCondCorr) then
              tenf = CellCvolFace_heat_c_tensor(idvol_r,iedge_r,icell)

              !c to be further checked - cross diffusion term 
              tend%x = tenf%xx
              tend%y = tenf%yy
              tend%z = tenf%zz

              wtend = math_common_tensor_transpose(tenf).cross.ntend
            else
              tend  = CellCvolFace_heat_c(idvol_r,iedge_r,icell)            
              wtend = tend.times.ntend
            end if

            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfheat_c_loc(idvol,icell1) = cvolfacearea*               &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c for advection/conduction, do not add rswitch here,
            !c due to the direction

            !c utend equal zero for isotropic media
            utend = vector_zero
            if (cell_projection == projection_xyz) then
              if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xy) then
              if (tend%x /= tend%y) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_yz) then
              if (tend%y /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xz) then
              if (tend%x /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            end if

            if (utend == vector_zero) then
              cinfheat_c_cross_loc(idvol,icell1) = vector_zero
            else
              cinfheat_c_cross_loc(idvol,icell1) = utend*              &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfheat_c

  !>
  !> calculate influence coefficient - dispersion of heat transport
  !>
  subroutine usg_face_utility_cinfheat_d(ivol,jvol,jtemp,              &
                 cinfheat_d_loc,cinfheat_d_cross_loc)

    implicit none

    !c passed variables
    integer, intent(in) :: ivol, jvol, jtemp
    real*8, intent(inout) ::                                           &
        cinfheat_d_loc(num_edge_dvols,num_edge_maxcells)
    type(point), intent(inout) ::                                      &
        cinfheat_d_cross_loc(num_edge_dvols,num_edge_maxcells)

    !c local variables
    integer :: idvol, icell, icell1, idvol_r, iedge_r
    real*8 :: rswitch, cvolfacearea
    type(point) :: tend, ntend, wtend, utend, vtend
    type(tensor) :: tenf
    real*8, parameter :: r0 = 0.0d0, rsmallarea = 1.0d-8

    !c initialize as zero
    tend = vector_zero
    cinfheat_d_loc = r0
    cinfheat_d_cross_loc = vector_zero

    do icell1 = 1, janumcell(jtemp)
      icell = jacell(icell1,jtemp)
      if (icell > 0) then
        do idvol = 1, num_edge_dvols

          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,            &
                                     idvol_r,iedge_r,rswitch)
          cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

          if(cvolfacearea > rsmallarea) then
            !c anisotropic K
            !c Ref Jayantha Pasdunkorale and Ian W. Turner, 2003,
            !c A second order finite volume technique for simulating transport
            !c in anisotropic media,                                       &
            !c International Journal of Numerical Methods for Heat and Fluid Flow            
            ntend = CellCvolFaceUnitNorm(idvol_r,iedge_r,icell)*rswitch
            if (useAnisoHeatDispCorr) then
              tenf = CellCvolFace_heat_d_tensor(idvol_r,iedge_r,icell)

              !c to be further checked - cross diffusion term 
              tend%x = tenf%xx
              tend%y = tenf%yy
              tend%z = tenf%zz

              wtend = math_common_tensor_transpose(tenf).cross.ntend
            else
              tend  = CellCvolFace_heat_d(idvol_r,iedge_r,icell)
              wtend = tend.times.ntend
            end if

            vtend = jaedgeunitdirection(jtemp)*jaedgelen(jtemp)
            cinfheat_d_loc(idvol,icell1) = cvolfacearea*               &
                                   ((wtend.dot.ntend)/(vtend.dot.ntend))

            !c utend equal zero for isotropic media
            utend = vector_zero
            if (cell_projection == projection_xyz) then
              if (tend%x /= tend%y .or. tend%y /= tend%z ) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xy) then
              if (tend%x /= tend%y) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_yz) then
              if (tend%y /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            else if (cell_projection == projection_xz) then
              if (tend%x /= tend%z) then
                utend = math_common_vector_unit(wtend-ntend*(wtend.dot.ntend))
              end if
            end if

            if (utend == vector_zero) then
              cinfheat_d_cross_loc(idvol,icell1) = vector_zero
            else
              cinfheat_d_cross_loc(idvol,icell1) = utend*              &
                   (cvolfacearea*((wtend.dot.utend)-((wtend.dot.ntend)*&
                   (vtend.dot.utend)/(vtend.dot.ntend))))
            end if
          end if
        end do
      end if
    end do

  end subroutine usg_face_utility_cinfheat_d

end module usg_face_utility
#endif
