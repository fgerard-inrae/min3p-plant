!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/gms_mesh_domain.F90 $
!---------------------------------------------------------------------
!********************************************************************!


! --------------------------------------------------------------------
!> Module of GMS mesh operation
!>
!> Module description:
!>
!> Written by:    Danyang Su - Jun. 04, 2016
!> Last modified:
! --------------------------------------------------------------------

module gms_mesh_domain
  use gen, only : ilog, rank
  use file_unit, only : lun_get, lun_free
  use file_utility, only : readnextline
#ifdef PETSC
  use petsc_mpi_common, only : petsc_mpi_finalize
#endif

  !c this is feature of Fortran 2003
  use iso_c_binding

  use geometry_definition

  implicit none

  private

  public gms_mesh_read, gms_mesh_set_layers, gms_mesh_read_layer,      &
         gms_mesh_output, gms_mesh_triangulation_prism,                &
         gms_mesh_free_data


  !c GMS mesh data structure
  integer :: num_vertices
  integer :: num_boundary_vertices
  integer :: num_edges
  integer :: num_boundary_edges
  integer :: num_triangles
  integer :: num_quadrilaterals
  integer :: num_elements

  type vertex
    integer :: id         !vertex id
    integer :: nedge      !number of half-edges
    integer :: edgeid(24) !linked half-edge id
    real*8 :: x, y, z     !point coordinate
    logical :: isboundary !indicate if this is a boundary node
  end type vertex

  type edge
    integer :: id         !edge id
    integer :: oppid      !edge id of opposed edge (share the same vertices)
    integer :: eleid      !element id and right element id
    integer :: vtxid(2)   !start vertex id and end vertex id
    logical :: isboundary !indicate if this is a boundary edge
  end type edge

  type element
    integer :: id        !polygon id
    integer :: matid     !material id
    integer :: nvtx      !number of vertex
    integer :: vtxid(4)  !polygon vertex id array, 3 for triangle and 4 for quadrilateral
    integer :: edgeid(4) !edge id
  end type element

  type(vertex), allocatable :: vertices(:)
  type(edge), allocatable :: edges(:)
  type(element), allocatable :: elements(:)

  !c layer data
  integer :: num_node_layers  !number of elevations layers
  real*8, allocatable :: vertices_z(:,:)  !vertices_z(num_vertices,num_node_layers)

  !c feature data
  integer, allocatable :: boundary_edges_id(:)
  integer, allocatable :: boundary_vertices_id(:)

  contains


  !c read gms 2D mesh file and make basic half-edge based topology
  subroutine gms_mesh_read(strfile)

    implicit none

    character(len=*), intent(in) :: strfile

    integer :: i, j, k, i2, j2, k2, iedge, ibdedge, ibdvtx, nedgetemp, &
               iele, ivtx, ivtxid, ieletype, iunit
    character(2048) :: strbuffer
    character(3) :: strdummy

    num_vertices = 0
    num_edges = 0
    num_triangles = 0
    num_quadrilaterals = 0
    num_elements = 0

    iunit = lun_get()

    open(unit=iunit,file=trim(adjustl(strfile)),status='old')

    !c get mesh stastics
    do while (readnextline(iunit, strbuffer))

      if (index(strbuffer, "e4q") == 1) then
        num_quadrilaterals = num_quadrilaterals + 1
      end if

      if (index(strbuffer, "e3t") == 1) then
        num_triangles = num_triangles + 1
      end if

      if (index(strbuffer, "nd") == 1) then
        num_vertices = num_vertices + 1
      end if

    end do

    num_elements = num_quadrilaterals + num_triangles

    !c allocate space for vertices and elements
    allocate(vertices(num_vertices))
    do i = 1, num_vertices
      vertices(i)%id = 0
      vertices(i)%nedge = 0
      vertices(i)%edgeid(:) = 0
      vertices(i)%x = 0.0d0
      vertices(i)%y = 0.0d0
      vertices(i)%z = 0.0d0
      vertices(i)%isboundary = .false.
    end do

    allocate(elements(num_elements))
    do i = 1, num_elements
      elements(i)%id = 0
      elements(i)%matid = 0
      elements(i)%nvtx = 0
      elements(i)%vtxid(:) = 0
      elements(i)%edgeid(:) = 0
    end do

    num_edges = 4*num_elements
    allocate(edges(num_edges))
    do i = 1, num_edges
      edges(i)%id = 0
      edges(i)%oppid = 0
      edges(i)%eleid = 0
      edges(i)%vtxid(:) = 0
      edges(i)%isboundary = .true.
    end do

    !c get detail mesh information
    iedge = 0
    iele = 0
    ivtx = 0
    rewind(iunit)
    do while (readnextline(iunit, strbuffer))

      ieletype = 0

      if (index(strbuffer, "e4q") == 1) then
        ieletype = 4
      end if

      if (index(strbuffer, "e3t") == 1) then
        ieletype = 3
      end if

      if (ieletype == 3 .or. ieletype == 4) then
        iele = iele + 1
        read(strbuffer,*) strdummy, elements(iele)%id,                 &
             elements(iele)%vtxid(1:ieletype), elements(iele)%matid

        elements(iele)%nvtx = ieletype

        do i = 1, ieletype
          j = i
          k = i + 1
          if (k > ieletype) then
            k = 1
          end if
          iedge = iedge + 1
          edges(iedge)%id = iedge
          edges(iedge)%eleid = iele
          edges(iedge)%vtxid(1) = elements(iele)%vtxid(j)
          edges(iedge)%vtxid(2) = elements(iele)%vtxid(k)
          elements(iele)%edgeid(i) = iedge

          ivtxid = elements(iele)%vtxid(i)
          nedgetemp = vertices(ivtxid)%nedge + 1

          if (nedgetemp > 24) then
            goto 999
          end if

          vertices(ivtxid)%nedge = nedgetemp
          vertices(ivtxid)%edgeid(nedgetemp) = iedge
        end do
      end if

      if (index(strbuffer, "nd") == 1) then
        ivtx = ivtx + 1
        read(strbuffer,*) strdummy, vertices(ivtx)%id,                 &
             vertices(ivtx)%x, vertices(ivtx)%y, vertices(ivtx)%z
      end if

    end do

    close(iunit)

    call lun_free(iunit)

    num_edges = iedge

    !c make mesh topology, half-edge-based
    do i = 1, num_vertices
      do j = 1, vertices(i)%nedge
        j2 = vertices(i)%edgeid(j)
        if (vertices(i)%id == edges(j2)%vtxid(1)) then
          i2 = edges(j2)%vtxid(2)
        else
          i2 = edges(j2)%vtxid(1)
        end if
        do k = 1, vertices(i2)%nedge
          k2 = vertices(i2)%edgeid(k)
          if (edges(j2)%vtxid(1) == edges(k2)%vtxid(2) .and.             &
              edges(j2)%vtxid(2) == edges(k2)%vtxid(1)) then
            edges(j2)%isboundary = .false.
            edges(j2)%oppid = edges(k2)%id
            edges(k2)%isboundary = .false.
            edges(k2)%oppid = edges(j2)%id
          end if
        end do
      end do
    end do

    !c get all the boundary list
    num_boundary_edges = 0
    do i = 1, num_edges
      if (edges(i)%isboundary) then
        num_boundary_edges = num_boundary_edges + 1
      end if
    end do

    ibdedge = 0
    allocate(boundary_edges_id(num_boundary_edges))
    do i = 1, num_edges
      if (edges(i)%isboundary) then
        ibdedge = ibdedge + 1
        boundary_edges_id(ibdedge) = edges(i)%id
        vertices(edges(i)%vtxid(1))%isboundary = .true.
        vertices(edges(i)%vtxid(2))%isboundary = .true.
      end if
    end do

    !c get all boundary vertices
    num_boundary_vertices = 0
    do i = 1, num_vertices
      if (vertices(i)%isboundary) then
        num_boundary_vertices = num_boundary_vertices + 1
      end if
    end do

    ibdvtx = 0
    allocate(boundary_vertices_id(num_boundary_vertices))
    do i = 1, num_vertices
      if (vertices(i)%isboundary) then
        ibdvtx = ibdvtx + 1
        boundary_vertices_id(ibdvtx) = vertices(i)%id
      end if
    end do

    write(*,*) "num_vertices ", num_vertices
    write(*,*) "num_boundary_vertices ", num_boundary_vertices
    write(*,*) "num_edges ", num_edges
    write(*,*) "num_boundary_edges ", num_boundary_edges
    write(*,*) "num_triangles ", num_triangles
    write(*,*) "num_quadrilaterals ", num_quadrilaterals
    write(*,*) "num_elements ", num_elements

    return

999 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,'(2a)') 'error in building mesh topology from GMS mesh file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,'(2a)') 'error in building mesh topology from GMS mesh file'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine gms_mesh_read

  !c set number of elevation layers
  subroutine gms_mesh_set_layers(n)

    implicit none

    integer, intent(in) :: n

    num_node_layers = n

    allocate(vertices_z(num_vertices, num_node_layers))

  end subroutine gms_mesh_set_layers

  !c read surface data of layers
  subroutine gms_mesh_read_layer(ilayer, strfile)

    implicit none

    integer, intent(in) :: ilayer
    character(len=*), intent(in) :: strfile

    integer :: ivtx, iunit
    character(2048) :: strbuffer

    iunit = lun_get()

    open(unit=iunit,file=trim(adjustl(strfile)),status='old')

    !c get detail mesh information
    ivtx = 0
    do while (readnextline(iunit, strbuffer))
      if (ichar(strbuffer(1:1)) >= 42 .and.                           &
          ichar(strbuffer(1:1)) <= 57) then
        ivtx = ivtx + 1
        read(strbuffer,*) vertices_z(ivtx,ilayer)
      end if
    end do

    close(iunit)

    call lun_free(iunit)

    return

999 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,'(2a)')                                               &
            'error in reading layer elevation data in file ',          &
            trim(strfile)
      write(*,*) 'SIMULATION TERMINATED'
      write(*,'(2a)') 'error in reading layer elevation data in file ',&
            trim(strfile)
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine gms_mesh_read_layer

  !c output mesh to GMSH file
  subroutine gms_mesh_output(ilayer_start, ilayer_end, strfile,        &
                 strformat, zratio_in)

    implicit none

    integer, intent(in) :: ilayer_start, ilayer_end
    character(len=*), intent(in) :: strfile, strformat
    real*8, intent(in), optional :: zratio_in

    integer :: i, j, k, iunit, ishift1, ishift2
    integer :: nlayers, nvertices, nelements
    real*8 :: zratio

    if (present(zratio_in)) then
      zratio = zratio_in
    else
      zratio = 1.0d0
    end if

    nlayers = ilayer_end-ilayer_start+1
    nvertices = num_vertices*nlayers
    if(nlayers == 1) then
      nelements = num_elements
    else
      nelements = num_elements*(nlayers-1)
    end if

    iunit = lun_get()

    open(unit=iunit,file=trim(adjustl(strfile)))

    if (trim(strformat) == "off") then

      !c write mesh information to off
      !c write off file header
      write(iunit,'(a)') "OFF"
      write(iunit,*) num_vertices*2, num_elements*2+num_boundary_edges,0
      !c write vertices of bottom layer
      do i = 1, num_vertices
        write(iunit,*) vertices(i)%x, vertices(i)%y,                   &
              vertices_z(i,ilayer_end)*zratio
      end do
      !c write vertices of top layer
      do i = 1, num_vertices
        write(iunit,*) vertices(i)%x, vertices(i)%y,                   &
              vertices_z(i,ilayer_start)*zratio
      end do
      !c write faces of bottom layer, note, index of vertex is 0-based
      do i = 1, num_elements
        write(iunit,*) elements(i)%nvtx,                               &
              elements(i)%vtxid(elements(i)%nvtx:1:-1)-1
      end do

      !c write faces of top layer, note, index of vertex is 0-based
      do i = 1, num_elements
        write(iunit,*) elements(i)%nvtx,                               &
              elements(i)%vtxid(1:elements(i)%nvtx)-1+num_vertices
      end do

      !c write side faces connected to boundary edges
      do i = 1, num_boundary_edges
        write(iunit,*) 4, edges(i)%vtxid(1:2)-1,                    &
              edges(i)%vtxid(2:1:-1)-1+num_vertices
      end do

    else if (trim(strformat) == "msh") then

      !c write mesh information to GMSH file format
      !c write file header
      write(iunit,'(a)') "$MeshFormat"
      write(iunit,'(a)') "2.0 0 8"
      write(iunit,'(a)') "$EndMeshFormat"

      !c write nodes
      write(iunit,'(a)') "$Nodes"
      write(iunit,*) nvertices
      k = 0
      !write vertices from bottom to top
      do i = ilayer_end, ilayer_start, -1
        do j = 1, num_vertices
          k = k + 1
          write(iunit,*) k, vertices(j)%x, vertices(j)%y,              &
                         vertices_z(j,i)*zratio
        end do
      end do
      write(iunit,'(a)') "$EndNodes"

      !c write elements
      write(iunit,'(a)') "$Elements"
      write(iunit,*) nelements
      k = 0
      if(nlayers == 1) then
        do j = 1, num_elements
          k = k + 1
          if (elements(j)%nvtx == 3) then
            write(iunit,*) k, 2, 2, i, i,                              &
              elements(j)%vtxid(1:elements(j)%nvtx)
          else if (elements(j)%nvtx == 4) then
            write(iunit,*) k, 3, 2, i, i,                              &
              elements(j)%vtxid(1:elements(j)%nvtx)
          end if
        end do
      else if (nlayers > 1) then
        do i = 1, nlayers-1
          ishift1 = (i-1)*num_vertices
          ishift2 = i*num_vertices
          do j = 1, num_elements
            k = k + 1
            if (elements(j)%nvtx == 3) then
              write(iunit,*) k, 6, 2, i, i,                            &
                elements(j)%vtxid(1:elements(j)%nvtx)+ishift1,         &
                elements(j)%vtxid(1:elements(j)%nvtx)+ishift2
            else if (elements(j)%nvtx == 4) then
              write(iunit,*) k, 5, 2, i, i,                            &
                elements(j)%vtxid(1:elements(j)%nvtx)+ishift1,         &
                elements(j)%vtxid(1:elements(j)%nvtx)+ishift2
            end if
          end do
        end do
      end if
      write(iunit,'(a)') "$EndElements"

    else if (trim(strformat) == "vtk") then

      !c write mesh information to vtk file format
      !c note: index in vtk format is 0-based
      !c Write header
      write(iunit,'(a)') "# vtk DataFile Version 2.0"
      write(iunit,'(a)') "GMS geological model mesh"
      write(iunit,'(a)') "ASCII"
      write(iunit,'(a)') "DATASET UNSTRUCTURED_GRID"

      !c write nodes
      write(iunit,'(a6,1x,i8,1x,a6)') "POINTS",nvertices,"double"

      !write vertices from bottom to top
      do i = ilayer_end, ilayer_start, -1
        do j = 1, num_vertices
          write(iunit,*) vertices(j)%x, vertices(j)%y,                 &
                vertices_z(j,i)*zratio
        end do
      end do
      write(iunit,'(a)') ""

      !c write elements
      if(nlayers == 1) then
        ishift1 = -1
        write(iunit,'(a,1x,i8,1x,i8)') "CELLS",nelements,              &
              num_quadrilaterals*5+num_triangles*4
        do j = 1, num_elements
          if (elements(j)%nvtx == 3) then
            write(iunit,'(a,6(1x,i8))') "3",                           &
            elements(j)%vtxid(1:elements(j)%nvtx)+ishift1
          else if (elements(j)%nvtx == 4) then
            write(iunit,'(a,8(1x,i8))') "4",                           &
            elements(j)%vtxid(1:elements(j)%nvtx)+ishift1
          end if
        end do
      else if (nlayers > 1) then
        write(iunit,'(a,1x,i8,1x,i8)') "CELLS",nelements,              &
              num_quadrilaterals*(nlayers-1)*9+                        &
              num_triangles*(nlayers-1)*7
        do i = 1, nlayers-1
          ishift1 = (i-1)*num_vertices-1
          ishift2 = i*num_vertices-1
          do j = 1, num_elements
            if (elements(j)%nvtx == 3) then
              write(iunit,'(a,6(1x,i8))') "6",                         &
                    elements(j)%vtxid(1:elements(j)%nvtx)+ishift1,     &
                    elements(j)%vtxid(1:elements(j)%nvtx)+ishift2
            else if (elements(j)%nvtx == 4) then
              write(iunit,'(a,8(1x,i8))') "8",                         &
                    elements(j)%vtxid(1:elements(j)%nvtx)+ishift1,     &
                    elements(j)%vtxid(1:elements(j)%nvtx)+ishift2
            end if
          end do
        end do
      end if

      write(iunit,'(a)') ""

      !c write cell type
      write(iunit,'(a,1x,i8)') "CELL_TYPES",nelements
      if (nlayers == 1) then
        do j = 1, num_elements
          if (elements(j)%nvtx == 3) then
            write(iunit,'(a2)') "5"
          else if (elements(j)%nvtx == 4) then
            write(iunit,'(a2)') "9"
          end if
        end do
      else if (nlayers > 1) then
        do i = 1, nlayers-1
          do j = 1, num_elements
            if (elements(j)%nvtx == 3) then
              write(iunit,'(a2)') "13"
            else if (elements(j)%nvtx == 4) then
              write(iunit,'(a2)') "12"
            end if
          end do
        end do
      end if

      write(iunit,'()') ""
      !c write node material id
      write(iunit,'(a,1x,i0)') "POINT_DATA",nvertices
      write(iunit,'(a)') "SCALARS node_matids int 1"
      write(iunit,'(a)') "LOOKUP_TABLE default"
      
      do i = ilayer_end, ilayer_start, -1
        do j = 1, num_vertices
          write(iunit,'(i0)') i
        end do
      end do

      write(iunit,'()') ""
      !c write cell material id
      write(iunit,'(a,1x,i0)') "CELL_DATA",nelements
      write(iunit,'(a)') "SCALARS cell_matids int 1"
      write(iunit,'(a)') "LOOKUP_TABLE default"
      if (nlayers == 1) then
        do j = 1, num_elements
          write(iunit,'(i0)') nlayers
        end do
      else if (nlayers > 1) then
        do i = 1, nlayers-1
          do j = 1, num_elements
            write(iunit,'(i0)') i
          end do
        end do
      end if

    end if

    close(iunit)

    call lun_free(iunit)

    return

  end subroutine gms_mesh_output


  !c triangulation based on the given point sets
  subroutine gms_mesh_triangulation_prism(ilayer_start, ilayer_end,    &
                 strfile, strformat, zratio_in)

#ifdef CGAL
    use cgal_triangulation_2d_iface, only : cgal_set_mesh_points_tri2d,&
        cgal_insert_constraint_polyline_tri2d, cgal_make_mesh_tri2d,   &
        cgal_output_mesh_tri2d, cgal_output_mesh_prism,                &
        cgal_number_of_vertices_tri2d, cgal_number_of_edges_tri2d,     &
        cgal_number_of_faces_tri2d, cgal_set_terrain_layers

#endif

    implicit none

    integer, intent(in) :: ilayer_start, ilayer_end
    character(len=*), intent(in) :: strformat, strfile  !c output mesh format and file path
    real*8, intent(in), optional :: zratio_in

#ifdef CGAL
    !c local variable
    integer :: i, j, k, nlayers, nvertices
    type(point2d_c), allocatable :: pts(:)
    type(point2d_c), allocatable :: pts_bd(:)
    real*8, allocatable :: vtx_z(:)
    real*8 :: zratio

    if (present(zratio_in)) then
      zratio = zratio_in
    else
      zratio = 1.0d0
    end if

    nlayers = ilayer_end-ilayer_start+1
    nvertices = num_vertices*nlayers

    !c set mesh points for the top layer
    allocate(pts(num_vertices))
    k = 0
    do j = 1, num_vertices
      k = k + 1
      pts(k)%x = vertices(j)%x
      pts(k)%y = vertices(j)%y
    end do

    call cgal_set_mesh_points_tri2d(num_vertices,pts(1:num_vertices))
    deallocate(pts)

    !c set layer elevations, from bottom to top
    k = 0
    allocate(vtx_z(nvertices))
    do i = ilayer_end, ilayer_start, -1
      do j = 1, num_vertices
        k = k + 1
        vtx_z(k) = vertices_z(j,i)*zratio
      end do
    end do

    call cgal_set_terrain_layers(nlayers, nvertices, vtx_z)
    deallocate(vtx_z)

    !c insert boundary constraint
    allocate(pts_bd(2))
    do i = 1, num_boundary_edges
      pts_bd(1)%x = vertices(edges(boundary_edges_id(i))%vtxid(1))%x
      pts_bd(1)%y = vertices(edges(boundary_edges_id(i))%vtxid(1))%y
      pts_bd(2)%x = vertices(edges(boundary_edges_id(i))%vtxid(2))%x
      pts_bd(2)%y = vertices(edges(boundary_edges_id(i))%vtxid(2))%y
      call cgal_insert_constraint_polyline_tri2d(2, pts_bd, .false.)
    end do
    deallocate(pts_bd)

    !c triangulation
    call cgal_make_mesh_tri2d

    !c output mesh information
    write(*,*) "-->check mesh - number of vertices: ",                 &
               cgal_number_of_vertices_tri2d()
    write(*,*) "-->check mesh - number of edges: ",                    &
               cgal_number_of_edges_tri2d()
    write(*,*) "-->check mesh - number of facets: ",                   &
               cgal_number_of_faces_tri2d()

    !c output mesh using "msh" format
    call cgal_output_mesh_prism(trim(strfile),trim(strformat))
#endif

  end subroutine gms_mesh_triangulation_prism


  !c free mesh data space
  subroutine gms_mesh_free_data()

    implicit none

    if(allocated(vertices)) then
      deallocate(vertices)
    end if

    if(allocated(edges)) then
      deallocate(edges)
    end if

    if(allocated(elements)) then
      deallocate(elements)
    end if

    if(allocated(vertices_z)) then
      deallocate(vertices_z)
    end if

    if(allocated(boundary_edges_id)) then
      deallocate(boundary_edges_id)
    end if

    if(allocated(boundary_vertices_id)) then
      deallocate(boundary_vertices_id)
    end if

  end subroutine gms_mesh_free_data

  !c gms mesh domain test
  subroutine gms_mesh_test

    implicit none

    integer :: i

    character(256) :: strfile_gms, strfile_layer(39)

    character(256) :: strfile_off1, strfile_off2, strfile_off3,        &
                      strfile_msh, strfile_tri_msh

    !c set file path
    strfile_gms = "example/domain_gms/grid_R3.gms"
    strfile_layer(1) = "example/domain_gms/top_NOAA_1234_7531_DEM_BATH_REGIONAL.txt"
    strfile_layer(2) = "example/domain_gms/top_SURF_R1_1_01_Hamilton_Gp.txt"
    strfile_layer(3) = "example/domain_gms/top_SURF_R1_1_02_Dundee.txt"
    strfile_layer(4) = "example/domain_gms/top_SURF_R1_1_03_Detroit_River_Gp.txt"
    strfile_layer(5) = "example/domain_gms/top_SURF_R1_1_04_Bois_Blanc.txt"
    strfile_layer(6) = "example/domain_gms/top_SURF_R1_1_05_Bass_Islands.txt"
    strfile_layer(7) = "example/domain_gms/top_SURF_R1_1_06_G_Unit.txt"
    strfile_layer(8) = "example/domain_gms/top_SURF_R1_1_07_F_Unit.txt"
    strfile_layer(9) = "example/domain_gms/top_SURF_R1_1_08_F_Salt.txt"
    strfile_layer(10) = "example/domain_gms/top_SURF_R1_1_09_E_Unit.txt"
    strfile_layer(11) = "example/domain_gms/top_SURF_R1_1_10_D_Unit.txt"
    strfile_layer(12) = "example/domain_gms/top_SURF_R1_1_11_B_and_C_Units.txt"
    strfile_layer(13) = "example/domain_gms/top_SURF_R1_1_12_B_Anhydrite__Salt.txt"
    strfile_layer(14) = "example/domain_gms/top_SURF_R1_1_13_A_2_Carbonate.txt"
    strfile_layer(15) = "example/domain_gms/top_SURF_R1_1_14_A_2_Evaporite.txt"
    strfile_layer(16) = "example/domain_gms/top_SURF_R1_1_15_A_1_Carbonate-A1_UC.txt"
    strfile_layer(17) = "example/domain_gms/top_SURF_R1_1_15_A_1_Carbonate-A1_C.txt"
    strfile_layer(18) = "example/domain_gms/top_SURF_R1_1_16_A_1_Evaporite-A1_E.txt"
    strfile_layer(19) = "example/domain_gms/top_SURF_R1_1_16_A_1_Evaporite-A0.txt"
    strfile_layer(20) = "example/domain_gms/top_SURF_R1_1_17_Guelph.txt"
    strfile_layer(21) = "example/domain_gms/top_THIC_R1_1_17_Goat_Island.txt"
    strfile_layer(22) = "example/domain_gms/top_THIC_R1_1_17_Gasport.txt"
    strfile_layer(23) = "example/domain_gms/top_THIC_R1_1_17_Lions_Head.txt"
    strfile_layer(24) = "example/domain_gms/top_SURF_R1_1_18_Reynales__Fossil_Hill.txt"
    strfile_layer(25) = "example/domain_gms/top_SURF_R1_1_19_Cabot_Head.txt"
    strfile_layer(26) = "example/domain_gms/top_SURF_R1_1_20_Manitoulin.txt"
    strfile_layer(27) = "example/domain_gms/top_SURF_R1_1_21_Queenston.txt"
    strfile_layer(28) = "example/domain_gms/top_SURF_R1_1_22_Georgian_Bay__Blue_Mtn.txt"
    strfile_layer(29) = "example/domain_gms/top_SURF_R1_1_23_Cobourg.txt"
    strfile_layer(30) = "example/domain_gms/top_SURF_R1_1_24_Sherman_Fall.txt"
    strfile_layer(31) = "example/domain_gms/top_SURF_R1_1_25_Kirkfield.txt"
    strfile_layer(32) = "example/domain_gms/top_SURF_R1_1_26_Coboconk.txt"
    strfile_layer(33) = "example/domain_gms/top_SURF_R1_1_27_Gull_River.txt"
    strfile_layer(34) = "example/domain_gms/top_SURF_R1_1_28_Shadow_Lake.txt"
    strfile_layer(35) = "example/domain_gms/top_SURF_R1_1_29_Cambrian.txt"
    strfile_layer(36) = "example/domain_gms/top_SURF_R1_1_30_Precambrian.txt"
    strfile_layer(37) = "example/domain_gms/top_SURF_R1_1_31_UW-Precambrian.txt"
    strfile_layer(38) = "example/domain_gms/top_SURF_R1_1_32_Bot-Precambrian.txt"
    strfile_layer(39) = "example/domain_gms/top_SURF_R1_1_33_Bottom.txt"

    !c read data
    call gms_mesh_read(trim(strfile_gms))
    call gms_mesh_set_layers(39)

    do i = 1, 39
      call gms_mesh_read_layer(i, trim(strfile_layer(i)))
    end do


    !c output mesh to off format
    strfile_off1 = "example/domain_gms/top_NOAA_1234_7531_DEM_BATH_REGIONAL.off"
    strfile_off2 = "example/domain_gms/top_SURF_R1_1_01_Hamilton_Gp.off"
    strfile_off3 = "example/domain_gms/top_SURF_R1_1_02_Dundee.off"
    write(*,*) "gms mesh domain test: output to separated off mesh file"
    call gms_mesh_output(1, 2, strfile_off1, "off", 1.0d0)
    call gms_mesh_output(2, 3, strfile_off2, "off", 1.0d0)
    call gms_mesh_output(3, 4, strfile_off3, "off", 1.0d0)

    !c output mesh to msh format
    strfile_msh = "example/domain_gms/grid_R3.msh"
    write(*,*) "gms mesh domain test: output to global msh mesh file"
    call gms_mesh_output(1, 4, strfile_msh, "msh", 50.0d0)


#ifdef CGAL
    !c triangulation the mesh and output
    strfile_tri_msh = "example/domain_gms/grid_R3_tri.msh"
    write(*,*) "gms mesh domain triangulation test: output to global msh mesh file"
    call gms_mesh_triangulation_prism(1, 39, strfile_tri_msh, "msh", 1.0d0)
#endif

    !c free data space
    call gms_mesh_free_data

  end subroutine gms_mesh_test

end module  gms_mesh_domain

