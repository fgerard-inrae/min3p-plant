!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/geometry.F90 $
!---------------------------------------------------------------------
!********************************************************************!


! --------------------------------------------------------------------
!> Module of geometry functions
!>
!> Module description: Basic functions for calculate geometry features
!>    such as area, volume, normal vector and etc.
!>    Currently support triangle, quadrilateral, tetrahedral, hexahedral and prism
!>
!> Written by:    Danyang Su - Jul. 29, 2016
!>
!> Last modified:
!>
! --------------------------------------------------------------------
module geometry

  use geometry_definition

  use math_common

  use parm

  implicit none

  interface geometry_veclength
    module procedure geometry_veclength_2d
    module procedure geometry_veclength_3d
    module procedure geometry_veclength_3d_2
    module procedure geometry_veclength_3d_ex
  end interface

  interface geometry_normal
    module procedure geometry_normal_2d
    module procedure geometry_normal_3d
  end interface

  contains

  !>
  !> return vector length
  !>
  function geometry_veclength_3d(a) result(length)

    implicit none

    type(point), intent(in) :: a

    real*8 :: length

    length = sqrt(a%x**2 + a%y**2 + a%z**2)

  end function geometry_veclength_3d

  !>
  !> return length of two point
  !>
  function geometry_veclength_3d_2(a,b) result(length)

    implicit none

    type(point), intent(in) :: a,b

    real*8 :: length

    length = geometry_veclength_3d(b-a)

  end function geometry_veclength_3d_2

  !>
  !> return effective vector a length projected to vector b
  !> or throughout of vector b, b is treated as unit vector
  !> itype = 1, projection (a dot b cos(alpha))
  !>       = 2, throughout (a dot b sin(alpha))
  !>
  function geometry_veclength_3d_ex(a,b,itype) result(length)

    implicit none

    type(point), intent(in) :: a,b
    integer :: itype

    real*8 :: angle, length

    angle = geometry_angle(a, b)

    length = sqrt(a%x**2 + a%y**2 + a%z**2)

    if (itype == 1) then
      length = length * abs(cos(angle))
    else if (itype == 2) then
      length = length * abs(sin(angle))
    end if

  end function geometry_veclength_3d_ex

  !>
  !> return vector length
  !>
  function geometry_veclength_2d(a,iplane) result(length)

    implicit none

    type(point), intent(in) :: a
    integer, intent(in) :: iplane

    real*8 :: length

    length = 0.0d0

    if(iplane == projection_xy) then
      length = sqrt(a%x**2 + a%y**2)
    else if (iplane == projection_yz) then
      length = sqrt(a%y**2 + a%z**2)
    else if (iplane == projection_xz) then
      length = sqrt(a%x**2 + a%z**2)
    end if

  end function geometry_veclength_2d

  !>
  !> return the outward normal of 2d vector pt1-pt2
  !>
  function geometry_normal_2d(pt1,pt2,iplane,bunit) result(normal)

    implicit none

    type(point), intent(in) :: pt1,pt2
    integer, intent(in) :: iplane
    type(point) :: normal
    logical, intent(in), optional :: bunit
    real*8 ::lenvector
    real*8, parameter ::rsmall = 1.0d-12

    call math_common_zero_vec(normal)

    lenvector = geometry_veclength(pt1-pt2)
    if (lenvector < rsmall) then
      return
    end if

    if(iplane == projection_xy) then
      normal%x = pt2%y-pt1%y
      normal%y = pt1%x-pt2%x
    else if(iplane == projection_yz) then
      normal%y = pt2%z-pt1%z
      normal%z = pt1%y-pt2%y
    else if(iplane == projection_xz) then
      !normal%x = pt2%z-pt1%z
      !normal%z = pt1%x-pt2%x

      normal%z = pt2%x-pt1%x
      normal%x = pt1%z-pt2%z
    end if

    if(present(bunit)) then
      if(bunit) then
        normal = normal / geometry_veclength(normal)
      end if
    end if

  end function geometry_normal_2d

  !>
  !> return the outward normal of a polygon
  !>
  function geometry_normal_3d(n,pts,bunit) result(normal)

    implicit none

    integer, intent(in) :: n
    type(point), intent(in) :: pts(n)
    type(point) :: normal
    logical, intent(in), optional :: bunit
    type(point) :: a, b, c
    integer :: i
    real*8 ::lenvector
    real*8, parameter ::rsmall = 1.0d-12

    call math_common_zero_vec(normal)

    lenvector = 0.0d0
    do i = 1, n-1
      lenvector = lenvector + geometry_veclength(pts(i+1)-pts(i))
    end do
    if (lenvector < rsmall) then
      return
    end if

    if (n == 3) then
      normal = (pts(2)-pts(1)).cross.(pts(3)-pts(1))
    else if (n == 4) then
      normal%x = (pts(3)%y-pts(1)%y)*(pts(4)%z-pts(2)%z) +            &
                 (pts(3)%z-pts(1)%z)*(pts(2)%y-pts(4)%y)
      normal%y = (pts(3)%z-pts(1)%z)*(pts(4)%x-pts(2)%x) +            &
                 (pts(3)%x-pts(1)%x)*(pts(2)%z-pts(4)%z)
      normal%z = (pts(3)%x-pts(1)%x)*(pts(4)%y-pts(2)%y) +            &
                 (pts(3)%y-pts(1)%y)*(pts(2)%x-pts(4)%x)
    else if (n > 4) then
      b = pts(n-1)
      c = pts(n)
      do i = 1, n
        a = b
        b = c
        c = pts(i)
        normal%x = normal%x + b%y*(c%z-a%z)
        normal%y = normal%y + b%z*(c%x-a%x)
        normal%z = normal%z + b%x*(c%y-a%y)
      end do
    end if

    if(present(bunit)) then
      if(bunit) then
        normal = normal / geometry_veclength(normal)
      end if
    end if

  end function geometry_normal_3d

  !>
  !> return rotation matrix
  !> rotation whose yaw, pitch, and roll angles are α, β and γ, respectively
  !> reference: https://en.wikipedia.org/wiki/Euler_angles
  !>            https://en.wikipedia.org/wiki/Rotation_matrix
  !> Kr = rml dot K dot rmr where rml is the left rotation matrix, 
  !> rmr is the right rotation matrix. rmr = rml^T
  !> Suppose K is the tensor before rotation and Kr is the tensor after rotation,
  !> we have Kr = (rml dot K ) dot (rmr)
  !>
  subroutine geometry_cal_rotation_matrix(angle,rml,rmr)

    implicit none

    type(point), intent(in) :: angle       !Tait-Bryan angle
    type(tensor), intent(inout) :: rml     !Rotation matrix left
    type(tensor), intent(inout) :: rmr     !Rotation matrix right

    !c local variables
    real*8 :: alpha, beta, gamma

    alpha = angle%z
    beta = angle%y
    gamma = angle%x

    rml%xx = cos(alpha)*cos(beta)
    rml%xy = cos(alpha)*sin(beta)*sin(gamma)-cos(gamma)*sin(alpha)
    rml%xz = sin(alpha)*sin(gamma)+cos(alpha)*cos(gamma)*sin(beta)
    rml%yx = cos(beta)*sin(alpha)
    rml%yy = cos(alpha)*cos(gamma)+sin(alpha)*sin(beta)*sin(gamma)
    rml%yz = cos(gamma)*sin(alpha)*sin(beta)-cos(alpha)*sin(gamma)
    rml%zx = -sin(beta)
    rml%zy = cos(beta)*sin(gamma)
    rml%zz = cos(beta)*cos(gamma)

    rmr%xx = rml%xx
    rmr%xy = rml%yx
    rmr%xz = rml%zx
    rmr%yx = rml%xy
    rmr%yy = rml%yy
    rmr%yz = rml%zy
    rmr%zx = rml%xz
    rmr%zy = rml%yz
    rmr%zz = rml%zz

  end subroutine geometry_cal_rotation_matrix
  
  !>
  !> return the area of a polygon
  !>
  function geometry_area(n,pts) result(area)

    implicit none

    integer, intent(in) :: n
    type(point), intent(in) :: pts(n)
    real*8 :: area

    area = geometry_veclength(geometry_normal(n,pts))*0.5d0

  end function geometry_area


  !>
  !> calculate tetrahedral volume
  !>
  function geometry_tetra(n,pts) result(volume)

    implicit none

    integer, intent(in) :: n
    type(point), intent(in) :: pts(n)
    real*8 :: volume

    !c local variable
    integer :: i
    real*8 :: mat(4,4)

    volume = 0.0d0

    if(n == 4) then
      do i = 1, n
        mat(1,i)=pts(i)%x
        mat(2,i)=pts(i)%y
        mat(3,i)=pts(i)%z
        mat(4,i)=1.0d0
      end do
      volume = abs(math_common_determinant(mat))/6.0d0
    else
      write(*,*) "Error: volume calculation is not supported by tetra"
    end if

  end function geometry_tetra

  !>
  !> calculate prism volume
  !>
  function geometry_prism(n,pts) result(volume)

    implicit none

    integer, intent(in) :: n
    type(point), intent(in) :: pts(n)
    real*8 :: volume

    !c local variable
    integer :: i

    volume = 0.0d0
    if(n == 6) then
      volume = geometry_tetra(4,pts(1:4)) +    &
               geometry_tetra(4,pts(2:5)) +    &
               geometry_tetra(4,pts(3:6))
    else
      write(*,*) "Error: volume calculation is not supported by prism"
    end if

  end function geometry_prism

  !>
  !> calculate prism volume
  !>
  function geometry_hexa(n,pts) result(volume)

    implicit none

    integer, intent(in) :: n
    type(point), intent(in) :: pts(n)
    real*8 :: volume

    !c local variable
    integer :: i
    type(point) :: pts6(6)

    volume = 0.0d0
    if(n == 8) then
      pts6(1:6) = (/pts(1),pts(2),pts(3),pts(5),pts(6),pts(7)/)
      volume = volume + geometry_prism(6,pts6)

      pts6(1:6) = (/pts(1),pts(3),pts(4),pts(5),pts(7),pts(8)/)
      volume = volume + geometry_prism(6,pts6)
    else
      write(*,*) "Error: volume calculation is not supported by hexa"
    end if

  end function geometry_hexa

  !>
  !> calculate object volume
  !>
  function geometry_volume(n,pts) result(volume)

    implicit none
    integer, intent(in) :: n
    type(point), intent(in) :: pts(n)
    real*8 :: volume

    volume = 0.0d0

    if (n == 4) then                      !tetra
      volume = geometry_tetra(n,pts)
    else if (n == 6) then                 !prism, divide into 3 prism
      volume = geometry_prism(n,pts)
    else if (n == 8) then
      volume = geometry_hexa(n,pts)
    else
      write(*,*) "Error: volume calculation is not supported"
    end if

  end function geometry_volume

  !>
  !> return the angle of two vector in radians
  !>
  function geometry_angle(pt1, pt2) result(angle)

    implicit none

    type(point), intent(in) :: pt1, pt2
    real*8 :: angle

    real*8, parameter ::rsmall = 1.0d-12, pi=3.14159265359d0

    angle = acos(geometry_vector_cos(pt1,pt2))

  end function geometry_angle

  !>
  !> return the cosine value of two vectors
  !>
  function geometry_vector_cos(pt1, pt2, bflag) result(vec_cos)

    implicit none

    type(point), intent(in) :: pt1, pt2
    logical, intent(in), optional :: bflag
    real*8 :: vec_cos

    !c local variable
    logical :: b_samepoint_zero
    real*8 ::len1, len2
    real*8, parameter ::rsmall = 1.0d-12, pi=3.14159265359d0

    if (present(bflag)) then
      b_samepoint_zero = bflag
    else
      b_samepoint_zero = .true.
    end if

    len1 = geometry_veclength(pt1)
    len2 = geometry_veclength(pt2)

    if (len1 < rsmall .or. len2 < rsmall) then
      if (b_samepoint_zero) then
        vec_cos = 0.0d0
      else
        vec_cos = 1.0d0
      end if
    else
      vec_cos = (pt1.dot.pt2)/(geometry_veclength(pt1)*             &
                               geometry_veclength(pt2))
    end if

  end function geometry_vector_cos

  !>
  !> return the circumcircle center of a triangle
  !> Barycentric coordinates from cross- and dot-products
  !> ref: http://math.wikia.com/wiki/Circumscribed_circle
  !>
  function geometry_circumcircle_center(pt1, pt2, pt3) result(pt0)

    implicit none

    type(point), intent(in) :: pt1, pt2, pt3
    type(point) :: pt0

    real*8 :: r, a, b, c, divid

    divid = geometry_veclength((pt1-pt2).cross.(pt2-pt3))

    r = (geometry_veclength(pt1-pt2)*geometry_veclength(pt2-pt3)*      &
         geometry_veclength(pt3-pt1))/divid/2.0d0


    a = (geometry_veclength(pt2-pt3))**2*((pt1-pt2).dot.(pt1-pt3))/    &
         divid**2/2.0d0

    b = (geometry_veclength(pt1-pt3))**2*((pt2-pt1).dot.(pt2-pt3))/    &
         divid**2/2.0d0

    c = (geometry_veclength(pt1-pt2))**2*((pt3-pt1).dot.(pt3-pt2))/    &
         divid**2/2.0d0

    pt0 = pt1*a + pt2*b + pt3*c

  end function geometry_circumcircle_center



  !>
  !> return the circumsphere center of a given tetrahedral
  !> solve matrix equation method (Cramer's rule)
  !> ref: http://mathworld.wolfram.com/Circumsphere.html
  !>
  function geometry_circumsphere_center(pt1, pt2, pt3, pt4) result(pt0)

    implicit none

    type(point), intent(in) :: pt1, pt2, pt3, pt4
    type(point) :: pt0

    !c local variables
    real*8 :: mat(4,4), mat2(4,4)
    real*8 :: a, l1, l2, l3, l4, Dx, Dy, Dz

    mat(1,1) = pt1%x
    mat(2,1) = pt2%x
    mat(3,1) = pt3%x
    mat(4,1) = pt4%x
    mat(1,2) = pt1%y
    mat(2,2) = pt2%y
    mat(3,2) = pt3%y
    mat(4,2) = pt4%y
    mat(1,3) = pt1%z
    mat(2,3) = pt2%z
    mat(3,3) = pt3%z
    mat(4,3) = pt4%z
    mat(1,4) = 1.0d0
    mat(2,4) = 1.0d0
    mat(3,4) = 1.0d0
    mat(4,4) = 1.0d0

    a = math_common_determinant(mat)

    l1 = geometry_veclength_3d(pt1)
    l2 = geometry_veclength_3d(pt2)
    l3 = geometry_veclength_3d(pt3)
    l4 = geometry_veclength_3d(pt4)

    mat2 = mat
    mat2(1,1) = l1**2
    mat2(2,1) = l2**2
    mat2(3,1) = l3**2
    mat2(4,1) = l4**2
    Dx = math_common_determinant(mat2)

    mat2(1,2) = pt1%x
    mat2(2,2) = pt2%x
    mat2(3,2) = pt3%x
    mat2(4,2) = pt4%x
    Dy = -math_common_determinant(mat2)

    mat2(1,3) = pt1%y
    mat2(2,3) = pt2%y
    mat2(3,3) = pt3%y
    mat2(4,3) = pt4%y
    Dz = math_common_determinant(mat2)

    pt0%x = Dx/2.0d0/a
    pt0%y = Dy/2.0d0/a
    pt0%z = Dz/2.0d0/a

  end function geometry_circumsphere_center

  !>
  !> check if vector vb is inside vector va and vc
  !> note: va to vc is in counterclockwise and angle from
  !> va to vc should be less than PI
  !>
  function geometry_vector_inside(vb, va, vc) result(bflag)

    implicit none

    type(point), intent(in) :: va, vb, vc

    logical :: bflag

    !c method 1: check by vector angle, not efficient due
    !real*8 :: deltangle
    !real*8, parameter :: rsmall = 1.0d-6
    !bflag = .false.
    !deltangle = geometry_angle(va,vb) + geometry_angle(vb,vc) -        &
    !            geometry_angle(va,vc)
    !if (abs(deltangle) < rsmall) then
    !  bflag = .true.
    !end if

    !c method 2: vecor cross product and dot product
    bflag = .false.

    if(((va.cross.vb).dot.(va.cross.vc)) >= 0 .and. &
       ((vc.cross.vb).dot.(vc.cross.va)) >= 0) then
      bflag = .true.
    end if

  end function geometry_vector_inside

  !>
  !> check if the two points are the same
  !>
  function geometry_points_same(pt0, pt1) result(bflag)

    implicit none

    type(point), intent(in) :: pt0, pt1

    logical :: bflag

    !c local variable
    type(point) :: pt
    real*8, parameter :: rverysmall = 1.0d-12

    pt = pt1 - pt0
    if ((pt%x**2 + pt%y**2 + pt%z**2) < rverysmall) then
      bflag = .true.
    else
      bflag = .false.
    end if

  end function geometry_points_same

  !>
  !> check if four points lie on the same plane in 3D
  !>
  function geometry_points_coplanar(pt0, pt1, pt2, pt3) result(bflag)

    implicit none

    type(point), intent(in) :: pt0, pt1, pt2, pt3

    logical :: bflag

    !c local variable
    type(point) :: pt01, pt02, pt03
    real*8, parameter :: rverysmall = 1.0d-12

    !c first check if pt0, pt1, pt2 are in the same location
    if (geometry_points_same(pt0, pt1) .or. geometry_points_same(pt0, pt2)) then
      bflag = .true.
      return
    end if

    pt01 = pt1 - pt0
    pt02 = pt2 - pt0
    pt03 = pt3 - pt0

    if (abs(pt03 .dot. (pt02 .cross. pt01)) < rverysmall) then
      bflag = .true.
    else
      bflag = .false.
    end if

  end function geometry_points_coplanar

  !>
  !> Calculate the distance of a point to line segment.
  !> When the projection of point to line segment is not inside the line segment,
  !> the distance is calculated based on the point and closest point in line segment.
  !> Works for both 2D and 3D.
  !>
  function geometry_point_to_line(pt,pt1,pt2,ext1,ext2) result(dist)

    implicit none 

    type(point), intent(in) :: pt, pt1, pt2     !point P, A, B
    logical, intent(in), optional :: ext1, ext2 !consider sphere extension of BA or AB
    real*8 :: dist 

    !c local variables
    real*8 :: dx, dy, dz, dx1, dy1, dz1, dx21, dy21, dz21, dot,        &
              len_sq, param, xx, yy, zz
    logical :: flag_ext1, flag_ext2
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rlarge = 1.0d300

    if (present(ext1)) then
      flag_ext1 = ext1
    else
      flag_ext1 = .true.
    end if

    if (present(ext2)) then
      flag_ext2 = ext2
    else
      flag_ext2 = .true.
    end if

    !c vector of AP
    dx1 = pt%x - pt1%x
    dy1 = pt%y - pt1%y
    dz1 = pt%z - pt1%z

    !c vector of AB
    dx21 = pt2%x - pt1%x
    dy21 = pt2%y - pt1%y
    dz21 = pt2%z - pt1%z


    !c calculate r=(AP•AB)/(|AB|^2), 
    !c when r < r0, projection of P to AB is at the extended line of BA,
    !c when r > r1, projection of P to AB is at the extended line of AB,
    !c when r0 <= r <= r1, projection of P to AB is between AB

    dot = dx1*dx21 + dy1*dy21 + dz1*dz21
    len_sq = dx21*dx21 + dy21*dy21 + dz21*dz21

    if (len_sq == r0) then 
      dist = sqrt(dx1*dx1 + dy1*dy1 + dz1*dz1)
      return
    end if

    param = dot/len_sq

    if (param < r0) then         !closest point is pt1
      if (flag_ext1) then
        xx = pt1%x
        yy = pt1%y
        zz = pt1%z
      else
        dist = rlarge
        return
      end if
    else if (param > r1) then    !closest point is pt2
      if (flag_ext2) then
        xx = pt2%x
        yy = pt2%y
        zz = pt2%z
      else
        dist = rlarge
        return
      end if
    else                         !between pt1 and pt2
      xx = pt1%x + param*dx21
      yy = pt1%y + param*dy21
      zz = pt1%z + param*dz21
    end if

    dx = pt%x - xx
    dy = pt%y - yy
    dz = pt%z - zz

    dist = sqrt(dx*dx + dy*dy + dz*dz)

  end function geometry_point_to_line

    !>
  !> get coordinates of intersection between two line in 2D space
  !> based on Line–line intersection wikipedia
  !> https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
  !>
  function geometry_line_line_intersect(iplane, pt0, pt1, pt2, pt3) result(pt)

    implicit none

    integer, intent(in) :: iplane

    type(point), intent(in) :: pt0, pt1, pt2, pt3

    type(point) :: pt

    !c local variables
    real*8 :: x0, x1, x2, x3, y0, y1, y2, y3,  x01, x23, y01, y23,     &
              det, a, b, x, y
    real*8, parameter :: r0 = 0.0d0

    if(iplane == projection_xy) then
      x0 = pt0%x
      x1 = pt1%x
      x2 = pt2%x
      x3 = pt3%x

      y0 = pt0%y
      y1 = pt1%y
      y2 = pt2%y
      y3 = pt3%y
    else if(iplane == projection_yz) then
      x0 = pt0%y
      x1 = pt1%y
      x2 = pt2%y
      x3 = pt3%y

      y0 = pt0%z
      y1 = pt1%z
      y2 = pt2%z
      y3 = pt3%z
    else if(iplane == projection_xz) then
      x0 = pt0%x
      x1 = pt1%x
      x2 = pt2%x
      x3 = pt3%x

      y0 = pt0%z
      y1 = pt1%z
      y2 = pt2%z
      y3 = pt3%z
    end if

    x01 = x0 - x1
    x23 = x2 - x3
    y01 = y0 - y1
    y23 = y2 - y3

    det = x01 * y23 - y01 * x23

    if (det /= r0) then
      a = x0 * y1 - y0 * x1
      b = x2 * y3 - y2 * x3

      x = (a * x23 - b * x01) / det
      y = (a * y23 - b * y01) / det

      if(iplane == projection_xy) then
        pt%x = x
        pt%y = y
        pt%z = r0
      else if(iplane == projection_yz) then
        pt%x = r0
        pt%y = x
        pt%z = y
      else if(iplane == projection_xz) then
        pt%x = x
        pt%y = r0
        pt%z = y
      end if
    else
      pt%x = -1.0E30
      pt%y = -1.0E30
      pt%z = -1.0E30
    end if


  end function geometry_line_line_intersect

  !>
  !> get coordinates of intersection between a plane and a straight line in 3D
  !> based on PythonCaller Script Example (Python 2.7 only)
  !> Create the intersection point between a plane containing the first three vertices
  !> of 3D polygon and a straight line containing the first segment of 3D line.
  !> Note: The resulting intersection could be outside of the source polygon
  !> and/or the source line segment.
  !> https://knowledge.safe.com/questions/44216/
  !> intersection-point-between-3d-line-and-3d-polygon-1.html
  !>
  function geometry_line_plane_intersect(ppt0, ppt1, ppt2, lpt0, lpt1) result(pt)

    implicit none

    type(point), intent(in) :: ppt0, ppt1, ppt2, lpt0, lpt1

    type(point) :: pt

    !c local variables
    real*8 :: x0, y0, z0, x1, y1, z1, nx, ny, nz, vx, vy, vz, d, t
    real*8, parameter :: r0 = 0.0d0

    !c Normal vector of the plane.
    x0 = ppt1%x - ppt0%x
    y0 = ppt1%y - ppt0%y
    z0 = ppt1%z - ppt0%z

    x1 = ppt2%x - ppt0%x
    y1 = ppt2%y - ppt0%y
    z1 = ppt2%z - ppt0%z

    nx = y0 * z1 - z0 * y1
    ny = z0 * x1 - x0 * z1
    nz = x0 * y1 - y0 * x1

    !c Direction (vector) of the line.
    vx = lpt1%x - lpt0%x
    vy = lpt1%y - lpt0%y
    vz = lpt1%z - lpt0%z

    !c Calculate coordinates of the intersection.
    d = nx * vx + ny * vy + nz * vz
    if (d /= r0) then
      t = (nx * (ppt0%x- lpt0%x) + ny * (ppt0%y- lpt0%y) + nz * (ppt0%z- lpt0%z)) / d
      pt%x = lpt0%x + vx * t
      pt%y = lpt0%y + vy * t
      pt%z = lpt0%z + vz * t
    else
      pt%x = -1.0E30
      pt%y = -1.0E30
      pt%z = -1.0E30
    end if

  end function geometry_line_plane_intersect

  !>
  !> check if cell-node ordering obey RHT rule for 2D plane in 3D space
  !>
  function geometry_isCounterClockwise(n,pts,iplane) result(iflag)

    implicit none
    integer, intent(in) :: n, iplane
    type(point), intent(in) :: pts(n)
    logical :: iflag

    real*8 :: area, area2, x1, y1, x2, y2, x3, y3

    iflag = .false.

    if (n == 3) then
      if (iplane == projection_xy) then
        x1 = pts(1)%x
        y1 = pts(1)%y
        x2 = pts(2)%x
        y2 = pts(2)%y
        x3 = pts(3)%x
        y3 = pts(3)%y
      else if (iplane == projection_yz) then
        x1 = pts(1)%y
        y1 = pts(1)%z
        x2 = pts(2)%y
        y2 = pts(2)%z
        x3 = pts(3)%y
        y3 = pts(3)%z
      else if (iplane == projection_xz) then
        x1 = pts(1)%z
        y1 = pts(1)%x
        x2 = pts(2)%z
        y2 = pts(2)%x
        x3 = pts(3)%z
        y3 = pts(3)%x
      end if

      area = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))*0.5

      if (area >= 0.0d0) then
        iflag = .true.
      else
        iflag = .false.
      end if

    else if (n == 4) then
      if (iplane == projection_xy) then
        x1 = pts(1)%x
        y1 = pts(1)%y
        x2 = pts(2)%x
        y2 = pts(2)%y
        x3 = pts(3)%x
        y3 = pts(3)%y
      else if (iplane == projection_yz) then
        x1 = pts(1)%y
        y1 = pts(1)%z
        x2 = pts(2)%y
        y2 = pts(2)%z
        x3 = pts(3)%y
        y3 = pts(3)%z
      else if (iplane == projection_xz) then
        x1 = pts(1)%z
        y1 = pts(1)%x
        x2 = pts(2)%z
        y2 = pts(2)%x
        x3 = pts(3)%z
        y3 = pts(3)%x
      end if

      area = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))*0.5

      if (iplane == projection_xy) then
        x3 = pts(4)%x
        y3 = pts(4)%y
      else if (iplane == projection_yz) then
        x3 = pts(4)%y
        y3 = pts(4)%z
      else if (iplane == projection_xz) then
        x3 = pts(4)%z
        y3 = pts(4)%x
      end if

      area2 = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))*0.5

      if (area >= 0.0d0 .and. area2 >= 0.0d0) then
        iflag = .true.
      else
        iflag = .false.
      end if
    end if


  end function geometry_isCounterClockwise

#ifdef CGAL
  !>
  !> check if a polygon is simple
  !>   check if a given set of points can construct a simple polygon in the specified projection.
  !>   In geometry a simple polygon is defined as a flat shape consisting of straight,
  !>   non-intersecting line segments or "sides" that are joined pair-wise to form a closed path.
  !> Passing parameters
  !>   ixyz   = 1, projection xy
  !>          = 2, projection yz
  !>          = 3, projection xz
  !>   n      = number of points in the given points set
  !>   pts    = points set array
  !>   bflag  = true if simple polygon and false if not.
  !>
  function geometry_is_polygon_simple(ixyz, n, pts) result(bflag)

    use cgal_polygon_iface, only : cgal_is_polygon_simple

    implicit none

    !c passing parameters
    integer :: ixyz,n
    type(point),allocatable :: pts(:)
    logical :: bflag

    !c local variable
    integer :: i
    type(point3d_c) :: pts_c(n)
    do i = 1, n
      pts_c(i)%x = pts(i)%x
      pts_c(i)%y = pts(i)%y
      pts_c(i)%z = pts(i)%z
    end do

    bflag = cgal_is_polygon_simple(ixyz, n, pts_c)

  end function geometry_is_polygon_simple

  !>
  !>   check if a given point is inside a simple polygon.
  !> Passing parameters
  !>   ixyz   = 1, projection xy
  !>          = 2, projection yz
  !>          = 3, projection xz
  !>   n      = number of points in the given points set
  !>   pts    = points set array
  !>   buf    = distance buffer
  !>   iflag  = -1, outside of the polygon boundary
  !>          =  0, on the polygon boundary
  !>          =  1, inside of the polygon boundary
  !>
  function geometry_is_point_inside_2d(ixyz,pt,n,pts,buf) result(iflag)

    use cgal_polygon_iface, only : cgal_check_inside

    implicit none

    !c passing parameters
    integer :: ixyz,n
    type(point) :: pt
    type(point),allocatable :: pts(:)
    real*8 :: buf

    integer :: iflag

    !c local variable
    integer :: i
    type(point3d_c) :: pt_c
    type(point3d_c) :: pts_c(n)

    pt_c%x = pt%x
    pt_c%y = pt%y
    pt_c%z = pt%z

    do i = 1, n
      pts_c(i)%x = pts(i)%x
      pts_c(i)%y = pts(i)%y
      pts_c(i)%z = pts(i)%z
    end do

    iflag = cgal_check_inside(ixyz,pt_c,n,pts_c)

  end function geometry_is_point_inside_2d
#else
  !>
  !> Check if a given point is inside a simple polygon use scanning ray method.
  !>   The default method will yes or no result if the node is on the edge.
  !>
  !> Passing parameters
  !>   ixyz   = 1, projection xy
  !>          = 2, projection yz
  !>          = 3, projection xz
  !>   n      = number of points in the given points set
  !>   pts    = points set array
  !>   iflag  = -1, outside of the polygon boundary
  !>          =  0, on the polygon boundary
  !>          =  1, inside of the polygon boundary
  !>
  function geometry_is_point_inside_2d(ixyz,pt,n,pts,buf) result(iflag)

    implicit none

    !c passing parameters
    integer :: ixyz,n
    type(point) :: pt
    type(point),allocatable :: pts(:)
    real*8 :: buf

    integer :: iflag

    !c local variable
    integer :: i, j
    real*8 :: dist

    iflag = -1

    !c first check if the node is same as polygon vertex
    do i = 1, n
      if(geometry_points_same(pt, pts(i))) then
        iflag = 0
        return
      end if
    end do

    !c second check if the node is on the edge by comparing the distance to the vector
    do i = 1, n
      j = mod(i,n)+1
      dist = geometry_point_to_line(pt, pts(i), pts(j))
      if (dist <= buf) then
        iflag = 0
        return
      end if
    end do

    !c finally check if the node is inside or outside of the polygon
    do i = 1, n
      j = mod(i,n)+1
      if (ixyz == projection_xy) then
        if (((pts(i)%y <= pt%y .and. pt%y < pts(j)%y) .or.             &
             (pts(j)%y <= pt%y .and. pt%y < pts(i)%y)) .and.           &
             (pt%x < (pts(j)%x - pts(i)%x) * (pt%y - pts(i)%y) /       &
             (pts(j)%y - pts(i)%y) + pts(i)%x)) then
          iflag = -iflag
        end if
      else if (ixyz == projection_yz) then
        if (((pts(i)%z <= pt%z .and. pt%z < pts(j)%z) .or.             &
             (pts(j)%z <= pt%z .and. pt%z < pts(i)%z)) .and.           &
             (pt%y < (pts(j)%y - pts(i)%y) * (pt%z - pts(i)%z) /       &
             (pts(j)%z - pts(i)%z) + pts(i)%y)) then
          iflag = -iflag
        end if
      else if (ixyz == projection_xz) then
        if (((pts(i)%x <= pt%x .and. pt%x < pts(j)%x) .or.             &
             (pts(j)%x <= pt%x .and. pt%x < pts(i)%x)) .and.           &
             (pt%z < (pts(j)%z - pts(i)%z) * (pt%x - pts(i)%x) /       &
             (pts(j)%x - pts(i)%x) + pts(i)%z)) then
          iflag = -iflag
        end if
      end if
    end do

    return

  end function geometry_is_point_inside_2d

#endif

end module geometry
