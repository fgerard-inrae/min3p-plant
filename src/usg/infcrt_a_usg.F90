!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/infcrt_a_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine infcrt_a
!c -------------------
!c
!c compute influence coefficients for advective and dispersive flux 
!c terms for rectangular, cartesian finite volume discretization 
!c (reactive transport) for aqueous phase
!c
!c from Uli Mayer's template
!c
!c written by:      Danyang Su - Aug 04, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c     input:
!c
!c passed:   real*8:
!c           -------
!c           integer*4:
!c           ----------
!c           idbg               = output for debugging information
!c           ilog               = unit number, logbook
!c           nngl               = max cells for dim purposes
!c           nphas              = max number of phases
!c           njavs             = max dim ja array (ncomp.com)
!c           pornew(ibk)        = porosity
!c           sanew(nngl)        = aqueous phase saturation
!c                                - new time level
!c           hhead(nngl)        = hydraulic head
!c           uvsnew(nngl)       = hydraulic pressure
!c           relperm(nngl)      = rel permeability
!c           cinfvs(nngl)       = influence coefficient
!c                                (variably saturated flow) 
!c           ia(), ja()         = ysmp pointers
!c           isymm(ii)          = symmetry pointer for cell ibk
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions
!c           variably_saturated = .true.  -> .not.fully_saturated,
!c                                        -> variably saturated
!c                                           conditions
!c           tortuosity_corr    = .true.  -> Millington-Quirk 
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c multidiff.f90
!c           logical:
!c           --------
!c         multi_diff = .true. -> multicomponent diffusion (MCD)
!c local:
!c
!c external: diffcoff   = compute effective diffusion coefficient
!c           fluxfs_usg = flux function for fully saturated flow
!c           fluxvs_usg = flux function for variably saturated flow
!c --------------------------------------------------------------------------
#ifdef USG
      subroutine infcrt_a_usg

#ifdef OPENMP      
      use omp_lib 
#endif
      use gen, only :                                                  &
#ifdef OPENMP
                     numofthreads_global,                              &
                     numofloops_thred_global,                          &
                     numofloops_thred_infcrt_a_1,                      &
                     numofloops_thred_infcrt_a_2,                      &
                     numofloops_thred_infcrt_a_3,                      &
#endif
                     iavs, javs, isymvs, cinfvs_a, cinfrt_va_usg,      &
                     cinfrt_da,  pornew, sanew, uvsnew, hhead, relperm,&
                     upstream, fully_saturated, variably_saturated,    &
                     diff_ic, diff_ic_tensor, type_diff_ic_coeff,      &
                     type_diff_coeff, type_disp_coeff, type_cond_perm, &
                     useAnisoTauCorr, useAnisoDispCorr,                &
                     useAnisoCondCorr, tau, tau_fac, assigned_tau,     &
                     marchies, nngl, njavs, tortuosity_corr,           &
                     mpropvs, mpropvs_cell, jacrossdiffweight,         &                     
                     b_use_fixed_flow_vel, fixed_flow_vel,             &
                     diff_coff, type_tortuosity, harmonic_porosity,    &
                     type_averaging_De, sonew, discretization_type,    &
                     jacell, janumcell, jaedgelen, jagradweight,       &
                     jaedgeunitdirection, jacrossdifficv,              &
                     jacrossdifficvnum,b_grad_interpolate_cell,        &
                     tor_corr_a_mq,tor_corr_b_mq, b_water_freezing,    &
                     num_crossdifficv_max, tkel,                       &
                     idbg, ilog, rank, b_enable_output
      use phys, only : disx, disy, disz, diff_a, is_cell_based_disp_rt,&
                       atc_zone, aca_vol, is_cell_based_relp,          &
                       frozen_diff_a, diff_a_tensor
      use chem, only : nc
      use multidiff, only : multi_diff
      use mod_diffcoff, only : diffcoff
      use mod_fluxvs_usg
      use mod_fluxfs_usg

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use geometry

      use math_common, only : math_common_harmonic

      use usg_mesh_data, only : nodes, cells, cell_type,               &
                                num_edge_dvols, num_edge_maxcells,     &
                                num_cells, num_edges_per_cell,         &
                                CellCvolFaceArea,                      &
                                CellCvolFaceUnitNorm,                  &
                                CellCvolFace_cond,                     &
                                CellCvolFace_cond_tensor,              &
                                CellCvolFace_disp_da,                  &
                                CellCvolFace_disp_da_tensor,           &
                                CellCvolFace_disp_da_ic,               &
                                CellCvolFace_disp_da_ic_tensor,        &
                                CellCvolFace_adv,                      &
                                get_cell_edge_cvol_id

      use usg_face_utility, only : usg_face_utility_cinfvs,            &
                                   usg_face_utility_vel_flow
      use gradient_usg, only : gradient_cross_diff

      implicit none
      
      integer :: info_debug

!c    local variables
      real*8 :: diff_eff1, diff_eff2
      real*8, parameter :: eps = 1.0d-300, r0 = 0.0d0, rhalf = 0.5d0,  &
              r1 = 1.0d0, r2 = 2.0d0, r3 = 3.0d0, rsmallarea = 1.0d-8, &
              rverysmall = 1.0d-100, pi = 3.141592653589793d0

      real*8 :: porav, satav, vmag, diffav, diff_eff, disx_avg,        &
                disy_avg, disz_avg, disxy_avg, disxz_avg, disyz_avg,   &
                tauav, marchieav, so_av, diff_i, diff_j, diff_ij,      &
                areaf, por_i, por_j, tau_i, tau_j, por1, por2

      type(tensor) :: diffav_tensor, diff_eff_tensor,                  &
                      diff_eff1_tensor, diff_eff2_tensor,              &
                      diff_i_tensor, diff_j_tensor,                    &
                      diff_ij_tensor, temptensor

      integer :: i, i2, icell, istart, iend, ii, id, ic, ivol, idvol,  &
                 jvol, jtemp1, icell1, k, icell2, jtemp2, iedge,       &
                 kvol, idvol_r, iedge_r, izn, jzn, ndvol
      type(point) :: vel, vxyz2, tend, cond, fnorm, atc_av, aca_av
      type(tensor) :: tenf, tenf_cond, rml, rmr

      real*8 :: cvolfacearea, rswitch

      character*1 :: iups
      real*8 :: flux_hls_corr(num_edge_dvols,num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      type(point) :: grad_locs(num_crossdifficv_max),                  &
                     grad_flow_mids(num_edge_dvols,num_edge_maxcells)

      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols)
      type(point) :: velsloc(num_edge_dvols)  
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: pressure_melt_k
      external :: pressure_melt_k

!c  compute influence coefficients for advective flux terms
!c  (influence coefficients are equal Darcy flux = J_ij/A_ij)


      ivol=0
      tau_i = r1
      tau_j = r1

!c  loop over control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_infcrt_a_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, icell1, icell2, idvol, idvol_r, iedge_r,     &
    !$omp istart, iend, iups, jtemp1, jvol, kvol, ndvol,              &
    !$omp cvolfacearea, cond, tenf_cond, fnorm,                       &
    !$omp flux_hls_corr, grad_flow_mids, grad_locs,                  &
    !$omp grad_flow_hls_loc, rswitch,                                 &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl

        istart = iavs(ivol)+1
        iend = iavs(ivol+1)-1

        do jtemp1 = istart, iend
          jvol = javs(jtemp1)

          cinfrt_va_usg(jtemp1) = r0

!c  consistent with upstream weighting
          if (upstream) then
            iups = 'i'                               !h_i >= h_j
            if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
              iups = 'j'
            end if
          end if

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
          grad_flow_mids = vector_zero
          flux_hls_corr = r0

          if (variably_saturated) then
            call gradient_cross_diff(jtemp1,ivol,jvol,hhead,grad_locs,   &
             grad_flow_mids,grad_weights,flux_hls_corr,grad_flow_hls_loc)
          else if (fully_saturated) then
            call gradient_cross_diff(jtemp1,ivol,jvol,uvsnew,grad_locs,  &
             grad_flow_mids,grad_weights,flux_hls_corr,grad_flow_hls_loc)
          end if          

!cdsu calculate influence coefficient for variable saturated flow
          call usg_face_utility_cinfvs(ivol,jvol,jtemp1,cinfvs_usg_loc,&
                                       cinfvs_usg_cross_loc)

!c  find darcy flux between node pair
          if (variably_saturated) then
            if (is_cell_based_relp) then
              do icell1 = 1, janumcell(jtemp1)
                icell2 = jacell(icell1,jtemp1)
                if (icell2 > 0) then
                  do idvol = 1, num_edge_dvols

                    call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2, &
                                               idvol_r,iedge_r,rswitch)
                    cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,   &
                                                    icell2)

                    if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                      tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
                    else if (type_cond_perm == 1) then
                      cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)                      
                    end if

                    if (cvolfacearea > rsmallarea) then
                      cinfrt_va_usg(jtemp1) = cinfrt_va_usg(jtemp1)                  &
                        - fluxvs_usg(upstream,hhead(ivol),hhead(jvol),1,1,           &
                                     grad_flow_mids(idvol:idvol,icell1:icell1),      &
                                     flux_hls_corr(idvol:idvol,icell1:icell1),       &
                                     .true.,1,relperm(icell2:icell2),                &
                                     iups,cinfvs_usg_loc(idvol:idvol,icell1:icell1), &
                                     cinfvs_usg_cross_loc(idvol:idvol,icell1:icell1))

                      if (rswitch > r0) then
                        fnorm = CellCvolFaceUnitNorm(idvol_r,iedge_r,  &
                                                     icell2)*rswitch
                      
                        if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                          CellCvolFace_adv(idvol_r,iedge_r,icell2) =   &
                            - fluxvs_vel_usg_tenf(upstream,.true.,1,   &
                                     relperm(icell2),iups,tenf_cond,   &
                                     grad_flow_mids(idvol,icell1),     &
                                     fnorm)
                        else if (type_cond_perm == 1) then
                          CellCvolFace_adv(idvol_r,iedge_r,icell2) =   &
                            - fluxvs_vel_usg_tend(upstream,.true.,1,   &
                                     relperm(icell2),iups,cond,        &
                                     grad_flow_mids(idvol,icell1),     &
                                     fnorm)
                        end if
                      end if

                    else

                      if (rswitch > r0) then
                        CellCvolFace_adv(idvol_r,iedge_r,icell2) = vector_zero
                      end if

                    end if
                  end do
                end if
              end do
            else
              do icell1 = 1, janumcell(jtemp1)
                icell2 = jacell(icell1,jtemp1)
                if (icell2 > 0) then
                  do idvol = 1, num_edge_dvols

                    call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2, &
                                               idvol_r,iedge_r,rswitch)
                    cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,   &
                                                    icell2)
                  
                    if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                      tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
                    else if (type_cond_perm == 1) then
                      cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
                    end if

                    if (cvolfacearea > rsmallarea) then
                      cinfrt_va_usg(jtemp1) = cinfrt_va_usg(jtemp1)                  &
                        - fluxvs_usg(upstream,hhead(ivol),hhead(jvol),1,1,           &
                                     grad_flow_mids(idvol:idvol,icell1:icell1),      &
                                     flux_hls_corr(idvol:idvol,icell1:icell1),       &
                                     .false.,2,(/relperm(ivol),relperm(jvol)/),      &
                                     iups,cinfvs_usg_loc(idvol:idvol,icell1:icell1), &
                                     cinfvs_usg_cross_loc(idvol:idvol,icell1:icell1))

                      if (rswitch > r0) then
                        fnorm = CellCvolFaceUnitNorm(idvol_r,iedge_r,  &
                                                     icell2)*rswitch
                        
                        if (type_cond_perm == 2 .or. useAnisoCondCorr) then                          
                          CellCvolFace_adv(idvol_r,iedge_r,icell2) =   &
                            - fluxvs_vel_usg_tenf(upstream,.false.,2,  &
                                     (/relperm(ivol),                  &
                                       relperm(jvol)/),iups,tenf_cond, &
                                      grad_flow_mids(idvol,icell1),    &
                                      fnorm)
                        else if (type_cond_perm == 1) then
                          CellCvolFace_adv(idvol_r,iedge_r,icell2) =   &
                            - fluxvs_vel_usg_tend(upstream,.false.,2,  &
                                     (/relperm(ivol),                  &
                                       relperm(jvol)/),iups,cond,      &
                                      grad_flow_mids(idvol,icell1),    &
                                      fnorm)
                        end if
                      end if

                    else

                      if (rswitch > r0) then
                        CellCvolFace_adv(idvol_r,iedge_r,icell2) = vector_zero
                      end if

                    end if

                  end do
                end if
              end do
            end if
          elseif (fully_saturated) then
            do icell1 = 1, janumcell(jtemp1)
                icell2 = jacell(icell1,jtemp1)
                if (icell2 > 0) then
                do idvol = 1, num_edge_dvols

                  call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,   &
                                             idvol_r,iedge_r,rswitch)
                  cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,     &
                                                  icell2)
                  
                  if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                    tenf_cond = CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)
                  else if (type_cond_perm == 1) then
                    cond = CellCvolFace_cond(idvol_r,iedge_r,icell2)
                  end if

                  if (cvolfacearea > rsmallarea) then
                    cinfrt_va_usg(jtemp1) = cinfrt_va_usg(jtemp1)      &
                      - fluxfs_usg(uvsnew(ivol),uvsnew(jvol),1,1,      &
                                   grad_flow_mids(idvol,icell1),       &
                                   flux_hls_corr(idvol,icell1),        &
                                   cinfvs_usg_loc(idvol,icell1),       &
                                   cinfvs_usg_cross_loc(idvol,icell1))

                    if (rswitch > r0) then                      
                      if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                        CellCvolFace_adv(idvol_r,iedge_r,icell2) =       &
                          - fluxfs_vel_usg_tenf(tenf_cond,grad_flow_mids(idvol,icell1))
                      else if (type_cond_perm == 1) then
                        CellCvolFace_adv(idvol_r,iedge_r,icell2) =       &
                          - fluxfs_vel_usg_tend(cond,grad_flow_mids(idvol,icell1))
                      end if
                    end if

                  else

                    if (rswitch > r0) then
                      CellCvolFace_adv(idvol_r,iedge_r,icell2) = vector_zero
                    end if

                  end if

                end do
              end if
            end do
          end if

!c  matrix is symmetric n a symbolic sense, since cinfrt_va between 
!c  cell ivol and jvol is equal to - cinfrt_va between cells id and ibk
          !cinfrt_va(isymvs(jtemp1)) = - cinfrt_va(jtemp1)
        end do

      end do      !c  loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  calculate influence coefficient based on mesh cells

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (num_cells > numofloops_thred_infcrt_a_3)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (icell, icell1, icell2, ic, idvol, idvol_r,         &
    !$omp iedge, iedge_r, ivol, istart, iend, jvol, jtemp1, jtemp2,   &
    !$omp tend, tenf, cvolfacearea, izn, jzn, atc_av, aca_av,         &
    !$omp diffav, diff_eff, diff_eff1, diff_eff2, rml, rmr,           &
    !$omp diff_i, diff_j, diff_ij, disx_avg, disy_avg, disz_avg,      &
    !$omp disxy_avg, disxz_avg, disyz_avg,                            &
    !$omp diffav_tensor, diff_eff_tensor,                             &
    !$omp diff_eff1_tensor, diff_eff2_tensor,                         &
    !$omp diff_i_tensor, diff_j_tensor, diff_ij_tensor,               &
    !$omp marchieav, porav, por1, por2, por_i, por_j, rswitch,        &
    !$omp satav, so_av, tauav, tau_i, tau_j, vel, velsloc, vmag, vxyz2)
    !$omp do schedule(static)
#endif
      do icell = 1, num_cells         !c loop over cells

!c  find ivol-jvol pair for the cell and calculate velocity component for this cell
        if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then
          do iedge = 1, num_edges_per_cell  !c loop over cell edges

            if (cell_type == cell_type_tri) then
              ivol = cells(edge_node_mapping_tri(1,iedge),icell)
              jvol = cells(edge_node_mapping_tri(2,iedge),icell)
            else if (cell_type == cell_type_quad) then
              ivol = cells(edge_node_mapping_quad(1,iedge),icell)
              jvol = cells(edge_node_mapping_quad(2,iedge),icell)
            end if

            !get the jtemp1 value
            istart = iavs(ivol)+1
            iend = iavs(ivol+1)-1
            do jtemp1 = istart, iend       !c loop over connections
              if(jvol == javs(jtemp1)) then
                exit
              end if
            end do
          end do
        else if (cell_type == cell_type_tetra .or.                     &
                 cell_type == cell_type_hexa .or.                      &
                 cell_type == cell_type_prism) then
          do iedge = 1, num_edges_per_cell

            if (cell_type == cell_type_tetra) then
              ivol = cells(edge_node_mapping_tetra(1,iedge),icell)
              jvol = cells(edge_node_mapping_tetra(2,iedge),icell)
            else if (cell_type == cell_type_hexa) then
              ivol = cells(edge_node_mapping_hexa(1,iedge),icell)
              jvol = cells(edge_node_mapping_hexa(2,iedge),icell)
            else if (cell_type == cell_type_prism) then
              ivol = cells(edge_node_mapping_prism(1,iedge),icell)
              jvol = cells(edge_node_mapping_prism(2,iedge),icell)
            end if

            !get the jtemp1 value
            istart = iavs(ivol)+1
            iend = iavs(ivol+1)-1
            do jtemp1 = istart, iend       !c loop over connections
              if(jvol == javs(jtemp1)) then
                exit
              end if
            end do

            !get the cell index of jacell
            icell1 = 0
            do icell1 = 1, janumcell(jtemp1)
              if (jacell(icell1,jtemp1) == icell) then
                exit
              end if
            end do

          end do
        end if

!c  find ivol-jvol pair for the cell and calculate influence coefficient
!c  jtemp1 is the index for edge ivol-jvol and jtemp2 is the index for edge jvol-ivol
        do iedge = 1, num_edges_per_cell
          if (cell_type == cell_type_tri) then
            ivol = cells(edge_node_mapping_tri(1,iedge),icell)
            jvol = cells(edge_node_mapping_tri(2,iedge),icell)
          else if (cell_type == cell_type_quad) then  
            ivol = cells(edge_node_mapping_quad(1,iedge),icell)
            jvol = cells(edge_node_mapping_quad(2,iedge),icell)
          else if (cell_type == cell_type_tetra) then  
            ivol = cells(edge_node_mapping_tetra(1,iedge),icell)
            jvol = cells(edge_node_mapping_tetra(2,iedge),icell)
          else if (cell_type == cell_type_hexa) then
            ivol = cells(edge_node_mapping_hexa(1,iedge),icell)
            jvol = cells(edge_node_mapping_hexa(2,iedge),icell)
          else if (cell_type == cell_type_prism) then
            ivol = cells(edge_node_mapping_prism(1,iedge),icell)
            jvol = cells(edge_node_mapping_prism(2,iedge),icell)
          end if

          ! get the jtemp1 value
          istart = iavs(ivol)+1
          iend = iavs(ivol+1)-1
          do jtemp1 = istart, iend       !c loop over connections
            if(jvol == javs(jtemp1)) then
              exit
            end if
          end do

          ! get the icell1 value
          do icell1 = 1, janumcell(jtemp1)
            if (jacell(icell1,jtemp1) == icell) then
              exit
            end if
          end do

          ! get the jtemp2 value, which is symmetrical to jtemp1
          istart = iavs(jvol)+1
          iend = iavs(jvol+1)-1
          do jtemp2 = istart, iend       !c loop over connections
            if(ivol == javs(jtemp2)) then
              exit
            end if
          end do

          ! get the icell2 value, this value can be same as icell1 after further optimization in javs
          do icell2 = 1, janumcell(jtemp2)
            if (jacell(icell2,jtemp2) == icell) then
              exit
            end if
          end do

          !c calculate control face velocity
          if (b_use_fixed_flow_vel) then
            velsloc = fixed_flow_vel
          else
            call usg_face_utility_vel_flow(ivol,jvol,icell1,jtemp1,velsloc)
          end if

!cdsu get rotation angle for anisotropic tortuosity and dispersivity correction
          if (useAnisoTauCorr .or. useAnisoDispCorr) then
            izn = mpropvs(ivol)
            jzn = mpropvs(jvol)
            
            aca_av = (aca_vol(ivol) + aca_vol(jvol))*rhalf
            call geometry_cal_rotation_matrix(aca_av,rml,rmr)

            if (useAnisoTauCorr) then
              if (type_averaging_De .eq. 'harmonic') then
                atc_av = math_common_harmonic(atc_zone(izn),atc_zone(jzn))
              else
                atc_av = (atc_zone(izn) + atc_zone(jzn))*rhalf
              end if
            end if

          end if

!cmx-------------------------------------------------------------------
!cmx-------------------------------------------------------------------
!cmx     Not harmonic average in porosity and/or De
!cmx-------------------------------------------------------------------
!cmx-------------------------------------------------------------------
          if (.not.harmonic_porosity .and.                             &
              (type_averaging_De.ne.'harmonic') .or.                   &
              (type_averaging_De.eq.'arithmetic' .and.                 &
              (harmonic_porosity)) .or.                                &
              trim(type_averaging_De).eq.'') then
            !c average of ivol-jvol, can be other interpolation methods
            porav = 0.5d0*(min(r1, pornew(ivol))+                      &
                           min(r1,pornew(jvol)))
            if (assigned_tau) then
              tauav = 0.5d0*(tau(ivol)*tau_fac(ivol)+                  &
                             tau(jvol)*tau_fac(jvol))
            end if
          
!c  calculate average dispersivities for the "pseudo
!c  dispersion element"
            if (is_cell_based_disp_rt) then
              disx_avg = disx(mpropvs_cell(icell))
              disy_avg = disy(mpropvs_cell(icell))
              disz_avg = disz(mpropvs_cell(icell))
            else
              disx_avg = (disx(mpropvs(ivol))+disx(mpropvs(jvol)))*0.5d0
              disy_avg = (disy(mpropvs(ivol))+disy(mpropvs(jvol)))*0.5d0
              disz_avg = (disz(mpropvs(ivol))+disz(mpropvs(jvol)))*0.5d0
            end if
!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element
            satav = (min(r1,sanew(ivol))+min(r1,sanew(jvol)))*0.5d0
            so_av = (min(r1,sonew(ivol))+min(r1,sonew(jvol)))*0.5d0
            
!c  calculate the average marchie factor
            marchieav = (marchies(ivol)+marchies(jvol))*0.5d0


!c  calculate effective diffusion coefficient
!c_bubbles use averaged diffusion coefficient
            if (type_diff_coeff == 0) then
              diffav = diff_a
            else if (type_diff_coeff > 0) then
              diffav_tensor = diff_a_tensor
            end if
            if (.not.diff_coff) then
              if (type_averaging_De .ne. 'arithmetic De' ) then
                if (type_diff_coeff == 0) then
                  diff_eff = diffcoff(diffav,satav,porav,              &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av,tor_corr_a_mq,tor_corr_b_mq)
                else if (type_diff_coeff > 0) then
                  diff_eff_tensor = diffcoff(diffav_tensor,satav,porav,&
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av,tor_corr_a_mq,tor_corr_b_mq)
                end if
              else
                por1 = min( r1, pornew(ivol) )
                por2 = min( r1, pornew(jvol) )
            
                if (type_diff_coeff == 0) then
                  diff_eff1 = diffcoff(diffav,satav,por1,              &
                                     tortuosity_corr,assigned_tau,     &
                                     tauav,type_tortuosity,marchieav,  &
                                     so_av,tor_corr_a_mq,tor_corr_b_mq)
                  diff_eff2 = diffcoff(diffav,satav,por2,              &
                                     tortuosity_corr,assigned_tau,     &
                                     tauav,type_tortuosity,marchieav,  &
                                     so_av,tor_corr_a_mq,tor_corr_b_mq)
                  diff_eff = (diff_eff1 + diff_eff2)/2.0d0
                else if (type_diff_coeff > 0) then
                  diff_eff1_tensor = diffcoff(diffav_tensor,satav,por1,&
                                     tortuosity_corr,assigned_tau,     &
                                     tauav,type_tortuosity,marchieav,  &
                                     so_av,tor_corr_a_mq,tor_corr_b_mq)
                  diff_eff2_tensor = diffcoff(diffav_tensor,satav,por2,&
                                     tortuosity_corr,assigned_tau,     &
                                     tauav,type_tortuosity,marchieav,  &
                                     so_av,tor_corr_a_mq,tor_corr_b_mq)
                  diff_eff_tensor = (diff_eff1_tensor +                &
                                     diff_eff2_tensor)/2.0d0
                end if
              end if

              if (b_water_freezing) then
                if (tkel(ivol) < pressure_melt_k(ivol,r0) .or.         &
                    tkel(jvol) < pressure_melt_k(jvol,r0)) then
                  if (type_diff_coeff == 0) then
                    diff_eff = diff_eff*frozen_diff_a
                  else if (type_diff_coeff > 0) then
                    diff_eff_tensor = diff_eff_tensor*frozen_diff_a
                  end if
                end if
              end if

! prc -------------------------------------------------------------------
! prc Modified for Multicomponent diffusion
! prc diff_eff = r0 the diffusion coefficient will be taken out from 
! prc dispersion coefficient.
! prc -------------------------------------------------------------------

              if (multi_diff) then
                if (type_diff_coeff == 0) then
                  diff_eff = r0
                else if (type_diff_coeff > 0) then
                  diff_eff_tensor = tensor_zero
                end if
              end if

!cdsu correction for anisotropic material properties
              if (useAnisoTauCorr) then
                if (type_diff_coeff == 0) then
                  diff_eff_tensor = tensor_zero                  
                  diff_eff_tensor%xx = diff_eff
                  diff_eff_tensor%yy = diff_eff
                  diff_eff_tensor%zz = diff_eff
                end if

                diff_eff_tensor%xx = diff_eff_tensor%xx*atc_av%x
                diff_eff_tensor%yy = diff_eff_tensor%yy*atc_av%y
                diff_eff_tensor%zz = diff_eff_tensor%zz*atc_av%z

                diff_eff_tensor = (rml.dot.diff_eff_tensor).dot.rmr
              end if
            
              do idvol = 1, num_edge_dvols
              
                call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,      &
                                           idvol_r,iedge_r,rswitch)
                cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

                if(jacell(icell1,jtemp1) > 0 .and. cvolfacearea > rsmallarea) then

!c  calculate dispersivity
                  vel = velsloc(idvol)
                  vmag = sqrt(vel%x**2 + vel%y**2 + vel%z**2)
                  vxyz2 = math_common_set_vector(vel%x**2/(vmag + eps),   &
                          vel%y**2/(vmag + eps),vel%z**2/(vmag + eps))

                  if (useAnisoDispCorr .or. useAnisoTauCorr) then
                    !c to be further checked if it is right here
                    tenf = tensor_zero

                    !c get dispersivity tensor
                    if (useAnisoDispCorr) then
                      !c get principle dispersivity
                      tenf%xx = disx_avg
                      tenf%yy = disy_avg
                      tenf%zz = disz_avg

                      tenf = (rml.dot.tenf).dot.rmr

                      disx_avg = tenf%xx
                      disy_avg = tenf%yy
                      disz_avg = tenf%zz
                      disxy_avg = tenf%xy
                      disxz_avg = tenf%xz
                      disyz_avg = tenf%yz
                    else
                      disxy_avg = disx_avg-disy_avg
                      disxz_avg = disx_avg-disz_avg
                      disyz_avg = disx_avg-disz_avg
                    end if

                    !c calculate dispersion terms
                    tenf%xx = disx_avg*vxyz2%x+disy_avg*vxyz2%y+      &
                              disz_avg*vxyz2%z
                    tenf%yy = disy_avg*vxyz2%x+disx_avg*vxyz2%y+      &
                              disz_avg*vxyz2%z
                    tenf%zz = disz_avg*vxyz2%x+disz_avg*vxyz2%y+      &
                              disx_avg*vxyz2%z
                    tenf%xy = disxy_avg*vel%x*vel%y/(vmag+eps)
                    tenf%yx = tenf%xy
                    tenf%xz = disxz_avg*vel%x*vel%z/(vmag+eps)
                    tenf%zx = tenf%xz
                    tenf%yz = disyz_avg*vel%y*vel%z/(vmag+eps)
                    tenf%zy = tenf%yz

                    CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell) = &
                                 tenf + diff_eff_tensor

                  else
                    !c save dispersion tensor
                    if (type_disp_coeff == 1) then
                      tend = math_common_set_vector(disx_avg*vxyz2%x+  &
                                                 disy_avg*vxyz2%y+     &
                                                 disz_avg*vxyz2%z,     &
                                                 disy_avg*vxyz2%x+     &
                                                 disx_avg*vxyz2%y+     &
                                                 disz_avg*vxyz2%z,     &
                                                 disz_avg*vxyz2%x+     &
                                                 disz_avg*vxyz2%y+     &
                                                 disx_avg*vxyz2%z)

                      if (type_diff_coeff == 0) then
                        tend = tend + math_common_set_vector(             &
                                               diff_eff,diff_eff,diff_eff)
                        CellCvolFace_disp_da(idvol_r,iedge_r,icell) = tend
                      else if (type_diff_coeff == 1) then
                        tend = tend + math_common_set_vector(             &
                                               diff_eff_tensor%xx,     &
                                               diff_eff_tensor%yy,     &
                                               diff_eff_tensor%zz)
                        CellCvolFace_disp_da(idvol_r,iedge_r,icell) = tend
                      else if (type_diff_coeff == 2) then 
                        tenf = diff_eff_tensor
                        tenf%xx = tenf%xx + tend%x
                        tenf%yy = tenf%yy + tend%y
                        tenf%zz = tenf%zz + tend%z
                        CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell) = tenf
                      end if
                    
                    else if (type_disp_coeff == 2) then 

                      tenf%xx = disx_avg*vxyz2%x+disy_avg*vxyz2%y+     &
                                   disz_avg*vxyz2%z
                      tenf%yy = disy_avg*vxyz2%x+disx_avg*vxyz2%y+     &
                                   disz_avg*vxyz2%z
                      tenf%zz = disz_avg*vxyz2%x+disz_avg*vxyz2%y+     &
                                   disx_avg*vxyz2%z
                      tenf%xy = (disx_avg-disy_avg)*vel%x*vel%y/(vmag+eps)
                      tenf%yx = tenf%xy
                      tenf%xz = (disx_avg-disz_avg)*vel%x*vel%z/(vmag+eps)
                      tenf%zx = tenf%xz
                      tenf%yz = (disx_avg-disz_avg)*vel%y*vel%z/(vmag+eps)
                      tenf%zy = tenf%yz 

                      if (type_diff_coeff == 0) then
                        tenf%xx = tenf%xx + diff_eff
                        tenf%yy = tenf%yy + diff_eff
                        tenf%zz = tenf%zz + diff_eff
                      else if (type_diff_coeff > 0) then
                        tenf = tenf + diff_eff_tensor
                      end if
                      CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell) = tenf
                    end if
                  end if

                end if
               
              end do

            else

              do idvol = 1, num_edge_dvols

                call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,      &
                                           idvol_r,iedge_r,rswitch)
                cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)
           
                do ic = 1,nc

                  if(jacell(icell1,jtemp1) > 0 .and.                   &
                     cvolfacearea > rsmallarea) then
!c  calculate dispersivity
                    vel = velsloc(idvol)
                    vmag = sqrt(vel%x**2 + vel%y**2 + vel%z**2)
                    vxyz2 = math_common_set_vector(vel%x**2/(vmag + eps), &
                            vel%y**2/(vmag + eps),vel%z**2/(vmag + eps))

                    if (type_diff_ic_coeff == 0) then
                      diff_eff = diffcoff(diff_ic(ic),satav,porav,     &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av,tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diff_ic_coeff > 0) then
                      diff_eff_tensor = diffcoff(                      &
                                diff_ic_tensor(ic),satav,porav,        &
                                tortuosity_corr,assigned_tau,          &
                                tauav,type_tortuosity,marchieav,       &
                                so_av,tor_corr_a_mq,tor_corr_b_mq)
                    end if

!cdsu correction for anisotropic material properties
                    if (useAnisoTauCorr) then
                      if (type_diff_ic_coeff == 0) then
                        diff_eff_tensor = tensor_zero
                        diff_eff_tensor%xx = diff_eff
                        diff_eff_tensor%yy = diff_eff
                        diff_eff_tensor%zz = diff_eff
                      end if

                      diff_eff_tensor%xx = diff_eff_tensor%xx*atc_av%x
                      diff_eff_tensor%yy = diff_eff_tensor%yy*atc_av%y
                      diff_eff_tensor%zz = diff_eff_tensor%zz*atc_av%z
      
                      diff_eff_tensor = (rml.dot.diff_eff_tensor).dot.rmr
                    end if


                    !c save dispersion tensor
                    if (type_disp_coeff == 1) then
                      tend = math_common_set_vector(disx_avg*vxyz2%x+     &
                                disy_avg*vxyz2%y+disz_avg*vxyz2%z,     &
                                                 disy_avg*vxyz2%x+     &
                                disx_avg*vxyz2%y+disz_avg*vxyz2%z,     &
                                                 disz_avg*vxyz2%x+     &
                                disz_avg*vxyz2%y+disx_avg*vxyz2%z)        
  

                      if (type_diff_ic_coeff == 0) then
                        tend = tend + diff_eff
                        CellCvolFace_disp_da_ic(ic,idvol_r,iedge_r,icell) = tend
                      else if (type_diff_ic_coeff == 1) then  
                        tend = tend + math_common_set_vector(           &
                                              diff_eff_tensor%xx,    &
                                              diff_eff_tensor%yy,    &
                                              diff_eff_tensor%zz)
                        CellCvolFace_disp_da_ic(ic,idvol_r,iedge_r,icell) = tend
                      else if (type_diff_ic_coeff == 2) then
                        tenf = diff_eff_tensor
                        tenf%xx = tenf%xx + tend%x
                        tenf%yy = tenf%yy + tend%y
                        tenf%zz = tenf%zz + tend%z
                        CellCvolFace_disp_da_ic_tensor(ic,idvol_r,iedge_r,icell) = tenf
                      end if

                    else if (type_disp_coeff == 2) then
                      tenf%xx = disx_avg*vxyz2%x+disy_avg*vxyz2%y+    &
                                   disz_avg*vxyz2%z
                      tenf%yy = disy_avg*vxyz2%x+disx_avg*vxyz2%y+    &
                                   disz_avg*vxyz2%z
                      tenf%zz = disz_avg*vxyz2%x+disz_avg*vxyz2%y+    &
                                   disx_avg*vxyz2%z
                      tenf%xy = (disx_avg-disy_avg)*vel%x*vel%y/(vmag+eps)
                      tenf%yx = tenf%xy
                      tenf%xz = (disx_avg-disz_avg)*vel%x*vel%z/(vmag+eps)
                      tenf%zx = tenf%xz
                      tenf%yz = (disx_avg-disz_avg)*vel%y*vel%z/(vmag+eps)
                      tenf%zy = tenf%yz

                      if (type_diff_ic_coeff == 0) then
                        tenf%xx = tenf%xx + diff_eff
                        tenf%yy = tenf%yy + diff_eff
                        tenf%zz = tenf%zz + diff_eff                        

                      else if (type_diff_ic_coeff > 0) then
                        tenf = tenf + diff_eff_tensor
                      end if

                      CellCvolFace_disp_da_ic_tensor(ic,idvol_r,iedge_r,icell) = tenf
                    end if
             
                  end if             
                end do             
              end do
            end if

          else  ! Harmonic averaging of effective diffusion
!c  calculate average dispersivities for the "pseudo
!c  dispersion element"
            if (type_diff_coeff == 0) then
              diffav = r0
            else if (type_diff_coeff > 0) then
              diffav_tensor = tensor_zero
            end if
            if (is_cell_based_disp_rt) then
              disx_avg = disx(mpropvs_cell(icell))
              disy_avg = disy(mpropvs_cell(icell))
              disz_avg = disz(mpropvs_cell(icell))
            else
              disx_avg = (disx(mpropvs(ivol))+disx(mpropvs(jvol)))*0.5d0
              disy_avg = (disy(mpropvs(ivol))+disy(mpropvs(jvol)))*0.5d0
              disz_avg = (disz(mpropvs(ivol))+disz(mpropvs(jvol)))*0.5d0
            end if

            !c property of ivol
            por_i = pornew(ivol)
            if (assigned_tau) then
              tau_i = tau(ivol)*tau_fac(ivol)
            end if 

            satav = min(r1, sanew(ivol))
            so_av = min(r1, sonew(ivol))
            marchieav = marchies(ivol)
           
            if (type_diff_coeff == 0) then
              diffav = diff_a
              diff_i = diffcoff(diffav,satav,por_i,tortuosity_corr,    &
                              assigned_tau,tau_i,type_tortuosity,      &
                              marchieav,so_av,                         &
                              tor_corr_a_mq,tor_corr_b_mq)
            else if (type_diff_coeff > 0) then
              diffav_tensor = diff_a_tensor
              diff_i_tensor = diffcoff(diffav_tensor,satav,            &
                              por_i,tortuosity_corr,                   &
                              assigned_tau,tau_i,type_tortuosity,      &
                              marchieav,so_av,                         &
                              tor_corr_a_mq,tor_corr_b_mq)
            end if

            if (b_water_freezing) then
              if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                if (type_diff_coeff == 0) then
                  diff_i = diff_i*frozen_diff_a
                else if (type_diff_coeff > 0) then
                  diff_i_tensor = diff_i_tensor*frozen_diff_a
                end if
              end if
            end if                              
           
            !c property of jvol
            por_j = pornew(jvol)
            if (assigned_tau) then
             tau_j = tau(jvol)*tau_fac(jvol)    !
            end if
           
            satav = min(r1, sanew(jvol))
            so_av = min(r1, sonew(jvol))
            marchieav = marchies(jvol)
           
            if (type_diff_coeff == 0) then
              diffav = diff_a
              diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,    &
                              assigned_tau,tau_j,type_tortuosity,      &
                              marchieav,so_av,                         &
                              tor_corr_a_mq,tor_corr_b_mq)
            else if (type_diff_coeff > 0) then
              diffav_tensor = diff_a_tensor
              diff_j_tensor = diffcoff(diffav_tensor,satav,            &
                              por_j,tortuosity_corr,                   &
                              assigned_tau,tau_j,type_tortuosity,      &
                              marchieav,so_av,                         &
                              tor_corr_a_mq,tor_corr_b_mq)
            end if

            if (b_water_freezing) then
              if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                if (type_diff_coeff == 0) then
                  diff_j = diff_j*frozen_diff_a
                else if (type_diff_coeff > 0) then
                  diff_j_tensor = diff_j_tensor*frozen_diff_a
                end if
              end if
            end if                               
           
            !c weighted harmonic average, midpoint, weight = 1.0
            !c check coordinate system to avoid dividing by zero
            if (type_diff_coeff == 0) then
              diff_ij = math_common_harmonic(diff_i,diff_j)
            else if (type_diff_coeff > 0) then
              diff_ij_tensor = math_common_harmonic(diff_i_tensor,     &
                                                    diff_j_tensor)
            end if

!cdsu correction for anisotropic material properties
            if (useAnisoTauCorr) then
              if (type_diff_coeff == 0) then                
                diff_ij_tensor = tensor_zero
                diff_ij_tensor%xx = diff_ij
                diff_ij_tensor%yy = diff_ij
                diff_ij_tensor%zz = diff_ij
              end if

              diff_ij_tensor%xx = diff_ij_tensor%xx*atc_av%x
              diff_ij_tensor%yy = diff_ij_tensor%yy*atc_av%y
              diff_ij_tensor%zz = diff_ij_tensor%zz*atc_av%z

              diff_ij_tensor = (rml.dot.diff_ij_tensor).dot.rmr
            end if

!c  calculate the influence coefficient for the specified icell1, icell2, jtemp1, jtemp2
            do idvol = 1, num_edge_dvols

              call get_cell_edge_cvol_id(idvol,ivol,jvol,icell,        &
                                         idvol_r,iedge_r,rswitch)
              cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell)

              !c influence coefficient of direct gradient term
              if(jacell(icell1,jtemp1) > 0 .and.                       &
                 cvolfacearea > rsmallarea) then

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element
                vel = velsloc(idvol)
                vmag = sqrt(vel%x**2 + vel%y**2 + vel%z**2)
                vxyz2 = math_common_set_vector(vel%x**2/(vmag + eps),     &
                          vel%y**2/(vmag + eps),vel%z**2/(vmag + eps))

                if (useAnisoDispCorr .or. useAnisoTauCorr) then
                  !c to be further checked if it is right here
                  tenf = tensor_zero

                  !c get dispersivity tensor
                  if (useAnisoDispCorr) then
                    !c get principle dispersivity
                    tenf%xx = disx_avg
                    tenf%yy = disy_avg
                    tenf%zz = disz_avg

                    tenf = (rml.dot.tenf).dot.rmr

                    disx_avg = tenf%xx
                    disy_avg = tenf%yy
                    disz_avg = tenf%zz
                    disxy_avg = tenf%xy
                    disxz_avg = tenf%xz
                    disyz_avg = tenf%yz
                  else
                    disxy_avg = disx_avg-disy_avg
                    disxz_avg = disx_avg-disz_avg
                    disyz_avg = disx_avg-disz_avg
                  end if

                  !c calculate dispersion terms
                  tenf%xx = disx_avg*vxyz2%x+disy_avg*vxyz2%y+      &
                             disz_avg*vxyz2%z
                  tenf%yy = disy_avg*vxyz2%x+disx_avg*vxyz2%y+      &
                               disz_avg*vxyz2%z
                  tenf%zz = disz_avg*vxyz2%x+disz_avg*vxyz2%y+      &
                               disx_avg*vxyz2%z
                  tenf%xy = disxy_avg*vel%x*vel%y/(vmag+eps)
                  tenf%yx = tenf%xy
                  tenf%xz = disxz_avg*vel%x*vel%z/(vmag+eps)
                  tenf%zx = tenf%xz
                  tenf%yz = disyz_avg*vel%y*vel%z/(vmag+eps)
                  tenf%zy = tenf%yz

                  CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell) = &
                                 tenf + diff_ij_tensor
                else  
                !c save dispersion tensor
                  if (type_disp_coeff == 1) then 
                    tend = math_common_set_vector(disx_avg*vxyz2%x+         &
                              disy_avg*vxyz2%y+disz_avg*vxyz2%z,         &
                                               disy_avg*vxyz2%x+         &
                              disx_avg*vxyz2%y+disz_avg*vxyz2%z,         &
                                               disz_avg*vxyz2%x+         &
                              disz_avg*vxyz2%y+disx_avg*vxyz2%z)

                    if (type_diff_coeff == 0) then
                      tend = tend + math_common_set_vector(               &
                                             diff_ij,diff_ij,diff_ij)
                      CellCvolFace_disp_da(idvol_r,iedge_r,icell) = tend
                    else if (type_diff_coeff == 1) then 
                      tend = tend + math_common_set_vector(               &
                                             diff_ij_tensor%xx,        &
                                             diff_ij_tensor%yy,        &
                                             diff_ij_tensor%zz)
                      CellCvolFace_disp_da(idvol_r,iedge_r,icell) = tend
                    else if (type_diff_coeff == 2) then
                      tenf = diff_ij_tensor
                      tenf%xx = tenf%xx + tend%x
                      tenf%yy = tenf%yy + tend%y
                      tenf%zz = tenf%zz + tend%z
                      CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell) = tenf
                    end if
                  
                  else if (type_disp_coeff == 2) then
                    tenf%xx = disx_avg*vxyz2%x+disy_avg*vxyz2%y+      &
                              disz_avg*vxyz2%z
                    tenf%yy = disy_avg*vxyz2%x+disx_avg*vxyz2%y+      &
                              disz_avg*vxyz2%z
                    tenf%zz = disz_avg*vxyz2%x+disz_avg*vxyz2%y+      &
                              disx_avg*vxyz2%z
                    tenf%xy = (disx_avg-disy_avg)*vel%x*vel%y/(vmag+eps)
                    tenf%yx = tenf%xy
                    tenf%xz = (disx_avg-disz_avg)*vel%x*vel%z/(vmag+eps)
                    tenf%zx = tenf%xz
                    tenf%yz = (disx_avg-disz_avg)*vel%y*vel%z/(vmag+eps)
                    tenf%zy = tenf%yz
                    if (type_diff_coeff == 0) then
                      tenf%xx = tenf%xx + diff_ij
                      tenf%yy = tenf%yy + diff_ij
                      tenf%zz = tenf%zz + diff_ij
                    else if (type_diff_coeff > 0) then
                      tenf = tenf + diff_ij_tensor
                    end if
                    CellCvolFace_disp_da_tensor(idvol_r,iedge_r,icell) = tenf
                  end if
                end if

              end if
              
            end do

          end if  !c Harmonic averaging of effective diffusion
          
        end do  

      end do    !c loop over cells
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then
      
        do ivol = 1,nngl
          do jtemp1 = iavs(ivol),iavs(ivol+1)-1
            jvol = javs(jtemp1)
            do icell1 = 1, janumcell(jtemp1)
              write(idbg,'(4(a,1x,i6,1x),a,1x,1pe15.6e3)')               &
                    '-->check cinfrt_va ivol',ivol,'jvol',jvol,          &
                    "local cell", icell1, 'cinfrt_va(',jtemp1,') = ',    &
                    cinfrt_va_usg(jtemp1)
            end do
          end do
        end do

        if (info_debug.gt.1) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      
      end if    ! (info_debug.gt.0)
#endif

      return
      end
#endif
