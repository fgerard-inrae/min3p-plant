!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/velodd_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine velodd
!c -------------------
!c
!c compute average interfacial velocities in x,y,z directions 
!c for rectangular, cartesian finite volume discretization
!c
!c
!c written by:     Danyang Su     - Oct 15, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           cinfvs(nn)         = influence coefficient               + -
!c                                (variably saturated flow) 
!c           dimcv(3,nn)        = dimension of cells in x,y,z         + -
!c                                direction
!c           pressure(nn)       = fluid pressure                      + -
!c           density(nn)        = density                             + -
!c           viscosity(nn)      = viscosity                           + -
!c           relperm(nn)        = relative permeability               + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           idbg               = output for debugging information    + -
!c           ilog               = unit number, logbook                + -
!c           ivel               = unit number, average interfacial    + -
!c                                velocities
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes           + -
!c                                in x direction
!c           nvy                = number of control volumes           + -
!c                                in y direction
!c           nvz                = number of control volumes           + -
!c                                in z direction
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           half_cells         = .true.  -> half cells on boundary   + -
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           aread(3,12)        = A_ij/d_ij for current "pseudo
!c                                dispersion element" associated
!c                                with control volume ivol, up to 4
!c                                entries for each dimension
!c           areai              = interfacial area
!c           dflux              = interfacial flux
!c           eps                = constant
!c           r0                 = constant
!c           rhalf              = constant
!c           vel(3)             = average interfacial velocities
!c           gacc               = gravitational acceleration [m s^-2]
!c           dvolcoef_ij        = relperm/viscosity for var_sat flow
!c                              = 1.0/viscosity for fully_sat flow
!c
!c           integer*4:
!c           ----------
!c           cvpair(3,12,2)     = pointers to connected control 
!c                                volumes in each pair for each 
!c                                dimension
!c           i1                 = pointer (connectivity list)
!c           i1sav              = pointer (connectivity list)
!c           idim               = pointer (dimensions)
!c           idim2              = pointer (dimensions)
!c           idim3              = pointer (dimensions)
!c           ipair              = counter (control volume pairs in
!c                                         dimension)
!c           ivol               = pointer (control volume i)
!c           jvol               = pointer (connected control volume j)
!c           ivol2              = counter (control volumes)
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           npair(3)           = number of control volume pairs
!c                                in dimension
!c
!c           character:
!c           ----------
!c           iups               = upstream pointer
!c
!c external: cliqdisp  = find control volume pairs for computation of 
!c                       average interfacial velocities
!c ----------------------------------------------------------------------
#ifdef USG
      subroutine velodd_usg(iprint)
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use phys
      use dens
      use writeversion
      use file_unit, only : lun_get, lun_free
      use geometry
      use usg_mesh_data

      use gradient_usg, only : gradient_dd_green_gauss_tri,            &
                               gradient_dd_green_gauss_tetra,          &
                               gradient_dd_least_square_cvol,          &
                               gradient_dd_hls_cvol,                   &
                               gradient_cross_diff_dd
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxdd_usg
#ifdef PETSC
#ifdef PETSC_HDF
      use hdf5
      use hdf5_usg
#endif
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC_HDF
      integer :: hdf5_ierr                   ! HDF5 error code
      integer(HID_T) :: file_id              ! File identifier
      integer(HID_T) :: group_id             ! Group identifier
      integer(HID_T) :: plist_id             ! Property list identifier
      integer :: ixmf                        ! XMF file id
#endif

#ifdef PETSC
      integer*4 :: courant_num_gbl
      real*8 :: courant_max_gbl
      PetscErrorCode :: ierrcode
#else
      integer :: ierrcode
#endif

      integer, intent(in) :: iprint

      integer :: i, i1, i2, icon, ivol, jvol, istart, iend, idvol,     &
                 kvol, idvol_r, iedge_r, icell, icell2, jtemp, l_sufx, &
                 ncell, ndvol, ncond, ngrad, nrelp, ierr

      type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)

      real*8 :: rho_av_ij, sa_av, courant, courant_loc, EdgeLen2

      !c other variables for velocity vector reconstruction with Perot's method
      real*8 :: viscosity_av
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: EdgeVec
      type(point) :: grad_ddflow_locs(num_crossdifficv_max)
      type(point) :: grad_ddflow_mids(num_edge_dvols,num_edge_maxcells)
      type(point) :: cvf2node_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,         &
                           r3 = 3.0d0, rhalf = 0.5d0,rsmall = 1.0d-10, &
                           rsmallarea = 1.0d-8

      character*5 suffix
      character*256 strbuffer
      character*256 :: strfilename, strfilename_result, strfilename_mesh

      external :: checkerr

!c  ---------------------------------------------------------------------
!c  calculate velocity for nodes based on the interfacial flux
!c  ---------------------------------------------------------------------
      if (b_use_fixed_flow_vel) then
        do ivol = 1, nngl           !loop over all volumes
          vels(ivol) = fixed_flow_vel
        end do
      else if (b_use_perot_flow_vel) then
        do ivol = 1, nngl           !loop over all volumes

          istart = iavs(ivol)+1     !pointer - start of row
          iend = iavs(ivol+1)-1     !pointer - end of row

          icon = 0                  !counter (connections)

          vels(ivol) = vector_zero

          do i1=istart,iend         !loop over connected control volumes

            jvol = javs(i1)         !column pointer
            icon = icon+1           !counter (connections)

            ncell = janumcell(i1)

            del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
            del_z(icon) = nodes(jvol)%z - nodes(ivol)%z

            rho_av_ij = rhalf * (density(ivol) + density(jvol))
            sa_av  = rhalf * (sanew(ivol) + sanew(jvol))

            if (av_dens_z) then
              del_p(icon) = rho_av_ij*(uvsnew(jvol)/density(jvol)-  &
                                       uvsnew(ivol)/density(ivol))
            end if

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential

            del_z(icon) = del_z(icon) * rho_av_ij * gacc
            del_p(icon) = del_p(icon) + del_z(icon)

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation

            if (is_cell_based_relp) then
              if (del_p(icon) .gt. r0) then
                dcoef(icon) = r1/viscosity(jvol)
              else
                dcoef(icon) = r1/viscosity(jvol)
              end if
            else
              if (del_p(icon) .gt. r0) then
                dcoef(icon) = relperm(jvol)/viscosity(jvol)
              else
                dcoef(icon) = relperm(ivol)/viscosity(ivol)
              end if
            end if

!c  compute fluxes between current control volume and adjacent
!c  control volumes

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
            grad_ddflow_mids = vector_zero
            flux_ddflow_hls_corr = r0

            call gradient_cross_diff_dd(i1,ivol,jvol,                  &
                 grad_ddflow_locs,grad_ddflow_mids,grad_weights,       &
                 flux_ddflow_hls_corr,grad_ddflow_hls_loc)

!cdsu calculate influence coefficient for variable saturated flow
            call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                         cinfvs_usg_cross_loc,         &
                                         cvf2node_loc=cvf2node_loc)

            relps_loc = 0.0d0
            if (is_cell_based_relp) then
              nrelp = ncell
              do icell = 1, ncell
                i2 = jacell(icell,i1)
                if (i2 >0) then
                  relps_loc(icell) = relperm(i2)
                end if
              end do
            else
              nrelp = 2
              relps_loc(1:2) = 1.0d0
            end if

            vels(ivol) = vels(ivol) - fluxdd_cvol_usg(                     &
                           del_p(icon),num_edge_dvols,ncell,               &
                           grad_ddflow_mids(1:num_edge_dvols,1:ncell),     &
                           flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell), &
                           cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                           cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell), &
                           cvf2node_loc(1:num_edge_dvols,1:ncell),         &
                           is_cell_based_relp,nrelp,                       &
                           relps_loc(1:nrelp)*dcoef(icon))


          end do                    !loop over connected control volumes

          vels(ivol) = vels(ivol) / cvol(ivol)

        end do                      !loop over all volumes      

      end if

!c calculate courant number
      courant_max = r0
      courant_num = 0

      do ivol = 1, nngl           !loop over all volumes

        istart = iavs(ivol)+1     !pointer - start of row
        iend = iavs(ivol+1)-1     !pointer - end of row

        courant = r0

        do jtemp = istart, iend   !loop over all connections
          jvol = javs(jtemp)

          EdgeVec = nodes(jvol) - nodes(ivol)
          EdgeLen2 = EdgeVec%x**2+EdgeVec%y**2+EdgeVec%z**2

          courant_loc = abs((vels(ivol).dot.EdgeVec)*(delt/pornew(ivol)/EdgeLen2))
          if (courant_loc > courant) then
            courant = courant_loc
          end if
        end do

        !c total instances with courant exceeding unity
        if (courant.gt.r1) then
          courant_num = courant_num + 1
        end if              

        if (courant.gt.courant_max) then
          courant_max = courant
        end if

      end do

#ifdef PETSC
      call MPI_Allreduce(courant_num, courant_num_gbl,1,MPI_INTEGER4, &
                         MPI_SUM,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      courant_num = courant_num_gbl

      call MPI_Allreduce(courant_max, courant_max_gbl,1,MPI_REAL8,    &
                         MPI_MAX,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      courant_max = courant_max_gbl
#endif      

!c exit if no file output is required, e.g., calculate courant number only
      if (iprint < 1) then
        return
      end if

!c file output informations
      l_sufx = 0

      if (igstime.lt.10) then

        !write(icnv,'(i1)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i1)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:1)
          l_sufx = 3
        else
          l_sufx = 1
        end if

      elseif (igstime.ge.10.and.igstime.lt.100) then

        !write(icnv,'(i2)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i2)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:2)
          l_sufx = 4
        else
          l_sufx = 2
        end if

      elseif (igstime.ge.100.and.igstime.lt.1000) then

        !write(icnv,'(i3)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i3)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:3)
          l_sufx = 5
        else
          l_sufx = 3
        end if

      elseif (igstime.gt.1000) then
        if (rank == 0) then
          write(ilog,'(/a)')'error in input file'
          write(ilog,'(a)')'max. number of output times exceeded'
          write(ilog,'(a)')'abnormal exit in routine velodd_usg'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

      end if


      !c file for result and mesh
      !c note: binary output using separated file for each subdomain is
      !c deprecated for unstructured grid version
      if (b_output_binary) then
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'.vel'
        if (b_output_separate_mesh_result) then
          strfilename_mesh = prefix(:l_prfx)//'_domain.h5'
          strfilename_result = trim(strfilename)//'.h5'
        else
          strfilename_mesh = trim(strfilename)//'.h5'
          strfilename_result = trim(strfilename)//'.h5'
        end if
      else
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//          &
                      trim(adjustl(str_rank))//'.vel'
      end if

!c  ---------------------------------------------------------------------
!c  open file for nodal values
!c  ---------------------------------------------------------------------
      if (b_output_binary) then

#ifdef PETSC_HDF
        !c open corresponding xmf file to be loaded by paraview
        if (rank == 0) then
          ixmf = lun_get()
          open(ixmf,file=trim(strfilename)//'.xmf',status='unknown',   &
               form='formatted')
        end if

        !c initialize fortran interface
        call h5open_f(hdf5_ierr)

        !c setup file access property list with parallel I/O access
        call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
        call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,            &
                                MPI_INFO_NULL, hdf5_ierr)
        !c create the file collectively
        call h5fcreate_f(strfilename_result, H5F_ACC_TRUNC_F, file_id, &
                         hdf5_ierr, access_prp = plist_id)

        !c write attribute
        call hdf5_usg_write_attribute(file_id)

        if (.not. b_output_separate_mesh_result) then
          !c write mesh data
          call hdf5_usg_write_mesh_data(file_id)
        end if

        !c open corresponding xmf file for mesh and domain decomposition
        if (rank == 0) then
          call hdf5_usg_write_xmf_initialize(ixmf)
          call hdf5_usg_write_xmf_mesh(ixmf,strfilename_mesh,          &
                    cell_type,num_cells_gbl,num_nodes_gbl,             &
                    num_nodes_per_cell)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_rank",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_rank",            &
                    "Scalar","Cell",num_cells_gbl,1)

          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_lg2g",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_lg2g",            &
                    "Scalar","Cell",num_cells_gbl,1)

          if (b_use_node_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","vertices_matid",      &
                      "Scalar","Node",num_nodes_gbl,1)
          end if
          if (b_use_cell_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","cells_matid",         &
                      "Scalar","Cell",num_cells_gbl,1)
          end if
        end if

        !c create a group for the mesh data set
        strbuffer = "results"
        !c create and open a group
        call h5gcreate_f(file_id,strbuffer,group_id,hdf5_ierr,         &
                         OBJECT_NAMELEN_DEFAULT_F)
#endif
      else
        open(ivel,file=trim(strfilename)//'.vtk',status='unknown',     &
             form='formatted')
      end if

      if (rank == 0) then

        if (steady_flow) then

          write(ifls,'(/2a/72a)')'Flow variables, steady ',            &
                                 'state solution',('-',i=1,72)

        else

          write(ifls,'(/a,1pe15.6e3,1x,a,/72a)')                       &
                'Flow variables, T = ',time_io,time_unit,('-',i=1,72)

        end if

        write(ifls,'(/a/)') trim(strfilename)//'.vtk'

        write(ifls,'(2a)')                                             &
              'column   entry                           ','unit'
        write(ifls,'(2a)')                                             &
              '1        x                               ','m'
        write(ifls,'(2a)')                                             &
              '2        y                               ','m'
        write(ifls,'(2a)')                                             &
              '3        z                               ','m'
        write(ifls,'(2a)')                                             &
              '4        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '5        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '6        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '7        v                               ','m/d'

      end if


!c  title and mesh variables
      if (.not. b_output_binary) then
        if (steady_flow) then
          call write_mesh_data_vtk_ascii(ivel,                         &
                     "Flow variables, steady state")
        else if (transient_flow) then
          write(strbuffer,'(a,1x,1pe15.6e3,1x,a)')                     &
                "Flow variables, solution time = ",time_io,time_unit
          call write_mesh_data_vtk_ascii(ivel,trim(adjustl(strbuffer)))
        end if
        write(ivel,'(a,1x,i12)') "POINT_DATA",nngl
      end if

      !c write velocity vector
      if (b_output_binary) then
#ifdef PETSC_HDF
        allocate(realbuffer(num_nodes*3), stat = ierr)
        call checkerr(ierr,'velodd_usg-realbuffer',ilog)
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)

        do ivol = 1, num_nodes
          realbuffer((ivol-1)*3+1) = vels(ivol)%x
          realbuffer((ivol-1)*3+2) = vels(ivol)%y
          realbuffer((ivol-1)*3+3) = vels(ivol)%z
        end do
        call hdf5_usg_write_group_data_vec(group_id,"velocity",3,      &
                  num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
        if (rank == 0) then
          call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result,   &
                    "results","velocity","Vector","Node",num_nodes_gbl,3)
        end if
        call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
        deallocate(realbuffer)
#endif
      else
        write(ivel,'(a)') "VECTORS velocity double"
        do ivol = 1, nngl
          write(ivel,'(3(1pe15.6e3,1x))') vels(ivol)%x,vels(ivol)%y,vels(ivol)%z
        end do
      end if

!c  ---------------------------------------------------------------------
!c  close files
!c  ---------------------------------------------------------------------
      if (b_output_binary) then
#ifdef PETSC_HDF
        !c close group
        call h5gclose_f(group_id,hdf5_ierr)

        !c close file
        call h5pclose_f(plist_id, hdf5_ierr)
        call h5fclose_f(file_id, hdf5_ierr)

        !c close FORTRAN interface
        call h5close_f(hdf5_ierr)

        !c close xmf file
        if (rank == 0) then
          call hdf5_usg_write_xmf_finalize(ixmf)
          close(ixmf)
          call lun_free(ixmf)
        end if
#endif
      else
        close(ivel)
      end if

      return
      end
#endif
