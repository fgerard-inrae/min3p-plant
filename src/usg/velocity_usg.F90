!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 878 $
!> $Author: dsu $
!> $Date: 2024-02-14 20:08:49 -0800 (Wed, 14 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/velocity_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine velocity_usg
!c -------------------
!c
!c write contour data of velocity for variably saturated flow
!c simulation to output file
!c
!c written by:      Danyang Su- Spet. 30, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c
!c                                                                    I O
!c passed:   -
!c
!c common:
!c code.f:    type:
!c           -------
!c                              =                                     + -
!c local:
!c code.f:    type:
!c           -------
!c                              =                                     + -
!c --------------------------------------------------------------------------
#ifdef USG
      subroutine velocity_usg
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use phys
      use writeversion
      use file_unit, only : lun_get, lun_free
      use geometry
      use usg_mesh_data
      use math_common
      use gradient_usg, only : gradient_green_gauss_tri,               &
                               gradient_green_gauss_tetra,             &
                               gradient_least_square_cvol,             &
                               gradient_hls_cvol,                      &
                               gradient_least_square_cell,             &
                               gradient_cross_diff
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxfs_usg
      use mod_fluxvs_usg
#ifdef PETSC
#ifdef PETSC_HDF
      use hdf5
      use hdf5_usg
#endif
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC_HDF
      integer :: hdf5_ierr                   ! HDF5 error code
      integer(HID_T) :: file_id              ! File identifier
      integer(HID_T) :: group_id             ! Group identifier
      integer(HID_T) :: plist_id             ! Property list identifier
      integer :: ixmf                        ! XMF file id
#endif

      integer :: i, i1, i2, icon, ivol, jvol, istart, iend, icell, izn,&
                 idvol, icell2, idvol_r, iedge_r, jtemp, kvol, l_sufx, &
                 ngrad, ncond, ncell, ndvol, nrelp, info_debug, ierr

      type(point) :: grad_icell, vel_ij
      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols)
      real*8 :: relperm_loc, perm_fac_icell, tkel_icell, cxx, cyy, czz,&
                kratio, uvs_icell

      real*8 :: pressure_melt_k
      external :: pressure_melt_k

      !c other variables for velocity vector reconstruction with Perot's method
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: flux_hls_corr(num_edge_dvols, num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      type(point) :: grad_locs(num_crossdifficv_max),                  &
                     grad_flow_mids(num_edge_dvols, num_edge_maxcells)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cvf2node_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,         &
                           r3 = 3.0d0, rhalf = 0.5d0,rsmall = 1.0d-10, &
                           rsmallarea = 1.0d-8
      character*5 suffix
      character*256 strbuffer
      character*256 :: strfilename, strfilename_result, strfilename_mesh

      external :: checkerr

      info_debug = 0

      l_sufx = 0

      if (igstime.lt.10) then

        !write(icnv,'(i1)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i1)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:1)
          l_sufx = 3
        else
          l_sufx = 1
        end if

      elseif (igstime.ge.10.and.igstime.lt.100) then

        !write(icnv,'(i2)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i2)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:2)
          l_sufx = 4
        else
          l_sufx = 2
        end if

      elseif (igstime.ge.100.and.igstime.lt.1000) then

        !write(icnv,'(i3)') igstime
        !rewind(icnv)
        !read(icnv,'(a3)') suffix
        write(suffix,'(i3)') igstime
        if (tran_steady_flow) then
          suffix = "o_"//suffix(:3)
          l_sufx = 5
        else
          l_sufx = 3
        end if

      elseif (igstime.gt.1000) then
        if (rank == 0) then
          write(ilog,'(/a)')'error in input file'
          write(ilog,'(a)')'max. number of output times exceeded'
          write(ilog,'(a)')'abnormal exit in routine velocity_usg'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

      end if


!c  ---------------------------------------------------------------------
!c  calculate velocity for cells/nodes based on the interfacial flux
!c  ---------------------------------------------------------------------

!c  to be checked in the future for the cell based velocity
!c  The velocity is calculated based on darcy flux using
!c  the gradient at the cell center based on nodal values 
!c  belong to the cell. However, it seems not accurate enough.
      if (b_use_cell_vel) then        !cell based velocity estimation       
          do icell = 1, num_cells     !loop over all cells

            !c calculate gradient and relative permeability
            if (variably_saturated) then
              call gradient_least_square_cell(icell, hhead, grad_icell)
              if (is_cell_based_relp) then
                relperm_loc = relperm(icell)
              else
                relperm_loc = usg_mesh_data_interpolate(icell,relperm)
              end if
            else if (fully_saturated) then              
              call gradient_least_square_cell(icell, uvsnew, grad_icell)
              relperm_loc = 1.0d0
            end if 

            !c get hydraulic conductivity/permeability
            if (is_cell_based_perm_cond) then              
              if (permeability_field) then
                cxx = permx(icell)
                cyy = permy(icell)
                czz = permz(icell)
              else
                izn = mpropvs_cell(icell)
                cxx = condxx(izn)*k_depth_ratio(icell)
                cyy = condyy(izn)*k_depth_ratio(icell)
                czz = condzz(izn)*k_depth_ratio(icell)
              end if
            else
              if (permeability_field) then
                cxx = usg_mesh_data_interpolate(icell,permx)
                cyy = usg_mesh_data_interpolate(icell,permy)
                czz = usg_mesh_data_interpolate(icell,permz)
              else 
                kratio = r0 
                do i = 1, num_nodes_per_cell
                  kratio = kratio + k_depth_ratio(cells(i,icell))
                end do
                kratio = kratio/num_nodes_per_cell
                cxx = usg_mesh_data_interpolate(icell,mpropvs,condxx)*&
                      kratio
                cyy = usg_mesh_data_interpolate(icell,mpropvs,condyy)*&
                      kratio
                czz = usg_mesh_data_interpolate(icell,mpropvs,condzz)*&
                      kratio
              end if
            end if

            if (update_permeability.or.update_permeability_flow) then
              perm_fac_icell = usg_mesh_data_interpolate(icell,perm_fac)
              cxx = perm_fac_icell*cxx
              cyy = perm_fac_icell*cyy
              czz = perm_fac_icell*czz
            end if
            
            if (b_water_freezing_cond) then
              tkel_icell = usg_mesh_data_interpolate(icell,tkel)
              uvs_icell = usg_mesh_data_interpolate(icell,uvsnew)
              if (tkel_icell < pressure_melt_k(0,uvs_icell)) then
                cxx = water_freezing_cond
                cyy = water_freezing_cond
                czz = water_freezing_cond
              end if
            end if

            !c calculate velocity based on Darcy's flux formulation
            vels(icell)%x = -relperm_loc*cxx*grad_icell%x
            vels(icell)%y = -relperm_loc*cyy*grad_icell%y
            vels(icell)%z = -relperm_loc*czz*grad_icell%z
          end do
       
      else if (b_use_fixed_flow_vel) then
        do ivol = 1, nngl           !loop over all volumes
          vels(ivol) = fixed_flow_vel
        end do       
      else if (b_use_perot_flow_vel) then
        do ivol = 1, nngl           !loop over all volumes
          istart = iavs(ivol)+1     !pointer - start of row
          iend = iavs(ivol+1)-1     !pointer - end of row

          icon = 0                  !counter (connections)

          vels(ivol) = vector_zero

          do i1 = istart, iend      !loop over connected control volumes

            icon = icon+1           !counter (connections)

            jvol = javs(i1)         !column pointer
            ncell = janumcell(i1)

!c  consistent with upstream weighting

            if (upstream) then
              iups(icon) = 'i'                         !h_i >= h_j
              if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
                iups(icon) = 'j'
              end if
            end if

!c  flux calculations

            if (variably_saturated) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_flow_mids = vector_zero
              flux_hls_corr = r0

              call gradient_cross_diff(i1,ivol,jvol,hhead,             &
                            grad_locs,grad_flow_mids,                  &
                            grad_weights,flux_hls_corr,                &
                            grad_flow_hls_loc)

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                                           cinfvs_usg_cross_loc,       &
                                           cvf2node_loc=cvf2node_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = (/relperm(ivol),relperm(jvol)/)
              end if

              vel_ij = -fluxvs_cvol_usg(upstream,hhead(ivol),          &
                        hhead(jvol),num_edge_dvols,ncell,              &
                        grad_flow_mids(1:num_edge_dvols,1:ncell),      &
                        flux_hls_corr(1:num_edge_dvols,1:ncell),       &
                        is_cell_based_relp,nrelp,                      &
                        relps_loc(1:nrelp),iups(icon),                 &
                        cinfvs_usg_loc(1:num_edge_dvols,1:ncell),      &
                        cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell),&
                        cvf2node_loc(1:num_edge_dvols,1:ncell))
              vels(ivol) = vels(ivol) + vel_ij

            else if (fully_saturated) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_flow_mids = vector_zero
              flux_hls_corr = r0

              call gradient_cross_diff(i1,ivol,jvol,uvsnew,            &
                            grad_locs,grad_flow_mids,                  &
                            grad_weights,flux_hls_corr,                &
                            grad_flow_hls_loc)

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                                           cinfvs_usg_cross_loc,       &
                                           cvf2node_loc=cvf2node_loc)
              vels(ivol) = vels(ivol) - fluxfs_cvol_usg(                     &
                             uvsnew(ivol),uvsnew(jvol),                      &
                             num_edge_dvols,ncell,                           &
                             grad_flow_mids(1:num_edge_dvols,1:ncell),       &
                             flux_hls_corr(1:num_edge_dvols,1:ncell),        &
                             cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                             cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell), &
                             cvf2node_loc(1:num_edge_dvols,1:ncell))

            end if

          end do                    !loop over connected control volumes

          vels(ivol) = vels(ivol) / cvol(ivol)

        end do                      !loop over all volumes

      end if

      !c file for result and mesh
      !c note: binary output using separated file for each subdomain is
      !c deprecated for unstructured grid version
      if (b_output_binary) then
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'.vel'
        if (b_output_separate_mesh_result) then
          strfilename_mesh = prefix(:l_prfx)//'_domain.h5'
          strfilename_result = trim(strfilename)//'.h5'
        else
          strfilename_mesh = trim(strfilename)//'.h5'
          strfilename_result = trim(strfilename)//'.h5'
        end if
      else
        strfilename = prefix(:l_prfx)//'_'//suffix(:l_sufx)//          &
                      trim(adjustl(str_rank))//'.vel'
      end if

!c  ---------------------------------------------------------------------
!c  open file for nodal values
!c  ---------------------------------------------------------------------
      if (b_output_binary) then

#ifdef PETSC_HDF
        !c open corresponding xmf file to be loaded by paraview
        if (rank == 0) then
          ixmf = lun_get()
          open(ixmf,file=trim(strfilename)//'.xmf',status='unknown',   &
               form='formatted')
        end if

        !c initialize fortran interface
        call h5open_f(hdf5_ierr)

        !c setup file access property list with parallel I/O access
        call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
        call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,            &
                                MPI_INFO_NULL, hdf5_ierr)
        !c create the file collectively
        call h5fcreate_f(strfilename_result, H5F_ACC_TRUNC_F, file_id, &
                         hdf5_ierr, access_prp = plist_id)

        !c write attribute
        call hdf5_usg_write_attribute(file_id)

        if (.not. b_output_separate_mesh_result) then
          !c write mesh data
          call hdf5_usg_write_mesh_data(file_id)
        end if

        !c open corresponding xmf file for mesh and domain decomposition
        if (rank == 0) then
          call hdf5_usg_write_xmf_initialize(ixmf)
          call hdf5_usg_write_xmf_mesh(ixmf,strfilename_mesh,          &
                    cell_type,num_cells_gbl,num_nodes_gbl,             &
                    num_nodes_per_cell)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_rank",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_rank",            &
                    "Scalar","Cell",num_cells_gbl,1)

          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","vertices_lg2g",         &
                    "Scalar","Node",num_nodes_gbl,1)
          call hdf5_usg_write_xmf_attribute(ixmf,                      &
                    strfilename_mesh,"domain","cells_lg2g",            &
                    "Scalar","Cell",num_cells_gbl,1)

          if (b_use_node_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","vertices_matid",      &
                      "Scalar","Node",num_nodes_gbl,1)
          end if
          if (b_use_cell_matids) then
            call hdf5_usg_write_xmf_attribute(ixmf,                    &
                      strfilename_mesh,"domain","cells_matid",         &
                      "Scalar","Cell",num_cells_gbl,1)
          end if
        end if

        !c create a group for the mesh data set
        strbuffer = "results"
        !c create and open a group
        call h5gcreate_f(file_id,strbuffer,group_id,hdf5_ierr,         &
                         OBJECT_NAMELEN_DEFAULT_F)
#endif
      else
        open(ivel,file=trim(strfilename)//'.vtk',status='unknown',     &
             form='formatted')
      end if

      if (rank == 0) then

        if (steady_flow) then

          write(ifls,'(/2a/72a)')'Flow variables, steady ',            &
                                 'state solution',('-',i=1,72)

        else

          write(ifls,'(/a,1pe15.6e3,1x,a,/72a)')                       &
                'Flow variables, T = ',time_io,time_unit,('-',i=1,72)

        end if

        write(ifls,'(/a/)') trim(strfilename)//'.vtk'

        write(ifls,'(2a)')                                             &
              'column   entry                           ','unit'
        write(ifls,'(2a)')                                             &
              '1        x                               ','m'
        write(ifls,'(2a)')                                             &
              '2        y                               ','m'
        write(ifls,'(2a)')                                             &
              '3        z                               ','m'
        write(ifls,'(2a)')                                             &
              '4        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '5        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '6        vx                              ','m/d'
        write(ifls,'(2a)')                                             &
              '7        v                               ','m/d'

      end if


!c  title and mesh variables
      if (.not. b_output_binary) then
        if (steady_flow) then
          call write_mesh_data_vtk_ascii(ivel,                         &
                     "Flow variables, steady state")
        else if (transient_flow) then
          write(strbuffer,'(a,1x,1pe15.6e3,1x,a)')                     &
                "Flow variables, solution time = ",time_io,time_unit
          call write_mesh_data_vtk_ascii(ivel,trim(adjustl(strbuffer)))
        end if
        if (b_use_cell_vel) then
          write(ivel,'(a,1x,i12)') "CELL_DATA",num_cells
        else
          write(ivel,'(a,1x,i12)') "POINT_DATA",nngl
        end if
      end if

      !c write velocity vector
      if (b_output_binary) then
#ifdef PETSC_HDF
        if (b_use_cell_vel) then
          allocate(realbuffer(num_cells*3), stat = ierr)
        else
          allocate(realbuffer(num_nodes*3), stat = ierr)
        end if
        call checkerr(ierr,'velocity_usg-realbuffer',ilog)
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)

        if (b_use_cell_vel) then
          do icell = 1, num_cells
            realbuffer((icell-1)*3+1) = vels(icell)%x
            realbuffer((icell-1)*3+2) = vels(icell)%y
            realbuffer((icell-1)*3+3) = vels(icell)%z
          end do
          call hdf5_usg_write_group_data_vec(group_id,"velocity",3,    &
                 num_cells_loc,num_cells_gbl,offset_cells,realbuffer)
          if (rank == 0) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result, &
                   "results","velocity","Vector","Cell",num_cells_gbl,3)
          end if
        else
          do ivol = 1, num_nodes
            realbuffer((ivol-1)*3+1) = vels(ivol)%x
            realbuffer((ivol-1)*3+2) = vels(ivol)%y
            realbuffer((ivol-1)*3+3) = vels(ivol)%z
          end do
          call hdf5_usg_write_group_data_vec(group_id,"velocity",3,    &
                 num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer)
          if (rank == 0) then
            call hdf5_usg_write_xmf_attribute(ixmf,strfilename_result, &
                   "results","velocity","Vector","Node",num_nodes_gbl,3)
          end if
        end if

        call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
        deallocate(realbuffer)
#endif
      else
        write(ivel,'(a)') "VECTORS velocity double"
        if (b_use_cell_vel) then
          do icell = 1, num_cells
            write(ivel,'(3(1pe15.6e3,1x))') vels(icell)%x,vels(icell)%y,vels(icell)%z
          end do
        else
          do ivol = 1, nngl
            write(ivel,'(3(1pe15.6e3,1x))') vels(ivol)%x,vels(ivol)%y,vels(ivol)%z
          end do
        end if
      end if

!c  ---------------------------------------------------------------------
!c  close files
!c  ---------------------------------------------------------------------
      if (b_output_binary) then
#ifdef PETSC_HDF
        !c close group
        call h5gclose_f(group_id,hdf5_ierr)

        !c close file
        call h5pclose_f(plist_id, hdf5_ierr)
        call h5fclose_f(file_id, hdf5_ierr)

        !c close FORTRAN interface
        call h5close_f(hdf5_ierr)

        !c close xmf file
        if (rank == 0) then
          call hdf5_usg_write_xmf_finalize(ixmf)
          close(ixmf)
          call lun_free(ixmf)
        end if
#endif
      else
        close(ivel)
      end if

      return
      end
#endif
