!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 786 $
!> $Author: dsu $
!> $Date: 2021-01-06 21:41:32 -0800 (Wed, 06 Jan 2021) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/fluxd_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 module mod_fluxd_usg
!c ---------------------
!c
!c compute dispersive/diffusive mass flux
!c
!c written by:      Danyang Su - Aug. 8, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           totc_i             = total aqueous component             + -
!c                                concentration in control volume i
!c           totc_j             = total aqueous component             + -
!c                                concentration in control volume j
!c           cinfrt_d           = influence coefficient               + -
!c                                (hydrodynamic dispersion)
!c           fluxd              = dispersive flux                     * +
!c
!c common:   -
!c
!c local:    - 
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
      module mod_fluxd_usg

      implicit none

      contains

      !c calculate flux term
      real*8 function fluxd_usg(totc_i,totc_j,ndvol,ncell,grad_mids,   &
                                flux_corr,cinfrt_d,cinfrt_d_cross)

        use geometry
        use gen, only : b_use_cross_diffusion_react,  b_use_hls_correction

        implicit none

        real*8 :: totc_i,totc_j
        integer :: ndvol, ncell
        real*8 :: flux_corr(ndvol,ncell)
        real*8 :: cinfrt_d(ndvol,ncell)
        type(point) :: grad_mids(ndvol,ncell), cinfrt_d_cross(ndvol,ncell)

        !c local variable
        integer :: i, j
        real*8 :: fluxd_direct, fluxd_cross

        if (b_use_hls_correction) then
          fluxd_direct = 0.0d0
          do i = 1, ncell
            do j = 1, ndvol
              fluxd_direct = fluxd_direct + cinfrt_d(j,i)*             &
                                   (totc_j-totc_i-flux_corr(j,i))
            end do
          end do
        else
          fluxd_direct = (totc_j - totc_i) * sum(cinfrt_d)
        end if

        fluxd_cross = 0.0d0
        if (b_use_cross_diffusion_react) then
          do i = 1, ncell
            do j = 1, ndvol
              fluxd_cross = fluxd_cross + (cinfrt_d_cross(j,i).dot.grad_mids(j,i))
            end do
          end do
        end if

        fluxd_usg = fluxd_direct + fluxd_cross

      end function fluxd_usg

      !c calculate velocity term
      type(point) function fluxd_vel_usg_tend(disp_mid, grad_mid)

        use geometry

        implicit none

        type(point) :: disp_mid, grad_mid 

        fluxd_vel_usg_tend = disp_mid.times.grad_mid

        return

      end function fluxd_vel_usg_tend

      !c calculate velocity term based on full dispersion tensor
      type(point) function fluxd_vel_usg_tenf(disp_mid, grad_mid)

        use geometry

        implicit none

        type(tensor) :: disp_mid
        type(point) :: grad_mid 

        fluxd_vel_usg_tenf = disp_mid.cross.grad_mid

        return

      end function fluxd_vel_usg_tenf

      end module mod_fluxd_usg
#endif
