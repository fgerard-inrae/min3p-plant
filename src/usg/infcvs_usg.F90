!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/infcvs_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine infcvs_usg
!c -----------------
!c
!c compute influence coefficients (variably saturated flow)
!c for USG mesh
!c
!c
!c                        /|   ij, K_ij
!c                       / | /
!c                      /  |/
!c                     |   /
!c            K_i      |  /|           K_j
!c            *--------|-*-------------*
!c            i d_i,ij |  \|  d_j,ij   j
!c                     |   \
!c                     |  / \
!c                     | /   A_ij
!c
!c
!c written by:      Danyang Su - Aug 01, 2016
!c
!c last modified:
!c
!c reference:       Hiroaki Nishikawa, 2010, Beyond Interface Gradient:
!c                  A General Principle for Constructing Diffusion Schemes
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           cinfvs(njavs)      = influence coefficients              * +
!c                                (variably saturated flow)
!c           permij(njavs)      = permeability                        * +
!c           delx(nvx)          = spatial increment in x-direction    + -
!c           dely(nvy)          = spatial increment in y-direction    + -
!c           delz(nvz)          = spatial increment in z-direction    + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           perm_fac(nn)       = scaling factor for permeability     + -
!c                                as a function of porosity changes
!c
!c           integer*4:
!c           ----------
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c
!c           logical:
!c           --------
!c           half_cells         = .true.  -> half cells on boundary   + -
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c
!c phys.f:   real*8:
!c           -------
!c           condxx(nzn)        = saturated hydraulic conductivity    + -
!c                                in x-direction
!c           condyy(nzn)        = saturated hydraulic conductivity    + -
!c                                in y-direction
!c           condzz(nzn)        = saturated hydraulic conductivity    + -
!c                                in z-direction
!c           permx(nn)          = saturated permeability in           + -
!c                                x-direction
!c           permy(nn)          = saturated permeability in           + -
!c                                y-direction
!c           permz(nn)          = saturated permeability in           + -
!c                                z-direction
!c
!c           logical:
!c           --------
!c           permeability_field = .true.  -> read permeability field  + -
!c                                .false. -> specify permeabilities
!c                                           in input file
!c
!c local:    real*8:
!c           -------
!c           areaf              = interfacial area
!c           delx_i             = interfacial distance i-ij in 
!c                                x-direction
!c           delx_j             = interfacial distance j-ij in
!c                                x-direction
!c           dely_i             = interfacial distance i-ij in
!c                                y-direction
!c           dely_j             = interfacial distance j-ij in
!c                                y-direction
!c           delz_i             = interfacial distance i-ij in
!c                                z-direction
!c           delz_j             = interfacial distance j-ij in
!c                                z-direction
!c           cxx_i              = hydraulic conductivity in
!c                                x-direction (control volume i)
!c           cxx_j              = hydraulic conductivity in
!c                                x-direction (control volume j)
!c           cyy_i              = hydraulic conductivity in
!c                                y-direction (control volume i)
!c           cyy_j              = hydraulic conductivity in
!c                                y-direction (control volume j)
!c           czz_i              = hydraulic conductivity in
!c                                z-direction (control volume i)
!c           czz_j              = hydraulic conductivity in
!c                                z-direction (control volume j)
!c           cxx_ij             = intermediate value (harmonic mean - 
!c                                interfacial hydraulic conductivity 
!c                                in x) 
!c           cyy_ij             = intermediate value (harmonic mean -
!c                                interfacial hydraulic conductivity 
!c                                in y)
!c           czz_ij             = intermediate value (harmonic mean -
!c                                interfacial hydraulic conductivity 
!c                                in z)
!c           rhalf              = constant
!c           
!c           integer*4:
!c           ----------
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           ivol               = pointer (current control volume)
!c           ivxp               = pointer (previous control 
!c                                volume in x-direction) 
!c           ivxn               = pointer (next control volume in 
!c                                x-direction)
!c           ivyp               = pointer (previous control
!c                                volume in y-direction)
!c           ivyn               = pointer (next control volume in
!c                                y-direction)
!c           ivzp               = pointer (previous control
!c                                volume in z-direction)
!c           ivzn               = pointer (next control volume in
!c                                z-direction)
!c           izn                = pointer (material property zone)
!c           jtemp              = pointer to colum entries
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
      subroutine infcvs_usg
 
      use parm
      use gen
      use phys
      use math_common, only : math_common_harmonic
      use chem, only : ng
      use dgml, only : dgm
      use m_heat_transport, only : heat_transport, energy_balance      
      
#ifdef OPENMP      
      use omp_lib
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use geometry
      use geometry_definition
      use usg_mesh_data, only : nodes, CellCenter, cvol_method,        &
                                num_edge_dvols, num_edge_maxcells,     &
                                node_num_cells, node_cells,            &
                                cell_projection, CellCvolFaceArea,     &
                                CellCvolFaceUnitNorm,                  &
                                CellCvolFace_cond,                     &
                                CellCvolFace_cond_tensor,              &
                                get_cell_edge_cvol_id

      implicit none
      
      real*8 :: r0, rhalf, r1, r2, rkelvin, pi, rsmallarea, rverysmall

      parameter (r0 = 0.0d0, rhalf = 0.5d0, r1 = 1.0d0, r2=2.0d0,      &
                 pi = 3.141592653589793d0, rsmallarea = 1.0d-8,        &
                 rkelvin=273.15d0, rverysmall = 1.0d-100)
      
      integer :: i1, info_debug, istart, iend, ivol, irow, izn,        &
                 jtemp, jvol, jzn, icell, idvol, ivol_track, ivol_gbl, &
                 icell2, idvol_r, iedge_r, kvol, ncell

      real*8 :: cxx_i, cyy_i, czz_i,cxx_j, cyy_j, czz_j,               &
                cxyz_i, cxyz_j, cxyz_ij, cxx, cyy, czz,                &
                delxyz_i, delxyz_j, convk, ratio, perm_fac_ij,         &
                alpha, beta, cvolfacearea, rswitch

      type(point) :: tend, wtend, utend, vtend, ntend, aca_av

      type(tensor) :: tenf_cond_i, tenf_cond_j, tenf_cond,             &
                      tenf_perm_i, tenf_perm_j, tenf_perm, rml, rmr

      real*8 :: relcond_freezing

      external :: relcond_freezing

      real*8 :: pressure_melt_k
      external :: pressure_melt_k

!cprovi-----------------------------------------------------------------------

#ifdef DEBUG
      if(iter_vs.eq.0) then
        info_debug = -1
        ivol_track = -1
      else
        info_debug = -1
        ivol_track = -1
      end if
#endif

      convk = visc_h2o/(dens_h2o * gacc)  !conductivity * convk = permeability
      
!c  initialize pointer to current control volume

!c  loop over control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_infcvs_1)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, istart, iend, izn, icell, icell2,             &
    !$omp idvol, idvol_r, iedge_r, jvol, jzn, kvol,                   &
    !$omp cvolfacearea, cxx, cyy, czz, cxx_i, cyy_i, czz_i,           &
    !$omp cxx_j, cyy_j, czz_j, delxyz_i, delxyz_j,                    &
    !$omp perm_fac_ij, rswitch, ratio, ncell, aca_av, rml, rmr,       &
    !$omp tenf_cond_i, tenf_cond_j, tenf_cond,                        &
    !$omp tenf_perm_i, tenf_perm_j, tenf_perm,                        &
    !$omp tend, ntend, wtend, utend, vtend)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl

!c  assign conductivities for current control volume

        if (.not. is_cell_based_perm_cond) then

          izn = mpropvs(ivol)       !retrieve material properties

          if (type_cond_perm == 1) then          
            if (permeability_field) then
              cxx_i = permx(ivol)       !assign hydraulic conductivities
              cyy_i = permy(ivol)
              czz_i = permz(ivol)
            else
              cxx_i = condxx(izn)*k_depth_ratio(ivol)       !assign hydraulic conductivities
              cyy_i = condyy(izn)*k_depth_ratio(ivol)
              czz_i = condzz(izn)*k_depth_ratio(ivol)
  
              permx(ivol) = cxx_i*convk       !hydraulic permeabilities
              permy(ivol) = cyy_i*convk       !conductivity: obsolete
              permz(ivol) = czz_i*convk  
            end if

!c  permeability update due to porosity changes

            if (update_permeability.or.update_permeability_flow) then
              cxx_i = perm_fac(ivol)*cxx_i
              cyy_i = perm_fac(ivol)*cyy_i
              czz_i = perm_fac(ivol)*czz_i
            end if
          else if (type_cond_perm == 2) then
            if (permeability_field) then    
              tenf_cond_i = perm_tensor(ivol)                          !assign hydraulic conductivities
            else
              tenf_cond_i = cond_tensor(izn)*k_depth_ratio(ivol)       !assign hydraulic conductivities
              perm_tensor(ivol) = tenf_cond_i*convk
            end if

!c  permeability update due to porosity changes

            if (update_permeability.or.update_permeability_flow) then
              tenf_cond_i = tenf_cond_i*perm_fac(ivol)
            end if
          end if

        end if


!c  assign interfacial distances of current control volume
        istart = iavs(ivol)+1
        iend = iavs(ivol+1)-1
        do jtemp = istart, iend
          jvol = javs(jtemp)

          delxyz_i = rhalf*jaedgelen(jtemp)
          delxyz_j = delxyz_i

          if (.not. is_cell_based_perm_cond) then

            jzn = mpropvs(jvol)

            if (type_cond_perm == 1) then
              if (permeability_field) then
                cxx_j = permx(jvol)
                cyy_j = permy(jvol)
                czz_j = permz(jvol)
              else
                cxx_j = condxx(jzn)*k_depth_ratio(jvol)
                cyy_j = condyy(jzn)*k_depth_ratio(jvol)
                czz_j = condzz(jzn)*k_depth_ratio(jvol)
              end if
  
              if (update_permeability.or.update_permeability_flow) then
                cxx_j = perm_fac(jvol)*cxx_j
                cyy_j = perm_fac(jvol)*cyy_j
                czz_j = perm_fac(jvol)*czz_j
              end if

              !c weighted harmonic average, midpoint, weight = 1.0
              !c check coordinate system to avoid dividing by zero
              if (cell_projection == projection_yz) then
                cxx = 0.0d0
              else
                cxx = math_common_harmonic(cxx_i,cxx_j)
              end if
  
              if (cell_projection == projection_xz) then
                cyy = 0.0d0
              else
                cyy = math_common_harmonic(cyy_i,cyy_j)
              end if
  
              if (cell_projection == projection_xy) then
                czz = 0.0d0
              else
                czz = math_common_harmonic(czz_i,czz_j)
              end if            

              tend = math_common_set_vector(cxx,cyy,czz)

#ifdef DEBUG
              if (info_debug > 10 .and. (ivol == ivol_track .or.       &
                  ivol_track == 0)) then
                write(idbg,*) "--> infcvs_usg-cxx",cxx,                &
                              "cyy",cyy,"czz",czz,                     &
                              "edgeunitdirection",                     &
                              jaedgeunitdirection(jtemp)%x,            &
                              jaedgeunitdirection(jtemp)%y,            &
                              jaedgeunitdirection(jtemp)%z
              end if
#endif

            else if (type_cond_perm == 2) then
              if (permeability_field) then
                tenf_cond_j = perm_tensor(jvol)
              else
                tenf_cond_j = cond_tensor(jzn)*k_depth_ratio(jvol)
              end if
  
              if (update_permeability.or.update_permeability_flow) then
                tenf_cond_j = tenf_cond_j*perm_fac(jvol)
              end if

              !c weighted harmonic average, midpoint, weight = 1.0
              !c check coordinate system to avoid dividing by zero
              tenf_cond = math_common_harmonic(tenf_cond_i, tenf_cond_j)
              
            end if

          end if

          do icell = 1, janumcell(jtemp)   !c loop over all linked cells
            icell2 = jacell(icell,jtemp)
            if (icell2 <= 0) then
              cycle
            end if

            if (is_cell_based_perm_cond) then

              jzn = mpropvs_cell(icell2)

              if (type_cond_perm == 1) then
                if (permeability_field) then
                  cxx = permx(icell2)
                  cyy = permy(icell2)
                  czz = permz(icell2)
                else
                  cxx = condxx(jzn)*k_depth_ratio(icell2)
                  cyy = condyy(jzn)*k_depth_ratio(icell2)
                  czz = condzz(jzn)*k_depth_ratio(icell2)
                end if
  
                if (update_permeability.or.update_permeability_flow) then
                  perm_fac_ij = (perm_fac(ivol)+perm_fac(jvol))*rhalf
                  cxx = perm_fac_ij*cxx
                  cyy = perm_fac_ij*cyy
                  czz = perm_fac_ij*czz
                end if
  
                tend = math_common_set_vector(cxx,cyy,czz)
              else if (type_cond_perm == 2) then
                if (permeability_field) then
                  tenf_cond = perm_tensor(icell2)
                else
                  tenf_cond = cond_tensor(jzn)*k_depth_ratio(icell2)
                end if
  
                if (update_permeability.or.update_permeability_flow) then
                  perm_fac_ij = (perm_fac(ivol)+perm_fac(jvol))*rhalf
                  tenf_cond = tenf_cond*perm_fac_ij
                end if
              end if

            end if

            do idvol = 1, num_edge_dvols   !c loop over all dual volumes
              call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,       &
                                         idvol_r,iedge_r,rswitch)
              cvolfacearea = CellCvolFaceArea(idvol_r,iedge_r,icell2)

              if(jacell(icell,jtemp) > 0 .and. cvolfacearea > rsmallarea) then

                !c save hydraulic conductivity tensor

                if (rswitch > r0) then
                  if (useAnisoCondCorr) then
                    if (type_cond_perm == 1) then
                      tenf_cond = tensor_zero
                      tenf_cond%xx = tend%x
                      tenf_cond%yy = tend%y
                      tenf_cond%zz = tend%z
                    end if
                    aca_av = (aca_vol(ivol) + aca_vol(jvol))*rhalf
                    call geometry_cal_rotation_matrix(aca_av,rml,rmr)
                    tenf_cond = (rml.dot.tenf_cond).dot.rmr
                    CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2) = tenf_cond
                  else
                    if (type_cond_perm == 1) then
                      CellCvolFace_cond(idvol_r,iedge_r,icell2) = tend
                    else if (type_cond_perm == 2) then
                      CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2) = tenf_cond
                    end if
                  end if


                  if (b_water_freezing_cond) then
                    if (tkel(ivol) < pressure_melt_k(ivol,r0) .or.           &
                        tkel(jvol) < pressure_melt_k(jvol,r0)) then
                      if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
                        CellCvolFace_cond(idvol_r,iedge_r,icell2) =          &
                                     vector_one*water_freezing_cond
                      else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                        CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2) =   &
                                     tensor_one*water_freezing_cond
                      end if
                    end if
                  else if (b_water_freezing_curve) then
                    if (tkel(ivol) < pressure_melt_k(ivol,r0) .or.           &
                        tkel(jvol) < pressure_melt_k(jvol,r0)) then                          
                      ratio = relcond_freezing((tkel(ivol)+tkel(jvol))/r2-rkelvin, &
                                               (uvsnew(ivol)+uvsnew(jvol))/r2)
                      if (type_cond_perm == 1 .and. .not.useAnisoCondCorr) then
                        CellCvolFace_cond(idvol_r,iedge_r,icell2) =          &
                          CellCvolFace_cond(idvol_r,iedge_r,icell2)*ratio
                      else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
                        CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2) =   &
                          CellCvolFace_cond_tensor(idvol_r,iedge_r,icell2)*ratio
                      end if
                    end if
                  end if

                end if

              end if

            end do
          end do

          if (heat_transport) then
            distcells(jtemp,1) = delxyz_i
            distcells(jtemp,2) = delxyz_j
          end if

        end do

      end do                                !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.1) then
        if (rank == 0) then  
          write(*,*) 'program stopped by dbg in infcvs_usg.F90'
          write(ilog,*) 'program stopped by dbg in infcvs_usg.F90'
        end if  
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
#endif
!cdbg

      return
      end
#endif
