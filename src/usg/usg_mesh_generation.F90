!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/usg_mesh_generation.F90 $
!---------------------------------------------------------------------
!********************************************************************!


! --------------------------------------------------------------------
!> Module of unstructured grid mesh generation
!>
!> Module description:
!>
!> Written by:    Danyang Su - May. 11, 2016
!> Last modified:
! --------------------------------------------------------------------


module usg_mesh_generation


#ifdef CGAL
  use cgal_polygon_iface
  use cgal_triangulation_2d_iface
  use cgal_triangulation_3d_iface
  use cgal_make_mesh_2d_iface
  use cgal_make_mesh_3d_iface
  use cgal_make_mesh_3d_polyhedra_iface
#endif

  use gms_mesh_domain
  use geometry_definition
  use file_unit, only : lun_get, lun_free
  use gen, only : ilog, idbg, prefix, l_prfx, rank, b_enable_output

#ifdef PETSC
  use petsc_mpi_common, only : petsc_mpi_finalize
#endif


  implicit none

  real*8, parameter :: pi = 3.141592653589793d0

  private

  public usg_mesh_set_input_file, usg_mesh_set_output_file,            &
         usg_mesh_from_struct_grid, usg_mesh_from_struct_boundary,     &
         usg_mesh_from_script_file, usg_mesh_from_scalar_points,       &
         usg_mesh_use_struct_grid

  character(256) :: str_usg_mesh_input_file

  character(256) :: str_usg_mesh_output_file

  character(6) :: str_usg_mesh_format

  contains

  !c set unstructured grid input file
  subroutine usg_mesh_set_input_file(strfile)

    implicit none

    character(len=*), intent(in) :: strfile

    str_usg_mesh_input_file = strfile

  end subroutine usg_mesh_set_input_file

  !c set unstructured grid output file
  subroutine usg_mesh_set_output_file(strfile, strformat)

    implicit none

    character(len=*), intent(in) :: strfile, strformat

    str_usg_mesh_output_file = strfile
    str_usg_mesh_format = strformat

  end subroutine usg_mesh_set_output_file

  !c generate unstructured grid format use the same structured grid
  subroutine usg_mesh_use_struct_grid(nvx, nvy, nvz, xlat, ylat, zlat,strfile)

    use gen, only : ascii_fmt

    implicit none

    !c passed variables
    integer, intent(in) :: nvx, nvy, nvz
    real*8, allocatable :: xlat(:), ylat(:), zlat(:)
    character(len=*), intent(in) :: strfile

    !c local variables
    integer :: iunit, ivx, ivy, ivz, ivol, nvols, iele, neles, nelevtx
    type(point), allocatable :: pts(:)
    integer, allocatable :: elements(:,:)
    real*8, parameter :: r0 = 0.0d0

    nelevtx = 4

    if (nvx > 1 .and. nvy > 1 .and. nvz > 1) then
      nelevtx = 8

      neles = (nvx-1)*(nvy-1)*(nvz-1)
      allocate(elements(8,neles))
    else if (nvx > 1 .and. nvy > 1) then
      neles = (nvx-1)*(nvy-1)
      allocate(elements(4,neles))
    else if (nvy > 1 .and. nvz > 1) then
      neles = (nvy-1)*(nvz-1)
      allocate(elements(4,neles))
    else if (nvx > 1 .and. nvz > 1) then
      neles = (nvx-1)*(nvz-1)
      allocate(elements(4,neles))
    else
      return
    end if

    nvols = nvx*nvy*nvz
    allocate(pts(nvols))

    !c set node coordinates
    ivol = 0
    do ivz = 1, nvz
      do ivy = 1, nvy
        do ivx = 1, nvx
          ivol = ivol + 1
          pts(ivol)%x = xlat(ivx)
          pts(ivol)%y = ylat(ivy)
          pts(ivol)%z = zlat(ivz)
        end do
      end do
    end do

    !c set cell-node index
    iele = 0
    if (nvx > 1 .and. nvy > 1 .and. nvz > 1) then
      do ivz = 1, nvz-1
        do ivy = 1, nvy-1
          do ivx = 1, nvx-1
            iele = iele + 1
            ivol = (ivz-1)*nvx*nvy+(ivy-1)*nvx+ivx
            elements(1,iele) = ivol
            elements(2,iele) = ivol+1
            elements(3,iele) = ivol+1+nvx
            elements(4,iele) = ivol+nvx
            elements(5,iele) = ivol+nvx*nvy
            elements(6,iele) = ivol+1+nvx*nvy
            elements(7,iele) = ivol+1+nvx+nvx*nvy
            elements(8,iele) = ivol+nvx+nvx*nvy
          end do
        end do
      end do
    else if (nvx > 1 .and. nvy > 1) then
      do ivy = 1, nvy-1
        do ivx = 1, nvx-1
          iele = iele + 1
          ivol = (ivy-1)*nvx+ivx
          elements(1,iele) = ivol
          elements(2,iele) = ivol+1
          elements(3,iele) = ivol+1+nvx
          elements(4,iele) = ivol+nvx
        end do
      end do
    else if (nvy > 1 .and. nvz > 1) then
      do ivz = 1, nvz-1
        do ivy = 1, nvy-1
          iele = iele + 1
          ivol = (ivz-1)*nvy+ivy
          elements(1,iele) = ivol
          elements(2,iele) = ivol+1
          elements(3,iele) = ivol+1+nvy
          elements(4,iele) = ivol+nvy
        end do
      end do
    else if (nvx > 1 .and. nvz > 1) then
      do ivz = 1, nvz-1
        do ivx = 1, nvx-1
          iele = iele + 1
          ivol = (ivz-1)*nvx+ivx
          elements(1,iele) = ivol
          elements(2,iele) = ivol+1
          elements(3,iele) = ivol+1+nvx
          elements(4,iele) = ivol+nvx
        end do
      end do
    end if

    !c write data back to vtk file
    iunit = lun_get()
    open(iunit,file=trim(strfile),status='unknown',form='formatted')

    !c write version information
    write(iunit,'(a)') "# vtk DataFile Version 2.0"

    !c write title
    if (nelevtx == 4) then
      write(iunit,'(a)') "2D Structured Grid in vtk Format"
    else if (nelevtx == 8) then
      write(iunit,'(a)') "3D Structured Grid in vtk Format"
    end if

    !c indicate ascii or binary data
    write(iunit,'(a)') "ASCII"

    !c write dataset head
    write(iunit,'(a)') "DATASET UNSTRUCTURED_GRID"

    !c write nodes
    write(iunit,'(a,1x,i12,1x,a)') "POINTS",nvols,"double"
    do ivol = 1, nvols
      write(iunit,ascii_fmt) pts(ivol)%x,pts(ivol)%y,pts(ivol)%z
    end do

    !c write cells
    write(iunit,'(a,2(1x,i12))') "CELLS",neles,neles*(nelevtx+1)
    do iele = 1, neles
      write(iunit,'(i3)',advance='no') nelevtx
      do ivol = 1, nelevtx
        write(iunit,'(8(1x,i0))',advance='no') elements(ivol,iele)-1
      end do
      write(iunit,'(/,a)') ' '
      backspace(iunit)
    end do

    !c write cell types
    write(iunit,'(a,1x,i12)') "CELL_TYPES",neles
    if (nelevtx == 4) then
      do iele = 1, neles
        write(iunit,'(i1)') 9
      end do
    else if (nelevtx == 8) then
      do iele = 1, neles
        write(iunit,'(i2)') 12
      end do
    end if
    close(iunit)
    call lun_free(iunit)

    !c deallocate memory after use
    deallocate(pts)
    deallocate(elements)

  end subroutine usg_mesh_use_struct_grid


  !c generate unstructured grid based on the structured grid
  subroutine usg_mesh_from_struct_grid(nvx, nvy, nvz, xlat, ylat, zlat)

    implicit none

    !c passed variables
    integer, intent(in) :: nvx, nvy, nvz
    real*8, allocatable :: xlat(:), ylat(:), zlat(:)

#ifdef CGAL

    !c local variables
    integer :: ivx, ivy, ivz, nvols, ivol
    type(point3d_c), allocatable :: pts_3d(:)
    type(point2d_c), allocatable :: pts_2d(:)

    ivol = 0
    nvols = nvx*nvy*nvz
    if (nvx > 1 .and. nvy > 1 .and. nvz > 1) then
      allocate(pts_3d(nvols))
      do ivz = 1, nvz
        do ivy = 1, nvy
          do ivx = 1, nvx
            ivol = ivol + 1
            pts_3d(ivol)%x = xlat(ivx)
            pts_3d(ivol)%y = ylat(ivy)
            pts_3d(ivol)%z = zlat(ivz)
          end do
        end do
      end do
      !c set grid points
      call cgal_set_mesh_points_3d(nvols, pts_3d)
      !c triangulation
      call cgal_triangulation_3d
      !c output mesh file
      call cgal_output_mesh_3d(trim(str_usg_mesh_output_file),         &
                trim(str_usg_mesh_format))
      deallocate(pts_3d)
    else if (nvx > 1 .and. nvy > 1) then
      allocate(pts_2d(nvols))
      do ivy = 1, nvy
        do ivx = 1, nvx
          ivol = ivol + 1
          pts_2d(ivol)%x = xlat(ivx)
          pts_2d(ivol)%y = ylat(ivy)
        end do
      end do
      !c set grid points
      call cgal_set_mesh_points_tri2d(nvols,pts_2d)
      !c triangulation
      call cgal_make_mesh_tri2d
      !c output mesh
      call cgal_output_mesh_tri2d(0, trim(str_usg_mesh_output_file),   &
                trim(str_usg_mesh_format))
      deallocate(pts_2d)
    else if (nvy > 1 .and. nvz > 1) then
      allocate(pts_2d(nvols))
      do ivz = 1, nvz
        do ivy = 1, nvy
          ivol = ivol + 1
          pts_2d(ivol)%x = ylat(ivy)
          pts_2d(ivol)%y = zlat(ivz)
        end do
      end do
      !c set grid points
      call cgal_set_mesh_points_tri2d(nvols,pts_2d)
      !c triangulation
      call cgal_make_mesh_tri2d
      !c output mesh
      call cgal_output_mesh_tri2d(1, trim(str_usg_mesh_output_file),   &
                trim(str_usg_mesh_format))
      deallocate(pts_2d)
    else if (nvx > 1 .and. nvz > 1) then
      allocate(pts_2d(nvols))
      do ivz = 1, nvz
        do ivx = 1, nvx
          ivol = ivol + 1
          pts_2d(ivol)%x = xlat(ivx)
          pts_2d(ivol)%y = zlat(ivz)
        end do
      end do
      !c set grid points
      call cgal_set_mesh_points_tri2d(nvols,pts_2d)
      !c triangulation
      call cgal_make_mesh_tri2d
      !c output mesh
      call cgal_output_mesh_tri2d(2, trim(str_usg_mesh_output_file),   &
                trim(str_usg_mesh_format))
      deallocate(pts_2d)
    end if

#endif

  end subroutine usg_mesh_from_struct_grid

  !c generate unstructured grid based on the given scalar points
  subroutine usg_mesh_from_scalar_points(strfile)

    use file_unit, only : lun_get, lun_free
    use file_utility, only : findnextline, readnextline

    implicit none

    !c passed variables
    character(len=*), intent(in) :: strfile

#ifdef CGAL
    !c local variables
    integer :: iunit, istat
    logical :: bstat
    character(2048) :: strbuffer
    character(256) :: pointlable
    integer :: nvols, ivol
    type(point3d_c), allocatable :: pts_3d(:)
    type(point2d_c), allocatable :: pts_2d(:)

    !c open file
    inquire(file = trim(adjustl(strfile)), exist = bstat)
    if (.not.bstat) then
      goto 991
    end if

    iunit = lun_get()
    open(unit=iunit, file = trim(adjustl(strfile)), iostat = istat)

    if (istat /= 0) then
      goto 992
    end if

    nvols = 0
    pointlable = ""
    if(readnextline(iunit, strbuffer, withquote=.false.)) then
      read(strbuffer,*,err=993,end=993) nvols,pointlable
      if (trim(adjustl(pointlable)) /= "xy" .and.                      &
          trim(adjustl(pointlable)) /= "yz" .and.                      &
          trim(adjustl(pointlable)) /= "xz" .and.                      &
          trim(adjustl(pointlable)) /= "xyz") then
        goto 993
      end if
    end if


    if (trim(adjustl(pointlable)) == "xyz") then
      allocate(pts_3d(nvols))
      do ivol = 1, nvols
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*) pts_3d(ivol)%x, pts_3d(ivol)%y, pts_3d(ivol)%z
        end if
      end do
      !c set grid points
      call cgal_set_mesh_points_3d(nvols, pts_3d)
      !c triangulation
      call cgal_triangulation_3d
      !c output mesh file
      call cgal_output_mesh_3d(trim(str_usg_mesh_output_file),         &
                trim(str_usg_mesh_format))
      deallocate(pts_3d)
    else if (trim(adjustl(pointlable)) == "xy") then
      allocate(pts_2d(nvols))
      do ivol = 1, nvols
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*) pts_2d(ivol)%x, pts_2d(ivol)%y
        end if
      end do
      !c set grid points
      call cgal_set_mesh_points_tri2d(nvols,pts_2d)
      !c triangulation
      call cgal_make_mesh_tri2d
      !c output mesh
      call cgal_output_mesh_tri2d(0, trim(str_usg_mesh_output_file),   &
                trim(str_usg_mesh_format))
      deallocate(pts_2d)
    else if (trim(adjustl(pointlable)) == "yz") then
      allocate(pts_2d(nvols))
      do ivol = 1, nvols
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*) pts_2d(ivol)%x, pts_2d(ivol)%y
        end if
      end do
      !c set grid points
      call cgal_set_mesh_points_tri2d(nvols,pts_2d)
      !c triangulation
      call cgal_make_mesh_tri2d
      !c output mesh
      call cgal_output_mesh_tri2d(1, trim(str_usg_mesh_output_file),   &
                trim(str_usg_mesh_format))
      deallocate(pts_2d)
    else if (trim(adjustl(pointlable)) == "xz") then
      allocate(pts_2d(nvols))
      do ivol = 1, nvols
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*) pts_2d(ivol)%x, pts_2d(ivol)%y
        end if
      end do
      !c set grid points
      call cgal_set_mesh_points_tri2d(nvols,pts_2d)
      !c triangulation
      call cgal_make_mesh_tri2d
      !c output mesh
      call cgal_output_mesh_tri2d(2, trim(str_usg_mesh_output_file),   &
                trim(str_usg_mesh_format))
      deallocate(pts_2d)
    end if

    return


991 continue
    if (rank == 0) then
      write(*,*) 'error: unstructured scalar points file is missing'
      write(ilog,*) 'error: unstructured scalar points file is missing'
      close(ilog)
    end if

    goto 999

992 continue
    if (rank == 0) then
      write(*,*) 'error: cannot open file ', trim(strfile)
      write(ilog,*) 'error: cannot open file ', trim(strfile)
      close(ilog)
    end if

    goto 999

993 continue
    if (rank == 0) then
      write(*,*) 'error: data value is not correct'
      write(ilog,*) 'error: data value is not correct'
      close(ilog)
    end if

    goto 999

999 continue
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

#endif

  end subroutine usg_mesh_from_scalar_points

  !c create off mesh file from given box
  !c        v
  !c 3----------2         p0(xmin, ymin, zmin)
  !c |\     ^   |\        p1(xmax, ymin, zmin)
  !c | \    |   | \       p2(xmax, ymax, zmin)
  !c |  \   |   |  \      p3(xmin, ymax, zmin)
  !c |   7------+---6
  !c |   |  +-- |-- | -> u
  !c 0---+---\--1   |
  !c  \  |    \  \  |     p4(xmin, ymin, zmax)
  !c   \ |     \  \ |     p5(xmax, ymin, zmax)
  !c    \|      w  \|     p6(xmax, ymax, zmax)
  !c     4----------5     p7(xmin, ymax, zmax)
  subroutine create_off_mesh_from_box(strfile, xmin, ymin, zmin,       &
                    xmax, ymax, zmax)

    use file_unit, only : lun_get, lun_free

    implicit none
    !c pass variable
    character(len=*), intent(in) :: strfile
    real*8, intent(in) :: xmin, ymin, zmin, xmax, ymax, zmax

    !c local variable
    integer :: iunit

    iunit = lun_get()

    open(unit = iunit, file = trim(strfile))
    write(iunit,'(a)') "OFF"
    write(iunit,'(a)') "8 6 12"
    !c write vertices
    write(iunit,'(3(1pe15.6e3, 1x))') xmin, ymin, zmin
    write(iunit,'(3(1pe15.6e3, 1x))') xmax, ymin, zmin
    write(iunit,'(3(1pe15.6e3, 1x))') xmax, ymax, zmin
    write(iunit,'(3(1pe15.6e3, 1x))') xmin, ymax, zmin
    write(iunit,'(3(1pe15.6e3, 1x))') xmin, ymin, zmax
    write(iunit,'(3(1pe15.6e3, 1x))') xmax, ymin, zmax
    write(iunit,'(3(1pe15.6e3, 1x))') xmax, ymax, zmax
    write(iunit,'(3(1pe15.6e3, 1x))') xmin, ymax, zmax
    !c write faces
    write(iunit,'(a)') "4 0 1 2 3"
    write(iunit,'(a)') "4 7 6 5 4"
    write(iunit,'(a)') "4 0 3 7 4"
    write(iunit,'(a)') "4 6 2 1 5"
    write(iunit,'(a)') "4 1 0 4 5"
    write(iunit,'(a)') "4 6 7 3 2"

    close(iunit)

    call lun_free(iunit)

  end subroutine create_off_mesh_from_box

  !c generate unstructured grid based on the structured grid boundary
  subroutine usg_mesh_from_struct_boundary(nvx, nvy, nvz,              &
                 xlat, ylat, zlat)

    implicit none

    !c passed variables
    integer, intent(in) :: nvx, nvy, nvz
    real*8, allocatable :: xlat(:), ylat(:), zlat(:)

#ifdef CGAL
    !c local variables
    integer :: ivx, ivy, ivz, nvols, ivol, ipt, npts
    real*8 :: xmin, ymin, zmin, xmax, ymax, zmax
    real*8 :: deltx, delty, deltz, deltmin
    type(point2d_c), allocatable :: pts(:)
    character(256) :: strfile

    xmin = minval(xlat)
    ymin = minval(ylat)
    zmin = minval(zlat)
    xmax = maxval(xlat)
    ymax = maxval(ylat)
    zmax = maxval(zlat)

    deltx = (xmax-xmin)/nvx
    delty = (ymax-ymin)/nvy
    deltz = (zmax-zmin)/nvz

    if (nvx > 1 .and. nvy > 1 .and. nvz > 1) then

      deltmin = min(deltx,delty,deltz)

      !c create the polyhedra off file as the input file for polyhedra mesh generation
      strfile = prefix(:l_prfx)//'_box.off'
      call create_off_mesh_from_box(strfile, xmin, ymin, zmin,         &
                  xmax, ymax, zmax)
      !c initialize polyhedra domain
      call cgal_initialize_polydomain_3d()
      !c set polyhedra mesh input and output file
      call cgal_set_polydomain_iofile(strfile, str_usg_mesh_output_file)
      !c make polyhedra domain surface mesh
      call cgal_make_polydomain_surface_mesh()
      !c set polyhedra domain criteria
      call cgal_set_polydomain_criteria(deltmin,0.25d0,deltmin,deltmin,2.0d0,deltmin)
      !c set polyhedra mesh Lloyd optimization parameters
      call cgal_set_polydomain_opt_params_lloyd(10,10.0d0)
      !c set polyhedra mesh Exude optimization parameters
      call cgal_set_polydomain_opt_params_exude(10.0d0,10.0d0)
      !c set polyhedra mesh Perturb optimization parameters
      call cgal_set_polydomain_opt_params_perturb(10.0d0,10.0d0)
      !c make and output polyhedra domain mesh to the specific format
      call cgal_make_output_polydomain_mesh(str_usg_mesh_format)
    else if (nvx > 1 .and. nvy > 1) then

      deltmin = min(deltx,delty)

      npts = 2*(nvx+nvy)-4
      allocate(pts(npts))
      ipt = 0
      do ivx = 1, nvx
        ipt = ipt + 1
        pts(ipt)%x = xlat(ivx)
        pts(ipt)%y = ylat(1)
      end do
      do ivy = 2, nvy-1
        ipt = ipt + 1
        pts(ipt)%x = xlat(nvx)
        pts(ipt)%y = ylat(ivy)
      end do
      do ivx = nvx, 1, -1
        ipt = ipt + 1
        pts(ipt)%x = xlat(ivx)
        pts(ipt)%y = ylat(nvy)
      end do
      do ivy = nvy-1, 2, -1
        ipt = ipt + 1
        pts(ipt)%x = xlat(1)
        pts(ipt)%y = ylat(ivy)
      end do
      !c set outer boundary
      call cgal_insert_constraint(npts, pts, .true.)
      !c set criteria
      call cgal_set_criteria(0.25d0, deltmin)
      !c make and refine mesh
      call cgal_make_refine_mesh()
      !c optimize mesh
      call cgal_optimize_mesh(10)
      !c output mesh
      call cgal_output_mesh(0, trim(str_usg_mesh_output_file),         &
                trim(str_usg_mesh_format))
      deallocate(pts)
    else if (nvy > 1 .and. nvz > 1) then

      deltmin = min(delty,deltz)

      npts = 2*(nvy+nvz)-4
      allocate(pts(npts))
      ipt = 0
      do ivy = 1, nvy
        ipt = ipt + 1
        pts(ipt)%x = ylat(ivy)
        pts(ipt)%y = zlat(1)
      end do
      do ivz = 2, nvz-1
        ipt = ipt + 1
        pts(ipt)%x = ylat(nvy)
        pts(ipt)%y = zlat(ivz)
      end do
      do ivy = nvy, 1, -1
        ipt = ipt + 1
        pts(ipt)%x = ylat(ivy)
        pts(ipt)%y = zlat(nvz)
      end do
      do ivz = nvz-1, 2, -1
        ipt = ipt + 1
        pts(ipt)%x = ylat(1)
        pts(ipt)%y = zlat(ivz)
      end do
      !c set outer boundary
      call cgal_insert_constraint(npts, pts, .true.)
      !c set criteria
      call cgal_set_criteria(0.25d0, deltmin)
      !c make and refine mesh
      call cgal_make_refine_mesh()
      !c optimize mesh
      call cgal_optimize_mesh(10)
      !c output mesh
      call cgal_output_mesh(1, trim(str_usg_mesh_output_file),         &
                trim(str_usg_mesh_format))
      deallocate(pts)
    else if (nvx > 1 .and. nvz > 1) then

      deltmin = min(deltx,deltz)

      npts = 2*(nvx+nvz)-4
      allocate(pts(npts))
      ipt = 0
      do ivx = 1, nvx
        ipt = ipt + 1
        pts(ipt)%x = xlat(ivx)
        pts(ipt)%y = zlat(1)
      end do
      do ivz = 2, nvz-1
        ipt = ipt + 1
        pts(ipt)%x = xlat(nvx)
        pts(ipt)%y = zlat(ivz)
      end do
      do ivx = nvx, 1, -1
        ipt = ipt + 1
        pts(ipt)%x = xlat(ivx)
        pts(ipt)%y = zlat(nvz)
      end do
      do ivz = nvz-1, 2, -1
        ipt = ipt + 1
        pts(ipt)%x = xlat(1)
        pts(ipt)%y = zlat(ivz)
      end do
      !c set outer boundary
      write(*,*) "set outer boundary"
      call cgal_insert_constraint(npts, pts, .true.)
      !c set criteria
      write(*,*) "set criteria, deltmin ", deltmin
      call cgal_set_criteria(0.25d0, deltmin)
      !c make and refine mesh
      write(*,*) "make and refine mesh"
      call cgal_make_refine_mesh()
      !c optimize mesh
      write(*,*) "optimize mesh"
      call cgal_optimize_mesh(10)
      !c output mesh
      write(*,*) "output mesh"
      call cgal_output_mesh(2, trim(str_usg_mesh_output_file),         &
                trim(str_usg_mesh_format))
      deallocate(pts)
    end if

#endif

  end subroutine usg_mesh_from_struct_boundary

  !c generate unstructured mesh from given external file
  !c
  subroutine usg_mesh_from_script_file(strfile)

    use file_unit, only : lun_get, lun_free

    use file_utility, only : findnextline, readnextline

    implicit none

    character(len=*), intent(in) :: strfile

    !c local variables
    character(2048) :: strbuffer
    character(256) :: subsection, subcommand
    character(256) :: strconstraint, strfilepath, subdomain_name
    character(12) :: type_gms_3d
    logical :: bstat, bfound, isclosed, ispolygon,                     &
               ismixed, isclosedmixed, isendmixed
    integer :: iunit, istat
    integer :: i, j, k, itypeCoordinate, num_constraints, num_pts,     &
               num_seeds, num_opt_iterations, num_subdomains,          &
               subdomain_id, num_node_layers, ilayer_start, ilayer_end
    type(point3d_c), allocatable :: pts_3d(:)
    type(point2d_c), allocatable :: pts_2d(:), seeds_2d(:)
    real*8 :: xmin, ymin, zmin, xlen, ylen, zlen, xdelt, ydelt, zdelt, &
              subdomain_delt
    !c discretization intervals for each segment in polyline constraint
    real*8, allocatable :: seg_intervals(:)
    !c number of discretization for each segment in polyline constraint
    integer, allocatable :: seg_sizes(:)
    !c discretization intervals for arc/circle constraint
    real*8 :: arc_interval

    !c 2D mesh generation criteria
    real*8 :: shape_bound, max_edge
    !c 3D mesh generation criteria
    real*8 :: edge_size, facet_angle, facet_size, facet_dist,          &
              cell_radius_edge_ratio, global_size
    !c 3D optimization parameters
    logical :: b_opt_lloyd, b_opt_exude, b_opt_perturb
    integer :: opt_lloyd_iteration
    real*8 :: opt_lloyd_timelimit
    real*8 :: opt_exude_sliverbound, opt_exude_timelimit
    real*8 :: opt_perturb_sliverbound, opt_perturb_timelimit

    inquire(file = trim(adjustl(strfile)), exist = bstat)
    if (.not.bstat) then
      goto 991
    end if

    iunit = lun_get()
    open(unit=iunit, file = trim(adjustl(strfile)), iostat = istat)

    if (istat /= 0) then
      goto 992
    end if

#ifdef CGAL
    !c read 'polygon 2d delaunay mesh' script
    subsection = 'polygon 2d delaunay mesh'
    bfound = findnextline(iunit, subsection, 0, .true.)
    if (bfound) then
      num_constraints = 0
      num_seeds = 0
      shape_bound = 0.0d0
      max_edge = 0.0d0
      num_opt_iterations = 0
      itypeCoordinate = 0

      subcommand = 'coordinate projection'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.true.)) then
          if(trim(strbuffer) == 'xy') then
            itypeCoordinate = 0
          else if(trim(strbuffer) == 'yz') then
            itypeCoordinate = 1
          else if(trim(strbuffer) == 'xz') then
            itypeCoordinate = 2
          end if
        end if
      end if

      num_constraints = 0
      subcommand = 'number of constraints'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if (bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) num_constraints
        end if
      end if

      ismixed = .false.
      isclosedmixed = .false.
      isendmixed = .false.

      do i = 1, num_constraints
        ispolygon = .false.
        isclosed = .false.
        strconstraint = ""
        num_pts = 0
        arc_interval = 0.0d0

        if(allocated(pts_2d)) then
          deallocate(pts_2d)
        end if

        if (allocated(seg_intervals)) then
          deallocate(seg_intervals)
        end if

        if (allocated(seg_sizes)) then
          deallocate(seg_sizes)
        end if

        do while(readnextline(iunit, strbuffer, withquote=.true.))

          subcommand = trim(strbuffer)

          !write(*,*) "subcommand:",trim(subcommand)

          if(trim(subcommand) == 'constraint type') then
              if(readnextline(iunit, strbuffer, withquote=.true.)) then
                strconstraint = trim(strbuffer)

                if (.not.ismixed) then
                  if(index(strconstraint,'closed mixed constraint') > 0) then
                    ismixed = .true.
                    isclosedmixed = .true.
                    call cgal_insert_constraint_mixed_init
                    cycle
                  end if

                  if(index(strconstraint,'open mixed constraint') > 0) then
                    ismixed = .true.
                    isclosedmixed = .false.
                    call cgal_insert_constraint_mixed_init
                    cycle
                  end if

                end if

                if(index(strconstraint,'polygon') > 0) then
                  ispolygon = .true.
                else
                  ispolygon = .false.
                end if

                if(index(strconstraint,'closed') > 0) then
                  isclosed = .true.
                else
                  isclosed = .false.
                end if

              end if

          else if (trim(subcommand) == 'number of vertices') then
              if(readnextline(iunit, strbuffer, withquote=.false.)) then
                read(strbuffer,*,err=994,end=994) num_pts
                if(num_pts < 2) then
                  if(rank == 0) then
                    write(*,*) "Error: number of vertices should 2 or more"
                    write(ilog,*) "Error: number of vertices should 2 or more"
                  end if
                  goto 994
                end if
                allocate(pts_2d(num_pts))
              end if

          else if(trim(subcommand) == 'vertices coordinate') then
              if (.not.ispolygon .and. num_pts /= 3) then
                if(rank == 0) then
                  write(*,*) "Error: number of vertices should be 3 for arc constraint"
                  write(ilog,*) "Error: number of vertices should be 3 for arc constraint"
                end if
                goto 994
              else if (ispolygon .and. num_pts < 2) then
                if(rank == 0) then
                  write(*,*) "Error: number of vertices should be 2 or more"
                  write(ilog,*) "Error: number of vertices should be 2 or more"
                end if
                goto 994
              end if
              do j = 1, num_pts   !polygon coordinates
                if(readnextline(iunit, strbuffer, withquote=.false.)) then
                  read(strbuffer,*,err=994,end=994) pts_2d(j)%x, pts_2d(j)%y
                end if
              end do

          else if(trim(subcommand) == 'segment discretization interval') then
              if(ispolygon .and. isclosed) then
                allocate(seg_intervals(num_pts))
                do j = 1, num_pts
                  if(readnextline(iunit, strbuffer, withquote=.false.)) then
                    read(strbuffer,*,err=994,end=994) seg_intervals(j)
                  end if
                end do
              else if (ispolygon .and. .not. isclosed) then
                allocate(seg_intervals(num_pts-1))
                do j = 1, num_pts-1
                  if(readnextline(iunit, strbuffer, withquote=.false.)) then
                    read(strbuffer,*,err=994,end=994) seg_intervals(j)
                  end if
                end do
              end if

          else if(trim(subcommand) == 'segment discretization size') then
              if(ispolygon .and. isclosed) then
                allocate(seg_sizes(num_pts))
                do j = 1, num_pts
                  if(readnextline(iunit, strbuffer, withquote=.false.)) then
                    read(strbuffer,*,err=994,end=994) seg_sizes(j)
                  end if
                end do
              else if (ispolygon .and. .not. isclosed) then
                allocate(seg_sizes(num_pts-1))
                do j = 1, num_pts-1
                  if(readnextline(iunit, strbuffer, withquote=.false.)) then
                    read(strbuffer,*,err=994,end=994) seg_sizes(j)
                  end if
                end do
              end if

          else if(trim(subcommand) == 'arc discretization size') then
              if(readnextline(iunit, strbuffer, withquote=.false.)) then
                read(strbuffer,*,err=994,end=994) arc_interval
              end if

          else if(trim(subcommand) == 'end of constraint') then
            if(readnextline(iunit, strbuffer, withquote=.true.)) then
              if(trim(strbuffer) == 'end of mixed constraint') then
                isendmixed = .true.
              else
                backspace(iunit)
              end if
            end if

            exit
          end if

        end do

        !write(*,*) "ismixed:",ismixed," isendmixed:",isendmixed

        if (ismixed) then
          if(trim(strconstraint) == 'open polygon') then
            call cgal_insert_constraint_mixed(num_pts, pts_2d)
          else if(trim(strconstraint) ==                               &
                  'open polygon with sub discretization interval') then
            call cgal_insert_constraint_mixed(num_pts, pts_2d,         &
                      seg_intervals)
          else if(trim(strconstraint) ==                               &
                  'open polygon with sub discretization size') then
            call cgal_insert_constraint_mixed(num_pts, pts_2d,         &
                      seg_sizes)
          else if(trim(strconstraint) ==                               &
                  'open arc with sub discretization size') then
            call cgal_insert_constraint_mixed(pts_2d, arc_interval)
          end if

          if(isendmixed) then
            call cgal_insert_constraint_mixed_final(isclosedmixed)
            ismixed = .false.
            isclosedmixed = .false.
            isendmixed = .false.
          end if
        else
          if(trim(strconstraint) == 'closed polygon') then
            call cgal_insert_constraint(num_pts, pts_2d, isclosed)
          else if(trim(strconstraint) == 'open polygon') then
            call cgal_insert_constraint(num_pts, pts_2d, isclosed)
          else if(trim(strconstraint) ==                               &
                  'closed polygon with sub discretization interval') then
            call cgal_insert_constraint(num_pts, pts_2d,               &
                      seg_intervals, isclosed)
          else if(trim(strconstraint) ==                               &
                  'open polygon with sub discretization interval') then
            call cgal_insert_constraint(num_pts, pts_2d,               &
                      seg_intervals, isclosed)
          else if(trim(strconstraint) ==                               &
                  'closed polygon with sub discretization size') then
            call cgal_insert_constraint(num_pts, pts_2d,               &
                      seg_sizes, isclosed)
          else if(trim(strconstraint) ==                               &
                  'open polygon with sub discretization size') then
            call cgal_insert_constraint(num_pts, pts_2d,               &
                      seg_sizes, isclosed)
          else if(trim(strconstraint) ==                               &
                  'closed arc with sub discretization size') then
            call cgal_insert_constraint(pts_2d, arc_interval,          &
                      isclosed)
          else if(trim(strconstraint) ==                               &
                  'open arc with sub discretization size') then
            call cgal_insert_constraint(pts_2d, arc_interval, isclosed)
          end if
        end if

      end do

      num_seeds = 0
      subcommand = 'number of seeds'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) num_seeds
          if(allocated(seeds_2d)) then
            deallocate(seeds_2d)
          end if
          allocate(seeds_2d(num_seeds))
        end if
      end if

      subcommand = 'seeds coordinate'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        do j = 1, num_seeds
          if(readnextline(iunit, strbuffer, withquote=.false.)) then
            read(strbuffer,*,err=994,end=994) seeds_2d(j)%x, seeds_2d(j)%y
          end if
        end do
        if(num_seeds > 0) then
          call cgal_set_seeds(num_seeds, seeds_2d)
        end if
      end if

      subcommand = 'global domain mesh criteria'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) shape_bound, max_edge
          !By default, the first input parameter is shape_bound.
          !If this value is larger than 10.0, it is treated as angle in degree
          !Convert from angle to shape bound
          !shape_bound = b, where sin(alpha) = sqrt(b)
          if (shape_bound > 10.0d0) then
            shape_bound = (sin(shape_bound/180.0d0*pi))**2
          end if
          if (shape_bound > 0.25d0) then
            if(rank == 0 .and. b_enable_output) then
              write(ilog,'(2a)') "Warning: shape_bound larger than",   &
                    "0.25 or 30° does not guarantee termination"
            end if
          end if
          call cgal_set_criteria(shape_bound, max_edge)
        end if
      end if

      subcommand = 'mesh optimization iterations'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) num_opt_iterations
        end if
      end if

      !c make and refine mesh
      call cgal_make_refine_mesh()

      !c optimize mesh
      call cgal_optimize_mesh(num_opt_iterations)

      !c output mesh
      call cgal_output_mesh(itypeCoordinate,                           &
                trim(str_usg_mesh_output_file),trim(str_usg_mesh_format))

    end if

    !c read 'polyhedra 3d delaunay mesh' script
    subsection = 'polyhedra 3d delaunay mesh'
    bfound = findnextline(iunit, subsection, 0, .true.)
    if (bfound) then
      strfilepath = ""
      subcommand = 'domain file path'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.true., lowercase=.false.)) then
          strfilepath = trim(strbuffer)
        end if
      end if

      edge_size = 0.0
      facet_angle = 0.0
      facet_size = 0.0
      facet_dist = 0.0
      cell_radius_edge_ratio = 0.0
      global_size = 0.0
      subcommand = 'global domain mesh criteria'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) edge_size, facet_angle,    &
               facet_size, facet_dist, cell_radius_edge_ratio,         &
               global_size
        end if
      end if

      b_opt_lloyd = .false.
      b_opt_exude = .false.
      b_opt_perturb = .false.
      opt_lloyd_iteration = 0
      opt_lloyd_timelimit = 0.0d0
      opt_exude_sliverbound = 0.0d0
      opt_exude_timelimit = 0.0d0
      opt_perturb_sliverbound = 0.0d0
      opt_perturb_timelimit = 0.0d0

      subcommand = 'lloyd optimization parameters'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          b_opt_lloyd = .true.
          read(strbuffer,*,err=994,end=994) opt_lloyd_iteration,       &
                                            opt_lloyd_timelimit
        end if
      end if

      subcommand = 'exude optimization parameters'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          b_opt_exude = .true.
          read(strbuffer,*,err=994,end=994) opt_exude_sliverbound,     &
                                            opt_exude_timelimit
        end if
      end if

      subcommand = 'perturb optimization parameters'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          b_opt_perturb = .true.
          read(strbuffer,*,err=994,end=994) opt_perturb_sliverbound,   &
                                            opt_perturb_timelimit
        end if
      end if

      !c initialize polyhedra domain
      call cgal_initialize_polydomain_3d()

      !c set polyhedra mesh input and output file
      call cgal_set_polydomain_iofile(strfilepath,                     &
                                      str_usg_mesh_output_file)

      !c make polyhedra domain surface mesh
      call cgal_make_polydomain_surface_mesh()

      !c set polyhedra domain criteria
      call cgal_set_polydomain_criteria(edge_size, facet_angle,        &
                facet_size, facet_dist, cell_radius_edge_ratio,        &
                global_size)

      !c set polyhedra mesh Lloyd optimization parameters
      if(b_opt_lloyd) then
        call cgal_set_polydomain_opt_params_lloyd(opt_lloyd_iteration, &
                  opt_lloyd_timelimit)
      end if

      !c set polyhedra mesh Exude optimization parameters
      if(b_opt_exude) then
        call cgal_set_polydomain_opt_params_exude(                     &
                  opt_exude_sliverbound, opt_exude_timelimit)
      end if

      !c set polyhedra mesh Perturb optimization parameters
      if(b_opt_perturb) then
        call cgal_set_polydomain_opt_params_perturb(                   &
                  opt_perturb_sliverbound, opt_perturb_timelimit)
      end if

      !c make and output polyhedra domain mesh to specified format
      call cgal_make_output_polydomain_mesh(str_usg_mesh_format)

    end if

    !c read 'multidomain 3d delaunay mesh' script
    subsection = 'multidomain 3d delaunay mesh'
    bfound = findnextline(iunit, subsection, 0, .true.)
    if (bfound) then

      !c initialize domain
      call cgal_initialize_domain_3d()

      xmin = 0.0d0
      ymin = 0.0d0
      zmin = 0.0d0
      subcommand = 'global domain bottom left coordinates'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) xmin, ymin, zmin
        end if
      end if

      xlen = 0.0d0
      ylen = 0.0d0
      zlen = 0.0d0
      subcommand = 'global domain length in xyz direction'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) xlen, ylen, zlen
        end if
      end if

      xdelt = 0.0d0
      ydelt = 0.0d0
      zdelt = 0.0d0
      subcommand = 'global domain minimum discretization in xyz direction'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) xdelt, ydelt, zdelt
        end if
      end if

      !c set domain box
      call cgal_set_domain_box_3d(xmin, ymin, zmin, xlen, ylen, zlen,       &
                             xdelt, ydelt, zdelt)

      edge_size = 0.0
      facet_angle = 0.0
      facet_size = 0.0
      facet_dist = 0.0
      cell_radius_edge_ratio = 0.0
      global_size = 0.0
      subcommand = 'global domain mesh criteria'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) edge_size, facet_angle,    &
               facet_size, facet_dist, cell_radius_edge_ratio,         &
               global_size
        end if
      end if

      !c set domain criteria
      call cgal_set_domain_criteria_3d(edge_size,                      &
               facet_angle,facet_size, facet_dist,                     &
               cell_radius_edge_ratio, global_size)

      num_subdomains = 0
      subcommand = 'number of subdomains'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if (bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) num_subdomains
        end if
      end if

      do i = 1, num_subdomains

        subdomain_id = 0
        subdomain_name = ""
        subdomain_delt = 0.0d0
        strfilepath = ""

        do while(readnextline(iunit, strbuffer, withquote=.true.))

          subcommand = trim(strbuffer)

          if(trim(subcommand) == 'subdomain id') then
            if(readnextline(iunit, strbuffer, withquote=.false.)) then
              read(strbuffer,*,err=994,end=994) subdomain_id
            end if

          else if (trim(subcommand) == 'subdomain name') then
            if(readnextline(iunit, strbuffer, withquote=.true.)) then
              subdomain_name = trim(strbuffer)
            end if

          else if(trim(subcommand) == 'subdomain discretization size') then
            if(readnextline(iunit, strbuffer, withquote=.false.)) then
              read(strbuffer,*,err=994,end=994) subdomain_delt
            end if

          else if (trim(subcommand) == 'subdomain file path') then
            if(readnextline(iunit, strbuffer, withquote=.true., lowercase=.false.)) then
              strfilepath = trim(strbuffer)
            end if

          else if(trim(subcommand) == 'end of subdomain') then
            call cgal_add_subdomain_3d(subdomain_id,                   &
                      trim(subdomain_name), subdomain_delt,            &
                      strfilepath)

            exit
          end if

        end do

      end do

      !c set domain data
      call cgal_set_domain_values_3d()

      !c make and output image
      strfilepath = prefix(:l_prfx)//'.inr'
      call cgal_make_output_image_3d(trim(strfilepath))


      num_constraints = 0
      subcommand = 'number of polyline features'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if (bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) num_constraints
        end if
      end if

      do i = 1, num_constraints

        if(allocated(pts_3d)) then
          deallocate(pts_3d)
        end if

        num_pts = 0
        isclosed = .false.

        do while(readnextline(iunit, strbuffer, withquote=.true.))

          subcommand = trim(strbuffer)

          if(trim(subcommand) == 'polyline type') then
            if(readnextline(iunit, strbuffer, withquote=.true.)) then
              if(trim(strbuffer) == 'closed') then
                isclosed = .true.
              end if
            end if

          else if(trim(subcommand) == 'number of vertices') then
            if(readnextline(iunit, strbuffer, withquote=.false.)) then
              read(strbuffer,*,err=994,end=994) num_pts
            end if
            allocate(pts_3d(num_pts))

          else if (trim(subcommand) == 'vertices coordinate') then
            do j = 1, num_pts
              if(readnextline(iunit, strbuffer, withquote=.false.)) then
                read(strbuffer,*,err=994,end=994) pts_3d(j)%x,         &
                     pts_3d(j)%y, pts_3d(j)%z
              end if
            end do

          else if(trim(subcommand) == 'end of polyline') then
            call cgal_insert_feature_polyline(num_pts, pts_3d, isclosed)
            exit
          end if

        end do

      end do

      opt_lloyd_iteration = 0
      opt_lloyd_timelimit = 0.0d0
      subcommand = 'lloyd optimization parameters'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          b_opt_lloyd = .true.
          read(strbuffer,*,err=994,end=994) opt_lloyd_iteration,       &
                                            opt_lloyd_timelimit
        end if
      end if
      !c set lloyd optimization parameters
      call cgal_set_domain_opt_params_lloyd(opt_lloyd_iteration,       &
                opt_lloyd_timelimit)

      opt_exude_sliverbound = 0.0d0
      opt_exude_timelimit = 0.0d0
      subcommand = 'exude optimization parameters'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          b_opt_exude = .true.
          read(strbuffer,*,err=994,end=994) opt_exude_sliverbound,     &
                                            opt_exude_timelimit
        end if
      end if

      !c set exude optimization parameters
      call cgal_set_domain_opt_params_exude(opt_exude_sliverbound,     &
                opt_exude_timelimit)

      opt_perturb_sliverbound = 0.0d0
      opt_perturb_timelimit = 0.0d0
      subcommand = 'perturb optimization parameters'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          b_opt_perturb = .true.
          read(strbuffer,*,err=994,end=994) opt_perturb_sliverbound,   &
                                            opt_perturb_timelimit
        end if
      end if

      !c set perturb optimization parameters
      call cgal_set_domain_opt_params_perturb(opt_perturb_sliverbound, &
                opt_perturb_timelimit)

      !c make and outptu mesh
      call cgal_make_output_mesh_3d(trim(strfilepath),                 &
                str_usg_mesh_output_file, str_usg_mesh_format)

    end if

#endif

    !c read 'gms 3d original mesh' script
    subsection = 'gms 3d mesh'
    bfound = findnextline(iunit, subsection, 0, .true.)
    if (bfound) then
      type_gms_3d = ""
      subcommand = 'mesh type'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.true.)) then
          type_gms_3d = trim(strbuffer)
        end if
      end if

      strfilepath = ""
      subcommand = 'gms mesh file path'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.true., lowercase=.false.)) then
          strfilepath = trim(strbuffer)
          !c read gms mesh data
          call gms_mesh_read(trim(strfilepath))
        end if
      end if


      num_node_layers = 0
      subcommand = 'number of layers'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) num_node_layers
          !c set number of layers
          call gms_mesh_set_layers(num_node_layers)
        end if
      end if


      subcommand = 'gms layer file path from top to bottom'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        do i = 1, num_node_layers
          if(readnextline(iunit, strbuffer, withquote=.true., lowercase=.false.)) then
            strfilepath = trim(strbuffer)
            !c read layer data
            call gms_mesh_read_layer(i, trim(strfilepath))
          end if
        end do
      end if

      ilayer_start = 0
      ilayer_end = 0
      subcommand = 'output layer range'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.false.)) then
          read(strbuffer,*,err=994,end=994) ilayer_start, ilayer_end
        end if
      end if

      subcommand = 'output surface mesh'
      bfound = findnextline(iunit, subcommand, 0, .true.)
      if(bfound) then
        if(readnextline(iunit, strbuffer, withquote=.true., lowercase=.false.)) then
          strfilepath = trim(strbuffer)
          !c output surface mesh for layers
          call gms_mesh_output(ilayer_start, ilayer_end, strfilepath, "off")
        end if
      end if

      !make and output mesh
      if(trim(type_gms_3d) == 'original') then
        call gms_mesh_output(ilayer_start, ilayer_end,                 &
                 str_usg_mesh_output_file, str_usg_mesh_format, 1.0d0)
#ifdef CGAL
      else if(trim(type_gms_3d) == 'prism') then
        call gms_mesh_triangulation_prism(ilayer_start, ilayer_end,    &
                 str_usg_mesh_output_file, str_usg_mesh_format, 1.0d0)
#endif
      end if

      !c free data space
      call gms_mesh_free_data

    end if

    close(iunit)

    return

991 continue
    if (rank == 0) then
      write(*,*) 'error: unstructured script file is missing'
      write(ilog,*) 'error: unstructured script file is missing'
      close(ilog)
    end if

    goto 999

992 continue
    if (rank == 0) then
      write(*,*) 'error: cannot open file ', trim(strfile)
      write(ilog,*) 'error: cannot open file ', trim(strfile)
      close(ilog)
    end if

    goto 999

993 continue
    if (rank == 0) then
      write(*,*) 'error: command is missing in input file'
      write(ilog,*) 'error: command is missing in input file'
      close(ilog)
    end if

    goto 999

994 continue
    if (rank == 0) then
      write(*,*) 'error: data value is not correct'
      write(ilog,*) 'error: data value is not correct'
      close(ilog)
    end if

    goto 999

999 continue
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_from_script_file



end module usg_mesh_generation

