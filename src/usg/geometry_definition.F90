!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/geometry_definition.F90 $
!---------------------------------------------------------------------
!********************************************************************!

! --------------------------------------------------------------------
!> Module of geometry definitions
!>
!> Module description:
!>
!> Written by:    Danyang Su - Jul. 29, 2016
!>
!> Last modified:
!>
! --------------------------------------------------------------------
module geometry_definition

  !c this is feature of Fortran 2003
  use iso_c_binding

  implicit none

  !>
  !> definition of point
  !>
  type :: point
    real*8 :: x = 0.0d0
    real*8 :: y = 0.0d0
    real*8 :: z = 0.0d0
  end type point

  type, bind(C) :: point2d_c
    real(c_double) :: x = 0.0d0
    real(c_double) :: y = 0.0d0
  end type point2d_c

  type, bind(C) :: point3d_c
    real(c_double) :: x = 0.0d0
    real(c_double) :: y = 0.0d0
    real(c_double) :: z = 0.0d0
  end type point3d_c

  !>
  !> definition of tensor
  !>
  type :: tensor
    real*8 :: xx = 0.0d0
    real*8 :: xy = 0.0d0
    real*8 :: xz = 0.0d0
    real*8 :: yx = 0.0d0
    real*8 :: yy = 0.0d0
    real*8 :: yz = 0.0d0
    real*8 :: zx = 0.0d0
    real*8 :: zy = 0.0d0
    real*8 :: zz = 0.0d0
  end type tensor


  !>
  !> definition of least-square reconstruction matrix
  !>
  !>
  !> [a11 a12 a13]   [ux]   [b1]
  !> [a12 a22 a23] x [uy] = [b2]
  !> [a13 a23 a33]   [uz]   [b3]
  !>
  !> b1 = sum(wij2*duij*dxij)
  !> b2 = sum(wij2*duij*dyij)
  !> b3 = sum(wij2*duij*dzij)
  !>
  !> ux = b1*bcoef11 + b2*bcoef12 + b3*bcoef13
  !> uy = b1*bcoef21 + b2*bcoef22 + b3*bcoef23
  !> uz = b1*bcoef31 + b2*bcoef32 + b3*bcoef33
  !>
  !> like matrix a, bcoef is a symmetric matrix that bcoef12 = bcoef21, bcoef13 = bcoef31 and bcoef23 = bcoef32
  !> only bcoef matrix is stored
  !>
  type :: grad_ls_matrix
    real*8 :: det     = 0.0d0
    real*8 :: bcoef11 = 0.0d0
    real*8 :: bcoef22 = 0.0d0
    real*8 :: bcoef33 = 0.0d0
    real*8 :: bcoef12 = 0.0d0
    real*8 :: bcoef13 = 0.0d0
    real*8 :: bcoef23 = 0.0d0
  end type grad_ls_matrix

  !>
  !> definition of high order least square overdetermined matrix
  !>
  type grad_hls_matrix
    !c nth order gradient reconstruction over-determined matrix, depending on the order and dimension
    real*8, allocatable :: coef(:,:)
    !c inverse distance spatial weighting
    real*8, allocatable :: weighting(:)
  end type grad_hls_matrix

  !>
  !> definition of zero vector
  !>
  type(point), parameter :: vector_zero = point(0.0d0,0.0d0,0.0d0)

  !>
  !> definition of unit vector
  !>
  type(point), parameter :: vector_one = point(1.0d0,1.0d0,1.0d0)

  !>
  !> definition of zero tensor
  !>
  type(tensor), parameter :: tensor_zero = tensor(0.0d0,0.0d0,0.0d0,   &
                                                  0.0d0,0.0d0,0.0d0,   &
                                                  0.0d0,0.0d0,0.0d0)

  !>
  !> definition of unit tensor
  !>
  type(tensor), parameter :: tensor_one = tensor(1.0d0,1.0d0,1.0d0,    &
                                                  1.0d0,1.0d0,1.0d0,   &
                                                  1.0d0,1.0d0,1.0d0)

  !>
  !> definition of high order gradient terms
  !>
  type grad_hls_term
    !creal*8      :: var  = 0.0d0      !zero order gradient, aka variable or unknown, not needed at present
    type(point) :: grad = vector_zero  !first order gradient
    real*8      :: eps  = 0.0d0        !sum of second and higher order for taylor's series
  end type grad_hls_term

  !>
  !> cell_type_xx: definiton of cell type, same as vtk cell type definition
  !>
  integer, parameter :: cell_type_vertex  = 1
  integer, parameter :: cell_type_line    = 3
  integer, parameter :: cell_type_tri     = 5
  integer, parameter :: cell_type_quad    = 9
  integer, parameter :: cell_type_tetra   = 10
  integer, parameter :: cell_type_hexa    = 12
  integer, parameter :: cell_type_prism   = 13
  integer, parameter :: cell_type_pyramid = 14

  !>
  !> edge node linking map for triangle
  !>
  integer, parameter, dimension(3,3) :: edge_node_link_tri =           &
                      reshape((/0,1,1,1,0,1,1,1,0/),(/3,3/))

  !>
  !> edge node linking map for quadrilateral
  !>
  integer, parameter, dimension(4,4) :: edge_node_link_quad =          &
                      reshape((/0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0/),(/4,4/))

  !>
  !> edge node linking map for tetra
  !>
  integer, parameter, dimension(4,4) :: edge_node_link_tetra =         &
                      reshape((/1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1/),(/4,4/))

  !>
  !> edge node linking map for hexahedral
  !>
  integer, parameter, dimension(8,8) :: edge_node_link_hexa =          &
                      reshape((/0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,       &
                                0,1,0,1,0,0,1,0,1,0,1,0,0,0,0,1,       &
                                1,0,0,0,0,1,0,1,0,1,0,0,1,0,1,0,       &
                                0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0/),(/8,8/))

  !>
  !> edge node linking map for prism
  !>
  integer, parameter, dimension(6,6) :: edge_node_link_prism =          &
                      reshape((/0,1,1,1,0,0,1,0,1,0,1,0,1,1,0,0,0,1,    &
                                1,0,0,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0/),(/6,6/))


  !>
  !> face node mapping for triangle 123
  !> edge node connection: 12, 23, 31
  !>
  integer, parameter, dimension(2,3) :: edge_node_mapping_tri =        &
                      reshape((/1,2,2,3,3,1/),(/2,3/))

  !>
  !> face node mapping for quadrilateral 1234
  !> edge node connection: 12, 23, 34, 41
  !>
  integer, parameter, dimension(2,4) :: edge_node_mapping_quad =       &
                      reshape((/1,2,2,3,3,4,4,1/),(/2,4/))

  !>
  !> edge node mapping for tetrahedral 1234
  !> edge node connection: 12,23,31,41,42,43
  !>
  integer, parameter, dimension(2,6) :: edge_node_mapping_tetra =      &
                      reshape((/1,2,2,3,3,1,4,1,4,2,4,3/),(/2,6/))

  !>
  !> edge node mapping for hexahedral 1234-5678
  !> edge node connection: 12, 23, 34, 41, 56, 67, 78, 85, 15, 26, 37, 48
  !>
  integer, parameter, dimension(2,12) :: edge_node_mapping_hexa =      &
                      reshape((/1,2,2,3,3,4,4,1,5,6,6,7,7,8,8,5,       &
                                1,5,2,6,3,7,4,8/),(/2,12/))

  !>
  !> edge node mapping for prism 123-456
  !> edge node connection: 12, 23, 31, 45, 56, 64, 14, 25, 36
  !>
  integer, parameter, dimension(2,9) :: edge_node_mapping_prism =      &
                      reshape((/1,2,2,3,3,1,4,5,5,6,6,4,               &
                                1,4,2,5,3,6/),(/2,9/))

  !>
  !> face node mapping for triangle 123
  !>
  integer, parameter, dimension(2,3) :: face_node_mapping_tri =        &
                      reshape((/2,3,3,1,1,2/),(/2,3/))

  !>
  !> face node mapping for quadrilateral 1234
  !>
  integer, parameter, dimension(2,4) :: face_node_mapping_quad =       &
                      reshape((/2,3,3,4,4,1,1,2/),(/2,4/))

  !>
  !> face node mapping for tetrahedral 1234
  !> face node connection: 123, 214, 324, 413
  !>
  integer, parameter, dimension(3,4) :: face_node_mapping_tetra =      &
                      reshape((/3,2,4,4,1,3,2,1,4,1,2,3/),(/3,4/))

  !>
  !> face node mapping for hexahedral 1234-5678
  !> face node connection: 1234, 8765, 2156, 3267, 4378, 1485
  !>
  integer, parameter, dimension(4,6) :: face_node_mapping_hexa =       &
                      reshape((/1,2,3,4,8,7,6,5,2,1,5,6,3,2,6,7,       &
                                4,3,7,8,1,4,8,5/),(/4,6/))

  !>
  !> face node mapping for prism 123-456
  !> face node connection: 123(1), 654(6), 2145, 3256, 1364
  !> note: for prism, use first node index as the fourth node
  !>
  integer, parameter, dimension(4,5) :: face_node_mapping_prism =      &
                      reshape((/1,2,3,1,6,5,4,6,2,1,4,5,3,2,5,6,       &
                                1,3,6,4/),(/4,5/))

  !>
  !> local half-face id for tetrahedral 1234
  !> local ID: <1,0>, <2,0>, <3,0>, <4,0>
  !>           <1,1>, <2,1>, <3,1>, <4,1>
  !>           <1,2>, <2,2>, <3,2>, <4,2>
  !>
  integer, parameter, dimension(3,4) :: local_ahf_tetra =              &
           reshape((/ishft(1,2),ishft(1,2)+1,ishft(1,2)+2,             &
                     ishft(2,2),ishft(2,2)+1,ishft(2,2)+2,             &
                     ishft(3,2),ishft(3,2)+1,ishft(3,2)+2,             &
                     ishft(4,2),ishft(4,2)+1,ishft(4,2)+2/),(/3,4/))

  !>
  !> projection_type_xx: definition of projection plane
  !>
  integer, parameter :: projection_x = 1      !2^0
  integer, parameter :: projection_y = 2      !2^1
  integer, parameter :: projection_z = 4      !2^2
  integer, parameter :: projection_xy = 3     !2^0+2^1
  integer, parameter :: projection_yz = 6     !2^1+2^2
  integer, parameter :: projection_xz = 5     !2^0+2^2
  integer, parameter :: projection_xyz = 7    !2^0+2^1+2^2

  !>
  !> control volume method
  !>
  integer, parameter :: cvol_method_md = 1          !median-dual
  integer, parameter :: cvol_method_vd = 2          !voronoi-diagram
  integer, parameter :: cvol_method_cc = 3          !cell center

  !>
  !> gradient reconstruction method
  !> grad_method_cgg: Cell based, second order Green-Gauss
  !>                  gradient reconstruction method
  !> grad_method_gg : Control volume based, second order Green-Gauss
  !>                  gradient reconstruction method
  !> grad_method_ls : Control volume based, second order Least-squares
  !>                  gradient reconstruction method
  !> grad_method_ls2: Control volume based, second order Least-squares
  !>                  gradient reconstruction method, use the nodes in
  !>                  interface located cell only, second-order accuracy
  !> grad_method_ls3: Control volume based, third order Least-squares
  !>                  gradient reconstruction method, use the nodes in
  !>                  interface located cell and first level neighbours,
  !>                  third-order accuracy
  !> grad_method_ls4: Control volume based, forth order Least-squares
  !>                  gradient reconstruction method, use the nodes in
  !>                  interface located cell and first level neighbours,
  !>                  forth-order accuracy
  !> grad_method_cls: Cell based, second order Least-squares
  !>                  gradient reconstruction method
  !> note: grad_method_ls3 and grad_method_ls4 will generate an over-determined
  !> system of equations which can be solved by least-squares method
  !>
  integer, parameter :: grad_method_cgg = 0
  integer, parameter :: grad_method_gg = 1
  integer, parameter :: grad_method_ls = 2
  integer, parameter :: grad_method_ls2 = 3
  integer, parameter :: grad_method_ls3 = 4
  integer, parameter :: grad_method_ls4 = 5
  integer, parameter :: grad_method_cls = 6

  !>
  !> required number of nodes for gradient reconstruction
  !>
  !> illustration of over-determined system of equations
  !> dxk is the distance in x direction between the midpoint of control
  !> volume interface and node k
  !> u is unknow
  !> u_x is gradient of u in x direction
  !> u_xx is the second order gradient of u in x direction
  !>
  !> |1 dx1 dy1 dx1^2/2 dy1^2/2 dx1*dy1 dx1^3/6 dy1^3/6 dx1^2*dy1/2 dx1*dy1^2/2|
  !> |1 dx2 dy2 dx2^2/2 dy2^2/2 dx2*dy2 dx2^3/6 dy2^3/6 dx2^2*dy2/2 dx2*dy2^2/2|
  !> |1 dx3 dy3 dx3^2/2 dy3^2/2 dx3*dy3 dx3^3/6 dy3^3/6 dx3^2*dy3/2 dx3*dy3^2/2|
  !> |...                                                                      |  x
  !> |...                                                                      |
  !> |...                                                                      |
  !> |1 dxn dyn dxn^2/2 dyn^2/2 dxn*dyn dxn^3/6 dyn^3/6 dxn^2*dyn/2 dxn*dyn^2/2|
  !>
  !> |u u_x u_y u_xx u_yy u_xy u_xxx u_yyy u_xxy u_yyx|^T             =
  !>
  !> |u1 u2 u3 ... un|^T
  integer, parameter :: min_num_nodes_ls2_2d = 3
  integer, parameter :: min_num_nodes_ls3_2d = 6
  integer, parameter :: min_num_nodes_ls4_2d = 10

  !> illustration of over-determined system of equations
  !> dxk is the distance in x direction between the midpoint of control
  !> volume interface and node k
  !> u is unknow
  !> u_x is gradient of u in x direction
  !> u_xx is the second order gradient of u in x direction
  !>
  !> |1 dx1 dy1 dz1 dx1^2/2 dy1^2/2 dz1^2/2 dx1*dy1 dx1dz1 dy1dz1 dx1^3/6 dy1^3/6 dz1^3/6 dx1^2*dy1/2 dx1^2*dz1/2 dy1^2*dx1/2 dy1^2*dz1/2 dz1^2*dx1/2 dz1^2*dy1/2|
  !> |1 dx2 dy2 dz2 dx2^2/2 dy2^2/2 dz2^2/2 dx2*dy2 dx2dz2 dy2dz2 dx2^3/6 dy2^3/6 dz2^3/6 dx2^2*dy2/2 dx2^2*dz2/2 dy2^2*dx2/2 dy2^2*dz2/2 dz2^2*dx2/2 dz2^2*dy2/2|
  !> |1 dx3 dy3 dz3 dx3^2/2 dy3^2/2 dz3^2/2 dx3*dy3 dx3dz3 dy3dz3 dx3^3/6 dy3^3/6 dz3^3/6 dx3^2*dy3/2 dx3^2*dz3/2 dy3^2*dx3/2 dy3^2*dz3/2 dz3^2*dx3/2 dz3^2*dy3/2|
  !> |...                                                                                                                                                        |  x
  !> |...                                                                                                                                                        |
  !> |...                                                                                                                                                        |
  !> |1 dxn dyn dzn dxn^2/2 dyn^2/2 dzn^2/2 dxn*dyn dxndzn dyndzn dxn^3/6 dyn^3/6 dzn^3/6 dxn^2*dyn/2 dxn^2*dzn/2 dyn^2*dxn/2 dyn^2*dzn/2 dzn^2*dxn/2 dzn^2*dyn/2|
  !>
  !> |u u_x u_y u_z u_xx u_yy u_zz u_xy u_xz u_yz u_xxx u_yyy u_zzz u_xxy u_xxz u_yyx u_yyz u_zzx u_zzy|^T                                  =
  !>
  !> |u1 u2 u3 ... un|^T
  integer, parameter :: min_num_nodes_ls2_3d = 4
  integer, parameter :: min_num_nodes_ls3_3d = 10
  integer, parameter :: min_num_nodes_ls4_3d = 19

end module geometry_definition

