!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/hdf5_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!


! --------------------------------------------------------------------
!> Module of hdf5 IO for MIN3P unstructured grid
!>
!> Module description: Parallel IO for HDF5 files
!>
!> Written by:    Danyang Su - Mar. 1st, 2018
!>
!> Last modified:
!>
!> Notes: PETSc should be built with HDF5
!>
!>
!> Example of xdmf file to load hdf5 data for paraview
!>      <?xml version="1.0" ?>
!>      <!DOCTYPE Xdmf SYSTEM "Xdmf.dtd" []>
!>      <Xdmf>
!>        <domain>
!>          <Grid Name="Mesh">
!>            <Topology Type="Triangle" NumberOfElements="1763">
!>              <DataItem Format="HDF" DataType="Int" Dimensions="1763 3">
!>                het-2d_0.gsp.h5:/domain/cells
!>              </DataItem>
!>            </Topology>
!>            <Geometry GeometryType="XYZ">
!>              <DataItem Format="HDF" Dimensions="953 3">
!>                het-2d_0.gsp.h5:/domain/vertices
!>              </DataItem>
!>            </Geometry>
!>            <Attribute Name="h_w" AttributeType="Scalar"  Center="Node">
!>              <DataItem Dimensions="953 1" Format="HDF">
!>              het-2d_0.gsp.h5:/result/h_w
!>              </DataItem>
!>            </Attribute>
!>            <Attribute Name="p_w" AttributeType="Scalar"  Center="Node">
!>              <DataItem Dimensions="953 1" Format="HDF">
!>              het-2d_0.gsp.h5:/result/p_w
!>              </DataItem>
!>            </Attribute>
!>            <Attribute Name="gradient" AttributeType="Vector"  Center="Node">
!>              <DataItem Dimensions="953 3" Format="HDF">
!>              het-2d_0.gsp.h5:/result/gradient
!>              </DataItem>
!>            </Attribute>
!>          </Grid>
!>        </domain>
!>      </Xdmf>
!>
! --------------------------------------------------------------------
#ifdef USG
#ifdef PETSC_HDF

module hdf5_usg

  use hdf5
  use geometry_definition
  use petsc_mpi_common, only : petsc_mpi_finalize

  implicit none

  !>
  !> interface of write 1d dataset to hdf5
  !>
  interface hdf5_usg_write_group_data_1d
    module procedure hdf5_usg_write_group_data_i1d
    module procedure hdf5_usg_write_group_data_r1d
  end interface hdf5_usg_write_group_data_1d

  !>
  !> interface of write 1d dataset to hdf5
  !>
  interface hdf5_usg_write_group_data_vec
    module procedure hdf5_usg_write_group_data_ivec
    module procedure hdf5_usg_write_group_data_rvec
  end interface hdf5_usg_write_group_data_vec

  !>
  !> interface of read 1d dataset from hdf5
  !>
  interface hdf5_usg_read_group_data_vec
    module procedure hdf5_usg_read_group_data_rvec
  end interface hdf5_usg_read_group_data_vec

  contains

  !>
  !> write attribute dataset to hdf5 file
  !>
  subroutine hdf5_usg_write_attribute(file_id,is_restart_w)

    use Version
    use gen, only : nprcs, numofthreads_global, time_io, time_bcvs,    &
                    time_unit, igstime, delt_vs, delt_rt
    use usg_mesh_data, only : num_nodes_gbl, num_cells_gbl

    implicit none

    !passed variables
    integer(HID_T), intent(in) :: file_id                ! File identifier
    logical, intent(in), optional :: is_restart_w

    !c local variables
    integer :: hdf5_ierr                                 ! HDF5 error code
    integer :: arank                                     ! Attribure rank
    integer(HID_T) :: attr_id                            ! Attribute identifier
    integer(HID_T) :: aspace_id                          ! Attribute Dataspace identifier
    integer(HID_T) :: atype_id                           ! Attribute Dataspace identifier
    integer(HSIZE_T) :: adims(1)                         ! Attribute dimension
    integer(SIZE_T) :: attrlen                           ! Length of the attribute string
    character(len=72) :: aname                           ! Attribute name
    character(len=256):: attr_data(1)                    ! Attribute data
    integer(HSIZE_T) :: data_dims(1)                     ! Attribute data dimension

    arank = 1
    adims(1) = 1
    data_dims(1) = 1

    call h5screate_simple_f(arank, adims, aspace_id, hdf5_ierr)

    call h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, hdf5_ierr)
    attrlen = 256
    call h5tset_size_f(atype_id, attrlen, hdf5_ierr)

    aname = "Name"
    attr_data(1) = "MIN3P-THCm-USG"
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Version"
    attr_data(1) = trim(BuildLabelVersion)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Commit date"
    attr_data(1) = trim(CommitDate)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Build date"
    attr_data(1) = trim(BuildDate)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Repository"
    attr_data(1) = trim(RepositoryURL)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Build mode"
    attr_data(1) = trim(BuildLabelMode)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Operation system"
    attr_data(1) = trim(BuildLabelSystem)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Included solver"
    attr_data(1) = trim(BuildLabelSolver)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Parallel mode"
    attr_data(1) = trim(BuildLabelParallel)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Schudule mode"
    attr_data(1) = trim(BuildLabelSchedule)
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Output time"
    write(attr_data(1),'(1pe15.6e3,1x,a)') time_io,time_unit
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, attr_data, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    call h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, hdf5_ierr)
    attrlen = 4
    call h5tset_size_f(atype_id, attrlen, hdf5_ierr)

    aname = "Number of processors"
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, nprcs, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Number of threads"
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, numofthreads_global, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Number of nodes"
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, num_nodes_gbl, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "Number of cells"
    call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
    call h5awrite_f(attr_id, atype_id, num_cells_gbl, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    !c information for restart file
    if (present(is_restart_w)) then
      if (is_restart_w) then
        call h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, hdf5_ierr)
        attrlen = 4
        call h5tset_size_f(atype_id, attrlen, hdf5_ierr)

        aname = "restart_igstime"
        call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
        call h5awrite_f(attr_id, atype_id, igstime, data_dims, hdf5_ierr)
        call h5aclose_f(attr_id, hdf5_ierr)

        aname = "restart_nprcs"
        call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
        call h5awrite_f(attr_id, atype_id, nprcs, data_dims, hdf5_ierr)
        call h5aclose_f(attr_id, hdf5_ierr)

        call h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, hdf5_ierr)
        attrlen = 8
        call h5tset_size_f(atype_id, attrlen, hdf5_ierr)

        aname = "restart_time_io"
        call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
        call h5awrite_f(attr_id, atype_id, time_io, data_dims, hdf5_ierr)
        call h5aclose_f(attr_id, hdf5_ierr)

        aname = "restart_time_bcvs"
        call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
        call h5awrite_f(attr_id, atype_id, time_bcvs, data_dims, hdf5_ierr)
        call h5aclose_f(attr_id, hdf5_ierr)

        aname = "restart_delt_vs"
        call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
        call h5awrite_f(attr_id, atype_id, delt_vs, data_dims, hdf5_ierr)
        call h5aclose_f(attr_id, hdf5_ierr)

        aname = "restart_delt_rt"
        call h5acreate_f(file_id, aname, atype_id, aspace_id, attr_id, hdf5_ierr)
        call h5awrite_f(attr_id, atype_id, delt_rt, data_dims, hdf5_ierr)
        call h5aclose_f(attr_id, hdf5_ierr)

      end if
    end if

    call h5sclose_f(aspace_id, hdf5_ierr)

  end subroutine hdf5_usg_write_attribute

  !>
  !> read restart attribute from restart hdf5 file
  !>
  subroutine hdf5_usg_read_attribute_r(file_id, file_name, time_io,    &
                      delt_rt, delt_vs, time_bcvs, igstime)
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
    use petscsys
#endif
#endif

    implicit none

    !passed variables
    integer(HID_T) :: file_id                            ! File identifier
    character(len=*) :: file_name
    real*8, intent(inout) :: time_io, delt_rt, delt_vs, time_bcvs
    integer, intent(inout) :: igstime

    !c local variables
    integer :: hdf5_ierr                                 ! HDF5 error code
    integer :: arank                                     ! Attribure rank
    integer(HID_T) :: plist_id                           ! Property list identifier
    integer(HID_T) :: attr_id                            ! Attribute identifier
    integer(HID_T) :: aspace_id                          ! Attribute Dataspace identifier
    integer(HID_T) :: atype_id                           ! Attribute Dataspace identifier
    integer(HSIZE_T) :: adims(1)                         ! Attribute dimension
    integer(SIZE_T) :: attrlen                           ! Length of the attribute string
    character(len=72) :: aname                           ! Attribute name
    integer(HSIZE_T) :: data_dims(1)                     ! Attribute data dimension

    arank = 1
    adims(1) = 1
    data_dims(1) = 1

    !c initialize the interface
    call h5open_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c setup file access property list with parallel I/O access
    call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
    call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,                &
                            MPI_INFO_NULL, hdf5_ierr)

    !c open the specified hdf5 file
    call h5fopen_f (file_name, H5F_ACC_RDONLY_F, file_id, hdf5_ierr,   &
                    access_prp = plist_id)
    if (hdf5_ierr < 0) then
      return
    end if

    !c information for restart file
    call h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, hdf5_ierr)
    attrlen = 4
    call h5tset_size_f(atype_id, attrlen, hdf5_ierr)

    aname = "restart_igstime"
    call h5aopen_f(file_id, aname, attr_id, hdf5_ierr)
    call h5aread_f(attr_id, atype_id, igstime, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    !aname = "restart_nprcs"
    !call h5aopen_f(file_id, aname, attr_id, hdf5_ierr)
    !call h5aread_f(attr_id, atype_id, nprcs, data_dims, hdf5_ierr)
    !call h5aclose_f(attr_id, hdf5_ierr)

    call h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, hdf5_ierr)
    attrlen = 8
    call h5tset_size_f(atype_id, attrlen, hdf5_ierr)

    aname = "restart_time_io"
    call h5aopen_f(file_id, aname, attr_id, hdf5_ierr)
    call h5aread_f(attr_id, atype_id, time_io, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "restart_time_bcvs"
    call h5aopen_f(file_id, aname, attr_id, hdf5_ierr)
    call h5aread_f(attr_id, atype_id, time_bcvs, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "restart_delt_vs"
    call h5aopen_f(file_id, aname, attr_id, hdf5_ierr)
    call h5aread_f(attr_id, atype_id, delt_vs, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    aname = "restart_delt_rt"
    call h5aopen_f(file_id, aname, attr_id, hdf5_ierr)
    call h5aread_f(attr_id, atype_id, delt_rt, data_dims, hdf5_ierr)
    call h5aclose_f(attr_id, hdf5_ierr)

    !c close the file after reading
    call h5pclose_f(plist_id, hdf5_ierr)
    call h5fclose_f(file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the interface after reading
    call h5close_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

  end subroutine hdf5_usg_read_attribute_r

  !>
  !> write integer 1d dataset to hdf5 file
  !>
  subroutine hdf5_usg_write_group_data_i1d(group_id,dataname,nsize,nsize_gbl,offset,dataset)

    use gen, only : hdf5_compress_level, nprcs

    implicit none

    !c passed variables
    integer(HID_T), intent(in) :: group_id     ! File identifier
    character(len=*), intent(in) :: dataname   ! Dataset name
    integer, intent(in) :: nsize           ! Size of local Dataset
    integer, intent(in) :: nsize_gbl       ! Size of global Dataset
    integer, intent(in) :: offset          ! Offset of local dataset
    integer, allocatable :: dataset(:)     ! Dataset

    !c local variables
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: hdf5_ndim                   ! h5gopen_fNumber of dimensions used in the dataspace
    integer(HSIZE_T) :: hdf5_count(1)      ! Number of blocks to select from dataspace
    integer(HSIZE_T) :: hdf5_gdsize(1)     ! Array with current dimension global sizes
    integer(HSIZE_T) :: hdf5_goffset(1)    ! Offset of start of hyperslab
    integer(HSIZE_T) :: hdf5_csize(1)      ! Ayyay conaining sizes of chunk dimensions
    integer(HID_T) :: dset_id              ! Dataset identifier
    integer(HID_T) :: chunk_id             ! Chunk identifier
    integer(HID_T) :: filespace            ! Dataspace identifier in file
    integer(HID_T) :: memspace             ! Memoryspace identifier in file
    integer(HID_T) :: plist_id             ! Property list identifier
    logical :: flag_chunk                  ! flag to use chunk

    ! Uncomment these variables to use SZIP compression
    !integer :: szip_options_mask
    !integer :: szip_pixels_per_block

    !c create the data space for the domain datset
    hdf5_ndim = 1
    hdf5_count(1) = nsize
    hdf5_gdsize(1) = nsize_gbl
    hdf5_goffset(1) = offset

    flag_chunk = .true.
    if (nsize_gbl/nprcs > 4096) then
      hdf5_csize(1) = 4096               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize_gbl/nprcs > 1024) then
      hdf5_csize(1) = 1024               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize_gbl/nprcs > 256) then
      hdf5_csize(1) = 256                !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize_gbl/nprcs > 64) then
      hdf5_csize(1) = 64                 !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else
      flag_chunk = .false.
    end if

    !c make sure the group has already been created before opening it
    
    !c create local memory space and hyperslab
    call h5screate_simple_f(hdf5_ndim, hdf5_gdsize, filespace,         &
                            hdf5_ierr)

    if (flag_chunk) then
      !c create a data chunking property
      call h5pcreate_f(H5P_DATASET_CREATE_F, chunk_id, hdf5_ierr)
      call h5pset_chunk_f(chunk_id, hdf5_ndim, hdf5_csize, hdf5_ierr)

      !c create compressed data, dataset must be chunked for compression
      !c the following cause crash in hdf5 library, check when new
      !c hdf5 version is available

      ! Set ZLIB / DEFLATE Compression using compression level 6.
      ! To use SZIP Compression comment out these lines.
      if (hdf5_compress_level > 0 .and. hdf5_compress_level < 10) then
        call h5pset_deflate_f(chunk_id, hdf5_compress_level, hdf5_ierr)
      end if

      ! Uncomment these lines to set SZIP Compression
      !szip_options_mask = H5_SZIP_NN_OM_F
      !szip_pixels_per_block = 16
      !call H5Pset_szip_f(chunk_id, szip_options_mask,                    &
      !                   szip_pixels_per_block, hdf5_ierr)

      !c create the dataset id
      call h5dcreate_f(group_id, dataname, H5T_NATIVE_INTEGER,           &
                       filespace, dset_id, hdf5_ierr, dcpl_id=chunk_id)
    else
      !c create the dataset id
      call h5dcreate_f(group_id, dataname, H5T_NATIVE_INTEGER,           &
                       filespace, dset_id, hdf5_ierr)
    end if

    call h5screate_simple_f(hdf5_ndim, hdf5_count, memspace, hdf5_ierr) 

    if (nsize <= 0) then
      call h5sselect_none_f(memspace,hdf5_ierr)
    end if

    !c Select hyperslab in the file.
    call h5dget_space_f(dset_id,filespace,hdf5_ierr)
    call h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F,          &
                               hdf5_goffset, hdf5_count, hdf5_ierr)

    if (nsize <= 0) then
      call h5sselect_none_f(filespace,hdf5_ierr)
    end if

    !c create a data transfer property
    call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, hdf5_ierr)
    call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F,          &
                            hdf5_ierr)

    !c write the dataset collectively                        
    call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, dataset, hdf5_count,  &
                    hdf5_ierr, file_space_id=filespace,                &
                    mem_space_id=memspace, xfer_prp = plist_id)

    !c close resources
    call h5dclose_f(dset_id, hdf5_ierr)
    call h5sclose_f(filespace, hdf5_ierr)
    call h5sclose_f(memspace, hdf5_ierr)
    call h5pclose_f(plist_id, hdf5_ierr)
    if (flag_chunk) then
      call h5pclose_f(chunk_id, hdf5_ierr)
    end if

  end subroutine hdf5_usg_write_group_data_i1d

  !>
  !> write real 1d dataset to hdf5 file
  !>
  subroutine hdf5_usg_write_group_data_r1d(group_id,dataname,nsize,nsize_gbl,offset,dataset)

    use gen, only : hdf5_compress_level, nprcs


    implicit none

    !c passed variables
    integer(HID_T), intent(in) :: group_id     ! File identifier
    character(len=*), intent(in) :: dataname   ! Dataset name
    integer, intent(in) :: nsize           ! Size of local Dataset
    integer, intent(in) :: nsize_gbl       ! Size of global Dataset
    integer, intent(in) :: offset          ! Offset of local dataset
#ifdef OUTPUT_DOUBLE
    real*8, allocatable :: dataset(:)      ! Dataset
#else
    real*4, allocatable :: dataset(:)      ! Dataset
#endif

    !c local variables
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: hdf5_ndim                   ! h5gopen_fNumber of dimensions used in the dataspace
    integer(HSIZE_T) :: hdf5_count(1)      ! Number of blocks to select from dataspace
    integer(HSIZE_T) :: hdf5_gdsize(1)     ! Array with current dimension global sizes
    integer(HSIZE_T) :: hdf5_goffset(1)    ! Offset of start of hyperslab
    integer(HSIZE_T) :: hdf5_csize(1)      ! Ayyay conaining sizes of chunk dimensions
    integer(HID_T) :: dset_id              ! Dataset identifier
    integer(HID_T) :: chunk_id             ! Chunk identifier
    integer(HID_T) :: filespace            ! Dataspace identifier in file
    integer(HID_T) :: memspace             ! Memoryspace identifier in file
    integer(HID_T) :: plist_id             ! Property list identifier
    logical :: flag_chunk                  ! flag to use chunk

    ! Uncomment these variables to use SZIP compression
    !integer :: szip_options_mask
    !integer :: szip_pixels_per_block

    !c create the data space for the domain datset
    hdf5_ndim = 1
    hdf5_count(1) = nsize
    hdf5_gdsize(1) = nsize_gbl
    hdf5_goffset(1) = offset

    flag_chunk = .true.
    if (nsize_gbl/nprcs > 4096) then
      hdf5_csize(1) = 4096               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize_gbl/nprcs > 1024) then
      hdf5_csize(1) = 1024               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize_gbl/nprcs > 256) then
      hdf5_csize(1) = 256                !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize_gbl/nprcs > 64) then
      hdf5_csize(1) = 64                 !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else
      flag_chunk = .false.
    end if
    !c make sure the group has already been created before opening it

  !c create local memory space and hyperslab
    call h5screate_simple_f(hdf5_ndim, hdf5_gdsize, filespace,         &
                            hdf5_ierr)

    if (flag_chunk) then
      !c create a data chunking property
      call h5pcreate_f(H5P_DATASET_CREATE_F, chunk_id, hdf5_ierr)
      call h5pset_chunk_f(chunk_id, hdf5_ndim, hdf5_csize, hdf5_ierr)

      !c create compressed data, dataset must be chunked for compression
      !c the following cause crash in hdf5 library, check when new
      !c hdf5 version is available

      ! Set ZLIB / DEFLATE Compression using compression level 6.
      ! To use SZIP Compression comment out these lines.
      if (hdf5_compress_level > 0 .and. hdf5_compress_level < 10) then
        call h5pset_deflate_f(chunk_id, hdf5_compress_level, hdf5_ierr)
      end if

      ! Uncomment these lines to set SZIP Compression
      !szip_options_mask = H5_SZIP_NN_OM_F
      !szip_pixels_per_block = 16
      !call H5Pset_szip_f(chunk_id, szip_options_mask,                  &
      !                   szip_pixels_per_block, hdf5_ierr)

      !c create the dataset id
      call h5dcreate_f(group_id, dataname,                             &
#ifdef OUTPUT_DOUBLE 
                       H5T_NATIVE_DOUBLE,                              &
#else
                       H5T_NATIVE_FLOAT,                               &
#endif
                       filespace, dset_id, hdf5_ierr, dcpl_id=chunk_id)

    else
      !c create the dataset id
      call h5dcreate_f(group_id, dataname,                             &
#ifdef OUTPUT_DOUBLE 
                       H5T_NATIVE_DOUBLE,                              &
#else
                       H5T_NATIVE_FLOAT,                               &
#endif
                       filespace, dset_id, hdf5_ierr) 
    end if

    call h5screate_simple_f(hdf5_ndim, hdf5_count, memspace, hdf5_ierr) 

    if (nsize <= 0) then
      call h5sselect_none_f(memspace,hdf5_ierr)
    end if

    !c Select hyperslab in the file.
    call h5dget_space_f(dset_id,filespace,hdf5_ierr)
    call h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F,            &
                               hdf5_goffset, hdf5_count, hdf5_ierr)

    if (nsize <= 0) then
      call h5sselect_none_f(filespace,hdf5_ierr)
    end if

    !c create a data transfer property
    call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, hdf5_ierr)
    call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F,          &
                            hdf5_ierr)

    !c write the dataset collectively                        
    call h5dwrite_f(dset_id,                                           &
#ifdef OUTPUT_DOUBLE 
                    H5T_NATIVE_DOUBLE,                                 &
#else
                    H5T_NATIVE_FLOAT,                                  &
#endif
                    dataset, hdf5_count,  &
                    hdf5_ierr, file_space_id=filespace,                &
                    mem_space_id=memspace, xfer_prp = plist_id)

    !c close resources
    call h5dclose_f(dset_id, hdf5_ierr)
    call h5sclose_f(filespace, hdf5_ierr)
    call h5sclose_f(memspace, hdf5_ierr)
    call h5pclose_f(plist_id, hdf5_ierr)
    if (flag_chunk) then
      call h5pclose_f(chunk_id, hdf5_ierr)
    end if

  end subroutine hdf5_usg_write_group_data_r1d

  !>
  !> write integer type vector dataset to hdf5 file
  !>
  subroutine hdf5_usg_write_group_data_ivec(group_id,dataname,         &
                  nsize1,nsize2,nsize2_gbl,offset,dataset)

    use gen, only : hdf5_compress_level, nprcs

    implicit none

    !c passed variables
    integer(HID_T), intent(in) :: group_id     ! File identifier
    character(len=*), intent(in) :: dataname   ! Dataset name
    integer, intent(in) :: nsize1          ! Size of block
    integer, intent(in) :: nsize2          ! Size of nodes/cells
    integer, intent(in) :: nsize2_gbl      ! Size of nodes/cells
    integer, intent(in) :: offset          ! Offset of local dataset
    integer, allocatable :: dataset(:)     ! Dataset

    !c local variables
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: hdf5_ndim                   ! h5gopen_fNumber of dimensions used in the dataspace
    integer(HSIZE_T) :: hdf5_count(2)      ! Number of blocks to select from dataspace
    integer(HSIZE_T) :: hdf5_gdsize(2)     ! Array with current dimension global sizes
    integer(HSIZE_T) :: hdf5_goffset(2)    ! Offset of start of hyperslab
    integer(HSIZE_T) :: hdf5_csize(2)      ! Ayyay conaining sizes of chunk dimensions
    integer(HID_T) :: dset_id              ! Dataset identifier
    integer(HID_T) :: chunk_id             ! Chunk identifier
    integer(HID_T) :: filespace            ! Dataspace identifier in file
    integer(HID_T) :: memspace             ! Memoryspace identifier in file
    integer(HID_T) :: plist_id             ! Property list identifier
    logical :: flag_chunk                  ! flag to use chunk

    ! Uncomment these variables to use SZIP compression
    !integer :: szip_options_mask
    !integer :: szip_pixels_per_block

    !c create the data space for the domain datset
    hdf5_ndim = 2
    hdf5_count(1) = nsize1
    hdf5_count(2) = nsize2
    hdf5_gdsize(1) = nsize1
    hdf5_gdsize(2) = nsize2_gbl
    hdf5_goffset(1) = 0
    hdf5_goffset(2) = offset

    flag_chunk = .true.
    hdf5_csize(1) = nsize1
    if (nsize2_gbl/nprcs > 4096) then
      hdf5_csize(2) = 4096               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 1024) then
      hdf5_csize(2) = 1024               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 256) then
      hdf5_csize(2) = 256                !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 64) then
      hdf5_csize(2) = 64                 !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else
      flag_chunk = .false.
    end if

    !c make sure the group has already been created before opening it

    !c create the global file space and hyperslab
    call h5screate_simple_f(hdf5_ndim,hdf5_gdsize,filespace,           &
                            hdf5_ierr)

    if (flag_chunk) then
      !c create a data chunking property
      call h5pcreate_f(H5P_DATASET_CREATE_F, chunk_id, hdf5_ierr)
      call h5pset_chunk_f(chunk_id, hdf5_ndim, hdf5_csize, hdf5_ierr)

      !c create compressed data, dataset must be chunked for compression
      !c the following cause crash in hdf5 library, check when new
      !c hdf5 version is available

      ! Set ZLIB / DEFLATE Compression using compression level 6.
      ! To use SZIP Compression comment out these lines.
      if (hdf5_compress_level > 0 .and. hdf5_compress_level < 10) then
        call h5pset_deflate_f(chunk_id, hdf5_compress_level, hdf5_ierr)
      end if

      ! Uncomment these lines to set SZIP Compression
      !szip_options_mask = H5_SZIP_NN_OM_F
      !szip_pixels_per_block = 16
      !call H5Pset_szip_f(chunk_id, szip_options_mask,                 &
      !                   szip_pixels_per_block, hdf5_ierr)

      !c create the dataset id
      call h5dcreate_f(group_id, dataname, H5T_NATIVE_INTEGER,         &
                       filespace, dset_id, hdf5_ierr, dcpl_id=chunk_id)
    else
      !c create the dataset id
      call h5dcreate_f(group_id, dataname, H5T_NATIVE_INTEGER,         &
                       filespace, dset_id, hdf5_ierr)
    end if

    !c create local memory space and hyperslab
    call h5screate_simple_f(hdf5_ndim, hdf5_count, memspace, hdf5_ierr)

    if (nsize1 <= 0 .or. nsize2 <= 0) then
      call h5sselect_none_f(memspace,hdf5_ierr)
    end if

    !c Select hyperslab in the file.
    call h5dget_space_f(dset_id,filespace,hdf5_ierr)
    call h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F,          &
                               hdf5_goffset, hdf5_count, hdf5_ierr)                               

    if (nsize1 <= 0 .or. nsize2 <= 0) then
      call h5sselect_none_f(filespace,hdf5_ierr)
    end if

    !c create a data transfer property
    call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, hdf5_ierr)
    call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F,          &
                            hdf5_ierr)

    !c write the dataset collectively
    call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, dataset,              &
                    hdf5_count, hdf5_ierr, file_space_id=filespace,    &
                    mem_space_id=memspace, xfer_prp = plist_id)

    !c close resources
    call h5dclose_f(dset_id, hdf5_ierr)
    call h5sclose_f(filespace, hdf5_ierr)
    call h5sclose_f(memspace, hdf5_ierr)
    call h5pclose_f(plist_id, hdf5_ierr)
    if (flag_chunk) then
      call h5pclose_f(chunk_id, hdf5_ierr)
    end if

  end subroutine hdf5_usg_write_group_data_ivec

  !>
  !> write real type vector dataset to hdf5 file
  !>
  subroutine hdf5_usg_write_group_data_rvec(group_id,dataname,         &
                  nsize1,nsize2,nsize2_gbl,offset,dataset)

    use gen, only : hdf5_compress_level, nprcs

    implicit none

    !c passed variables
    integer(HID_T), intent(in) :: group_id     ! File identifier
    character(len=*), intent(in) :: dataname   ! Dataset name
    integer, intent(in) :: nsize1          ! Size of block
    integer, intent(in) :: nsize2          ! Size of nodes/cells
    integer, intent(in) :: nsize2_gbl      ! Size of nodes/cells
    integer, intent(in) :: offset          ! Offset of local dataset
#ifdef OUTPUT_DOUBLE
    real*8, allocatable :: dataset(:)      ! Dataset
#else
    real*4, allocatable :: dataset(:)      ! Dataset
#endif

    !c local variables
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: hdf5_ndim                   ! h5gopen_fNumber of dimensions used in the dataspace
    integer(HSIZE_T) :: hdf5_count(2)      ! Number of blocks to select from dataspace
    integer(HSIZE_T) :: hdf5_gdsize(2)     ! Array with current dimension global sizes
    integer(HSIZE_T) :: hdf5_goffset(2)    ! Offset of start of hyperslab
    integer(HSIZE_T) :: hdf5_csize(2)      ! Ayyay conaining sizes of chunk dimensions
    integer(HID_T) :: dset_id              ! Dataset identifier
    integer(HID_T) :: chunk_id             ! Chunk identifier
    integer(HID_T) :: filespace            ! Dataspace identifier in file
    integer(HID_T) :: memspace             ! Memoryspace identifier in file
    integer(HID_T) :: plist_id             ! Property list identifier
    logical :: flag_chunk                  ! flag to use chunk

    ! Uncomment these variables to use SZIP compression
    !integer :: szip_options_mask
    !integer :: szip_pixels_per_block

    !c create the data space for the domain datset
    hdf5_ndim = 2
    hdf5_count(1) = nsize1
    hdf5_count(2) = nsize2
    hdf5_gdsize(1) = nsize1
    hdf5_gdsize(2) = nsize2_gbl
    hdf5_goffset(1) = 0
    hdf5_goffset(2) = offset

    flag_chunk = .true.
    hdf5_csize(1) = nsize1
    if (nsize2_gbl/nprcs > 4096) then
      hdf5_csize(2) = 4096               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 1024) then
      hdf5_csize(2) = 1024               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 256) then
      hdf5_csize(2) = 256                !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 64) then
      hdf5_csize(2) = 64                 !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else
      flag_chunk = .false.
    end if

    !c make sure the group has already been created before opening it

    !c create the global file space and hyperslab
    call h5screate_simple_f(hdf5_ndim,hdf5_gdsize,filespace,           &
                            hdf5_ierr)

    if (flag_chunk) then
      !c create a data chunking property
      call h5pcreate_f(H5P_DATASET_CREATE_F, chunk_id, hdf5_ierr)
      call h5pset_chunk_f(chunk_id, hdf5_ndim, hdf5_csize, hdf5_ierr)

      !c create compressed data, dataset must be chunked for compression
      !c the following cause crash in hdf5 library, check when new
      !c hdf5 version is available

      ! Set ZLIB / DEFLATE Compression using compression level 6.
      ! To use SZIP Compression comment out these lines.
      if (hdf5_compress_level > 0 .and. hdf5_compress_level < 10) then
        call h5pset_deflate_f(chunk_id, hdf5_compress_level, hdf5_ierr)
      end if

      ! Uncomment these lines to set SZIP Compression
      !szip_options_mask = H5_SZIP_NN_OM_F
      !szip_pixels_per_block = 16
      !call H5Pset_szip_f(chunk_id, szip_options_mask,                 &
      !                   szip_pixels_per_block, hdf5_ierr)

      !c create the dataset id
      call h5dcreate_f(group_id, dataname,                             &
#ifdef OUTPUT_DOUBLE 
                       H5T_NATIVE_DOUBLE,                              &
#else
                       H5T_NATIVE_FLOAT,                               &
#endif
                       filespace, dset_id, hdf5_ierr, dcpl_id=chunk_id)
    else
      !c create the dataset id
      call h5dcreate_f(group_id, dataname,                             &
#ifdef OUTPUT_DOUBLE 
                       H5T_NATIVE_DOUBLE,                              &
#else
                       H5T_NATIVE_FLOAT,                               &
#endif
                       filespace, dset_id, hdf5_ierr)
    end if


    !c create local memory space and hyperslab
    call h5screate_simple_f(hdf5_ndim, hdf5_count, memspace, hdf5_ierr)

    if (nsize1 <= 0 .or. nsize2 <= 0) then
      call h5sselect_none_f(memspace,hdf5_ierr)
    end if

    !c Select hyperslab in the file.
    call h5dget_space_f(dset_id,filespace,hdf5_ierr)
    call h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F,            &
                               hdf5_goffset, hdf5_count, hdf5_ierr)                               

    if (nsize1 <= 0 .or. nsize2 <= 0) then
      call h5sselect_none_f(filespace,hdf5_ierr)
    end if

    !c create a data transfer property
    call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, hdf5_ierr)
    call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F,          &
                            hdf5_ierr)

    !c write the dataset collectively
    call h5dwrite_f(dset_id,                                           &
#ifdef OUTPUT_DOUBLE 
                    H5T_NATIVE_DOUBLE,                                 &
#else
                    H5T_NATIVE_FLOAT,                                  &
#endif
                    dataset, hdf5_count, hdf5_ierr,                    &
                    file_space_id=filespace, mem_space_id=memspace,    &
                    xfer_prp = plist_id)

    !c close resources
    call h5dclose_f(dset_id, hdf5_ierr)
    call h5sclose_f(filespace, hdf5_ierr)
    call h5sclose_f(memspace, hdf5_ierr)
    call h5pclose_f(plist_id, hdf5_ierr)
    if (flag_chunk) then
      call h5pclose_f(chunk_id, hdf5_ierr)
    end if

  end subroutine hdf5_usg_write_group_data_rvec

  !>
  !> read real type vector dataset from hdf5 file, not mpi collective
  !>
  subroutine hdf5_usg_read_group_data_rvec(group_id,dataname,         &
                  nsize1,nsize2,nsize2_gbl,offset,dataset)

    use gen, only : hdf5_compress_level, nprcs

    implicit none

    !c passed variables
    integer(HID_T), intent(in) :: group_id     ! File identifier
    character(len=*), intent(in) :: dataname   ! Dataset name
    integer, intent(in) :: nsize1          ! Size of block
    integer, intent(in) :: nsize2          ! Size of nodes/cells
    integer, intent(in) :: nsize2_gbl      ! Size of nodes/cells
    integer, intent(in) :: offset          ! Offset of local dataset
#ifdef OUTPUT_DOUBLE
    real*8, allocatable :: dataset(:)      ! Dataset
#else
    real*4, allocatable :: dataset(:)      ! Dataset
#endif

    !c local variables
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: hdf5_ndim                   ! h5gopen_fNumber of dimensions used in the dataspace
    integer(HSIZE_T) :: hdf5_count(2)      ! Number of blocks to select from dataspace
    integer(HSIZE_T) :: hdf5_gdsize(2)     ! Array with current dimension global sizes
    integer(HSIZE_T) :: hdf5_goffset(2)    ! Offset of start of hyperslab
    integer(HSIZE_T) :: hdf5_csize(2)      ! Ayyay conaining sizes of chunk dimensions
    integer(HID_T) :: dset_id              ! Dataset identifier
    integer(HID_T) :: chunk_id             ! Chunk identifier
    integer(HID_T) :: filespace            ! Dataspace identifier in file
    integer(HID_T) :: memspace             ! Memoryspace identifier in file
    integer(HID_T) :: plist_id             ! Property list identifier
    logical :: flag_chunk                  ! flag to use chunk

    !c create the data space for the domain datset
    hdf5_ndim = 2
    hdf5_count(1) = nsize1
    hdf5_count(2) = nsize2
    hdf5_gdsize(1) = nsize1
    hdf5_gdsize(2) = nsize2_gbl
    hdf5_goffset(1) = 0
    hdf5_goffset(2) = offset

    flag_chunk = .true.
    hdf5_csize(1) = nsize1
    if (nsize2_gbl/nprcs > 4096) then
      hdf5_csize(2) = 4096               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 1024) then
      hdf5_csize(2) = 1024               !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 256) then
      hdf5_csize(2) = 256                !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else if (nsize2_gbl/nprcs > 64) then
      hdf5_csize(2) = 64                 !1024 intege*4 is 4096(4K) which matches most file block size on file systems
    else
      flag_chunk = .false.
    end if

    !c make sure the group has already been created before opening it

    !c create the global file space and hyperslab
    call h5screate_simple_f(hdf5_ndim,hdf5_gdsize,filespace,           &
                            hdf5_ierr)
    
    !c open the dataset id
    call h5dopen_f(group_id, dataname, dset_id, hdf5_ierr)

    if (flag_chunk) then
      !c create a data chunking property
      call h5dget_create_plist_f(dset_id, chunk_id, hdf5_ierr)
      call h5pget_chunk_f(chunk_id, hdf5_ndim, hdf5_csize, hdf5_ierr)

      !c create compressed data, dataset must be chunked for compression
      !c the following cause crash in hdf5 library, check when new
      !c hdf5 version is available

      ! Set ZLIB / DEFLATE Compression using compression level 6.
      ! To use SZIP Compression comment out these lines.
      if (hdf5_compress_level > 0 .and. hdf5_compress_level < 10) then
        call h5pset_deflate_f(chunk_id, hdf5_compress_level, hdf5_ierr)
      end if

      ! Uncomment these lines to set SZIP Compression
      !szip_options_mask = H5_SZIP_NN_OM_F
      !szip_pixels_per_block = 16
      !call H5Pset_szip_f(chunk_id, szip_options_mask,                 &
      !                  szip_pixels_per_block, hdf5_ierr)
    end if
                            
    if (nsize1 <= 0 .or. nsize2 <= 0) then
      call h5sselect_none_f(memspace,hdf5_ierr)
    end if

    !c Select hyperslab in the file.
    call h5dget_space_f(dset_id,filespace,hdf5_ierr)
    call h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F,            &
                               hdf5_goffset, hdf5_count, hdf5_ierr)   

    if (nsize1 <= 0 .or. nsize2 <= 0) then
      call h5sselect_none_f(filespace,hdf5_ierr)
    end if

    !c create a data transfer property
    call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, hdf5_ierr)
    call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F,          &
                            hdf5_ierr)
  
    !c read the dataset    
    call h5dread_f(dset_id,                                            &
#ifdef OUTPUT_DOUBLE 
                   H5T_NATIVE_DOUBLE,                                  &
#else
                   H5T_NATIVE_FLOAT,                                   &
#endif
                   dataset, hdf5_count,                                &
                   hdf5_ierr, file_space_id=filespace,                 &
                   mem_space_id=memspace, xfer_prp = plist_id)

    !c close resources
    call h5dclose_f(dset_id, hdf5_ierr)
    call h5sclose_f(filespace, hdf5_ierr)
    call h5sclose_f(memspace, hdf5_ierr)
    call h5pclose_f(plist_id, hdf5_ierr)
    if (flag_chunk) then
      call h5pclose_f(chunk_id, hdf5_ierr)
    end if

  end subroutine hdf5_usg_read_group_data_rvec

  !>
  !> read node global/natural ordering stored in domain.h5 file
  !> important note, this is in sequential mode, each processor
  !> gets its own copy
  !>
  subroutine hdf5_usg_read_node_lg2g(file_id, file_name, hdf5_ierr)

    use gen, only : ilog, node_hdf5_lg2g_pre, node_idx_lg2g,           &
                    mem_cur, mem_max, memory_monitor
    use usg_mesh_data, only : num_nodes, num_nodes_gbl

    implicit none

    integer(HID_T) :: file_id
    character(len=*) :: file_name
    integer :: hdf5_ierr

    !c local variables
    integer :: inode, inode_gbl, ierr
    integer, allocatable :: hdf_pg2g(:), hdf_g2pg(:)

    integer(HID_T) :: group_id, dset_id
    integer(HSIZE_T), dimension(1) :: dset_dims

    external :: checkerr

    !c allocate data for temporatory use
    allocate(hdf_pg2g(num_nodes_gbl), stat = ierr)
    call checkerr(ierr,'hdf_pg2g',ilog)
    hdf_pg2g = 0
    call memory_monitor(sizeof(hdf_pg2g),'hdf_pg2g',.true.)

    allocate(hdf_g2pg(num_nodes_gbl), stat = ierr)
    call checkerr(ierr,'hdf_g2pg',ilog)
    hdf_g2pg = 0
    call memory_monitor(sizeof(hdf_g2pg),'hdf_g2pg',.true.)

    !c initialize global data size
    !c required by old MPI version (e.g., OpenMPI 1.6.5)
    dset_dims = num_nodes_gbl

    hdf5_ierr = 0

    !c initialize the interface
    call h5open_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the specified hdf5 file
    call h5fopen_f (file_name, H5F_ACC_RDONLY_F, file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the group "domain"
    call h5gopen_f(file_id, "domain", group_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the dataset "vertices_lg2g"
    call h5dopen_f(group_id, "vertices_lg2g", dset_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c read the dataset
    call h5dread_f(dset_id, H5T_NATIVE_INTEGER, hdf_pg2g, dset_dims, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the dataset after reading
    call h5dclose_f(dset_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the group after reading
    call h5gclose_f(group_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the file after reading
    call h5fclose_f(file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the interface after reading
    call h5close_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c set mapping for node_hdf5_pre_lg2g
    do inode_gbl = 1,num_nodes_gbl
      inode = hdf_pg2g(inode_gbl)
      hdf_g2pg(inode) = inode_gbl
    end do

    allocate(node_hdf5_lg2g_pre(num_nodes), stat = ierr)
    call checkerr(ierr,'node_hdf5_lg2g_pre',ilog)
    node_hdf5_lg2g_pre = 0
    call memory_monitor(sizeof(node_hdf5_lg2g_pre),'node_hdf5_lg2g_pre',.true.)

    do inode = 1, num_nodes
      node_hdf5_lg2g_pre(inode) = hdf_g2pg(node_idx_lg2g(inode))
    end do

    call memory_monitor(-sizeof(hdf_pg2g),'hdf_pg2g',.true.)
    call memory_monitor(-sizeof(hdf_g2pg),'hdf_g2pg',.true.)
    deallocate(hdf_pg2g)
    deallocate(hdf_g2pg)

  end subroutine hdf5_usg_read_node_lg2g

  !>
  !> read global node variables in petsc ordering from domain.h5 file
  !> important note, this is in sequential mode, each processor
  !> gets its own copy
  !>
  subroutine hdf5_usg_read_layer_node_var(file_id, file_name,          &
                  group_name, dset_name, var_out, b_exist, hdf5_ierr)

    use gen, only : ilog, mem_cur, mem_max, memory_monitor
    use usg_mesh_data, only : num_nodes_per_layer, node_to_layer_node
    use usg_mesh_surface, only : num_nodes_sn, node_idx_sn2lg

    implicit none

    integer(HID_T) :: file_id
    character(len=*) :: file_name, group_name, dset_name
    real*8, allocatable :: var_out(:)
    logical :: b_exist
    integer :: hdf5_ierr

    !c local variables
    integer :: inode, inode_sn, inode_ln, ierr
    integer(HID_T) :: group_id, dset_id
    integer(HSIZE_T), dimension(1) :: dset_dims

#ifdef OUTPUT_DOUBLE
    real*8, allocatable :: dset_var_layer(:)
#else
    real*4, allocatable :: dset_var_layer(:)
#endif

    external :: checkerr

    !c allocate memory for the dataset to be read
    allocate(dset_var_layer(num_nodes_per_layer), stat = ierr)
    call checkerr(ierr,'dset_var_layer',ilog)
    call memory_monitor(sizeof(dset_var_layer),'dset_var_layer',.true.)

    !c initialize global data size
    !c required by old MPI version (e.g., OpenMPI 1.6.5)
    dset_dims = num_nodes_per_layer

    !c initialize the interface
    call h5open_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the specified hdf5 file
    call h5fopen_f (file_name, H5F_ACC_RDONLY_F, file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the group "domain"
    call h5gopen_f(file_id, trim(group_name), group_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c check if dataset exists
    call h5lexists_f(group_id, trim(dset_name), b_exist, hdf5_ierr)    
    if (b_exist) then
      !c open the dataset if exists
      call h5dopen_f(group_id, trim(dset_name), dset_id, hdf5_ierr)
      if (hdf5_ierr < 0) then
        return
      end if
  
      !c read the dataset
      call h5dread_f(dset_id,                                          &
#ifdef OUTPUT_DOUBLE 
                     H5T_NATIVE_DOUBLE,                                &
#else
                     H5T_NATIVE_FLOAT,                                 &
#endif
                     dset_var_layer,dset_dims, hdf5_ierr)
      if (hdf5_ierr < 0) then
        return
      end if
  
      !c close the dataset after reading
      call h5dclose_f(dset_id, hdf5_ierr)
      if (hdf5_ierr < 0) then
        return
      end if

      !c set the local value
      do inode_sn = 1, num_nodes_sn
        inode_ln = node_to_layer_node(node_idx_sn2lg(inode_sn))
        var_out(inode_sn) = dset_var_layer(inode_ln)
      end do
  
      call memory_monitor(-sizeof(dset_var_layer),'dset_var_layer',.true.)
      deallocate(dset_var_layer)

    end if

    !c close the group after reading
    call h5gclose_f(group_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the file after reading
    call h5fclose_f(file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the interface after reading
    call h5close_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

  end subroutine hdf5_usg_read_layer_node_var

  !>
  !> read global node variables in petsc ordering from domain.h5 file
  !> important note, this is in sequential mode, each processor
  !> gets its own copy
  !>
  subroutine hdf5_usg_read_node_var(file_id, file_name, group_name,    &
                                dset_name, var_out, b_exist, hdf5_ierr)

    use gen, only : ilog, node_hdf5_lg2g_pre, mem_cur, mem_max,        &
                    memory_monitor
    use usg_mesh_data, only : num_nodes, num_nodes_gbl

    implicit none

    integer(HID_T) :: file_id
    character(len=*) :: file_name, group_name, dset_name
    real*8, allocatable :: var_out(:)
    logical :: b_exist
    integer :: hdf5_ierr

    !c local variables
    integer :: inode, ierr
    integer(HID_T) :: group_id, dset_id
    integer(HSIZE_T), dimension(1) :: dset_dims

#ifdef OUTPUT_DOUBLE 
    real*8, allocatable :: dset_var_gbl(:)
#else
    real*4, allocatable :: dset_var_gbl(:)
#endif

    external :: checkerr

    !c allocate memory for the dataset to be read
    allocate(dset_var_gbl(num_nodes_gbl), stat = ierr)
    call checkerr(ierr,'dset_var_gbl',ilog)
    call memory_monitor(sizeof(dset_var_gbl),'dset_var_gbl',.true.)

    !c initialize global data size
    !c required by old MPI version (e.g., OpenMPI 1.6.5)
    dset_dims = num_nodes_gbl

    !c initialize the interface
    call h5open_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the specified hdf5 file
    call h5fopen_f (file_name, H5F_ACC_RDONLY_F, file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c open the group "domain"
    call h5gopen_f(file_id, trim(group_name), group_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c check if dataset exists
    call h5lexists_f(group_id, trim(dset_name), b_exist, hdf5_ierr)    
    if (b_exist) then
      !c open the dataset if exists
      call h5dopen_f(group_id, trim(dset_name), dset_id, hdf5_ierr)
      if (hdf5_ierr < 0) then
        return
      end if
  
      !c read the dataset
      call h5dread_f(dset_id,                                          &
#ifdef OUTPUT_DOUBLE 
                     H5T_NATIVE_DOUBLE,                                &
#else
                     H5T_NATIVE_FLOAT,                                 &
#endif
                     dset_var_gbl, dset_dims, hdf5_ierr)
      if (hdf5_ierr < 0) then
        return
      end if
  
      !c close the dataset after reading
      call h5dclose_f(dset_id, hdf5_ierr)
      if (hdf5_ierr < 0) then
        return
      end if

      !c set the local value
      do inode = 1, num_nodes
        var_out(inode) = dset_var_gbl(node_hdf5_lg2g_pre(inode))
      end do
  
      call memory_monitor(-sizeof(dset_var_gbl),'dset_var_gbl',.true.)
      deallocate(dset_var_gbl)

    end if

    !c close the group after reading
    call h5gclose_f(group_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the file after reading
    call h5fclose_f(file_id, hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

    !c close the interface after reading
    call h5close_f(hdf5_ierr)
    if (hdf5_ierr < 0) then
      return
    end if

  end subroutine hdf5_usg_read_node_var

  !>
  !> write mesh data and domain decomposition to hdf5 file
  !>
  subroutine hdf5_usg_write_mesh_data(file_id)

    use gen, only : rank, realbuffer_hdf, integerbuffer_hdf,           &
                    node_idx_lg2pg, mem_cur, mem_max, memory_monitor,  &
                    node_idx_lg2g, cell_idx_lg2g, ilog
    use usg_mesh_data, only : num_nodes_loc, num_nodes, num_nodes_gbl, &
                              num_cells_loc, num_cells, num_cells_gbl, &
                              nodes, cells, offset_nodes, offset_cells,&
                              b_mesh_output_scale, mesh_output_scale,  &
                              b_use_node_matids, b_use_cell_matids,    &
                              node_matids, cell_matids,                &
                              num_nodes_per_cell

    implicit none

    !c passed variables
    integer(HID_T) :: file_id              ! File identifier
    integer(HID_T) :: group_id             ! Group identifier
    integer(HID_T) :: plist_id             ! Property list identifier

    !c local variables
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: i, inode, icell, ierr
    character*256 :: strbuffer

    real*8 :: zout
    real*8, external :: zoutput
    external :: checkerr

    !c create a group for the mesh data set
    strbuffer = "domain"
    !c create and open a group
    call h5gcreate_f(file_id,strbuffer,group_id,hdf5_ierr,             &
                     OBJECT_NAMELEN_DEFAULT_F)
    !c write vertices dataset to the group
    allocate(realbuffer_hdf(num_nodes*3), stat = ierr)
    call checkerr(ierr,'hdf5_usg-realbuffer_hdf',ilog)
    call memory_monitor(sizeof(realbuffer_hdf),'realbuffer_hdf',.true.)

    if (b_mesh_output_scale) then
      do inode = 1, num_nodes
        realbuffer_hdf((inode-1)*3+1) = nodes(inode)%x*mesh_output_scale%x
        realbuffer_hdf((inode-1)*3+2) = nodes(inode)%y*mesh_output_scale%y
        realbuffer_hdf((inode-1)*3+3) = nodes(inode)%z*mesh_output_scale%z
      end do
    else
      do inode = 1, num_nodes
        realbuffer_hdf((inode-1)*3+1) = nodes(inode)%x
        realbuffer_hdf((inode-1)*3+2) = nodes(inode)%y
        realbuffer_hdf((inode-1)*3+3) = nodes(inode)%z
      end do
    end if

    call hdf5_usg_write_group_data_vec(group_id,'vertices',3,          &
              num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer_hdf)
    call memory_monitor(-sizeof(realbuffer_hdf),'realbuffer_hdf',.true.)
    deallocate(realbuffer_hdf)

    !c write cells dataset to the group
    allocate(integerbuffer_hdf(num_nodes_per_cell*num_cells), stat = ierr)
    call checkerr(ierr,'hdf5_usg-integerbuffer_hdf',ilog)
    call memory_monitor(sizeof(integerbuffer_hdf),'integerbuffer_hdf',.true.)

    do icell = 1, num_cells
      do i = 1, num_nodes_per_cell
        integerbuffer_hdf((icell-1)*num_nodes_per_cell+i) =            &
                      node_idx_lg2pg(cells(i,icell))-1
      end do
    end do
    call hdf5_usg_write_group_data_vec(group_id,'cells',               &
              num_nodes_per_cell,num_cells_loc,num_cells_gbl,          &
              offset_cells,integerbuffer_hdf)
    call memory_monitor(-sizeof(integerbuffer_hdf),'integerbuffer_hdf',.true.)
    deallocate(integerbuffer_hdf)

    !c write node domain decomposition information to the group
    allocate(integerbuffer_hdf(num_nodes_loc), stat = ierr)
    call checkerr(ierr,'hdf5_usg-integerbuffer_hdf',ilog)
    integerbuffer_hdf = rank
    call memory_monitor(sizeof(integerbuffer_hdf),'integerbuffer_hdf',.true.)

    call hdf5_usg_write_group_data_1d(group_id,"vertices_rank",        &
              num_nodes_loc,num_nodes_gbl,offset_nodes,integerbuffer_hdf)
    call memory_monitor(-sizeof(integerbuffer_hdf),'integerbuffer_hdf',.true.)
    deallocate(integerbuffer_hdf)

    !c write cell domain decomposition information to the group
    allocate(integerbuffer_hdf(num_cells_loc), stat = ierr)
    call checkerr(ierr,'hdf5_usg-integerbuffer_hdf',ilog)
    integerbuffer_hdf = rank
    call memory_monitor(sizeof(integerbuffer_hdf),'integerbuffer_hdf',.true.)

    call hdf5_usg_write_group_data_1d(group_id,"cells_rank",           &
              num_cells_loc,num_cells_gbl,offset_cells,integerbuffer_hdf)
    call memory_monitor(-sizeof(integerbuffer_hdf),'integerbuffer_hdf',.true.)
    deallocate(integerbuffer_hdf)

    !c write node natural ordering to the group
    call hdf5_usg_write_group_data_1d(group_id,"vertices_lg2g",        &
              num_nodes_loc,num_nodes_gbl,offset_nodes,node_idx_lg2g)

    !c write cell natural ordering to the group
    call hdf5_usg_write_group_data_1d(group_id,"cells_lg2g",           &
                num_cells_loc,num_cells_gbl,offset_cells,cell_idx_lg2g)

    !c write node material property id to the group
    if (b_use_node_matids) then
      call hdf5_usg_write_group_data_1d(group_id,"vertices_matid",     &
                num_nodes_loc,num_nodes_gbl,offset_nodes,node_matids)
    end if

    !c write cell material property id to the group
    if (b_use_cell_matids) then
      call hdf5_usg_write_group_data_1d(group_id,"cells_matid",        &
                num_cells_loc,num_cells_gbl,offset_cells,cell_matids)
    end if

    !c close group
    call h5gclose_f(group_id,hdf5_ierr)

  end subroutine hdf5_usg_write_mesh_data

  !>
  !> write mesh data and domain decomposition to hdf5 file
  !>
  subroutine hdf5_usg_write_surface_mesh_data(file_id)

    use gen, only : rank, ilog, realbuffer_hdf, integerbuffer_hdf,     &
                    memory_monitor
    
    use usg_mesh_surface, only : num_nodes_sn, num_cells_sn,           &
                                 num_nodes_sn_loc, num_cells_sn_loc,   &
                                 num_nodes_sn_gbl, num_cells_sn_gbl,   &
                                 node_idx_sn2lg, cell_idx_sn2lg,       &
                                 node_idx_lg2sn, num_nodes_sn_per_cell,&
                                 offset_nodes_sn, offset_cells_sn,     &
                                 node_idx_sn2sg
                                 
                                                     
    use usg_mesh_data, only : cells, b_mesh_output_scale,              &
                              mesh_output_scale, b_use_node_matids,    &
                              b_use_cell_matids, node_matids,          &
                              cell_matids, layer_nodes_top,            &
                              num_nodes_per_cell, node_to_layer_node,  &
                              cell_to_layer_cell
                              

    implicit none

    !c passed variables
    integer(HID_T) :: file_id              ! File identifier    

    !c local variables
    integer(HID_T) :: group_id             ! Group identifier
    integer(HID_T) :: plist_id             ! Property list identifier
    integer :: hdf5_ierr                   ! HDF5 error code
    integer :: i, j, k, i_sn, icell_sn, inode, icell, ierr
    character*256 :: strbuffer
    logical, allocatable :: iflags(:)

    real*8 :: zout
    real*8, external :: zoutput
    external :: checkerr

    !c create a group for the mesh data set
    strbuffer = "domain"
    !c create and open a group
    call h5gcreate_f(file_id,strbuffer,group_id,hdf5_ierr,             &
                     OBJECT_NAMELEN_DEFAULT_F)
    !c write vertices dataset to the group
    allocate(realbuffer_hdf(num_nodes_sn*3), stat = ierr)
    call checkerr(ierr,'hdf5_usg-realbuffer_hdf',ilog)
    call memory_monitor(sizeof(realbuffer_hdf),'realbuffer_hdf',.false.)

    if (b_mesh_output_scale) then
      do i_sn = 1, num_nodes_sn
        inode = node_to_layer_node(node_idx_sn2lg(i_sn))
        realbuffer_hdf((i_sn-1)*3+1) = layer_nodes_top(inode)%x*mesh_output_scale%x
        realbuffer_hdf((i_sn-1)*3+2) = layer_nodes_top(inode)%y*mesh_output_scale%y
        realbuffer_hdf((i_sn-1)*3+3) = layer_nodes_top(inode)%z*mesh_output_scale%z
      end do
    else
      do i_sn = 1, num_nodes_sn
        inode = node_to_layer_node(node_idx_sn2lg(i_sn))
        realbuffer_hdf((i_sn-1)*3+1) = layer_nodes_top(inode)%x
        realbuffer_hdf((i_sn-1)*3+2) = layer_nodes_top(inode)%y
        realbuffer_hdf((i_sn-1)*3+3) = layer_nodes_top(inode)%z
      end do
    end if

    call hdf5_usg_write_group_data_vec(group_id,'vertices',3,          &
              num_nodes_sn_loc,num_nodes_sn_gbl,offset_nodes_sn,       &
              realbuffer_hdf)
    call memory_monitor(-sizeof(realbuffer_hdf),'realbuffer_hdf',.false.)
    deallocate(realbuffer_hdf)

    !c write cells dataset to the group
    allocate(iflags(num_cells_sn), stat = ierr)
    iflags = .false.
    call checkerr(ierr,'hdf5_usg-iflags',ilog)
    call memory_monitor(sizeof(iflags),'hdf5_usg-iflags',.false.)

    do i_sn = 1, num_cells_sn
      icell = cell_idx_sn2lg(i_sn)
      k = 0
      do i = 1, num_nodes_per_cell
        j = node_idx_lg2sn(cells(i,icell))
        if (j > 0 .and. j <= num_nodes_sn) then
          k = k + 1
        end if
      end do
      if (k == num_nodes_sn_per_cell) then
        iflags(i_sn) = .true.
      end if
    end do  

    allocate(integerbuffer_hdf(num_nodes_sn_per_cell*num_cells_sn), stat = ierr)
    call checkerr(ierr,'hdf5_usg-integerbuffer_hdf',ilog)
    call memory_monitor(sizeof(integerbuffer_hdf),'integerbuffer_hdf',.false.)

    icell_sn = 0
    do i_sn = 1, num_cells_sn
      if (.not.iflags(i_sn)) then
        cycle
      end if
      icell = cell_idx_sn2lg(i_sn)
      icell_sn = icell_sn + 1
      k = 0
      do i = 1, num_nodes_per_cell
        j = node_idx_lg2sn(cells(i,icell))
        if (j > 0) then
          k = k + 1
          integerbuffer_hdf((icell_sn-1)*num_nodes_sn_per_cell+k) =        &
                 node_idx_sn2sg(node_idx_lg2sn(cells(i,icell)))-1
        end if
      end do
    end do

    call hdf5_usg_write_group_data_vec(group_id,'cells',               &
              num_nodes_sn_per_cell,num_cells_sn_loc,num_cells_sn_gbl, &
              offset_cells_sn,integerbuffer_hdf)  

    !c free memory space
    call memory_monitor(-sizeof(iflags),'hdf5_usg-iflags',.false.)
    deallocate(iflags, stat = ierr)    
              
    call memory_monitor(-sizeof(integerbuffer_hdf),'integerbuffer_hdf',.false.)
    deallocate(integerbuffer_hdf)

    !c write node domain decomposition information to the group
    allocate(integerbuffer_hdf(num_nodes_sn), stat = ierr)
    call checkerr(ierr,'hdf5_usg-integerbuffer_hdf',ilog)
    integerbuffer_hdf = rank
    call memory_monitor(sizeof(integerbuffer_hdf),'integerbuffer_hdf',.false.)

    call hdf5_usg_write_group_data_1d(group_id,"vertices_rank",        &
              num_nodes_sn_loc,num_nodes_sn_gbl,offset_nodes_sn,       &
              integerbuffer_hdf)

    !c write node natural ordering to the group
    do i_sn = 1, num_nodes_sn
      integerbuffer_hdf(i_sn) = node_to_layer_node(node_idx_sn2lg(i_sn))
    end do
    call hdf5_usg_write_group_data_1d(group_id,"vertices_lg2g",        &
              num_nodes_sn_loc,num_nodes_sn_gbl,offset_nodes_sn,       &
              integerbuffer_hdf)

    !c write node material property id to the group
    if (b_use_node_matids) then
      do i_sn = 1, num_nodes_sn
        integerbuffer_hdf(i_sn) = node_matids(node_idx_sn2lg(i_sn))
      end do

      call hdf5_usg_write_group_data_1d(group_id,"vertices_matid",     &
                num_nodes_sn_loc,num_nodes_sn_gbl,offset_nodes_sn,     &
                integerbuffer_hdf) 
    end if

    call memory_monitor(-sizeof(integerbuffer_hdf),'integerbuffer_hdf',.false.)
    deallocate(integerbuffer_hdf)

    !c write cell domain decomposition information to the group
    allocate(integerbuffer_hdf(num_cells_sn), stat = ierr)
    call checkerr(ierr,'hdf5_usg-integerbuffer_hdf',ilog)
    integerbuffer_hdf = rank
    call memory_monitor(sizeof(integerbuffer_hdf),'integerbuffer_hdf',.false.)

    call hdf5_usg_write_group_data_1d(group_id,"cells_rank",           &
              num_cells_sn_loc,num_cells_sn_gbl,offset_cells_sn,       &
              integerbuffer_hdf)

    !c write cell natural ordering to the group
    do i_sn = 1, num_cells_sn
      integerbuffer_hdf(i_sn) = cell_to_layer_cell(cell_idx_sn2lg(i_sn))
    end do
    call hdf5_usg_write_group_data_1d(group_id,"cells_lg2g",           &
              num_cells_sn_loc,num_cells_sn_gbl,offset_cells_sn,       &
              integerbuffer_hdf)

    !c write cell material property id to the group
    if (b_use_cell_matids) then
      do i_sn = 1, num_cells_sn
        integerbuffer_hdf(i_sn) = cell_matids(cell_idx_sn2lg(i_sn))
      end do

      call hdf5_usg_write_group_data_1d(group_id,"cells_matid",        &
                num_cells_sn_loc,num_cells_sn_gbl,offset_cells_sn,     &
                cell_matids)
    end if

    call memory_monitor(-sizeof(integerbuffer_hdf),'integerbuffer_hdf',.false.)
    deallocate(integerbuffer_hdf)

    !c close group
    call h5gclose_f(group_id,hdf5_ierr)

  end subroutine hdf5_usg_write_surface_mesh_data 
 
  !>
  !> initialize xmf file for hdf5 data to be loaded by paraview
  !>
  subroutine hdf5_usg_write_xmf_initialize(iunit)

    implicit none

    integer, intent(in) :: iunit

    write(iunit,10)
    write(iunit,11)
    write(iunit,12)
    write(iunit,13)
    write(iunit,14)

10  format ('<?xml version="1.0" ?>')
11  format ('<!DOCTYPE Xdmf SYSTEM "Xdmf.dtd" []>')
12  format ('<Xdmf>')
13  format (2x,'<Domain>')
14  format (4x,'<Grid Name="Mesh">')

  end subroutine hdf5_usg_write_xmf_initialize

  !>
  !> finalize xmf file for hdf5 data to be loaded by paraview
  !>
  subroutine hdf5_usg_write_xmf_finalize(iunit)

    implicit none

    integer, intent(in) :: iunit

    write(iunit,10)
    write(iunit,11)
    write(iunit,12)

10  format (4x,'</Grid>')
11  format (2x,'</Domain>')
12  format ('</Xdmf>')

  end subroutine hdf5_usg_write_xmf_finalize

  !>
  !> write xml file mesh data
  !>
  subroutine hdf5_usg_write_xmf_mesh(iunit,filename,celltype,numcells, &
                                     numnodes,numnodes_percell)

    implicit none

    !c passed variables
    integer, intent(in) :: iunit
    character(len=*), intent(in) :: filename
    integer, intent(in) :: celltype
    integer, intent(in) :: numcells
    integer, intent(in) :: numnodes
    integer, intent(in) :: numnodes_percell

    !c local variables
    character(len=36) :: cellname

    if (celltype == cell_type_tri) then
      cellname = 'Triangle'
    else if (celltype == cell_type_quad) then
      cellname = 'Quadrilateral'
    else if (celltype == cell_type_tetra) then
      cellname = 'Tetrahedron'
    else if (celltype == cell_type_hexa) then
      cellname = 'Hexahedron'
    else if (celltype == cell_type_prism) then
      cellname = 'Wedge'
    else if (celltype == cell_type_pyramid) then
      cellname = 'Pyramid'
    end if

    !c write cells
    write(iunit,10) trim(cellname),numcells
    write(iunit,11) numcells,numnodes_percell
    write(iunit,12) trim(filename)
    write(iunit,13)
    write(iunit,14)

    !c write vertices
    write(iunit,15)
    write(iunit,16) numnodes,3
    write(iunit,17) trim(filename)
    write(iunit,13)
    write(iunit,18)


10  format (6x,'<Topology Type="',a,'" NumberOfElements="',i0,'">')
11  format (8x,'<DataItem Format="HDF" DataType="Int" Dimensions="',i0,1x,i0,'">')
12  format (10x,a,':/domain/cells')
13  format (8x,'</DataItem>')
14  format (6x,'</Topology>')

15  format (6x,'<Geometry GeometryType="XYZ">')
16  format (8x,'<DataItem Format="HDF" Dimensions="',i0,1x,i0,'">')
17  format (10x,a,':/domain/vertices')
18  format (6x,'</Geometry>')

  end subroutine hdf5_usg_write_xmf_mesh

  !>
  !> write attribute data to xml file mesh data
  !>
  subroutine hdf5_usg_write_xmf_attribute(iunit,filename,attrigroup,   &
                  attriname,attritype,centertype,attrinum,ndim,alias)

    implicit none

    !c passed variables
    integer, intent(in) :: iunit
    character(len=*), intent(in) :: filename
    character(len=*), intent(in) :: attrigroup
    character(len=*), intent(in) :: attriname
    character(len=*), intent(in) :: attritype
    character(len=*), intent(in) :: centertype
    integer, intent(in) :: attrinum
    integer, intent(in) :: ndim
    character(len=*), intent(in), optional :: alias

    !c local variables

    if (present(alias)) then
      write(iunit,10) trim(alias),trim(attritype),trim(centertype)
    else
      write(iunit,10) trim(attriname),trim(attritype),trim(centertype)
    end if
    write(iunit,11) attrinum,ndim
    write(iunit,12) trim(filename),trim(attrigroup),trim(attriname)
    write(iunit,13)
    write(iunit,14)

10  format (6x,'<Attribute Name="',a,'" AttributeType="',a,'" Center="',a,'">')
11  format (8x,'<DataItem Dimensions="',i0,1x,i0,'" Format="HDF">')
12  format (10x,a,':/',a,'/',a)
13  format (8x,'</DataItem>')
14  format (6x,'</Attribute>')

  end subroutine hdf5_usg_write_xmf_attribute

end module hdf5_usg

#endif
#endif
