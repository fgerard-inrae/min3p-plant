!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/usg_mesh_data.F90 $
!---------------------------------------------------------------------
!********************************************************************!


! --------------------------------------------------------------------
!> Module of unstructured grid mesh generation
!>
!> Module description: Compact Array-Based Mesh Data Structures for
!>                     storing unstructured grid data
!>
!> Written by:    Danyang Su - Jul. 25, 2016
!>
!> Last modified:
!>
!> Notes: Ref. Tyler J. Alumbaugh and Xiangmin Jiao,
!>        Compact Array-Based Mesh Data Structures,
!>        Proceedings, 14th International Meshing Roundtable,
!>        Springer-Verlag, pp.485-504, September 11-14 2005
!>
!>        The structure in the paper is buggy without considerring
!>        the face with two or more borders. Modified in current
!>        implementation.
!>
!>
! --------------------------------------------------------------------

#ifdef USG

module usg_mesh_data

  use math_common
  use geometry
  use geometry_definition

#ifdef CGAL
  !c this is feature of Fortran 2003
  use iso_c_binding
#endif

#ifdef PETSC
  use petsc_mpi_common, only : petsc_mpi_finalize
#endif

  implicit none

  !>
  !> cell_type: input cell type data
  !>
  integer :: cell_type

  !>
  !> mesh projection
  !>
  integer :: cell_projection

  !>
  !> control volume method, median dual or voronoi diagram
  !>
  integer :: cvol_method

  !>
  !> number of nodes in the mesh
  !>
  integer :: num_nodes

  !>
  !> number of cells in the mesh
  !>
  integer :: num_cells

  !>
  !> number of nodes in each cell
  !>
  integer :: num_nodes_per_cell

  !>
  !> number of border edges
  !>
  integer :: num_border_faceedges

  !>
  !> number of edges per cell
  !>
  integer :: num_edges_per_cell

  !>
  !> number of faces per cell
  !>
  integer :: num_faces_per_cell
  
  !>
  !> number of nodes per face
  !>
  integer :: num_nodes_per_face

  !>
  !> maximum number of dual volume interface for the same cell linked to the edge
  !>
  integer :: num_edge_dvols

  !>
  !> maximum number of cells linked to the edge
  !>
  integer :: num_edge_maxcells

  !>
  !> maximum number adjacent nodes for cell
  !>
  integer :: cell_ajd_max_nodes

  !>
  !> base of node index of original mesh
  !>
  integer :: index_base_original

  !>
  !> USG topology data, Cell(Face)-Edge-Node
  !>
  logical :: b_renumber_node_id

  !>
  !> reverse node ordering in a cell
  !> used to convert a clockwise ordering to counterclockwise ordering
  !>
  logical :: b_reverse_cell_node

  !>
  !> reorder node ordering in a cell based on RHT rule
  !> used to convert a clockwise ordering to counterclockwise ordering
  !> different from b_reverse_cell_node, this flag only reverse cell node ordering
  !> for 2D coordinates in 3D space if it does not obey RHT rule
  !>
  logical :: b_reorder_cell_node

  !>
  !> export current mesh to pflotran mesh format
  !>
  logical :: b_export_mesh_pflotran

  !>
  !> nodes: id and coordinates of the nodes in the mesh
  !>
  type(point), allocatable :: nodes(:)

  !>
  !> cells: map each cell to the vertex index to create connectivity
  !> used in 2d or 3d
  !>
  integer, allocatable :: cells(:,:)

  !>
  !> b_use_node_matids: if true, use node material id from vtk mesh file 
  !>
  logical :: b_use_node_matids
  
  !>
  !> node material id
  !>
  integer, allocatable :: node_matids(:)


  !>
  !> b_use_cell_matids: if true, use cell material id from vtk mesh file
  !>
  logical :: b_use_cell_matids

  !>
  !> cell material id
  !>
  integer, allocatable :: cell_matids(:)

  !>
  !> number of nodes per layer
  !>
  integer :: num_nodes_per_layer

  !>
  !> number of cells per layer
  !>
  integer :: num_cells_per_layer

  !>
  !> number of node layers
  !>
  integer :: num_node_layers

  !>
  !> number of cell layers
  !>
  integer :: num_cell_layers

  !>
  !> layered nodes top, size: number of global nodes per layer
  !> note: node index does not change after RCM ordering
  !>
  type(point), allocatable :: layer_nodes_top(:)

  !>
  !> layered nodes bottom, size: number of global nodes per layer
  !> note: node index does not change after RCM ordering
  !>
  type(point), allocatable :: layer_nodes_bottom(:)

  !>
  !> map of local node to global layered node index (original node id in 2D without layer)
  !> note: this array point to the original data saved in layer_nodes_top and layer_nodes_bottom
  !>
  integer, allocatable :: node_to_layer_node(:)

  !>
  !> map of local cell to global layered cell index (original node id in 2D without layer)
  !>
  integer, allocatable :: cell_to_layer_cell(:)

  !>
  !> flag to use scale factor for mesh transforming during output
  !>
  logical :: b_mesh_output_scale

  !>
  !> scale factor of mesh transforming, for output of unstructured grid simulation only
  !>
  type(point) :: mesh_output_scale

  !>
  !> flag to use 2D plane in 3D space
  !>
  logical :: b_anchor_coord

  !>
  !> original two anchor points from the mesh used in the simulation 
  !>
  type(point) :: anchor_coord_old(2)

  !>
  !> corresponding two anchor points in the new mesh
  !>
  type(point) :: anchor_coord_new(2)

  !>
  !> on error, mark the flag
  !>
  logical :: b_error_flag

#ifdef PETSC
  !>
  !> number of nodes in the mesh
  !>
  integer :: num_nodes_loc

  !>
  !> number of nodes in the mesh
  !>
  integer :: num_nodes_gbl

  !>
  !> total number of ghost nodes
  !>
  integer :: num_ghost_nodes_gbl

  !>
  !> total number of nodes with ghost nodes from each processor
  !>
  integer :: num_nodes_with_ghost_gbl

  !>
  !> number of cells in the mesh
  !>
  integer :: num_cells_loc

  !>
  !> number of cells in the mesh
  !>
  integer :: num_cells_gbl

  !>
  !> total number of ghost nodes
  !>
  integer :: num_ghost_cells_gbl

  !>
  !> nodes: id and coordinates of the nodes in the global mesh
  !>
  type(point), allocatable :: nodes_gbl(:)

  !>
  !> cells: map each cell to the vertex index to create connectivity
  !> used in 2d or 3d
  !>
  integer, allocatable :: cells_gbl(:,:)

  !>
  !> number of local cells owned by each processor, public to all processors
  !>
  integer, allocatable :: num_cells_rank(:)

  !>
  !> number of nodes owned by each processor, including ghost nodes, public to all processors
  !>
  integer, allocatable :: num_nodes_with_ghost_rank(:)

  !>
  !> number of node offset value
  !>
  integer :: offset_nodes

  !>
  !> number of node offset value with ghost nodes
  !>
  integer :: offset_nodes_with_ghost

  !>
  !> number of cell offset value
  !>
  integer :: offset_cells


#endif
  
  !>
  !> cell_adj_nodes_ia: number of adjacent nodes to a cell
  !> used for third order and fourth order least-squares
  !> gradient reconstruction method.
  !>
  integer, allocatable :: cell_adj_nodes_ia(:)

  !>
  !> cell_adj_nodes_ja: number of adjacent nodes to a cell
  !> used for third order and fourth order least-squares
  !> gradient reconstruction method.
  !>
  integer, allocatable :: cell_adj_nodes_ja(:)


  !>
  !> number of cells attached to a node
  !>
  integer, allocatable :: node_num_cells(:)

  !>
  !> node_cells(ncon_cell_usg,num_nodes),
  !>assume the maximum number of cells attached to a node is ncon_usg
  !>
  integer, allocatable :: node_cells(:,:)
  
  !>
  !> boundary node indicator
  !>
  logical, allocatable :: is_boundary_node(:)

  !>
  !> boundary node indicator, global and temporary
  !>
  logical, allocatable :: is_boundary_node_gbl(:)

  !>
  !> boundary cell indicator
  !>
  logical, allocatable :: is_boundary_cell(:)

  !>
  !> boundary cell indicator, global and temporary
  !>
  logical, allocatable :: is_boundary_cell_gbl(:)

  !> ********************************************************************************

  !> half-edge based data storage for 2d mesh
  !>
  !> Half-edge ID <f,e,i>: the ID is composed of a pair of number where f is the ID
  !> of its containing face, e is the index of the edge which is always optitive,
  !> and i is the index of the edge (1-based) with the face. The different is
  !> when the edge is on the border, i is set to 0.
  !> To support boundary classification, the bth border half-edge is indicated as
  !> <b,e,0>, where the zero value distinguishes a border edge from a non-border one.
  !> Since the number of edges per face is at most four for 2d mesh, the ID is encoded
  !> in a single integer, using the last three bits to store the third part i, the second
  !> last three bits to store the edge index e, and the remaining bits the first part.
  !> Using 64-bit integers, the maximum number of cells is 2^(63-6)
  !>

  !> half-face based data storage for 3d mesh
  !>
  !> Anchored Half-Face AHF ID<c,f,a,i>: the anchor of a half-face is defined as its
  !> designated first vertex and each half-face has m anchored copies, where m is
  !> the number of vertices (or edges) of the face. The anchor is introduced because
  !> the ordering of vertices in a half-face is cyclic without a designated starting point.
  !> The first two parts correspond to the half-face ID where c is the cell index and f
  !> is face index (both start from 1) and the third part corresponds to the anchor index
  !> and the fourth parth is border indicator.
  !> (starts from 0) which is defined as follows: for a non-border half-face, if the
  !> anchor is the kth vertex in the face-vertex list of the face following the CGNS
  !> convention, then the anchor index is k-1; for a border half-face, the anchor index
  !> is mod(m-t,m), where t is the anchor index of the vertex in its opposite half-face.
  !> Each AHF has one opposite AHF, which is its opposite half-face with the same anchor.
  !> The middle two parts <f,a> of an AFH ID constitute the local AHF ID.
  !> The border indicator (0,1) requres 1 bit, the anchor index requires only two bits
  !> (0,1,2,3), the face index requires 3 bits (1 to 6), the local AHF ID requires 5 bits.
  !> Using 64-bit integers, the maximum number of cells is 2^(63-6).
  !>
  !> Note: the following variables use the same name and structure for 2D and 3D problem
  !>

  !>
  !> node2halfid: map each vertex to the ID of an incident half-edge originated from the node;
  !> map a border node to a border half-edge
  !> used in 2d only
  !>
  !> node2halfid: map each vertex to the ID of an incident half-face anchored at the node;
  !> map a border node to a border AHF
  !> used in 3d only
  !>
  integer*8, allocatable :: node2halfid(:)

  !>
  !> cell2halfid: map each non-boder half-edge to the ID of its twin half-edge
  !> used in 2d only, cell means face here
  !>
  !> cell2halfid: map each non-boder half-face to the ID of its twin half-face
  !> used in 3d only, cell means volume here
  !>
  integer*8, allocatable :: cell2halfid(:,:)

  !>
  !> border2halfid: map each border half-edge to the ID of its twin non-boder half edge
  !> used in 2d only
  !>
  !> border2halfid: map each border half-face to the ID of its twin non-boder half face
  !> used in 3d only
  !>
  integer*8, allocatable :: border2halfid(:)
  !> ********************************************************************************

  !>
  !> USG geometry data, Cell(Face)-Edge-Node
  !>

  !>
  !> cell center coordinates
  !> used in 2d and 3d, cell is reduced to face in 2d
  !>
  type(point), allocatable :: CellCenter(:)
  
  !>
  !> cell volume
  !> used in 2d and 3d
  !>
  real*8, allocatable :: cell_volumes(:)

  !>
  !> cell face area
  !>
  real*8, allocatable :: CellFaceArea(:,:)

  !>
  !> inverse distance weighting from node to cell center
  !> only used when cell-based velocity export is specified
  !>
  real*8, allocatable :: CellNodeInversDist(:,:)

  !>
  !> least square gradient reconstruction for cell-based
  !> velocity output
  !>
  type(grad_ls_matrix), allocatable :: CellNodeInversDistMatrix(:)

  !>
  !> angles in each cell
  !>
  real*8, allocatable :: CellNodeAngle(:,:)

  !>
  !> cell face center, NOT control volume interface
  !> used in 2d/3d
  !>
  type(point), allocatable :: CellFaceCenter(:,:)

  !>
  !> cell control volume interface area
  !>
  real*8, allocatable :: CellCvolFaceArea(:,:,:)

  !>
  !> control volume interface center
  !>
  type(point), allocatable :: CellCvolFaceCenter(:,:,:)

  !>
  !> control volume interface unit ourward normal vector
  !> note: this outward normal vector is for the  edge (ivol-jvol),
  !> for edge (jvol-ivol), switch the direction by multiplicator rswitch
  !>
  type(point), allocatable :: CellCvolFaceUnitNorm(:,:,:)

  !>
  !> cell face out normal vector, NOT control volume interface
  !> used in 2d and 3d
  !>
  type(point), allocatable :: CellFaceScaledNorm(:,:)

  !>
  !> volume (surface area) of triangles splitted from quadrilateral cell
  !> used in 2d quadrilateral when splitted into two triangles
  !>
  real*8, allocatable :: cells_trivol(:,:)

  !>
  !> node index of triangles splitted from quadrilateral cell
  !> used in 2d quadrilateral when splitted into two triangles
  !>
  integer, allocatable :: CellsQuadTriNode(:,:,:)

  !>
  !> cell face out normal vector, NOT control volume interface
  !> used in 2d quadrilateral when splitted into two triangles
  !>
  type(point), allocatable :: CellsQuadTriFaceScaledNorm(:,:,:)

  !>
  !> advection velocity tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_adv(:,:,:)

  !>
  !> hydraulic conductivity tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_cond(:,:,:)

  !>
  !> hydraulic conductivity tensor at control volume interface center
  !>
  type(tensor), allocatable :: CellCvolFace_cond_tensor(:,:,:)

  !>
  !> dispersion tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_disp_da(:,:,:)

  !>
  !> full dispersion tensor at control volume interface center
  !>
  type(tensor), allocatable :: CellCvolFace_disp_da_tensor(:,:,:)

  !>
  !> dispersion tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_disp_da_ic(:,:,:,:)

  !>
  !> full dispersion tensor at control volume interface center
  !>
  type(tensor), allocatable :: CellCvolFace_disp_da_ic_tensor(:,:,:,:)

  !>
  !> gas dispersion tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_disp_g(:,:,:)

  !>
  !> multicomponent dispersion tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_disp_mcd(:,:,:)

  !>
  !> multicomponent dispersion tensor at control volume interface center
  !>
  type(tensor), allocatable :: CellCvolFace_disp_mcd_tensor(:,:,:)

  !>
  !> evaporation conductivity tensor espect to liquid pressure at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_evap_pa(:,:,:)

  !>
  !> evaporation conductivity tensor respect to temperature at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_evap_t(:,:,:)

  !>
  !> heat conductivity tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_heat_c(:,:,:)

  !>
  !> heat conductivity tensor at control volume interface center
  !>
  type(tensor), allocatable :: CellCvolFace_heat_c_tensor(:,:,:)

  !>
  !> heat dispersivity tensor at control volume interface center
  !>
  type(point), allocatable :: CellCvolFace_heat_d(:,:,:)

  !>
  !> heat dispersivity tensor at control volume interface center
  !>
  type(tensor), allocatable :: CellCvolFace_heat_d_tensor(:,:,:)

  !>
  !> check if obtuse cells are allowed
  !>
  logical :: allow_obtuse_cells

  !>
  !> gradient reconstruction type
  !>
  integer :: grad_method

  !>
  !> requirement of minimum number of nodes for high order
  !> least square gradient reconstruction
  !>
  integer :: grad_hls_min_nodes

  !>
  !> inverse distance spatial weighting
  !>
  logical :: grad_spatial_weighting

  !>
  !> gradient average spatial weighting
  !> 2: minimum
  !> 1: harmonic
  !> 0: centered
  !>
  integer :: grad_average_weighting

  !>
  !> separate interface for each cell or not
  !> for Voronoi diagram method, the control volume interface cross
  !> two cells (2D) or n cells (3D) for the shared edge. This parameter
  !> allows to use separated interface for each cell or not
  !>
  logical :: b_use_face_based_flux

  !>
  !> inverse distance spatial weighting factor
  !>
  real*8 :: grad_spatial_factor

  !>
  !> use volume weighted gradient interpolation between neighbour cells
  !>
  logical :: b_cell_based_grad_itpl

  !>
  !> least square gradient reconstruction matrix data
  !>
  type(grad_ls_matrix), allocatable :: grad_ls_matrices(:)

  !>
  !> least square gradient reconstruction matrix data for
  !> high order gradient reconstruction
  !>
  type(grad_hls_matrix), allocatable :: grad_hls_matrices(:,:,:)

  !>
  !> vector of face midpoint to node, used to calculate taylor's high
  !> order truncation error
  !>
  type(point), allocatable :: edge_face2nodes_vec(:,:,:,:)

  !> half-face based data storage for 3d mesh,
  !>*****************to be added********************

  !>
  !> interfaces of write mesh data
  !>
  interface write_mesh_data_vtk_ascii
    module procedure write_mesh_data_vtk_ascii_z
    module procedure write_mesh_data_vtk_ascii_z_order
    module procedure write_mesh_data_vtk_ascii_zout
  end interface write_mesh_data_vtk_ascii

  !>
  !> interface of calculate jacell id
  !>
  interface cal_jacell_id
    module procedure cal_jacell_id1
    module procedure cal_jacell_id2
  end interface cal_jacell_id

  !>
  !> interface of spatial interpolation
  !>
  interface usg_mesh_data_interpolate
    module procedure usg_mesh_data_interpolate_xyz
    module procedure usg_mesh_data_interpolate_center
    module procedure usg_mesh_data_interpolate_center2
    module procedure usg_mesh_data_interpolate_center3  
  end interface usg_mesh_data_interpolate

  contains


  !>
  !> read mesh data from input vtk file, current do not support hybrid mesh
  !> note: vtk mesh data is 0-based
  !>       for legacy_vtk, coordinates of each line contain three points
  !> need modification for usg parallel version
  !>
  subroutine usg_mesh_data_input_vtk(strfile,legacy_vtk)

    use file_unit, only : lun_get, lun_free
    use file_utility, only : makelowercase, replacecharacter
    use gen, only : node_min, node_max, b_use_layered_mesh,            &
                    ndim_sys, mem_cur, mem_max, memory_monitor,        &
                    mnjavs, ilog, idbg, usg_mesh_ordering,             &
                    ctype_num_node_layers, num_node_layers_inp,        &
                    rank, b_enable_output, prefix, l_prfx
    use parm, only : ncon_usg_est, ncon_usg, ncon_cell_usg

    implicit none

    character(len=*), intent(in) :: strfile
    logical, intent(in) :: legacy_vtk

    !c local variables
    logical :: bexist, b_counterclockwise
    integer :: i, j, k, idummy, itemp, ntemp, ivtk, inids, itype,      &
               ntri, nquad, ntetra, nhexa, nprism, npyramid, nhalf,    &
               ncells_counterclockwise, ncells_reordered, iread,       &
               nread, istart, iend, nsize, iedge, ivol, jvol, ierr
    integer :: ncells_chk
    integer :: cellnodes_loc(8)
    integer, allocatable :: cellnodes_1d(:)    
    !> renumber node ids, should be same 0-based or 1-based with the input file
    integer, allocatable :: node_ids(:)
    type(point), allocatable :: pts(:)
    integer, allocatable :: node_cell_conn(:,:)
    integer, allocatable :: node_node_conn(:,:)
    character(256) :: strbuffer
    real*8, parameter :: rsmall = 1.0d-10

    external :: checkerr

    !c set error flag
    b_error_flag = .false.

    inquire(file = trim(strfile), exist = bexist)
    if(.not. bexist) then
      if(rank == 0) then
        write(*,'(3(1x,a))') "Error: mesh data file",trim(strfile),    &
                             " is missing"
        write(ilog,'(3(1x,a))') "Error: mesh data file",trim(strfile), &
                             " is missing"
      end if
      goto 990
    end if

    ivtk = lun_get()
    open(ivtk,file=trim(strfile),status='old',form='formatted',    &
         access='sequential',err=990)

    !c set material id flags to false
    b_use_node_matids = .false.
    b_use_cell_matids = .false.

    !c read cell information to check if this mesh is cell is mixed with point,
    !c line and other types
    !c check the dataset attributes
    ntri = 0
    nquad = 0
    ntetra = 0
    nhexa = 0
    nprism = 0
    npyramid = 0
    do while(.true.)
      !c begin reading dataset, keywords: points, cells, cell_types followed by the number of items
      read(ivtk,'(a)',err=998,end=900) strbuffer
      call makelowercase(strbuffer)
      if(index(strbuffer,'cell_types') == 1) then
        call replacecharacter(strbuffer, achar(9), " ")     !replace tab with blank space
        i = index(strbuffer,' ')
        if(i > 0) then
          read(strbuffer(i:),*) ntemp
        else
          if(rank == 0) then
            write(ilog,*) "error in reading number of cell_types"
          end if
          goto 998
        end if

        do i = 1, ntemp
          read(ivtk,*,err=998,end=900) itype
          if (itype == cell_type_tri) then
            ntri = ntri + 1
          else if (itype == cell_type_quad) then
            nquad = nquad + 1
          else if (itype == cell_type_tetra) then
            ntetra = ntetra + 1
          else if (itype == cell_type_hexa) then
            nhexa = nhexa + 1
          else if (itype == cell_type_prism) then
            nprism = nprism + 1
          else if (itype == cell_type_pyramid) then
            npyramid = npyramid + 1
          end if
        end do
        exit
      end if
    end do

    !c check if this is hybrid mesh and assign number of cells
    if (ntetra > 0 .or. nhexa > 0 .or. nprism > 0 .or. npyramid > 0) then
      itemp = 0
      if (ntetra > 0) then
        itemp = itemp + 1
      end if
      if (nhexa > 0) then
        itemp = itemp + 1
      end if
      if (nprism > 0) then
        itemp = itemp + 1
      end if
      if (npyramid > 0) then
        itemp = itemp + 1
      end if

      if (itemp > 1) then
        if(rank == 0) then
          write(ilog,*) "hybrid mesh with different cell types are not supported"
        end if
        goto 998
      else if (ntetra > 0) then
        cell_type = cell_type_tetra
        num_cells = ntetra
        num_nodes_per_cell = 4
      else if (nhexa > 0) then
        cell_type = cell_type_hexa
        num_cells = nhexa
        num_nodes_per_cell = 8
      else if (nprism > 0) then
        cell_type = cell_type_prism
        num_cells = nprism
        num_nodes_per_cell = 6
      else if (npyramid > 0) then
        cell_type = cell_type_pyramid
        num_cells = npyramid
        num_nodes_per_cell = 5
      end if
    else
      if (ntri > 0 .and. nquad > 0) then
        if(rank == 0) then
          write(ilog,*) "hybrid mesh with different cell types are not supported"
        end if
        goto 998
      else if (ntri > 0) then
        cell_type = cell_type_tri
        num_cells = ntri
        num_nodes_per_cell = 3
      else if (nquad > 0) then
        cell_type = cell_type_quad
        num_cells = nquad
        num_nodes_per_cell = 4
      end if
    end if

    if (legacy_vtk .and. num_cells /= ntemp) then
      if(rank == 0) then
        write(*,*) "error in reading legacy vtk file: mixed cell types"
        write(ilog,*) "error in reading legacy vtk file: mixed cell types"
      end if
      goto 998
    end if

    !c allocate memory if cell node reordering is turned on
    allocate(pts(num_nodes_per_cell), stat = ierr)
    call checkerr(ierr,'pts',ilog)
    call memory_monitor(sizeof(num_nodes_per_cell),'num_nodes_per_cell',.false.)


    !c read the version of mesh data file
    rewind(ivtk)
    read(ivtk,'(a)',err=998,end=999) strbuffer
    call makelowercase(strbuffer)

    if(index(strbuffer,'# vtk datafile version') /= 1) then
      if(rank == 0) then
        write(ilog,*) "error reading in mesh data version"
      end if
      goto 998
    end if

    !c read the header of mesh data file
    read(ivtk,'(a)',err=998,end=999) strbuffer
    call makelowercase(strbuffer)

    !c read the file format of mesh data file, current only support ascii
    read(ivtk,'(a)',err=998,end=999) strbuffer
    call makelowercase(strbuffer)
    if(index(strbuffer,'ascii') /= 1) then
      if(rank == 0) then
        write(ilog,*) "error: vtk file format should be ascii"
      end if
      goto 998
    end if

    !c read dataset structure
    read(ivtk,'(a)',err=998,end=999) strbuffer
    call makelowercase(strbuffer)

    !c check the dataset attributes
    do while(.true.)

      !c begin reading dataset, keywords: points, cells, cell_types followed by the number of items
      read(ivtk,'(a)',err=998,end=900) strbuffer
      call makelowercase(strbuffer)

      if(index(strbuffer,'points') == 1) then
        call replacecharacter(strbuffer, achar(9), " ")     !replace tab with blank space
        i = index(strbuffer,' ')
        if(i > 0) then
          read(strbuffer(i:),*) num_nodes

          if (b_renumber_node_id) then
            allocate(node_ids(0:num_nodes-1), stat = ierr)
            call checkerr(ierr,'node_ids',ilog)
            call memory_monitor(sizeof(node_ids),'node_ids',.false.)

            inids = lun_get()
            open(inids,file=trim(prefix(:l_prfx)//'.nids'),            &
                 status='old',form='formatted',err=998)
            do j = 1, num_nodes
              read(inids,*) k
              node_ids(k) = j
            end do
            close(inids)
            call lun_free(inids)
          end if
        else
          if(rank == 0) then
            write(ilog,*) "error in reading number of points"
          end if
          goto 998
        end if

        !c calculate maximum connection
        !c 0 index in the first direction means the total number of connected nodes/cells
        !c 0 index in the second direction means the possible zero based node index
        !c initialize the array with -1 since the index can be either 0-based or 1-based.
        allocate(node_node_conn(0:ncon_usg_est,0:num_nodes), stat = ierr)
        call checkerr(ierr,'node_node_conn',ilog)
        node_node_conn(0,:) = 0
        node_node_conn(1:ncon_usg_est,:) = -1
        call memory_monitor(sizeof(node_node_conn),'node_node_conn',.false.)

        allocate(node_cell_conn(0:ncon_usg_est,0:num_nodes), stat = ierr)
        call checkerr(ierr,'node_cell_conn',ilog)
        node_cell_conn(0,:) = 0
        node_cell_conn(1:ncon_usg_est,:) = -1
        call memory_monitor(sizeof(node_cell_conn),'node_cell_conn',.false.)

        !c allocate nodes dataset
        allocate(nodes(num_nodes), stat = ierr)
        call checkerr(ierr,'nodes',ilog)

        if (legacy_vtk) then
          nread = 3
        else
          nread = 1
        end if

        if (b_renumber_node_id) then
          do i = 1, num_nodes, nread
            istart = i
            iend = i+nread-1
            if (iend > num_nodes) then
              iend = num_nodes
            end if
            read(ivtk,*,err=999,end=999) (nodes(node_ids(iread-1))%x,  &
                                          nodes(node_ids(iread-1))%y,  &
                                          nodes(node_ids(iread-1))%z,  &
                                          iread=istart,iend)
          end do
        else
          do i = 1, num_nodes, nread
            istart = i
            iend = i+nread-1
            if (iend > num_nodes) then
              iend = num_nodes
            end if
            read(ivtk,*,err=999,end=999) (nodes(iread)%x,              &
                                           nodes(iread)%y,             &
                                           nodes(iread)%z,             &
                                           iread=istart,iend)
          end do
        end if

        !c set max and min nodes
        node_min%x = 1.0d100
        node_min%y = 1.0d100
        node_min%z = 1.0d100

        node_max%x = -1.0d100
        node_max%y = -1.0d100
        node_max%z = -1.0d100

        do i = 1, num_nodes
          if (nodes(i)%x > node_max%x) then
            node_max%x = nodes(i)%x
          else if (nodes(i)%x < node_min%x) then
            node_min%x = nodes(i)%x
          end if
          if (nodes(i)%y > node_max%y) then
            node_max%y = nodes(i)%y
          else if (nodes(i)%y < node_min%y) then
            node_min%y = nodes(i)%y
          end if
          if (nodes(i)%z > node_max%z) then
            node_max%z = nodes(i)%z
          else if (nodes(i)%z < node_min%z) then
            node_min%z = nodes(i)%z
          end if
        end do

        !c set coordinate system
        if ((node_max%x-node_min%x)>rsmall .and.                           &
            (node_max%y-node_min%y)>rsmall .and.                           &
            (node_max%z-node_min%z)>rsmall) then
          cell_projection = projection_xyz
          ndim_sys = 3
        else if ((node_max%x-node_min%x)>rsmall .and.                      &
                 (node_max%y-node_min%y)>rsmall) then
          cell_projection = projection_xy
          ndim_sys = 2
        else if ((node_max%y-node_min%y)>rsmall .and.                      &
                 (node_max%z-node_min%z)>rsmall) then
          cell_projection = projection_yz
          ndim_sys = 2
        else if ((node_max%x-node_min%x)>rsmall .and.                      &
                 (node_max%z-node_min%z)>rsmall) then
          cell_projection = projection_xz
          ndim_sys = 2
        else if (node_max%x-node_min%x>rsmall) then
          cell_projection = projection_x
          ndim_sys = 1
        else if (node_max%y-node_min%y>rsmall) then
          cell_projection = projection_y
          ndim_sys = 1
        else if (node_max%z-node_min%z>rsmall) then
          cell_projection = projection_z
          ndim_sys = 1
        end if

      else if((legacy_vtk .and. index(strbuffer,'connectivity') == 1) .or. &
              (.not.legacy_vtk .and. index(strbuffer,'cells') == 1)) then
        
        !c allocate cells dataset
        nhalf = num_nodes_per_cell/2

        allocate(cells(num_nodes_per_cell, num_cells), stat = ierr)
        call checkerr(ierr,'cells',ilog)
        call memory_monitor(sizeof(cells),'cells',.false.)

        !c only read selected cell type
        !c note: for legacy vtk format, only one cell type is allowed,
        !c for general vtk format, only one cell type is selected during reading
        if (legacy_vtk) then
          nsize = num_nodes_per_cell*num_cells
          allocate(cellnodes_1d(nsize), stat = ierr)
          call checkerr(ierr,'cellnodes_1d',ilog)
          call memory_monitor(sizeof(cellnodes_1d),'cellnodes_1d',.false.)

          do j = 1, ntemp
            istart = (j-1)*9+1
            iend = istart+8
            if (iend > nsize) then
              iend = nsize
            end if
            read(ivtk,*,err=998,end=900) cellnodes_1d(istart:iend) 
            if (iend == nsize) then
              exit
            end if
          end do
        end if

        i = 0
        ncells_chk = 0
        ncells_reordered = 0

        do j = 1, ntemp
          !c only read selected cell type
          !c note: for legacy vtk format, only one cell type is allowed,
          !c for general vtk format, only one cell type is selected during reading
          if (legacy_vtk) then
            ncells_chk = ncells_chk + 1
            istart = (ncells_chk-1)*num_nodes_per_cell+1
            iend = ncells_chk*num_nodes_per_cell
            cellnodes_loc(1:num_nodes_per_cell) = cellnodes_1d(istart:iend)
          else
            read(ivtk,'(a)',err=998,end=900) strbuffer
            read(strbuffer,*) itemp
            if (itemp == num_nodes_per_cell) then
              ncells_chk = ncells_chk + 1
              read(strbuffer,*) idummy, cellnodes_loc(1:num_nodes_per_cell)
            else
              cycle
            end if
          end if

          !c calculate node-node connection
          if (cell_type == cell_type_tri) then
            do iedge = 1, size(edge_node_mapping_tri,2)
              ivol = cellnodes_loc(edge_node_mapping_tri(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_tri(2,iedge))

              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_quad) then
            do iedge = 1, size(edge_node_mapping_quad,2)
              ivol = cellnodes_loc(edge_node_mapping_quad(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_quad(2,iedge))

              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_tetra) then
            do iedge = 1, size(edge_node_mapping_tetra,2)
              ivol = cellnodes_loc(edge_node_mapping_tetra(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_tetra(2,iedge))

              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_hexa) then
            do iedge = 1, size(edge_node_mapping_hexa,2)
              ivol = cellnodes_loc(edge_node_mapping_hexa(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_hexa(2,iedge))

              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_prism) then
            do iedge = 1, size(edge_node_mapping_prism,2)
              ivol = cellnodes_loc(edge_node_mapping_prism(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_prism(2,iedge))

              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          !else if (cell_type == cell_type_pyramid) then
          end if

          !c calculate node-cell connection
          do ivol = 1, num_nodes_per_cell
            k = node_cell_conn(0,cellnodes_loc(ivol)) + 1
            if (k > ncon_usg_est) then
              if (rank == 0) then
                write(*,'(2(a,1x,i0,1x))') 'error: ivol',ivol,     &
                      'maximum cell connection ',k
                write(ilog,'(2(a,1x,i0,1x))') 'error: ivol',ivol,  &
                      'maximum cell connection',k
              end if
              b_error_flag = .true.
              goto 900
            end if
            node_cell_conn(0,cellnodes_loc(ivol)) = k
            node_cell_conn(k,cellnodes_loc(ivol)) = ncells_chk          
          end do

          if (b_reverse_cell_node) then
            if (cell_type == cell_type_prism .or. cell_type == cell_type_hexa) then
              cells(1:nhalf,ncells_chk) = cellnodes_loc(nhalf+1:nhalf*2)
              cells(nhalf+1:nhalf*2,ncells_chk) = cellnodes_loc(1:nhalf)
            else
              do k = 1, num_nodes_per_cell
                cells(k,ncells_chk) = cellnodes_loc(num_nodes_per_cell-k+1)
              end do
            end if
          else
            if (b_reorder_cell_node .and. cell_projection /= projection_xyz) then
              do k = 1, num_nodes_per_cell
                pts(k) = nodes(cellnodes_loc(k)+1)
              end do
              b_counterclockwise = geometry_isCounterClockwise(      &
                num_nodes_per_cell,pts(1:num_nodes_per_cell),        &
                cell_projection)
              if (b_counterclockwise) then
                cells(1:num_nodes_per_cell,ncells_chk) = cellnodes_loc(1:num_nodes_per_cell)
              else
                do k = 1, num_nodes_per_cell
                  cells(k,ncells_chk) = cellnodes_loc(num_nodes_per_cell-k+1)
                end do
                ncells_reordered = ncells_reordered + 1
              end if
            else
              cells(1:num_nodes_per_cell,ncells_chk) = cellnodes_loc(1:num_nodes_per_cell)
            end if
          end if

          !c convert 0-based to 1-based
          if (b_renumber_node_id) then
            cells(1:num_nodes_per_cell,ncells_chk) = node_ids(cells(1:num_nodes_per_cell,ncells_chk))
          else
            cells(1:num_nodes_per_cell,ncells_chk) = cells(1:num_nodes_per_cell,ncells_chk) + 1
          end if

          if (ncells_chk == num_cells) then
            exit
          end if
        end do

        if (legacy_vtk) then
          call memory_monitor(-sizeof(cellnodes_1d),'cellnodes_1d',.false.)
          deallocate(cellnodes_1d)
          call checkerr(ierr,'cellnodes_1d',ilog)
        end if

        !c calculate maximum connection
        mnjavs = 0
        ncon_usg = 0
        if (node_node_conn(0,0) > 0) then
          index_base_original = 0
        else
          index_base_original = 1
        end if

        ivol = 0
        do i = 0+index_base_original,num_nodes-1+index_base_original
          mnjavs = mnjavs + node_node_conn(0,i)+1
          if (node_node_conn(0,i) >= ncon_usg) then
            ncon_usg = node_node_conn(0,i)+1
            ivol = i
          end if
        end do

        if (rank == 0) then
          if (b_enable_output) then
            write(*,'(2(a,1x,i0,1x))') 'node',ivol,                    &
                  ',maximum node-node connection',ncon_usg
            write(ilog,'(2(a,1x,i0,1x))') 'node',ivol,                 &
                  ',maximum node-node connection',ncon_usg
          end if
        end if

        !c calculate maximum number of connections belong to an edge
        if (cell_projection == projection_xyz) then
          num_edge_maxcells = 0
          do ivol = 0+index_base_original,num_nodes-1+index_base_original
            do i = 1, node_node_conn(0,ivol)
              jvol = node_node_conn(i,ivol)
              !ntemp = 0
              !do j = 1, node_cell_conn(0,ivol)
              !  itemp = node_cell_conn(j,ivol)
              !  if (any(node_cell_conn(1:,jvol) == itemp)) then
              !    ntemp = ntemp + 1
              !  end if
              !end do
              ntemp = get_edge_shared_cells_num(                         &
                          node_cell_conn(0,ivol),node_cell_conn(0,jvol), &
                          node_cell_conn(1:node_cell_conn(0,ivol),ivol), &
                          node_cell_conn(1:node_cell_conn(0,jvol),jvol))
              num_edge_maxcells = max(num_edge_maxcells,ntemp)
            end do
          end do
        else
          num_edge_maxcells = 2
        end if

        ncon_cell_usg = 0
        jvol = 0
        !do i = 0, num_nodes
        do ivol = 0+index_base_original,num_nodes-1+index_base_original
          if (node_cell_conn(0,ivol) > ncon_cell_usg) then
            ncon_cell_usg = node_cell_conn(0,ivol)
            jvol = ivol
          end if
        end do

        if (rank == 0) then
          if (b_enable_output) then
            write(*,'(2(a,1x,i0,1x))') 'node',jvol,                    &
                  ',maximum node-cell connection',ncon_cell_usg
            write(ilog,'(2(a,1x,i0,1x))') 'node',jvol,                 &
                  ',maximum node-cell connection',ncon_cell_usg
          end if
        end if

        call memory_monitor(-sizeof(node_node_conn),'node_node_conn',.false.)
        deallocate(node_node_conn, stat = ierr)
        call checkerr(ierr,'node_node_conn',ilog)

        call memory_monitor(-sizeof(node_cell_conn),'node_cell_conn',.false.)
        deallocate(node_cell_conn, stat = ierr)
        call checkerr(ierr,'node_cell_conn',ilog)

        !c check number of cells that is counterclockwise and obeys RHT rule
        !c this part can be improved by moving the code upward
        if (cell_projection /= projection_xyz) then
          if (b_reorder_cell_node .and. ncells_reordered > 0) then
            if (rank == 0 .and. b_enable_output) then
              write(*,'(2(a,i0),a)')                                   &
                    "warning: cell-node ordering of ",                 &
                    ncells_reordered, "/",num_cells,                   &
                    " cells are reordered"
              write(ilog,'(2(a,i0),a)')                                &
                    "warning: cell-node ordering of ",                 &
                    ncells_reordered, "/",num_cells,                   &
                    " cells are reordered"
            end if
          end if

          ncells_counterclockwise = 0
          do j = 1, num_cells
            do k = 1, num_nodes_per_cell
              pts(k) = nodes(cells(k,j))
            end do
            b_counterclockwise = geometry_isCounterClockwise(          &
                  num_nodes_per_cell,pts(1:num_nodes_per_cell),        &
                  cell_projection)
            if (b_counterclockwise) then
              ncells_counterclockwise = ncells_counterclockwise + 1
            end if
          end do
          if (ncells_counterclockwise < num_cells) then
            if (rank == 0 .and. b_enable_output) then
              write(*,'(2(a,i0),a)')                                   &
                    "warning: cell-node ordering of ",                 &
                    num_cells-ncells_counterclockwise, "/",num_cells,  &
                    " cells are clockwise"
              write(ilog,'(2(a,i0),a)')                                &
                    "warning: cell-node ordering of ",                 &
                    num_cells-ncells_counterclockwise, "/",num_cells,  &
                    " cells are clockwise"
            end if
          end if

        end if

      else if(index(strbuffer,'point_data') == 1) then
        call replacecharacter(strbuffer, achar(9), " ")     !replace tab with blank space
        i = index(strbuffer,' ')
        if(i > 0) then
          read(strbuffer(i:),*) ntemp
        else
          if(rank == 0) then
            write(ilog,*) "error in reading number of point data"
          end if
          goto 998
        end if

        read(ivtk,'(a)',err=998,end=900) strbuffer
        if (index(strbuffer,'node_matids') > 0) then
          b_use_node_matids = .true.

          !c allocate ndoes material id dataset
          if (allocated(node_matids)) then
            call memory_monitor(-sizeof(node_matids),'node_matids',.false.)
            deallocate(node_matids, stat = ierr)
            call checkerr(ierr,'node_matids',ilog)
          end if
          allocate(node_matids(ntemp), stat = ierr)
          call checkerr(ierr,'node_matids',ilog)
          call memory_monitor(sizeof(node_matids),'node_matids',.false.)

          !c skip 'lookup_table default' line
          read(ivtk,'(a)',err=998,end=900) strbuffer

          i = 0
          do j = 1, ntemp
            read(ivtk,*) node_matids(j)
          end do

        end if

      else if(index(strbuffer,'cell_data') == 1) then
        call replacecharacter(strbuffer, achar(9), " ")     !replace tab with blank space
        i = index(strbuffer,' ')
        if(i > 0) then
          read(strbuffer(i:),*) ntemp
        else
          if(rank == 0) then
            write(ilog,*) "error in reading number of cell data"
          end if
          goto 998
        end if

        read(ivtk,'(a)',err=998,end=900) strbuffer
        if (index(strbuffer,'cell_matids') > 0) then
          b_use_cell_matids = .true.

          !c allocate cells material id dataset
          if (allocated(cell_matids)) then
            call memory_monitor(-sizeof(cell_matids),'cell_matids',.false.)
            deallocate(cell_matids, stat = ierr)
            call checkerr(ierr,'cell_matids',ilog)
          end if

          allocate(cell_matids(ntemp), stat = ierr)
          call checkerr(ierr,'cell_matids',ilog)
          call memory_monitor(sizeof(cell_matids),'cell_matids',.false.)

          !c skip 'lookup_table default' line, not required for cell_data
          read(ivtk,'(a)',err=998,end=900) strbuffer

          i = 0
          do j = 1, ntemp
            read(ivtk,*) cell_matids(j)
          end do

        end if

      end if
    end do

900 continue

    close(ivtk)
    call lun_free(ivtk)
    
    if (b_error_flag) then
      if (rank == 0) then
        write(*,'(a,1x,i0)') "Error: maximum node connection exceeds",ncon_usg_est
        write(ilog,'(a,1x,i0)') "Error: maximum node connection exceeds",ncon_usg_est
      end if
      return
    end if

    if (allocated(node_ids)) then
      call memory_monitor(-sizeof(node_ids),'node_ids',.false.)
      deallocate(node_ids, stat = ierr)
      call checkerr(ierr,'node_ids',ilog)
    end if

    !c simply check if all the data has been read in successfully
    if (num_nodes < 1 .or. num_cells < 1) then
      goto 999
    end if

#ifdef PETSC
    num_nodes_gbl = num_nodes
    num_cells_gbl = num_cells

    if (btest(usg_mesh_ordering,0) .or. b_export_mesh_pflotran) then
      allocate(nodes_gbl(num_nodes_gbl), stat = ierr)
      call checkerr(ierr,'nodes_gbl',ilog)
      call memory_monitor(sizeof(nodes_gbl),'nodes_gbl',.false.)
      nodes_gbl = nodes

      allocate(cells_gbl(num_nodes_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'cells_gbl',ilog)
      call memory_monitor(sizeof(cells_gbl),'cells_gbl',.false.)
      cells_gbl = cells
    end if
#endif

    !c Set node properties for layered prism and hexahedral mesh
    !c this part is optional, help to set 3d domain initial condition
    !c Note: NOT strict if the material id is not set layer by later
    if (b_use_layered_mesh .and. (cell_type == cell_type_quad .or.    &
        cell_type == cell_type_prism .or. cell_type == cell_type_hexa)) then
             
      if (ctype_num_node_layers == 'material id') then        
        !c method 1: requires all the material id is consecutive 
        !c and identical for each layer
        if (b_use_node_matids) then 
          num_node_layers = maxval(node_matids)-minval(node_matids)+1
          num_nodes_per_layer = num_nodes/num_node_layers
        end if
      else if (ctype_num_node_layers == 'coordinate') then
        !c method 2: coordinates based
        do i = 2, num_nodes
          if ((nodes(i)%x == nodes(1)%x .and. nodes(i)%y == nodes(1)%y) .or. &
              (nodes(i)%y == nodes(1)%y .and. nodes(i)%z == nodes(1)%z) .or. &
              (nodes(i)%z == nodes(1)%z .and. nodes(i)%x == nodes(1)%x)) then
            num_nodes_per_layer = i - 1
            exit
          end if
        end do
        num_node_layers = num_nodes/num_nodes_per_layer
      else if (ctype_num_node_layers == 'user specified') then
          !c method 3: user specified
          num_node_layers = num_node_layers_inp
          num_nodes_per_layer = num_nodes/num_node_layers
      end if
        
      allocate(layer_nodes_top(num_nodes_per_layer), stat = ierr)
      call checkerr(ierr,'layer_nodes_top',ilog)
      call memory_monitor(sizeof(layer_nodes_top),'layer_nodes_top',.false.)

      allocate(layer_nodes_bottom(num_nodes_per_layer), stat = ierr)
      call checkerr(ierr,'layer_nodes_bottom',ilog)
      call memory_monitor(sizeof(layer_nodes_bottom),'layer_nodes_bottom',.false.)

      !c check if node order in z direction is descending or ascending
      itemp = num_nodes - num_nodes_per_layer

      if (nodes(1)%z > nodes(1+itemp)%z) then
        do i = 1, num_nodes_per_layer
          layer_nodes_top(i) = nodes(i)
        end do
        
        do i = 1, num_nodes_per_layer
          layer_nodes_bottom(i) = nodes(i+itemp)
        end do
      else
        do i = 1, num_nodes_per_layer
          layer_nodes_bottom(i) = nodes(i)
        end do
        
        do i = 1, num_nodes_per_layer
          layer_nodes_top(i) = nodes(i+itemp)
        end do
      end if

      if (num_node_layers > 1) then
        num_cell_layers = num_node_layers-1
        num_cells_per_layer = num_cells/num_cell_layers
      end if

    else
      num_node_layers = 0      
      num_nodes_per_layer = 0
      num_cell_layers = 0
      num_cells_per_layer = 0
    end if

    if (num_node_layers == 0) then
      b_use_layered_mesh = .false.
    end if

    !c no PETSc is used, allocate node_to_layer_node array here
    if (num_node_layers > 0) then
      if (allocated(node_to_layer_node)) then
        call memory_monitor(-sizeof(node_to_layer_node),'node_to_layer_node',.false.)
        deallocate(node_to_layer_node, stat = ierr)
        call checkerr(ierr,'node_to_layer_node',ilog)
      end if

      allocate(node_to_layer_node(num_nodes), stat = ierr)
      call checkerr(ierr,'node_to_layer_node',ilog)
      call memory_monitor(sizeof(node_to_layer_node),'node_to_layer_node',.false.)

      do i = 1, num_nodes
        j = mod(i,num_nodes_per_layer)
        if (j == 0) then
          j = num_nodes_per_layer
        end if
        node_to_layer_node(i) = j
      end do
    end if

    !c no PETSc is used, allocate cell_to_layer_cell array here
    if (num_cell_layers > 0) then
      if (allocated(cell_to_layer_cell)) then
        call memory_monitor(-sizeof(cell_to_layer_cell),'cell_to_layer_cell',.false.)
        deallocate(cell_to_layer_cell, stat = ierr)
        call checkerr(ierr,'cell_to_layer_cell',ilog)
      end if

      allocate(cell_to_layer_cell(num_cells), stat = ierr)
      call checkerr(ierr,'cell_to_layer_cell',ilog)
      call memory_monitor(sizeof(cell_to_layer_cell),'cell_to_layer_cell',.false.)

      do i = 1, num_cells
        j = mod(i,num_cells_per_layer)
        if (j == 0) then
          j = num_cells_per_layer
        end if
        cell_to_layer_cell(i) = j
      end do
    end if    

    if (b_enable_output .and. rank == 0) then
      write(*,'(a)') "Read unstructured vtk mesh from file, done."
    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening vtk mesh data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening vtk mesh data file'
      close(ilog)
    end if
    b_error_flag = .true.
    return

998 continue
    backspace(ivtk)
    read(ivtk,'(a)') strbuffer
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,'(2a)') 'error reading in vtk mesh data file: ',trim(strbuffer)
      write(*,*) 'SIMULATION TERMINATED'
      write(*,'(2a)') 'error reading in vtk mesh data file: ',trim(strbuffer)
      close(ilog)
    end if
    b_error_flag = .true.
    return

999 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'end in reading vtk mesh data file'
      close(ilog)
    end if
    b_error_flag = .true.
    return

  end subroutine usg_mesh_data_input_vtk

  !>
  !> read mesh data from input vtk file, current do not support hybrid mesh
  !> note: gid mesh data is 1-based
  !> need modification for usg parallel version
  !>
  subroutine usg_mesh_data_input_gid_mesh(strfile)

    use file_unit, only : lun_get, lun_free
    use file_utility, only : makelowercase, replacecharacter
    use gen, only : node_min, node_max, ndim_sys, ilog, idbg, rank,    &
                    mem_cur, mem_max, memory_monitor, mnjavs,          &
                    usg_mesh_ordering, b_enable_output, prefix,l_prfx
    use parm, only : ncon_usg_est, ncon_usg, ncon_cell_usg

    implicit none

    character(len=*), intent(in) :: strfile

    !c local variables
    logical :: bexist, bflag, b_counterclockwise
    integer :: i, j, k, idummy, itemp, imsh, inids, ierr,              &
               iedge, ivol, jvol, ntemp,                               &
               nhalf, ncells_counterclockwise, ncells_reordered
    integer :: cellnodes_loc(8)
    !> renumber node ids, should be same 0-based or 1-based with the input file
    integer, allocatable :: node_ids(:)
    type(point), allocatable :: pts(:)
    integer, allocatable :: node_cell_conn(:,:)
    integer, allocatable :: node_node_conn(:,:)
    character(256) :: strbuffer
    real*8, parameter :: rsmall = 1.0d-10

    external :: checkerr

    !c set error flag
    b_error_flag = .false.

    inquire(file = trim(strfile), exist = bexist)
    if(.not. bexist) then
      if(rank == 0) then
        write(*,'(3(1x,a))') "Error: mesh data file",trim(strfile),    &
                             " is missing"
        write(ilog,'(3(1x,a))') "Error: mesh data file",trim(strfile), &
                             " is missing"
      end if
      goto 990
    end if

    imsh = lun_get()
    open(imsh,file=trim(strfile),status='old',form='formatted',    &
         access='sequential',err=990)

    !c read the header of mesh data file
    read(imsh,'(a)',err=998,end=999) strbuffer
    call makelowercase(strbuffer)

    if(index(strbuffer,'mesh') /= 1) then
      if(rank == 0) then
        write(ilog,*) "error reading in mesh header"
      end if
      goto 998
    end if

    !c read element type
    if(index(strbuffer,'linear') >= 1) then
      cell_type = cell_type_line
      num_nodes_per_cell = 2
    else if(index(strbuffer,'triangle') >= 1) then
      cell_type = cell_type_tri
      num_nodes_per_cell = 3
    else if(index(strbuffer,'quadrilateral') >= 1) then
      cell_type = cell_type_quad
      num_nodes_per_cell = 4
    else if(index(strbuffer,'tetrahedra') >= 1) then
      cell_type = cell_type_tetra
      num_nodes_per_cell = 4
    else if(index(strbuffer,'prism') >= 1) then
      cell_type = cell_type_prism
      num_nodes_per_cell = 6
    else if(index(strbuffer,'hexahedra') >= 1) then
      cell_type = cell_type_hexa
      num_nodes_per_cell = 8
    end if

    !c allocate memory if cell node reordering is turned on
    allocate(pts(num_nodes_per_cell), stat = ierr)
    call checkerr(ierr,'pts',ilog)
    call memory_monitor(sizeof(pts),'pts',.false.)

    !c read number of points
    bflag = .true.
    num_nodes = 0
    rewind(imsh)
    do while(bflag)
      !c begin reading dataset, keywords: points, cells, cell_types followed by the number of items
      read(imsh,'(a)',err=998,end=900) strbuffer
      call makelowercase(strbuffer)

      if(index(strbuffer,'coordinates') == 1) then
        do while(.true.)
          read(imsh,'(a)',err=998,end=900) strbuffer
          call makelowercase(strbuffer)
          if(index(strbuffer,'end coordinates') == 1) then
            bflag = .false.
            exit
          else
            num_nodes = num_nodes + 1
          end if
        end do
      end if
    end do

    !c read renumbed node ids if specified
    if (b_renumber_node_id) then
      allocate(node_ids(num_nodes), stat = ierr)
      call checkerr(ierr,'node_ids',ilog)
      call memory_monitor(sizeof(node_ids),'node_ids',.false.)

      inids = lun_get()
      open(inids,file=trim(prefix(:l_prfx)//'.nids'),            &
           status='old',form='formatted',err=998)
      do j = 1, num_nodes
        read(inids,*) k
        node_ids(k) = j
      end do
      close(inids)
      call lun_free(inids)
    end if

    !c read point data
    allocate(nodes(num_nodes), stat = ierr)
    call checkerr(ierr,'nodes',ilog)
    call memory_monitor(sizeof(nodes),'nodes',.false.)

    !c calculate maximum connection
    !c 0 index in the first direction means the total number of connected nodes/cells
    !c 0 index in the second direction means the possible zero based node index
    !c initialize the array with -1 since the index can be either 0-based or 1-based.
    allocate(node_node_conn(0:ncon_usg_est,0:num_nodes), stat = ierr)
    call checkerr(ierr,'node_node_conn',ilog)
    node_node_conn(0,:) = 0
    node_node_conn(1:ncon_usg_est,:) = -1
    call memory_monitor(sizeof(node_node_conn),'node_node_conn',.false.)

    allocate(node_cell_conn(0:ncon_usg_est,0:num_nodes), stat = ierr)
    call checkerr(ierr,'node_cell_conn',ilog)
    node_cell_conn(0,:) = 0
    node_cell_conn(1:ncon_usg_est,:) = -1
    call memory_monitor(sizeof(node_cell_conn),'node_cell_conn',.false.)

    bflag = .true.
    rewind(imsh)
    do while(bflag)
      !c begin reading dataset, keywords: points, cells, cell_types followed by the number of items
      read(imsh,'(a)',err=998,end=900) strbuffer
      call makelowercase(strbuffer)

      if(index(strbuffer,'coordinates') == 1) then
        if (b_renumber_node_id) then
          do i = 1, num_nodes
            read(imsh,*) nodes(node_ids(i))%x,nodes(node_ids(i))%y,    &
                         nodes(node_ids(i))%z
          end do
        else
          do i = 1, num_nodes
            read(imsh,*) idummy, nodes(i)%x,nodes(i)%y,nodes(i)%z
          end do
        end if
        bflag = .false.
        exit
      end if
    end do

    !c set max and min nodes
    node_min%x = 1.0d100
    node_min%y = 1.0d100
    node_min%z = 1.0d100

    node_max%x = -1.0d100
    node_max%y = -1.0d100
    node_max%z = -1.0d100

    do i = 1, num_nodes
      if (nodes(i)%x > node_max%x) then
        node_max%x = nodes(i)%x
      else if (nodes(i)%x < node_min%x) then
        node_min%x = nodes(i)%x
      end if
      if (nodes(i)%y > node_max%y) then
        node_max%y = nodes(i)%y
      else if (nodes(i)%y < node_min%y) then
        node_min%y = nodes(i)%y
      end if
      if (nodes(i)%z > node_max%z) then
        node_max%z = nodes(i)%z
      else if (nodes(i)%z < node_min%z) then
        node_min%z = nodes(i)%z
      end if
    end do

    !c set coordinate system
    if ((node_max%x-node_min%x)>rsmall .and.                           &
        (node_max%y-node_min%y)>rsmall .and.                           &
        (node_max%z-node_min%z)>rsmall) then
      cell_projection = projection_xyz
      ndim_sys = 3
    else if ((node_max%x-node_min%x)>rsmall .and.                      &
             (node_max%y-node_min%y)>rsmall) then
      cell_projection = projection_xy
      ndim_sys = 2
    else if ((node_max%y-node_min%y)>rsmall .and.                      &
             (node_max%z-node_min%z)>rsmall) then
      cell_projection = projection_yz
      ndim_sys = 2
    else if ((node_max%x-node_min%x)>rsmall .and.                      &
             (node_max%z-node_min%z)>rsmall) then
      cell_projection = projection_xz
      ndim_sys = 2
    else
      ndim_sys = 1
    end if

    !c read number of cells
    bflag = .true.
    num_cells = 0
    rewind(imsh)
    do while(bflag)
      !c begin reading dataset, keywords: points, cells, cell_types followed by the number of items
      read(imsh,'(a)',err=998,end=900) strbuffer
      call makelowercase(strbuffer)

      if(index(strbuffer,'elements') == 1) then
        do while(.true.)
          read(imsh,'(a)',err=998,end=900) strbuffer
          call makelowercase(strbuffer)
          if(index(strbuffer,'end elements') == 1) then
            bflag = .false.
            exit
          else
            num_cells = num_cells + 1
          end if
        end do
      end if
    end do

    !c read cell dataset
    nhalf = num_nodes_per_cell/2

    allocate(cells(num_nodes_per_cell, num_cells), stat = ierr)
    call checkerr(ierr,'cells',ilog)
    call memory_monitor(sizeof(cells),'cells',.false.)

    bflag = .true.
    ncells_reordered = 0

    rewind(imsh)
    do while(bflag)
      !c begin reading dataset, keywords: points, cells, cell_types followed by the number of items
      read(imsh,'(a)',err=998,end=900) strbuffer
      call makelowercase(strbuffer)

      if(index(strbuffer,'elements') == 1) then
        do i = 1, num_cells
          read(imsh,*) idummy, cellnodes_loc(1:num_nodes_per_cell)

          !c calculate node-node connection
          if (cell_type == cell_type_tri) then
            do iedge = 1, size(edge_node_mapping_tri,2)
              ivol = cellnodes_loc(edge_node_mapping_tri(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_tri(2,iedge))
              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_quad) then
            do iedge = 1, size(edge_node_mapping_quad,2)
              ivol = cellnodes_loc(edge_node_mapping_quad(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_quad(2,iedge))
              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_tetra) then
            do iedge = 1, size(edge_node_mapping_tetra,2)
              ivol = cellnodes_loc(edge_node_mapping_tetra(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_tetra(2,iedge))
              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_hexa) then
            do iedge = 1, size(edge_node_mapping_hexa,2)
              ivol = cellnodes_loc(edge_node_mapping_hexa(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_hexa(2,iedge))
              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if

              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          else if (cell_type == cell_type_prism) then
            do iedge = 1, size(edge_node_mapping_prism,2)
              ivol = cellnodes_loc(edge_node_mapping_prism(1,iedge))
              jvol = cellnodes_loc(edge_node_mapping_prism(2,iedge))
              k = node_node_conn(0,ivol) + 1
              if (all(node_node_conn(1:k,ivol) /= jvol)) then
                node_node_conn(k,ivol) = jvol
                node_node_conn(0,ivol) = k
              end if
              k = node_node_conn(0,jvol) + 1
              if (all(node_node_conn(1:k,jvol) /= ivol)) then
                node_node_conn(k,jvol) = ivol
                node_node_conn(0,jvol) = k
              end if
            end do
          !else if (cell_type == cell_type_pyramid) then
          end if

          !c calculate node-cell connection
          do ivol = 1, num_nodes_per_cell
            k = node_cell_conn(0,cellnodes_loc(ivol)) + 1
            if (k > ncon_usg_est) then
              if (rank == 0) then
                write(*,'(2(a,1x,i0,1x))') 'error: ivol',ivol,     &
                      'maximum cell connection ',k
                write(ilog,'(2(a,1x,i0,1x))') 'error: ivol',ivol,  &
                      'maximum cell connection',k
              end if
              b_error_flag = .true.
              goto 900
            end if
            node_cell_conn(0,cellnodes_loc(ivol)) = k
            node_cell_conn(k,cellnodes_loc(ivol)) = i
          end do

          if (b_reverse_cell_node) then
            if (cell_type == cell_type_prism .or. cell_type == cell_type_hexa) then
              cells(1:nhalf,i) = cellnodes_loc(nhalf+1:nhalf*2)
              cells(nhalf+1:nhalf*2,i) = cellnodes_loc(1:nhalf)
            else
              do k = 1, num_nodes_per_cell
                cells(k,i) = cellnodes_loc(num_nodes_per_cell-k+1)
              end do
            end if
          else
            if (b_reorder_cell_node .and. cell_projection /= projection_xyz) then
              do k = 1, num_nodes_per_cell
                pts(k) = nodes(cellnodes_loc(k))
              end do
              b_counterclockwise = geometry_isCounterClockwise(      &
                num_nodes_per_cell,pts(1:num_nodes_per_cell),        &
                cell_projection)
              if (b_counterclockwise) then
                cells(1:num_nodes_per_cell,i) = cellnodes_loc(1:num_nodes_per_cell)
              else
                do k = 1, num_nodes_per_cell
                  cells(k,i) = cellnodes_loc(num_nodes_per_cell-k+1)
                end do
                ncells_reordered = ncells_reordered + 1
              end if
            else
              cells(1:num_nodes_per_cell,i) = cellnodes_loc(1:num_nodes_per_cell)
            end if
          end if

          !c convert 0-based to 1-based
          if (b_renumber_node_id) then
            cells(1:num_nodes_per_cell,i) = node_ids(cells(1:num_nodes_per_cell,i))
          end if
        end do

        !c check number of cells that is counterclockwise and obeys RHT rule
        !c this part can be improved by moving the code upward
        if (cell_projection /= projection_xyz) then
          if (b_reorder_cell_node .and. ncells_reordered > 0) then
            if (rank == 0 .and. b_enable_output) then
              write(*,'(2(a,i0),a)')                                   &
                    "warning: cell-node ordering of ",                 &
                    ncells_reordered, "/",num_cells,                   &
                    " cells are reordered"
              write(ilog,'(2(a,i0),a)')                                &
                    "warning: cell-node ordering of ",                 &
                    ncells_reordered, "/",num_cells,                   &
                    " cells are reordered"
            end if
          end if

          ncells_counterclockwise = 0
          do j = 1, num_cells
            do k = 1, num_nodes_per_cell
              pts(k) = nodes(cells(k,j))
            end do
            b_counterclockwise = geometry_isCounterClockwise(          &
                  num_nodes_per_cell,pts(1:num_nodes_per_cell),        &
                  cell_projection)
            if (b_counterclockwise) then
              ncells_counterclockwise = ncells_counterclockwise + 1
            end if
          end do
          if (ncells_counterclockwise < num_cells) then
            if (rank == 0 .and. b_enable_output) then
              write(*,'(2(a,1x,i8,1x),a)')                             &
                    "warning: cell-node ordering of",                  &
                    num_cells-ncells_counterclockwise, "in",num_cells, &
                    "cells are clockwise"
              write(ilog,'(2(a,1x,i8,1x),a)')                          &
                    "warning: cell-node ordering of",                  &
                    num_cells-ncells_counterclockwise, "in",num_cells, &
                    "cells are clockwise"
            end if
          end if
        end if

        bflag = .false.
        exit
      end if
    end do

900 continue

    close(imsh)
    call lun_free(imsh)

    if (b_error_flag) then
      if (rank == 0) then
        write(*,'(a,1x,i0)') "Error: maximum node connection exceeds",ncon_usg_est
        write(ilog,'(a,1x,i0)') "Error: maximum node connection exceeds",ncon_usg_est
      end if
      return
    end if

    !c calculate maximum connection
    mnjavs = 0
    ncon_usg = 0

    if (node_node_conn(0,0) > 0) then
      index_base_original = 0
    else
      index_base_original = 1
    end if

    ivol = 0
    do i = 0+index_base_original,num_nodes-1+index_base_original
      mnjavs = mnjavs + node_node_conn(0,i)+1
      if (node_node_conn(0,i) >= ncon_usg) then
        ncon_usg = node_node_conn(0,i)+1
        ivol = i
      end if
    end do

    if (rank == 0) then
      if (b_enable_output) then
        write(*,'(2(a,1x,i0,1x))') 'node',ivol,                        &
              ',maximum node-node connection',ncon_usg
        write(ilog,'(2(a,1x,i0,1x))') 'node',ivol,                     &
              ',maximum node-node connection',ncon_usg
      end if
    end if

    !c calculate maximum number of connections belong to an edge
    if (cell_projection == projection_xyz) then
      num_edge_maxcells = 0
      do ivol = 0+index_base_original,num_nodes-1+index_base_original
        do i = 1, node_node_conn(0,ivol)
          jvol = node_node_conn(i,ivol)
          !ntemp = 0
          !do j = 1, node_cell_conn(0,ivol)
          !  itemp = node_cell_conn(j,ivol)
          !  if (any(node_cell_conn(1:,jvol) == itemp)) then
          !    ntemp = ntemp + 1
          !  end if
          !end do
          ntemp = get_edge_shared_cells_num(                           &
                      node_cell_conn(0,ivol),node_cell_conn(0,jvol),   &
                      node_cell_conn(1:node_cell_conn(0,ivol),ivol),   &
                      node_cell_conn(1:node_cell_conn(0,jvol),jvol))
          num_edge_maxcells = max(num_edge_maxcells,ntemp)
        end do
      end do
    else
      num_edge_maxcells = 2
    end if

    ncon_cell_usg = 0
    do i = 0, num_nodes
      ncon_cell_usg = max(node_cell_conn(0,i),ncon_cell_usg)
    end do

    if (rank == 0) then
      if (b_enable_output) then
        write(*,'(a,1x,i0)') 'number of maximum node cell connection',ncon_cell_usg
        write(ilog,'(a,1x,i0)') 'number of maximum node cell connection',ncon_cell_usg
      end if
    end if

    call memory_monitor(-sizeof(node_node_conn),'node_node_conn',.false.)
    deallocate(node_node_conn, stat = ierr)
    call checkerr(ierr,'node_node_conn',ilog)

    call memory_monitor(-sizeof(node_cell_conn),'node_cell_conn',.false.)
    deallocate(node_cell_conn, stat = ierr)
    call checkerr(ierr,'node_cell_conn',ilog)

    if (allocated(node_ids)) then
      call memory_monitor(-sizeof(node_ids),'node_ids',.false.)
      deallocate(node_ids, stat = ierr)
      call checkerr(ierr,'node_ids',ilog)
    end if

    !c simply check if all the data has been read in successfully
    if (num_nodes < 1 .or. num_cells < 1) then
      goto 999
    end if


#ifdef PETSC
    num_nodes_gbl = num_nodes
    num_cells_gbl = num_cells

    if (btest(usg_mesh_ordering,0) .or. b_export_mesh_pflotran) then
      allocate(nodes_gbl(num_nodes_gbl), stat = ierr)
      call checkerr(ierr,'nodes_gbl',ilog)
      call memory_monitor(sizeof(nodes_gbl),'nodes_gbl',.false.)
      nodes_gbl = nodes

      allocate(cells_gbl(num_nodes_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'cells_gbl',ilog)
      call memory_monitor(sizeof(cells_gbl),'cells_gbl',.false.)
      cells_gbl = cells
    end if
#endif

    if (b_enable_output .and. rank == 0) then
      write(*,'(a)') "Read unstructured mesh from gid mesh file, done."
    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening gid mesh data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening gid mesh data file'
      close(ilog)
    end if
    b_error_flag = .true.
    return

998 continue
    backspace(imsh)
    read(imsh,'(a)') strbuffer
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,'(2a)') 'error reading in gid mesh data file: ',trim(strbuffer)
      write(*,*) 'SIMULATION TERMINATED'
      write(*,'(2a)') 'error reading in gid mesh data file: ',trim(strbuffer)
      close(ilog)
    end if
    b_error_flag = .true.
    return

999 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'end in reading gid mesh data file'
      close(ilog)
    end if
    b_error_flag = .true.
    return

  end subroutine usg_mesh_data_input_gid_mesh

  !>
  !> apply node reordering
  !>
  subroutine usg_mesh_data_reorder

    use gen, only : ilog, b_use_layered_mesh,                          &
                    mem_cur, mem_max, memory_monitor,                  &
                    node_idx_g2g_lorder, node_idx_g2g_invord

    implicit none

    !c local variables
    integer :: i, inode, icell, ierr

    type(point), allocatable :: nodes_tmp(:)
    integer, allocatable :: cells_tmp(:,:)
    integer, allocatable :: ints_tmp(:)

    !c apply node value, at this time, the array nodes equals the array nodes_gbl
#ifdef PETSC
    do inode = 1, num_nodes
      nodes(inode) = nodes_gbl(node_idx_g2g_lorder(inode))
    end do
    nodes_gbl = nodes
#else
    allocate(nodes_tmp(num_nodes), stat = ierr)
    call checkerr(ierr,'nodes_tmp',ilog)
    call memory_monitor(sizeof(nodes_tmp),'nodes_tmp',.false.)

    nodes_tmp = nodes
    do inode = 1, num_nodes
      nodes(inode) = nodes_tmp(node_idx_g2g_lorder(inode))
    end do
    call memory_monitor(-sizeof(nodes_tmp),'nodes_tmp',.false.)
    deallocate(nodes_tmp, stat = ierr)
    call checkerr(ierr,'nodes_tmp',ilog)
#endif

    !c apply cell value, at this time, the array cells equals the array cells_gbl
#ifdef PETSC
    do icell = 1, num_cells
      do i = 1, num_nodes_per_cell
        cells(i,icell) = node_idx_g2g_invord(cells_gbl(i,icell))
      end do
    end do
    cells_gbl = cells
#else
    allocate(cells_tmp(num_nodes_per_cell,num_cells), stat = ierr)
    call checkerr(ierr,'cells_tmp',ilog)
    call memory_monitor(sizeof(cells_tmp),'cells_tmp',.false.)

    cells_tmp = cells
    do icell = 1, num_cells
      do i = 1, num_nodes_per_cell
        cells(i,icell) = node_idx_g2g_invord(cells_tmp(i,icell))
      end do
    end do

    call memory_monitor(-sizeof(cells_tmp),'cells_tmp',.false.)
    deallocate(cells_tmp, stat = ierr)
    call checkerr(ierr,'cells_tmp',ilog)
#endif

    !c temporary variable
    allocate(ints_tmp(num_nodes), stat = ierr)
    call checkerr(ierr,'ints_tmp',ilog)
    call memory_monitor(sizeof(ints_tmp),'ints_tmp',.false.)

    !c apply node material id
    if (b_use_node_matids) then
      ints_tmp = node_matids
      do inode = 1, num_nodes
        node_matids(inode) = ints_tmp(node_idx_g2g_lorder(inode))
      end do
    end if

    !c node layer information
    if (num_node_layers > 0) then
      ints_tmp = node_to_layer_node
      do inode = 1, num_nodes
        node_to_layer_node(inode) = ints_tmp(node_idx_g2g_lorder(inode))
      end do
    end if

    !c release memory of temporary variable
    call memory_monitor(sizeof(-ints_tmp),'ints_tmp',.false.)
    deallocate(ints_tmp, stat = ierr)
    call checkerr(ierr,'ints_tmp',ilog)

    !c cell index is not changed after node reording, no need to change here.

  end subroutine usg_mesh_data_reorder


  !>
  !> build mesh data structure
  !> use half-edge based storage for 2d usg mesh and half-face based storage for 3d usg mesh
  !>
  subroutine usg_mesh_data_build(b_mark_boundary)

    use gen, only : ilog, idbg, rank, nprcs, b_enable_output,          &
                    mem_cur, mem_max, memory_monitor,                  &
                    usg_mesh_ordering, node_idx_lg2g, cell_idx_lg2g

    use parm, only : ncon_usg, ncon_cell_usg

    implicit none

    !c passed variables
    logical, intent(in) :: b_mark_boundary

    !c local variables
    integer :: i, j, k, i2, j2, k0, k1, k2, k3, k4, ivol, jvol, iborder, nvec
    integer*8 :: id
    integer :: inodes(4)
    integer*8, allocatable :: iwork(:)
    integer :: info_debug, ierr
    type(point) :: pt
    type(point) :: pts(8)
    real*8 :: len1, len2, len3, rtemp
    integer :: ivec(6)
    real*8 :: vecdot(6)
    real*8, parameter :: rsmall = 1.0d-10, pi=3.14159265359d0, r_1 = -1.0d0
#ifdef DEBUG
    character*256 :: strbuffer, strbuffer2
#endif

    external :: checkerr

    if (b_enable_output .and. rank == 0) then
      if (b_mark_boundary) then
        write(*,'(a)') "Build global unstructured mesh, please wait ..."
      else
        write(*,'(a)') "Build local unstructured mesh, please wait ..."
      end if
    end if

    info_debug = 0

    num_edges_per_cell = 0
    num_faces_per_cell = 0
    num_nodes_per_face = 0

    !c allocate and fill node_cells data
    allocate(node_num_cells(num_nodes), stat = ierr)
    call checkerr(ierr,'node_num_cells',ilog)
    node_num_cells = 0
    call memory_monitor(sizeof(node_num_cells),'node_num_cells',.false.)

    allocate(node_cells(ncon_cell_usg,num_nodes), stat = ierr)
    call checkerr(ierr,'node_cells',ilog)
    node_cells = 0
    call memory_monitor(sizeof(node_cells),'node_cells',.false.)

    do i = 1, num_cells
      do j = 1, num_nodes_per_cell
        k = cells(j,i)
        node_num_cells(k) = node_num_cells(k) + 1
        i2 = node_num_cells(k)
        if(i2 > ncon_cell_usg) then
          if(rank == 0) then
            write(*,'(2(a,1x,i6,1x))')                                 &
                  "Error: maximum connection of node",k,               &
                  "is larger than",ncon_cell_usg
          end if
          goto 999
        end if
        node_cells(i2,k) = i
      end do
    end do

    !c check islated nodes without cells
    do i = 1, num_nodes
      if (node_num_cells(i) == 0) then
        if(rank == 0) then
          write(*,'(a,1x,i6,1x,a)')                                    &
                "Error: node",i,"is not linked to any cells"
          write(ilog,'(a,1x,i6,1x,a)')                                 &
                "Error: node",i,"is not linked to any cells"
        end if
        goto 999
      end if
    end do

    !c test part
#ifdef DEBUG
    if(info_debug > 0) then
      write(idbg,*) "test-> node_cells list"
      do i = 1, num_nodes
        write(idbg,'(2(a,1x,i8,1x),a,10(1x,i8))') "node ",i,           &
              "num.cells",node_num_cells(i),"cells ",                  &
              node_cells(1:node_num_cells(i),i)
      end do
    end if
#endif

    !c mark the boundary nodes
    allocate(is_boundary_node(num_nodes), stat = ierr)
    call checkerr(ierr,'is_boundary_node',ilog)
    is_boundary_node = .false.
    call memory_monitor(sizeof(is_boundary_node),'is_boundary_node',.false.)

    !c return if the subroutine is used for mesh reordering only
    if (allocated(node2halfid)) then
      call memory_monitor(-sizeof(node2halfid),'node2halfid',.false.)
      deallocate(node2halfid)
    end if

    if (allocated(cell2halfid)) then
      call memory_monitor(-sizeof(cell2halfid),'cell2halfid',.false.)
      deallocate(cell2halfid)
    end if

    !c loop over all cell connections to build half-edged mesh structure
    if(cell_type == cell_type_tri .or. cell_type == cell_type_quad) then

      if (cell_type == cell_type_tri) then
        num_edges_per_cell = 3
        num_faces_per_cell = 3   !edge is treated face in 2D
        num_nodes_per_face = 3
      else if(cell_type == cell_type_quad) then
        num_edges_per_cell = 4
        num_faces_per_cell = 4   !edge is treated face in 2D
        num_nodes_per_face = 4
      end if

      !c mark local boundary nodes, including inner ghost nodes (pseudo boundary)
      allocate(node2halfid(num_nodes), stat = ierr)
      call checkerr(ierr,'node2halfid',ilog)
      node2halfid = 0
      call memory_monitor(sizeof(node2halfid),'node2halfid',.false.)

      allocate(cell2halfid(num_faces_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'cell2halfid',ilog)
      cell2halfid = 0
      call memory_monitor(sizeof(cell2halfid),'cell2halfid',.false.)

      !c allocate a temporatory maximum size to boder edges
      allocate(border2halfid(num_nodes), stat = ierr)
      call checkerr(ierr,'border2halfid',ilog)
      border2halfid = 0
      call memory_monitor(sizeof(border2halfid),'border2halfid',.false.)
      iborder = 0

#ifdef DEBUG
      if(info_debug > 0) then
        write(idbg,*) "test-> loop over cells to create half-edge structure"
      end if
#endif

      do i = 1, num_cells
        do j = 1, num_edges_per_cell          !c number of edges

          if (cell_type == cell_type_tri) then
            k = cells(edge_node_mapping_tri(1,j),i)
            k2 = cells(edge_node_mapping_tri(2,j),i)
          else
            k = cells(edge_node_mapping_quad(1,j),i)
            k2 = cells(edge_node_mapping_quad(2,j),i)
          end if

          !c assign node2halfid, do not overwrite border edge
          if (node2halfid(k) == 0) then
            node2halfid(k) = cal_edge_id(i,j,1)
#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(4(a,1x,i8,1x))') "node",k,                  &
              "is assigned to cell",cal_cellface_index(node2halfid(k)),&
              "edge",cal_faceedge_index(node2halfid(k)), " non-border",&
              cal_border_indicator(node2halfid(k))
            end if
#endif
          end if

          !c assign cell2halfid
          !c assume this edge is a border edge, overwrite it in the next step
          cell2halfid(j,i)=cal_edge_id(i,j,0)
          do i2 = 1, node_num_cells(k)
            j2 = node_cells(i2,k)
            if(j2 /= i) then
              inodes(1) = k
              inodes(2) = k2
              id = cal_faceedge_id(cell_type,j2,inodes,1)
              if(id > 0) then
                cell2halfid(j,i) = id
                exit
              end if
            end if
          end do

#ifdef DEBUG
          if(info_debug > 0) then
            write(idbg,'(4(a,1x,i8,1x))') "edge",k,"-",k2,             &
            "is assigned to cell",cal_cellface_index(cell2halfid(j,i)),&
            "edge",cal_faceedge_index(cell2halfid(j,i)), " non-border",&
             cal_border_indicator(cell2halfid(j,i))
          end if
#endif

          !c check if this is the edge is a border edge
          if(cal_border_indicator(cell2halfid(j,i)) == 0) then
            iborder = iborder + 1
            border2halfid(iborder) = cal_edge_id(i,j,1)

            is_boundary_node(k) = .true.
            is_boundary_node(k2) = .true.

#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(3(a,1x,i8,1x))') "border",iborder,          &
                    "is assigned to cell",                             &
                    cal_cellface_index(border2halfid(iborder)),"edge", &
                    cal_faceedge_index(border2halfid(iborder))
            end if
#endif

            !c overwrite the node2halfid value
            node2halfid(k2) = cell2halfid(j,i)
#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(3(a,1x,i8,1x))') "node",k2,                 &
                    "is reassigned to cell",                           &
                    cal_cellface_index(node2halfid(k2)),"edge",        &
                    cal_faceedge_index(node2halfid(k2))
            end if
#endif
          end if
        end do
      end do

      !c reallocate border edges storage
      num_border_faceedges = iborder
      allocate(iwork(num_border_faceedges), stat = ierr)
      call checkerr(ierr,'usg_mesh_data-iwork',ilog)
      call memory_monitor(sizeof(iwork),'iwork',.false.)

      iwork(1:num_border_faceedges) = border2halfid(1:num_border_faceedges)
      call memory_monitor(-sizeof(border2halfid),'border2halfid',.false.)
      deallocate(border2halfid)

      allocate(border2halfid(num_border_faceedges), stat = ierr)
      call checkerr(ierr,'border2halfid',ilog)
      call memory_monitor(sizeof(border2halfid),'border2halfid',.false.)

      border2halfid(1:num_border_faceedges) = iwork(1:num_border_faceedges)
      call memory_monitor(-sizeof(iwork),'iwork',.false.)
      deallocate(iwork)

#ifdef DEBUG
      if(info_debug > 0) then
        write(idbg,'(a,1x,i8)') "number of nodes",num_nodes
        write(idbg,'(a,1x,i8)') "number of cells",num_cells
        write(idbg,'(a,1x,i8)') "number of borders",num_border_faceedges

        write(idbg,'(a)') "node-<half-edge> list"
        do i = 1, num_nodes
          write(idbg,'(i4,1x,3(a,i8),a)') i,"<",                         &
                cal_cellface_index(node2halfid(i)),",",                  &
                cal_faceedge_index(node2halfid(i)),",",                  &
                cal_border_indicator(node2halfid(i)),">"
        end do

        write(idbg,'(a)') "cell-<half-edge> lists"
        do i = 1, num_cells
          strbuffer = ""
          do j = 1, num_nodes_per_cell
            write(strbuffer2,'(3(a,i8),a)') "<",                         &
                  cal_cellface_index(cell2halfid(j,i)),",",              &
                  cal_faceedge_index(cell2halfid(j,i)),",",              &
                  cal_border_indicator(cell2halfid(j,i)),">"
            strbuffer = trim(strbuffer)//trim(strbuffer2)//"  "
          end do
          write(idbg,'(i8,1x,a)'),i,trim(strbuffer)
        end do

        write(idbg,'(a)') "border-Opp.<half-edge> lists"
        do i = 1, num_border_faceedges
          write(idbg,'(i4,1x,3(a,i8),a)') i,"<",                         &
                cal_cellface_index(border2halfid(i)),",",                &
                cal_faceedge_index(border2halfid(i)),",",                &
                cal_border_indicator(border2halfid(i)),">"
        end do
      end if
#endif

    else if(cell_type == cell_type_tetra .or.                          &
            cell_type == cell_type_hexa .or.                           &
            cell_type == cell_type_prism) then

      if (cell_type == cell_type_tetra) then
        num_edges_per_cell = 6
        num_faces_per_cell = 4
        num_nodes_per_face = 3
      else if (cell_type == cell_type_hexa) then
        num_edges_per_cell = 12
        num_faces_per_cell = 6
        num_nodes_per_face = 4
      else if (cell_type == cell_type_prism) then
        num_edges_per_cell = 9
        num_faces_per_cell = 5
        num_nodes_per_face = 4
      end if

      !c mark local boundary nodes, including inner ghost nodes (pseudo boundary)
      allocate(node2halfid(num_nodes), stat = ierr)
      call checkerr(ierr,'node2halfid',ilog)
      node2halfid = 0
      call memory_monitor(sizeof(node2halfid),'node2halfid',.false.)

      allocate(cell2halfid(num_faces_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'cell2halfid',ilog)
      cell2halfid = 0
      call memory_monitor(sizeof(cell2halfid),'cell2halfid',.false.)

      !c allocate a temporatory maximum size to boder face
      allocate(border2halfid(num_cells*num_faces_per_cell), stat = ierr)
      call checkerr(ierr,'border2halfid',ilog)
      call memory_monitor(sizeof(border2halfid),'border2halfid',.false.)
      border2halfid = 0
      iborder = 0

      do i = 1, num_cells
        do j = 1, num_faces_per_cell          !c number of faces

          if (cell_type == cell_type_tetra) then
            k = cells(face_node_mapping_tetra(1,j),i)
            k2 = cells(face_node_mapping_tetra(2,j),i)
            k3 = cells(face_node_mapping_tetra(3,j),i)
          else if (cell_type == cell_type_hexa) then
            k = cells(face_node_mapping_hexa(1,j),i)
            k2 = cells(face_node_mapping_hexa(2,j),i)
            k3 = cells(face_node_mapping_hexa(3,j),i)
            k4 = cells(face_node_mapping_hexa(4,j),i)
          else if (cell_type == cell_type_prism) then
            k = cells(face_node_mapping_prism(1,j),i)
            k2 = cells(face_node_mapping_prism(2,j),i)
            k3 = cells(face_node_mapping_prism(3,j),i)
            k4 = cells(face_node_mapping_prism(4,j),i)
          end if

          !c assign node2halfid, do not overwrite border edge
          if (node2halfid(k) == 0) then
            node2halfid(k) = cal_face_id(i,j,0,1)
#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(5(a,1x,i8,1x))') "node",k,                  &
              "is assigned to cell",cal_cellface_index(node2halfid(k)),&
              "face",cal_faceedge_index(node2halfid(k)), "anchor",     &
              cal_face_anchor_index(node2halfid(k)),"non-border",      &
              cal_border_indicator(node2halfid(k))
            end if
#endif
          end if

          !c assign cell2halfid
          !c assume this face is a border face, overwrite it in the next step
          cell2halfid(j,i)=cal_face_id(i,j,0,0)

          do i2 = 1, node_num_cells(k)
            j2 = node_cells(i2,k)
            if(j2 /= i) then
              inodes(1) = k
              inodes(2) = k2
              inodes(3) = k3
              if (cell_type == cell_type_hexa .or. cell_type == cell_type_prism) then
                inodes(4) = k4
              end if

              id = cal_faceedge_id(cell_type,j2,inodes,1)
              if(id > 0) then
                cell2halfid(j,i) = id
                exit
              end if
            end if
          end do

#ifdef DEBUG
          if(info_debug > 0) then
            write(idbg,'(7(a,1x,i8,1x))') "face",k,"-",k2,"-",k3,      &
            "is assigned to cell",cal_cellface_index(cell2halfid(j,i)),&
            "face",cal_faceedge_index(cell2halfid(j,i)), "anchor",     &
            cal_face_anchor_index(cell2halfid(j,i)),"non-border",      &
            cal_border_indicator(cell2halfid(j,i))
          end if
#endif

          !c check if this is the edge is a border edge
          if(cal_border_indicator(cell2halfid(j,i)) == 0) then
            iborder = iborder + 1
            border2halfid(iborder) = cal_face_id(i,j,0,1)

            is_boundary_node(k) = .true.
            is_boundary_node(k2) = .true.
            is_boundary_node(k3) = .true.
            if (cell_type == cell_type_hexa .or. cell_type == cell_type_prism) then
              is_boundary_node(k4) = .true.
            end if

#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(3(a,1x,i8,1x))') "border",iborder,          &
                    "is assigned to cell",                             &
                    cal_cellface_index(border2halfid(iborder)),"face", &
                    cal_faceedge_index(border2halfid(iborder))
            end if
#endif

            !c overwrite the node2halfid value
            node2halfid(k2) = cell2halfid(j,i)
#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,'(3(a,1x,i8,1x))') "node",k2,                 &
                    "is reassigned to cell",                           &
                    cal_cellface_index(node2halfid(k2)),"face",        &
                    cal_faceedge_index(node2halfid(k2)),"non-border",  &
                    cal_border_indicator(cell2halfid(j,i))
            end if
#endif
          end if
        end do
      end do
      
      !c reallocate border edges storage
      num_border_faceedges = iborder
      allocate(iwork(num_border_faceedges), stat = ierr)
      call checkerr(ierr,'usg_mesh_data-iwork',ilog)
      call memory_monitor(sizeof(iwork),'iwork',.false.)

      iwork(1:num_border_faceedges) = border2halfid(1:num_border_faceedges)
      call memory_monitor(-sizeof(border2halfid),'border2halfid',.false.)
      deallocate(border2halfid)

      allocate(border2halfid(num_border_faceedges), stat = ierr)
      call checkerr(ierr,'border2halfid',ilog)
      call memory_monitor(sizeof(border2halfid),'border2halfid',.false.)

      border2halfid(1:num_border_faceedges) = iwork(1:num_border_faceedges)
      call memory_monitor(-sizeof(iwork),'iwork',.false.)
      deallocate(iwork)


#ifdef DEBUG
      if(info_debug > 0) then
        write(idbg,'(a,1x,i8)') "number of nodes",num_nodes
        write(idbg,'(a,1x,i8)') "number of cells",num_cells
        write(idbg,'(a,1x,i8)') "number of borders",num_border_faceedges

        write(idbg,'(a)') "is boundary node"
        do i = 1, num_nodes
          write(idbg,'(i8,1x,l2)') i, is_boundary_node(i)
        end do

        write(idbg,'(a)') "node-<half-face> list"
        do i = 1, num_nodes
          write(idbg,'(i8,1x,4(a,i8),a)') i,"<",                         &
                cal_cellface_index(node2halfid(i)),",",                  &
                cal_faceedge_index(node2halfid(i)),",",                  &
                cal_face_anchor_index(node2halfid(i)),",",               &
                cal_border_indicator(node2halfid(i)),">"
        end do

        write(idbg,'(a)') "cell-<half-face> lists"
        do i = 1, num_cells
          strbuffer = ""
          do j = 1, num_faces_per_cell
            write(strbuffer2,'(4(a,i8),a)') "<",                        &
                  cal_cellface_index(cell2halfid(j,i)),",",              &
                  cal_faceedge_index(cell2halfid(j,i)),",",              &
                  cal_face_anchor_index(cell2halfid(j,i)),",",           &
                  cal_border_indicator(cell2halfid(j,i)),">"
            strbuffer = trim(strbuffer)//trim(strbuffer2)//"  "
          end do
          write(idbg,'(i8,1x,a)'),i,trim(strbuffer)
        end do

        write(idbg,'(a)') "border-Opp.<half-face> lists"
        do i = 1, num_border_faceedges
          write(idbg,'(i4,1x,4(a,i8),a)') i,"<",                         &
                cal_cellface_index(border2halfid(i)),",",                &
                cal_faceedge_index(border2halfid(i)),",",                &
                cal_face_anchor_index(border2halfid(i)),",",             &
                cal_border_indicator(border2halfid(i)),">"
        end do
      end if
#endif

    else
      goto 999
    end if

    !c mark boundary cells (with at least one face on the boundary)
    allocate(is_boundary_cell(num_cells), stat = ierr)
    call checkerr(ierr,'is_boundary_cell',ilog)
    is_boundary_cell = .false.
    call memory_monitor(sizeof(is_boundary_cell),'is_boundary_cell',.false.)

    do i = 1, num_nodes
      if (.not. is_boundary_node(i)) then
        cycle
      end if

      if(cell_type == cell_type_tri) then
        do j = 1, node_num_cells(i)
          j2 = node_cells(j,i)
          do k = 1, num_edges_per_cell
            k1 = cells(edge_node_mapping_tri(1,k),j2)
            k2 = cells(edge_node_mapping_tri(2,k),j2)
            if (is_boundary_node(k1) .and. is_boundary_node(k2)) then
              is_boundary_cell(j2) = .true.
            end if
          end do
        end do
      else if (cell_type == cell_type_quad) then
        do j = 1, node_num_cells(i)
          j2 = node_cells(j,i)
          do k = 1, num_edges_per_cell
            k1 = cells(edge_node_mapping_quad(1,k),j2)
            k2 = cells(edge_node_mapping_quad(2,k),j2)
            if (is_boundary_node(k1) .and. is_boundary_node(k2)) then
              is_boundary_cell(j2) = .true.
            end if
          end do
        end do
      else if (cell_type == cell_type_tetra) then
        do j = 1, node_num_cells(i)
          j2 = node_cells(j,i)
          do k = 1, num_faces_per_cell
            k1 = cells(face_node_mapping_tetra(1,k),j2)
            k2 = cells(face_node_mapping_tetra(2,k),j2)
            k3 = cells(face_node_mapping_tetra(3,k),j2)
            if (is_boundary_node(k1) .and. is_boundary_node(k2) .and.  &
                is_boundary_node(k3)) then
              is_boundary_cell(j2) = .true.
            end if
          end do
        end do
      else if (cell_type == cell_type_hexa) then
        do j = 1, node_num_cells(i)
          j2 = node_cells(j,i)
          do k = 1, num_faces_per_cell
            k1 = cells(face_node_mapping_hexa(1,k),j2)
            k2 = cells(face_node_mapping_hexa(2,k),j2)
            k3 = cells(face_node_mapping_hexa(3,k),j2)
            k4 = cells(face_node_mapping_hexa(4,k),j2)
            if (is_boundary_node(k1) .and. is_boundary_node(k2) .and.  &
                is_boundary_node(k3) .and. is_boundary_node(k4)) then
              is_boundary_cell(j2) = .true.
            end if
          end do
        end do
      else if (cell_type == cell_type_prism) then
        do j = 1, node_num_cells(i)
          j2 = node_cells(j,i)
          do k = 1, 2
            k1 = cells(face_node_mapping_prism(1,k),j2)
            k2 = cells(face_node_mapping_prism(2,k),j2)
            k3 = cells(face_node_mapping_prism(3,k),j2)
            if (is_boundary_node(k1) .and. is_boundary_node(k2) .and.  &
                is_boundary_node(k3)) then
              is_boundary_cell(j2) = .true.
            end if
          end do

          do k = 3, num_faces_per_cell
            k1 = cells(face_node_mapping_prism(1,k),j2)
            k2 = cells(face_node_mapping_prism(2,k),j2)
            k3 = cells(face_node_mapping_prism(3,k),j2)
            k4 = cells(face_node_mapping_prism(4,k),j2)
            if (is_boundary_node(k1) .and. is_boundary_node(k2) .and.  &
                is_boundary_node(k3) .and. is_boundary_node(k4)) then
              is_boundary_cell(j2) = .true.
            end if
          end do
        end do
      end if
    end do

    !c return if the subroutine is used for mesh reordering only
    if (b_mark_boundary .and. btest(usg_mesh_ordering,0) .and.         &
        .not. btest(usg_mesh_ordering,1)) then
      call memory_monitor(-sizeof(border2halfid),'border2halfid',.false.)
      call memory_monitor(-sizeof(is_boundary_node),'is_boundary_node',.false.)
      call memory_monitor(-sizeof(is_boundary_cell),'is_boundary_cell',.false.)
      deallocate(border2halfid)
      deallocate(is_boundary_node)
      deallocate(is_boundary_cell)

      return
    end if

    !c end of marking boundary nodes and cells
#ifdef PETSC
    if (b_mark_boundary) then
      allocate(is_boundary_node_gbl(num_nodes), stat = ierr)
      call checkerr(ierr,'is_boundary_node_gbl',ilog)
      is_boundary_node_gbl = is_boundary_node
      call memory_monitor(sizeof(is_boundary_node_gbl),'is_boundary_node_gbl',.false.)

      allocate(is_boundary_cell_gbl(num_cells), stat = ierr)
      call checkerr(ierr,'is_boundary_cell_gbl',ilog)
      is_boundary_cell_gbl = is_boundary_cell
      call memory_monitor(sizeof(is_boundary_cell_gbl),'is_boundary_cell_gbl',.false.)

      call memory_monitor(-sizeof(node_num_cells),'node_num_cells',.false.)
      call memory_monitor(-sizeof(node_cells),'node_cells',.false.)
      call memory_monitor(-sizeof(node2halfid),'node2halfid',.false.)
      call memory_monitor(-sizeof(cell2halfid),'cell2halfid',.false.)
      call memory_monitor(-sizeof(border2halfid),'border2halfid',.false.)
      call memory_monitor(-sizeof(is_boundary_node),'is_boundary_node',.false.)
      call memory_monitor(-sizeof(is_boundary_cell),'is_boundary_cell',.false.)

      deallocate(node_num_cells)
      deallocate(node_cells)
      deallocate(node2halfid)
      deallocate(cell2halfid)
      deallocate(border2halfid)
      deallocate(is_boundary_node)
      deallocate(is_boundary_cell)

      if (b_enable_output .and. rank == 0) then
        write(*,'(a)') "Build global unstructured mesh, done."
      end if

      return
    else
      do i = 1, num_nodes
        if (is_boundary_node(i)) then
          j = node_idx_lg2g(i)
          is_boundary_node(i) = is_boundary_node_gbl(j)
        end if
      end do
      call memory_monitor(-sizeof(is_boundary_node_gbl),'is_boundary_node_gbl',.false.)
      deallocate(is_boundary_node_gbl)

      do i = 1, num_cells
        if (is_boundary_cell(i)) then
          j = cell_idx_lg2g(i)
          is_boundary_cell(i) = is_boundary_cell_gbl(j)
        end if
      end do
      call memory_monitor(-sizeof(is_boundary_cell_gbl),'is_boundary_cell_gbl',.false.)
      deallocate(is_boundary_cell_gbl)

    end if
#endif

    !c calculate cell volumes
    allocate(cell_volumes(num_cells), stat = ierr)
    call checkerr(ierr,'cell_volumes',ilog)
    call memory_monitor(sizeof(cell_volumes),'cell_volumes',.true.)

    if(cell_type == cell_type_tri .or. cell_type == cell_type_quad) then
      do i = 1, num_cells
        do j = 1, num_nodes_per_cell
          pts(j) = nodes(cells(j,i))
        end do
        cell_volumes(i) = geometry_area(num_nodes_per_cell,            &
                                        pts(1:num_nodes_per_cell))
      end do
    else if(cell_type == cell_type_tetra .or.                          &
            cell_type == cell_type_hexa .or.                           &
            cell_type == cell_type_prism) then
      do i = 1, num_cells
        do j = 1, num_nodes_per_cell
          pts(j) = nodes(cells(j,i))
        end do
        cell_volumes(i) = geometry_volume(num_nodes_per_cell,pts)
      end do
    else
      if(rank == 0) then
        write(ilog,*) "Error: specified cell type is currently not supported"
      end if
      goto 999
    end if

    !c calculate cell center coordinates
    allocate(CellFaceCenter(num_faces_per_cell,num_cells), stat = ierr)
    call checkerr(ierr,'CellFaceCenter',ilog)
    call memory_monitor(sizeof(CellFaceCenter),'CellFaceCenter',.true.)

    if (cell_projection == projection_xyz) then
      allocate(CellFaceScaledNorm(num_faces_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellFaceScaledNorm',ilog)
      call memory_monitor(sizeof(CellFaceScaledNorm),'CellFaceScaledNorm',.true.)

      allocate(CellFaceArea(num_faces_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellFaceArea',ilog)
      call memory_monitor(sizeof(CellFaceArea),'CellFaceArea',.true.)
    else if (cell_projection == projection_xy .or.                     &
             cell_projection == projection_yz .or.                     &
             cell_projection == projection_xz) then
      allocate(CellFaceScaledNorm(num_faces_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellFaceScaledNorm',ilog)
      call memory_monitor(sizeof(CellFaceScaledNorm),'CellFaceScaledNorm',.true.)

      allocate(CellNodeAngle(num_nodes_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellNodeAngle',ilog)
      call memory_monitor(sizeof(CellNodeAngle),'CellNodeAngle',.true.)
    
      if (cell_type == cell_type_quad) then
        allocate(CellsQuadTriNode(3,2,num_cells), stat = ierr)
        call checkerr(ierr,'CellsQuadTriNode',ilog)
        call memory_monitor(sizeof(CellsQuadTriNode),'CellsQuadTriNode',.true.)

        allocate(CellsQuadTriFaceScaledNorm(3,2,num_cells), stat = ierr)
        call checkerr(ierr,'CellsQuadTriFaceScaledNorm',ilog)
        call memory_monitor(sizeof(CellsQuadTriFaceScaledNorm),'CellsQuadTriFaceScaledNorm',.true.)

        allocate(cells_trivol(2,num_cells), stat = ierr)
        call checkerr(ierr,'cells_trivol',ilog)
        call memory_monitor(sizeof(cells_trivol),'cells_trivol',.true.)
      end if
    
    end if

    allocate(CellCenter(num_cells), stat = ierr)
    call checkerr(ierr,'CellCenter',ilog)
    call memory_monitor(sizeof(CellCenter),'CellCenter',.true.)

    if (cell_type == cell_type_tri) then
      do i = 1, num_cells                  !number of cells
        do j = 1, num_nodes_per_cell       !number of faces
          k0 = cells(j,i)
          k1 = cells(face_node_mapping_tri(1,j),i)
          k2 = cells(face_node_mapping_tri(2,j),i)
          CellNodeAngle(j,i) = geometry_angle(nodes(k1)-nodes(k0),nodes(k2)-nodes(k0))

          CellFaceScaledNorm(j,i) = geometry_normal(nodes(k1),nodes(k2),   &
                                                    cell_projection)
        end do        
      end do
    else if (cell_type == cell_type_quad) then
      do i = 1, num_cells                  !number of cells
        do j = 1, num_nodes_per_cell       !number of faces
          if (j < num_nodes_per_cell) then
            k0 = cells(j,i)
            k1 = cells(face_node_mapping_quad(1,j),i)
            k2 = cells(face_node_mapping_quad(2,j+1),i)
          else
            k0 = cells(j,i)
            k1 = cells(face_node_mapping_quad(1,j),i)
            k2 = cells(face_node_mapping_quad(2,1),i)
          end if
          CellNodeAngle(j,i) = geometry_angle(nodes(k1)-nodes(k0),nodes(k2)-nodes(k0))

          CellFaceScaledNorm(j,i) = geometry_normal(                   &
              nodes(k1),nodes(k2),cell_projection)

          if (CellNodeAngle(1,i)+CellNodeAngle(3,i) >                  &
              CellNodeAngle(2,i)+CellNodeAngle(4,i)) then
            CellsQuadTriNode(1,1,i) = cells(2,i)
            CellsQuadTriNode(2,1,i) = cells(3,i)
            CellsQuadTriNode(3,1,i) = cells(1,i)

            CellsQuadTriNode(1,2,i) = cells(4,i)
            CellsQuadTriNode(2,2,i) = cells(1,i)
            CellsQuadTriNode(3,2,i) = cells(3,i)

            CellsQuadTriFaceScaledNorm(1,1,i) = geometry_normal(       &
                nodes(cells(3,i)),nodes(cells(1,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(2,1,i) = geometry_normal(       &
                nodes(cells(1,i)),nodes(cells(2,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(3,1,i) = geometry_normal(       &
                nodes(cells(2,i)),nodes(cells(3,i)),cell_projection)

            CellsQuadTriFaceScaledNorm(1,2,i) = geometry_normal(       &
                nodes(cells(1,i)),nodes(cells(3,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(2,2,i) = geometry_normal(       &
                nodes(cells(3,i)),nodes(cells(4,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(3,2,i) = geometry_normal(       &
                nodes(cells(4,i)),nodes(cells(1,i)),cell_projection)
          else
            CellsQuadTriNode(1,1,i) = cells(1,i)
            CellsQuadTriNode(2,1,i) = cells(2,i)
            CellsQuadTriNode(3,1,i) = cells(4,i)

            CellsQuadTriNode(1,2,i) = cells(3,i)
            CellsQuadTriNode(2,2,i) = cells(4,i)
            CellsQuadTriNode(3,2,i) = cells(2,i)

            CellsQuadTriFaceScaledNorm(1,1,i) = geometry_normal(       &
                nodes(cells(2,i)),nodes(cells(4,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(2,1,i) = geometry_normal(       &
                nodes(cells(4,i)),nodes(cells(1,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(3,1,i) = geometry_normal(       &
                nodes(cells(1,i)),nodes(cells(2,i)),cell_projection)

            CellsQuadTriFaceScaledNorm(1,2,i) = geometry_normal(       &
                nodes(cells(4,i)),nodes(cells(2,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(2,2,i) = geometry_normal(       &
                nodes(cells(2,i)),nodes(cells(3,i)),cell_projection)
            CellsQuadTriFaceScaledNorm(3,2,i) = geometry_normal(       &
                nodes(cells(3,i)),nodes(cells(4,i)),cell_projection)
          end if

          cells_trivol(1,i) = geometry_area(3,(/                       &
                                      nodes(CellsQuadTriNode(1,1,i)),  &
                                      nodes(CellsQuadTriNode(2,1,i)),  &
                                      nodes(CellsQuadTriNode(3,1,i))/))

          cells_trivol(2,i) = geometry_area(3,(/                       &
                                      nodes(CellsQuadTriNode(1,2,i)),  &
                                      nodes(CellsQuadTriNode(2,2,i)),  &
                                      nodes(CellsQuadTriNode(3,2,i))/))
        end do
      end do
    end if

    if(cvol_method == cvol_method_md .or. cvol_method == cvol_method_cc) then
      if (cell_type == cell_type_vertex  .or.                          &
          cell_type == cell_type_line    .or.                          &
          cell_type == cell_type_tri     .or.                          &
          cell_type == cell_type_quad    .or.                          &
          cell_type == cell_type_tetra   .or.                          &
          cell_type == cell_type_hexa    .or.                          &
          cell_type == cell_type_prism) then
        do i = 1, num_cells
          call math_common_zero(CellCenter(i))
          do j = 1, num_nodes_per_cell
            CellCenter(i) = CellCenter(i) + nodes(cells(j,i))
          end do
          CellCenter(i) = CellCenter(i)/(num_nodes_per_cell*1.0d0)
        end do
      else if (cell_type == cell_type_pyramid) then
        do i = 1, num_cells
          call math_common_zero(CellCenter(i))
          do j = 1, num_nodes_per_cell-1
            CellCenter(i) = CellCenter(i) + nodes(cells(j,i))*3.0d0
          end do
          j = num_nodes_per_cell
          CellCenter(i) = CellCenter(i) + nodes(cells(j,i))*4.0d0

          CellCenter(i) = CellCenter(i)/16.0d0
        end do
      end if

      !c calculate face circumcicle center and scaled outnorm
      !c ********* add other cell types accordingly *********
      if(cell_type == cell_type_tri) then
        do i = 1, num_cells                  !number of cells
          do j = 1, num_faces_per_cell       !number of faces
            call math_common_zero(CellFaceCenter(j,i))

            k1 = cells(edge_node_mapping_tri(1,j),i)
            k2 = cells(edge_node_mapping_tri(2,j),i)

            if (cvol_method == cvol_method_md) then
              CellFaceCenter(j,i) = (nodes(k1)+nodes(k2))/2.0d0
            else if (cvol_method == cvol_method_cc) then
              !c get adjacent cell index of current cell-face
              i2 = cal_cellface_index(cell2halfid(j,i))
              if (i == i2) then
                CellFaceCenter(j,i) = (nodes(k1)+nodes(k2))/2.0d0
              else
                CellFaceCenter(j,i) = geometry_line_line_intersect(    &
                                      cell_projection,                 &
                                      nodes(k1),nodes(k2),             &
                                      CellCenter(i),CellCenter(i2))
              end if
            end if
          end do
        end do
      else if(cell_type == cell_type_quad) then
        do i = 1, num_cells                  !number of cells
          do j = 1, num_faces_per_cell       !number of faces
            call math_common_zero(CellFaceCenter(j,i))

            k1 = cells(edge_node_mapping_quad(1,j),i)
            k2 = cells(edge_node_mapping_quad(2,j),i)

            if (cvol_method == cvol_method_md) then
              CellFaceCenter(j,i) = (nodes(k1)+nodes(k2))/2.0d0
            else if (cvol_method == cvol_method_cc) then
              !c get adjacent cell index of current cell-face
              i2 = cal_cellface_index(cell2halfid(j,i))
              if (i == i2) then
                CellFaceCenter(j,i) = (nodes(k1)+nodes(k2))/2.0d0
              else
                CellFaceCenter(j,i) = geometry_line_line_intersect(    &
                                      cell_projection,                 &
                                      nodes(k1),nodes(k2),             &
                                      CellCenter(i),CellCenter(i2))
              end if
            end if
          end do
        end do
      else if(cell_type == cell_type_tetra) then
        do i = 1, num_cells                  !number of cells
          do j = 1, num_faces_per_cell       !number of faces
            call math_common_zero(CellFaceCenter(j,i))
            if (cvol_method == cvol_method_md) then
              do k = 1, num_nodes_per_face
                pts(k) = nodes(cells(face_node_mapping_tetra(k,j),i))
                CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
              end do
              CellFaceCenter(j,i) = CellFaceCenter(j,i) / (num_nodes_per_face*1.0d0)
            else if (cvol_method == cvol_method_cc) then
              !c get adjacent cell index of current cell-face
              i2 = cal_cellface_index(cell2halfid(j,i))

              do k = 1, num_nodes_per_face
                pts(k) = nodes(cells(face_node_mapping_tetra(k,j),i))
                if (i == i2) then
                  CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
                end if
              end do

              if (i == i2) then
                CellFaceCenter(j,i) = CellFaceCenter(j,i) / (num_nodes_per_face*1.0d0)
              else
                pts(num_nodes_per_face+1) = CellCenter(i)
                pts(num_nodes_per_face+2) = CellCenter(i2)

                CellFaceCenter(j,i) = geometry_line_plane_intersect(         &
                                      pts(1),pts(2),pts(3),                  &
                                      CellCenter(i),CellCenter(i2))
              end if
            end if


            !c calculate cell face scaled outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(num_nodes_per_face,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(num_nodes_per_face,pts)

          end do
        end do
      else if(cell_type == cell_type_hexa) then
        do i = 1, num_cells                  !number of cells
          do j = 1, num_faces_per_cell       !number of faces
            call math_common_zero(CellFaceCenter(j,i))

            if (cvol_method == cvol_method_md) then
              do k = 1, num_nodes_per_face
                pts(k) = nodes(cells(face_node_mapping_hexa(k,j),i))
                CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
              end do
              CellFaceCenter(j,i) = CellFaceCenter(j,i) / (num_nodes_per_face*1.0d0)
            else if (cvol_method == cvol_method_cc) then
              !c get adjacent cell index of current cell-face
              i2 = cal_cellface_index(cell2halfid(j,i))

              do k = 1, num_nodes_per_face
                pts(k) = nodes(cells(face_node_mapping_hexa(k,j),i))
                if (i == i2) then
                  CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
                end if
              end do

              if (i == i2) then
                CellFaceCenter(j,i) = CellFaceCenter(j,i) / (num_nodes_per_face*1.0d0)
              else
                CellFaceCenter(j,i) = geometry_line_plane_intersect(         &
                                      pts(1),pts(2),pts(3),                  &
                                      CellCenter(i),CellCenter(i2))
              end if

            end if


            !c calculate cell face scaled outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(num_nodes_per_face,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(num_nodes_per_face,pts)

          end do
        end do
      else if(cell_type == cell_type_prism) then
        do i = 1, num_cells                  !number of cells
          do j = 1, 2                        !top and bottom faces, 3 nodes
            call math_common_zero(CellFaceCenter(j,i))
            if (cvol_method == cvol_method_md) then
              do k = 1, 3
                pts(k) = nodes(cells(face_node_mapping_prism(k,j),i))
                CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
              end do
              CellFaceCenter(j,i) = CellFaceCenter(j,i) / 3.0d0
            else if (cvol_method == cvol_method_cc) then
              !c get adjacent cell index of current cell-face
              i2 = cal_cellface_index(cell2halfid(j,i))

              do k = 1, 3
                pts(k) = nodes(cells(face_node_mapping_prism(k,j),i))
                if (i == i2) then
                  CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
                end if
              end do

              if (i == i2) then
                CellFaceCenter(j,i) = CellFaceCenter(j,i) / 3.0d0
              else
                CellFaceCenter(j,i) = geometry_line_plane_intersect(   &
                                      pts(1),pts(2),pts(3),            &
                                      CellCenter(i),CellCenter(i2))
              end if
            end if

            !c calculate cell face scaled outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(3,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(3,pts)

          end do

          do j = 3, num_faces_per_cell       !other faces, 4 nodes
            call math_common_zero(CellFaceCenter(j,i))

            if (cvol_method == cvol_method_md) then
              do k = 1, num_nodes_per_face
                pts(k) = nodes(cells(face_node_mapping_prism(k,j),i))
                CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
              end do
              CellFaceCenter(j,i) = CellFaceCenter(j,i) / (num_nodes_per_face*1.0d0)
            else if (cvol_method == cvol_method_cc) then
              !c get adjacent cell index of current cell-face
              i2 = cal_cellface_index(cell2halfid(j,i))

              do k = 1, num_nodes_per_face
                pts(k) = nodes(cells(face_node_mapping_prism(k,j),i))
                if (i == i2) then
                  CellFaceCenter(j,i) = CellFaceCenter(j,i) + pts(k)
                end if
              end do

              if (i == i2) then
                CellFaceCenter(j,i) = CellFaceCenter(j,i) / (num_nodes_per_face*1.0d0)
              else
                CellFaceCenter(j,i) = geometry_line_plane_intersect(         &
                                      pts(1),pts(2),pts(3),                  &
                                      CellCenter(i),CellCenter(i2))
              end if
            end if


            !c calculate cell face scaled outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(num_nodes_per_face,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(num_nodes_per_face,pts)

          end do

        end do
      end if

    else if (cvol_method == cvol_method_vd) then        
      if (cell_type == cell_type_tri) then
        do i = 1, num_cells
          pt = nodes(cells(3,i)) - nodes(cells(2,i))
          len1 = pt%x**2 + pt%y**2 + pt%z**2

          pt = nodes(cells(1,i)) - nodes(cells(3,i))
          len2 = pt%x**2 + pt%y**2 + pt%z**2

          pt = nodes(cells(2,i)) - nodes(cells(1,i))
          len3 = pt%x**2 + pt%y**2 + pt%z**2

          if (len1 > len2 + len3) then
            if(.not. allow_obtuse_cells) then
              goto 998
            else
              CellCenter(i) = (nodes(cells(2,i))+nodes(cells(3,i)))*0.50d0
            end if
          else if (len2 > len1 + len3) then
            if(.not. allow_obtuse_cells) then
              goto 998
            else
              CellCenter(i) = (nodes(cells(1,i))+nodes(cells(3,i)))*0.50d0
            end if
          else if (len3 > len1 + len2) then
            if(.not. allow_obtuse_cells) then
              goto 998
            else
              CellCenter(i) = (nodes(cells(1,i))+nodes(cells(2,i)))*0.50d0
            end if
          else    
            CellCenter(i) = geometry_circumcircle_center(              &
                            nodes(cells(1,i)),nodes(cells(2,i)),       &
                            nodes(cells(3,i)))
          end if

          do j = 1, num_faces_per_cell       !number of faces
            k1 = cells(edge_node_mapping_tri(1,j),i)
            k2 = cells(edge_node_mapping_tri(2,j),i)
            CellFaceCenter(j,i) = (nodes(k1)+nodes(k2))/2.0d0
          end do
        end do
      else if (cell_type == cell_type_tetra) then

        do i = 1, num_cells                  !number of cells
          do j = 1, num_faces_per_cell       !number of faces
            !c calculate face circumcicle center and scaled outnorm
            do k = 1, 3
              pts(k) = nodes(cells(face_node_mapping_tetra(k,j),i))
            end do

            pt = pts(3) - pts(2)
            len1 = pt%x**2 + pt%y**2 + pt%z**2

            pt = pts(1) - pts(3)
            len2 = pt%x**2 + pt%y**2 + pt%z**2

            pt = pts(2) - pts(1)
            len3 = pt%x**2 + pt%y**2 + pt%z**2


            if (len1 > len2 + len3) then
              if(.not. allow_obtuse_cells) then
                goto 998
              else
                CellFaceCenter(j,i) = (pts(2)+pts(3))*0.50d0
              end if
            else if (len2 > len1 + len3) then
              if(.not. allow_obtuse_cells) then
                goto 998
              else
                CellFaceCenter(j,i) = (pts(1)+pts(3))*0.50d0
              end if
            else if (len3 > len1 + len2) then
              if(.not. allow_obtuse_cells) then
                goto 998
              else
                CellFaceCenter(j,i) = (pts(1)+pts(2))*0.50d0
              end if
            else
              CellFaceCenter(j,i) = geometry_circumcircle_center(      &
                                             pts(1),pts(2),pts(3))
            end if

            !c calculate cell face outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(3,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(3,pts)

          end do

          !c calculate cell circumsphere center
          CellCenter(i) = geometry_circumsphere_center(                &
                                   nodes(cells(1,i)),nodes(cells(2,i)),&
                                   nodes(cells(3,i)),nodes(cells(4,i)))

#ifdef DEBUG
          if(info_debug > 0) then
            write(idbg,'(a,1x,i8,3(1x,1pe15.6e3),4(1x,a,1x,i6,1x,      &
                  a,3(1x,1pe15.6e3),1x))')                             &
                  "circumsphere center of cell",i,                     &
                  CellCenter(i)%x,CellCenter(i)%y,CellCenter(i)%z,     &
                  "nodes 1-",cells(1,i),"coord",nodes(cells(1,i))%x,   &
                  nodes(cells(1,i))%y,nodes(cells(1,i))%z,             &
                  "nodes 2-",cells(2,i),"coord",nodes(cells(2,i))%x,   &
                  nodes(cells(2,i))%y,nodes(cells(2,i))%z,             &
                  "nodes 3-",cells(3,i),"coord",nodes(cells(3,i))%x,   &
                  nodes(cells(3,i))%y,nodes(cells(3,i))%z,             &
                  "nodes 4-",cells(4,i),"coord",nodes(cells(4,i))%x,   &
                  nodes(cells(4,i))%y,nodes(cells(4,i))%z
          end if
#endif

          !c check if the center is outside the cell
          nvec = 0
          ivec = 0
          vecdot = 0.0d0
          do j = 1, num_faces_per_cell       !number of faces
            pt = CellCenter(i) - CellFaceCenter(j,i)
            vecdot(j) = pt.dot.CellFaceScaledNorm(j,i)
            !c consider round error, set the threshold to a small nonnegative value
            if (vecdot(j) > rsmall) then
              nvec = nvec + 1
              ivec(nvec) = j
            end if
          end do

          if (nvec == 1) then
            CellCenter(i) = CellFaceCenter(ivec(1),i)
#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,*) "sphere center of cell",i,"is out of volume, reset to face",&
                    j,"center", CellCenter(i)%x,CellCenter(i)%y,CellCenter(i)%z
            end if
#endif
          else if (nvec == 2) then
            CellCenter(i) = (nodes(cells(1,i)) + nodes(cells(2,i)) +         &
                             nodes(cells(3,i)) + nodes(cells(4,i)))*0.25d0

#ifdef DEBUG
            if(info_debug > 0) then
              write(idbg,*) "sphere center of cell",i,"is out of volume, reset to midpoint",&
                    CellCenter(i)%x,CellCenter(i)%y,CellCenter(i)%z
            end if
#endif

          else if (nvec > 2) then
            if (rank == 0) then
              write(*,'(a,1x,i6)') "Error: Check mesh quality, cell id",i
              write(ilog,'(a,1x,i6)') "Error: Check mesh quality, cell id",i
            end if
            goto 999
          end if

        end do

      else if (cell_type == cell_type_prism) then

        do i = 1, num_cells                  !number of cells

          !c calculate top and bottom face of prism (triangles)
          do j = 1, 2       !number of faces
            !c calculate face circumcicle center and scaled outnorm
            do k = 1, 3
              pts(k) = nodes(cells(face_node_mapping_prism(k,j),i))
            end do

            pt = pts(3) - pts(2)
            len1 = pt%x**2 + pt%y**2 + pt%z**2

            pt = pts(1) - pts(3)
            len2 = pt%x**2 + pt%y**2 + pt%z**2

            pt = pts(2) - pts(1)
            len3 = pt%x**2 + pt%y**2 + pt%z**2


            if (len1 > len2 + len3) then
              if(.not. allow_obtuse_cells) then
                goto 998
              else
                CellFaceCenter(j,i) = (pts(2)+pts(3))*0.50d0
              end if
            else if (len2 > len1 + len3) then
              if(.not. allow_obtuse_cells) then
                goto 998
              else
                CellFaceCenter(j,i) = (pts(1)+pts(3))*0.50d0
              end if
            else if (len3 > len1 + len2) then
              if(.not. allow_obtuse_cells) then
                goto 998
              else
                CellFaceCenter(j,i) = (pts(1)+pts(2))*0.50d0
              end if
            else
              CellFaceCenter(j,i) = geometry_circumcircle_center(      &
                                             pts(1),pts(2),pts(3))
            end if

            !c calculate cell face outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(3,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(3,pts)

          end do

          !c calculate side faces of prism
          do j = 3, num_faces_per_cell       !number of faces
            !c calculate face circumcicle center and scaled outnorm
            do k = 1, 4
              pts(k) = nodes(cells(face_node_mapping_prism(k,j),i))
            end do

            CellFaceCenter(j,i) = (pts(1)+pts(2)+pts(3)+pts(4))/4.0d0

            !c calculate cell face outnorm
            CellFaceScaledNorm(j,i) = geometry_normal(4,pts,.false.)*r_1

            !c calculate cell face area
            CellFaceArea(j,i) = geometry_area(4,pts)

          end do

          !c calculate cell center, use the middle point of top face center
          !c and bottom face center
          CellCenter(i) = (CellFaceCenter(1,i) + CellFaceCenter(2,i))/2.0d0

        end do

      end if

    end if

    !c allocate least square gradient reconstruction matrix
    if (grad_method == grad_method_ls) then
      allocate(grad_ls_matrices(num_nodes), stat = ierr)
      call memory_monitor(sizeof(grad_ls_matrices),'grad_ls_matrices',.true.)
    else if (grad_method == grad_method_cls) then
      allocate(grad_ls_matrices(num_cells), stat = ierr)
      call memory_monitor(sizeof(grad_ls_matrices),'grad_ls_matrices',.true.)
    end if

    if (b_enable_output .and. rank == 0) then
      write(*,'(a)') "Build unstructured mesh, done."
    end if

    return

998 continue
    if(rank == 0) then
      write(ilog,'(a,1x,i8,2(1x,a))') "Error: cell",i,           &
            "is an obtuse triangle, not supported by voronoi",   &
            "diagram method"
      write(*,'(a,1x,i8,2(1x,a))') "Error: cell",i,              &
            "is an obtuse triangle, not supported by voronoi",   &
            "diagram method"
    end if

999 continue
    if (rank == 0) then
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error in building usg mesh data structure'
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error in building usg mesh data structure'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_build

  !c
  !c build control volume interface related variables
  !c
  subroutine usg_mesh_data_build_interface

    use gen, only : memory_monitor, ilog, idbg, rank, b_enable_output

    implicit none

    integer :: icell, iface, iedge, idvol, iadj, istart, iend, nadj,   &
               ivol, jvol, jtemp, findex1, findex2, ierr
    integer*8 :: cellid

    real*8 :: dxij, dyij, dzij, wij2

    type(point) :: pt0, pt1, pt2, pt3

    real*8, parameter :: r2 = 2.0d0, r3 = 3.0d0, r6 = 6.0d0

    external :: checkerr


    !c calculate variable required for common use
    allocate(CellCvolFaceArea(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
    call checkerr(ierr,'CellCvolFaceArea',ilog)
    call memory_monitor(sizeof(CellCvolFaceArea),'CellCvolFaceArea',.true.)

    allocate(CellCvolFaceCenter(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
    call checkerr(ierr,'CellCvolFaceCenter',ilog)
    call memory_monitor(sizeof(CellCvolFaceCenter),'CellCvolFaceCenter',.true.)

    allocate(CellCvolFaceUnitNorm(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
    call checkerr(ierr,'CellCvolFaceUnitNorm',ilog)
    call memory_monitor(sizeof(CellCvolFaceUnitNorm),'CellCvolFaceUnitNorm',.true.)


    do icell = 1, num_cells
      pt3 = CellCenter(icell)
      do iedge = 1, num_edges_per_cell

        if (cell_type == cell_type_tri) then
          ivol = cells(edge_node_mapping_tri(1,iedge),icell)
          jvol = cells(edge_node_mapping_tri(2,iedge),icell)
        else if (cell_type == cell_type_quad) then
          ivol = cells(edge_node_mapping_quad(1,iedge),icell)
          jvol = cells(edge_node_mapping_quad(2,iedge),icell)
        else if (cell_type == cell_type_tetra) then
          ivol = cells(edge_node_mapping_tetra(1,iedge),icell)
          jvol = cells(edge_node_mapping_tetra(2,iedge),icell)
        else if (cell_type == cell_type_hexa) then
          ivol = cells(edge_node_mapping_hexa(1,iedge),icell)
          jvol = cells(edge_node_mapping_hexa(2,iedge),icell)
        else if (cell_type == cell_type_prism) then
          ivol = cells(edge_node_mapping_prism(1,iedge),icell)
          jvol = cells(edge_node_mapping_prism(2,iedge),icell)
        end if

        if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then

          iface = get_face_edge_index(icell,ivol,jvol)
          pt0 = CellFaceCenter(iface,icell)

          do idvol = 1, num_edge_dvols
            if (b_use_face_based_flux) then
              CellCvolFaceCenter(idvol,iedge,icell) = (pt0+pt3)/r2
            else
              CellCvolFaceCenter(idvol,iedge,icell) = pt0
            end if

            CellCvolFaceArea(idvol,iedge,icell) = geometry_veclength(pt3-pt0)

            CellCvolFaceUnitNorm(idvol,iedge,icell) = geometry_normal( &
                    pt0,pt3,cell_projection,.true.)
          end do
        else if (cell_type == cell_type_tetra .or.                     &
                 cell_type == cell_type_hexa  .or.                     &
                 cell_type == cell_type_prism) then

          !DSU pt0, pt1, pt2 and cell center may be not in a plane for cell center dual volume type
          !DSU need further improvement in this case
          pt0 = (nodes(ivol)+nodes(jvol))/r2

          cellid = cal_jacell_id(icell,ivol,jvol,cell_type)
          findex1 = cal_jacell_faceindex1(cellid)
          findex2 = cal_jacell_faceindex2(cellid)
          pt1 = CellFaceCenter(findex1,icell)
          pt2 = CellFaceCenter(findex2,icell)
          if (b_use_face_based_flux) then
            CellCvolFaceCenter(1,iedge,icell) = (pt0+pt1+pt3)/r3
            CellCvolFaceCenter(2,iedge,icell) = (pt0+pt2+pt3)/r3
          else
            CellCvolFaceCenter(1,iedge,icell) = pt0
            CellCvolFaceCenter(2,iedge,icell) = pt0
          end if

          CellCvolFaceArea(1,iedge,icell) = geometry_area(3,(/pt0,pt1,pt3/))
          CellCvolFaceArea(2,iedge,icell) = geometry_area(3,(/pt0,pt3,pt2/))

          CellCvolFaceUnitNorm(1,iedge,icell) = geometry_normal(3,(/pt0,pt1,pt3/),.true.)
          CellCvolFaceUnitNorm(2,iedge,icell) = geometry_normal(3,(/pt0,pt3,pt2/),.true.)

        end if

      end do
    end do

    !c calculate variables required by higher order least square method
    if (grad_method >= grad_method_ls2) then
      allocate(grad_hls_matrices(num_edge_dvols,num_edges_per_cell,    &
                    num_cells), stat = ierr)
      call checkerr(ierr,'grad_hls_matrices',ilog)
      call memory_monitor(sizeof(grad_hls_matrices),'grad_hls_matrices',.true.)

      allocate(edge_face2nodes_vec(2, num_edge_dvols,                 &
                    num_edges_per_cell, num_cells), stat = ierr)
      call checkerr(ierr,'edge_face2nodes_vec',ilog)
      call memory_monitor(sizeof(edge_face2nodes_vec),'edge_face2nodes_vec',.true.)

      do icell = 1, num_cells
        istart = cell_adj_nodes_ia(icell)
        iend = cell_adj_nodes_ia(icell+1)-1
        nadj = iend-istart+1
        do iedge = 1, num_edges_per_cell
          if (cell_type == cell_type_tri) then
            ivol = cells(edge_node_mapping_tri(1,iedge),icell)
            jvol = cells(edge_node_mapping_tri(2,iedge),icell)
          else if (cell_type == cell_type_quad) then
            ivol = cells(edge_node_mapping_quad(1,iedge),icell)
            jvol = cells(edge_node_mapping_quad(2,iedge),icell)
          else if (cell_type == cell_type_tetra) then
            ivol = cells(edge_node_mapping_tetra(1,iedge),icell)
            jvol = cells(edge_node_mapping_tetra(2,iedge),icell)
          else if (cell_type == cell_type_hexa) then
            ivol = cells(edge_node_mapping_hexa(1,iedge),icell)
            jvol = cells(edge_node_mapping_hexa(2,iedge),icell)
          else if (cell_type == cell_type_prism) then
            ivol = cells(edge_node_mapping_prism(1,iedge),icell)
            jvol = cells(edge_node_mapping_prism(2,iedge),icell)
          end if

          do idvol = 1, num_edge_dvols
            allocate(grad_hls_matrices(idvol,iedge,icell)%coef(nadj,   &
                          grad_hls_min_nodes), stat = ierr)
            call checkerr(ierr,'grad_hls_matrices%coef',ilog)
            call memory_monitor(sizeof(grad_hls_matrices(idvol,iedge,icell)%coef),&
                                'grad_hls_matrices%coef',.false.)

            allocate(grad_hls_matrices(idvol,iedge,icell)%weighting(nadj), stat = ierr)
            call checkerr(ierr,'grad_hls_matrices%weighting',ilog)
            call memory_monitor(sizeof(grad_hls_matrices(idvol,iedge,icell)%weighting),&
                                'grad_hls_matrices%weighting',.false.)

            pt0 = CellCvolFaceCenter(idvol,iedge,icell)
            edge_face2nodes_vec(1,idvol,iedge,icell) = nodes(jvol)-pt0
            edge_face2nodes_vec(2,idvol,iedge,icell) = nodes(ivol)-pt0

            iadj = 0
            do jtemp = istart, iend
              iadj = iadj + 1
              pt1 = nodes(cell_adj_nodes_ja(jtemp))
              dxij = pt1%x-pt0%x
              dyij = pt1%y-pt0%y
              dzij = pt1%z-pt0%z

              if (grad_spatial_weighting) then
                wij2 = 1.0d0/(sqrt(dxij**2+dyij**2+dzij**2))**grad_spatial_factor
              else
                wij2 = 1.0d0
              end if

              grad_hls_matrices(idvol,iedge,icell)%weighting(iadj) = wij2

              if (cell_projection == projection_xy) then
                if (grad_method == grad_method_ls2) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dyij/)*wij2
                else if (grad_method == grad_method_ls3) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dyij,                            &
                         dxij**2/r2, dyij**2/r2, dxij*dyij/)*wij2
                else if (grad_method == grad_method_ls4) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dyij,                            &
                         dxij**2/r2, dyij**2/r2, dxij*dyij,            &
                         dxij**3/r6, dyij**3/r6,                       &
                         dyij*dxij**2/r2, dxij*dyij**2/r2/)*wij2
                end if
              else if (cell_projection == projection_yz) then
                if (grad_method == grad_method_ls2) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dyij, dzij/)*wij2
                else if (grad_method == grad_method_ls3) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dyij, dzij,                            &
                         dyij**2/r2, dzij**2/r2, dyij*dzij/)*wij2
                else if (grad_method == grad_method_ls4) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dyij, dzij,                            &
                         dyij**2/r2, dzij**2/r2, dyij*dzij,            &
                         dyij**3/r6, dzij**3/r6,                       &
                         dzij*dyij**2/r2, dyij*dzij**2/r2/)*wij2
                end if
              else if (cell_projection == projection_xz) then
                if (grad_method == grad_method_ls2) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dzij/)*wij2
                else if (grad_method == grad_method_ls3) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dzij,                            &
                         dxij**2/r2, dzij**2/r2, dxij*dzij/)*wij2
                else if (grad_method == grad_method_ls4) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dzij,                            &
                         dxij**2/r2, dzij**2/r2, dxij*dzij,            &
                         dxij**3/r6, dzij**3/r6,                       &
                         dzij*dxij**2/r2, dxij*dzij**2/r2/)*wij2
                end if
              else if (cell_projection == projection_xyz) then
                if (grad_method == grad_method_ls2) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dyij, dzij/)*wij2
                else if (grad_method == grad_method_ls3) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dyij, dzij,                      &
                         dxij**2/r2, dyij**2/r2, dzij**2/r2,           &
                         dxij*dyij, dxij*dzij, dyij*dzij/)*wij2
                else if (grad_method == grad_method_ls4) then
                  grad_hls_matrices(idvol,iedge,icell)%coef(iadj,:) =  &
                       (/1.0d0, dxij, dyij, dzij,                      &
                         dxij**2/r2, dyij**2/r2, dzij**2/r2,           &
                         dxij*dyij, dxij*dzij, dyij*dzij,              &
                         dxij**3/r6, dyij**3/r6, dzij**3/r6,           &
                         dxij**2*dyij/r2, dxij**2*dzij/r2,             &
                         dyij**2*dxij/r2, dyij**2*dzij/r2,             &
                         dzij**2*dxij/r2, dzij**2*dyij/r2/)*wij2
                end if
              end if
            end do
          end do
        end do
      end do
    end if

    if (b_enable_output .and. rank == 0) then
      write(*,'(a)') "Build control volume interface, done."
    end if

    return

  end subroutine usg_mesh_data_build_interface

  !>
  !> allocate memory space for control volume interface related variables
  !>
  subroutine usg_mesh_data_mem_vs

    use gen, only : memory_monitor, ilog, idbg, rank, b_enable_output, &
                    type_cond_perm, useAnisoCondCorr

    implicit none

    integer :: ierr

    external :: checkerr

    !c allocate advective velocity tensor for later use
    allocate(CellCvolFace_adv(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
    call checkerr(ierr,'CellCvolFace_adv',ilog)
    call memory_monitor(sizeof(CellCvolFace_adv),'CellCvolFace_adv',.true.)

    !c allocate hydraulic conductivity and other properties tensor for later use
    if (type_cond_perm == 1 .and. .not. useAnisoCondCorr) then
      allocate(CellCvolFace_cond(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellCvolFace_cond',ilog)
      call memory_monitor(sizeof(CellCvolFace_cond),'CellCvolFace_cond',.true.)
    else if (type_cond_perm == 2 .or. useAnisoCondCorr) then
      allocate(CellCvolFace_cond_tensor(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellCvolFace_cond_tensor',ilog)
      call memory_monitor(sizeof(CellCvolFace_cond_tensor),'CellCvolFace_cond_tensor',.true.)
    end if

  end subroutine usg_mesh_data_mem_vs

  !>
  !> allocate memory space for control volume interface related variables
  !>
  subroutine usg_mesh_data_mem_rt

    use gen, only : reactive_transport, diff_coff, type_diff_coeff,    &
                    type_disp_coeff, type_diff_ic_coeff,               &
                    useAnisoDispCorr, useAnisoTauCorr,                 &
                    useAnisoHeatCondCorr, useAnisoHeatDispCorr,        &
                    memory_monitor, ilog, idbg, rank, b_enable_output
    use m_heat_transport, only : heat_transport, evaporation
    use multidiff, only : multi_diff, hmulti_diff,                     &
                          mdiff_ic_cvol, mdiff_ix_cvol,                &
                          mdiff_ic_cvol_tensor, mdiff_ix_cvol_tensor,  &
                          type_mdiff_ic_coeff, type_mdiff_ix_coeff
    use chem, only : nc, nx

    implicit none

    integer :: ierr

    external :: checkerr

    if (reactive_transport) then
      if (type_disp_coeff == 2 .or. type_diff_coeff == 2 .or.          &
          useAnisoDispCorr .or. useAnisoTauCorr) then
        allocate(CellCvolFace_disp_da_tensor(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_disp_da_tensor',ilog)
        call memory_monitor(sizeof(CellCvolFace_disp_da_tensor),'CellCvolFace_disp_da_tensor',.true.)
      else
        allocate(CellCvolFace_disp_da(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_disp_da',ilog)
        call memory_monitor(sizeof(CellCvolFace_disp_da),'CellCvolFace_disp_da',.true.)
      end if

      allocate(CellCvolFace_disp_g(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
      call checkerr(ierr,'CellCvolFace_disp_g',ilog)
      call memory_monitor(sizeof(CellCvolFace_disp_g),'CellCvolFace_disp_g',.true.)

      if (multi_diff) then

        if (type_mdiff_ic_coeff > 0) then
          call memory_monitor(-sizeof(mdiff_ic_cvol),'mdiff_ic_cvol',.true.) 
          deallocate(mdiff_ic_cvol)         

          allocate (mdiff_ic_cvol_tensor(nc, num_nodes), stat = ierr)
          mdiff_ic_cvol_tensor = tensor_zero 
          call checkerr(ierr,'mdiff_ic_cvol_tensor',ilog)
          call memory_monitor(sizeof(mdiff_ic_cvol_tensor),'mdiff_ic_cvol_tensor',.true.)
        end if
          
        if (type_mdiff_ix_coeff > 0) then
          call memory_monitor(-sizeof(mdiff_ix_cvol),'mdiff_ix_cvol',.true.) 
          deallocate(mdiff_ix_cvol)   

          allocate (mdiff_ix_cvol_tensor(nx, num_nodes), stat = ierr)
          mdiff_ix_cvol_tensor = tensor_zero
          call checkerr(ierr,'mdiff_ix_cvol_tensor',ilog)
          call memory_monitor(sizeof(mdiff_ix_cvol_tensor),'mdiff_ix_cvol_tensor',.true.)
        end if

        if (useAnisoTauCorr) then
          allocate(CellCvolFace_disp_mcd_tensor(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
          call checkerr(ierr,'CellCvolFace_disp_mcd_tensor',ilog)
          call memory_monitor(sizeof(CellCvolFace_disp_mcd_tensor),'CellCvolFace_disp_mcd_tensor',.true.)
        else
          allocate(CellCvolFace_disp_mcd(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
          call checkerr(ierr,'CellCvolFace_disp_mcd',ilog)
          call memory_monitor(sizeof(CellCvolFace_disp_mcd),'CellCvolFace_disp_mcd',.true.)
        end if
      end if
      if (diff_coff) then
        if (type_disp_coeff == 2 .or. type_diff_ic_coeff == 2) then
          allocate(CellCvolFace_disp_da_ic_tensor(nc,num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
          call checkerr(ierr,'CellCvolFace_disp_da_ic_tensor',ilog)
          call memory_monitor(sizeof(CellCvolFace_disp_da_ic_tensor),'CellCvolFace_disp_da_ic_tensor',.true.)
        else
          allocate(CellCvolFace_disp_da_ic(nc,num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
          call checkerr(ierr,'CellCvolFace_disp_da_ic',ilog)
          call memory_monitor(sizeof(CellCvolFace_disp_da_ic),'CellCvolFace_disp_da_ic',.true.)
        end if
      end if
    end if

    if (heat_transport) then
      if (useAnisoHeatCondCorr) then
        allocate(CellCvolFace_heat_c_tensor(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_heat_c_tensor',ilog)
        call memory_monitor(sizeof(CellCvolFace_heat_c_tensor),'CellCvolFace_heat_c_tensor',.true.)
      else
        allocate(CellCvolFace_heat_c(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_heat_c',ilog)
        call memory_monitor(sizeof(CellCvolFace_heat_c),'CellCvolFace_heat_c',.true.)
      end if

      if (useAnisoHeatDispCorr) then
        allocate(CellCvolFace_heat_d_tensor(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_heat_d_tensor',ilog)
        call memory_monitor(sizeof(CellCvolFace_heat_d_tensor),'CellCvolFace_heat_d_tensor',.true.)
      else
        allocate(CellCvolFace_heat_d(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_heat_d',ilog)
        call memory_monitor(sizeof(CellCvolFace_heat_d),'CellCvolFace_heat_d',.true.)
      end if

      if (evaporation) then
        allocate(CellCvolFace_evap_pa(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_evap_pa',ilog)
        call memory_monitor(sizeof(CellCvolFace_evap_pa),'CellCvolFace_evap_pa',.true.)

        allocate(CellCvolFace_evap_t(num_edge_dvols,num_edges_per_cell,num_cells), stat = ierr)
        call checkerr(ierr,'CellCvolFace_evap_t',ilog)
        call memory_monitor(sizeof(CellCvolFace_evap_t),'CellCvolFace_evap_t',.true.)
      end if
    end if

  end subroutine usg_mesh_data_mem_rt


  !>
  !> export mesh to pflotran mesh format
  !>
  subroutine usg_mesh_data_export_pflotran(strfile,num_nodes_in,       &
                                  num_cells_in,nodes_in,cells_in)

    use file_unit, only : lun_get, lun_free
    use gen, only : ilog, idbg, rank

    implicit none

    character(len=*), intent(in) :: strfile
    integer, intent(in) :: num_nodes_in, num_cells_in
    type(point), allocatable :: nodes_in(:)
    integer, allocatable :: cells_in(:,:)

    !c local variables
    integer :: imsh, inode, icell
    real*8 :: dx, dy, dz

    imsh = lun_get()
    open(imsh,file=trim(strfile),status='unknown',form='formatted',err=990)

    dx = 0.0d0
    dy = 0.0d0
    dz = 0.0d0

    if (cell_type == cell_type_tri) then
      !c export to wedge as pflotran does not support 2d triangle mesh
      if (cell_projection == projection_xy) then
        dx = 0.0d0
        dy = 0.0d0
        dz = 1.0d0
      else if (cell_projection == projection_yz) then
        dx = 1.0d0
        dy = 0.0d0
        dz = 0.0d0
      else if (cell_projection == projection_xz) then
        dx = 0.0d0
        dy = 1.0d0
        dz = 0.0d0
      end if

      !c write head, number of cells_in and number of vertices
      write(imsh,'(2(i0,1x))') num_cells_in, num_nodes_in*2

      !c write cells_in
      do icell = 1, num_cells_in
        write(imsh,'(a1,6(1x,i0))')                                    &
             'W',cells_in(1,icell),cells_in(2,icell),cells_in(3,icell),&
             cells_in(1,icell)+num_nodes_in,                           &
             cells_in(2,icell)+num_nodes_in,                           &
             cells_in(3,icell)+num_nodes_in
      end do

      !c write nodes_in
      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x,nodes_in(inode)%y,nodes_in(inode)%z
      end do

      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x+dx,nodes_in(inode)%y+dy,               &
              nodes_in(inode)%z+dz
      end do

    else if (cell_type == cell_type_quad) then
      !c export to hexahedron as pflotran does not support 2d quad mesh
      if (cell_projection == projection_xy) then
        dx = 0.0d0
        dy = 0.0d0
        dz = 1.0d0
      else if (cell_projection == projection_yz) then
        dx = 1.0d0
        dy = 0.0d0
        dz = 0.0d0
      else if (cell_projection == projection_xz) then
        dx = 0.0d0
        dy = 1.0d0
        dz = 0.0d0
      end if

      !c write head, number of cells_in and number of vertices
      write(imsh,'(2(i0,1x))') num_cells_in, num_nodes_in*2
      !c write cells_in
      do icell = 1, num_cells_in
        write(imsh,'(a1,8(1x,i0))')                                    &
             'H',cells_in(1,icell),cells_in(2,icell),cells_in(3,icell),&
             cells_in(4,icell),cells_in(1,icell)+num_nodes_in,         &
             cells_in(2,icell)+num_nodes_in,                           &
             cells_in(3,icell)+num_nodes_in,                           &
             cells_in(4,icell)+num_nodes_in
      end do

      !c write nodes_in
      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x,nodes_in(inode)%y,nodes_in(inode)%z
      end do

      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x+dx,nodes_in(inode)%y+dy,               &
              nodes_in(inode)%z+dz
      end do
    else if (cell_type == cell_type_tetra) then
      !c write head, number of cells_in and number of vertices
      write(imsh,'(2(i0,1x))') num_cells_in, num_nodes_in
      !c write cells_in
      do icell = 1, num_cells_in
        write(imsh,'(a1,4(1x,i0))')                                    &
             'T',cells_in(1,icell),cells_in(2,icell),cells_in(3,icell),&
             cells_in(4,icell)
      end do
      !c write nodes_in
      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x,nodes_in(inode)%y,nodes_in(inode)%z
      end do
    else if (cell_type == cell_type_hexa) then
      !c write head, number of cells_in and number of vertices
      write(imsh,'(2(i0,1x))') num_cells_in, num_nodes_in
      !c write cells_in
      do icell = 1, num_cells_in
        write(imsh,'(a1,8(1x,i0))')                                    &
             'H',cells_in(1,icell),cells_in(2,icell),cells_in(3,icell),&
             cells_in(4,icell),cells_in(5,icell),cells_in(6,icell),    &
             cells_in(7,icell),cells_in(8,icell)
      end do
      !c write nodes_in
      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x,nodes_in(inode)%y,nodes_in(inode)%z
      end do
    else if (cell_type == cell_type_prism) then
      !c write head, number of cells_in and number of vertices
      write(imsh,'(2(i0,1x))') num_cells_in, num_nodes_in
      !c write cells_in
      do icell = 1, num_cells_in
        write(imsh,'(a1,6(1x,i0))')                                    &
             'W',cells_in(1,icell),cells_in(2,icell),cells_in(3,icell),&
             cells_in(4,icell),cells_in(5,icell),cells_in(6,icell)
      end do
      !c write nodes_in
      do inode = 1, num_nodes_in
        write(imsh,'(3(1pe15.6e3,1x))')                                &
              nodes_in(inode)%x,nodes_in(inode)%y,nodes_in(inode)%z
      end do
    end if

    close(imsh)

    call lun_free(imsh)

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening pflotran mesh file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening pflotran mesh file'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_export_pflotran


  !>
  !> create unstructured data points spatial searching
  !>
  subroutine usg_mesh_data_search_build

#ifdef CGAL
  use cgal_search_with_point_iface, only :    &
           cgal_search_point_initialize,      &
           cgal_search_point_add_point,       &
           cgal_search_point_make_tree
#endif
    use gen, only : ilog, rank, b_enable_output,                       &
                    mem_cur, mem_max, memory_monitor
    implicit none

    integer :: i, j, ivol, cindex, eindex, itype, ierr
    integer*8 :: ifaceedge
    integer :: n_search_points
    integer, allocatable :: ivol_search_points(:)

#ifdef CGAL
    !c build data points spatial searching for all the nodes
    itype = 0
    !c initialize spatial searching
    call cgal_search_point_initialize(itype)
    !c add data points
    do i = 1, num_nodes
      call cgal_search_point_add_point(itype,i,nodes(i)%x,nodes(i)%y,nodes(i)%z)
    end do
    !c make data point tree
    call cgal_search_point_make_tree(itype)

    !c build data points spatial searching for all the nodes
    itype = 1
    !c initialize spatial searching
    call cgal_search_point_initialize(itype)

    if(cell_projection == projection_xyz) then
      n_search_points = 0
      allocate(ivol_search_points(num_border_faceedges*4), stat = ierr)
      call checkerr(ierr,'ivol_search_points',ilog)
      ivol_search_points = 0
      call memory_monitor(sizeof(ivol_search_points),'ivol_search_points',.false.)
    end if

    !c add data points
    do i = 1, num_border_faceedges
      ifaceedge = border2halfid(i)
      cindex = cal_cellface_index(ifaceedge)
      eindex = cal_faceedge_index(ifaceedge)

      if(cell_type == cell_type_tri .or. cell_type == cell_type_quad) then
        ivol = cells(eindex,cindex)
        call cgal_search_point_add_point(itype,ivol,nodes(ivol)%x,     &
                                         nodes(ivol)%y,nodes(ivol)%z)
      else if(cell_type == cell_type_tetra .or.                        &
              cell_type == cell_type_hexa .or.                         &
              cell_type == cell_type_prism) then
        do j = 1, num_nodes_per_face
          if (cell_type == cell_type_tetra) then
            ivol = cells(face_node_mapping_tetra(j,eindex),cindex)
          else if (cell_type == cell_type_hexa) then
            ivol = cells(face_node_mapping_hexa(j,eindex),cindex)
          else if (cell_type == cell_type_prism) then
            ivol = cells(face_node_mapping_prism(j,eindex),cindex)
          end if

          if(n_search_points > 0) then
            if (all(ivol_search_points(1:n_search_points) /= ivol)) then
              n_search_points = n_search_points + 1
              ivol_search_points(n_search_points) = ivol
            end if
          else
            n_search_points = n_search_points + 1
            ivol_search_points(n_search_points) = ivol
          end if
        end do
      end if
    end do
    !c make data point tree
    call cgal_search_point_make_tree(itype)

#else
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    write(*,*) "error: CGAL is required for spatial searching"
    write(ilog,*) "error: CGAL is required for spatial searching"
    stop
#endif

    if (b_enable_output .and. rank == 0) then
      write(*,'(a)') "Build data point search tree, done."
    end if

  end subroutine usg_mesh_data_search_build


  !>
  !> get shared cell list
  !>
  subroutine get_edge_shared_cells(ncells_ivol, ncells_jvol,           &
                                   cells_ivol,cells_jvol,cells_shared)

    implicit none

    integer, intent(in) :: ncells_ivol, ncells_jvol
    integer, intent(in) :: cells_ivol(ncells_ivol),                    &
                           cells_jvol(ncells_jvol)
    integer, intent(inout) :: cells_shared(*)

    !c local varaibles
    integer :: i, j, icell, n

    n = 0

    do i = 1, ncells_ivol
      icell = cells_ivol(i)
      do j = 1, ncells_jvol
        if (cells_jvol(j) == icell) then
          n = n + 1
          cells_shared(n) = icell
          exit
        end if
      end do
    end do

  end subroutine get_edge_shared_cells

  !>
  !> get maximum number of cells with shared edge
  !>
  function get_edge_shared_cells_num(ncells_ivol, ncells_jvol,         &
               cells_ivol,cells_jvol) result(num)

    implicit none

    integer, intent(in) :: ncells_ivol, ncells_jvol
    integer, intent(in) :: cells_ivol(ncells_ivol),                    &
                           cells_jvol(ncells_jvol)
    integer :: num

    !c local varaibles
    integer :: i, j, icell

    num = 0

    do i = 1, ncells_ivol
      icell = cells_ivol(i)
      do j = 1, ncells_jvol
        if (cells_jvol(j) == icell) then
          num = num + 1
          exit
        end if
      end do
    end do

  end function get_edge_shared_cells_num


  !>
  !> calculate half-edge/half-face ID based on the cell index and node ids
  !> pair number <f,i>
  !>
  function cal_faceedge_id(ctype,cindex,inodes,iflag_border) result(id)

    implicit none

    integer, intent(in) :: ctype, cindex
    integer, intent(in) :: inodes(4)
    integer :: iflag_border
    integer*8 :: id

    integer :: i, iindex

    id = 0

    if(ctype == cell_type_tri) then

      do i = 1, num_edges_per_cell      ! number of edges
        if(cells(edge_node_mapping_tri(1,i),cindex) == inodes(2) .and.       &
           cells(edge_node_mapping_tri(2,i),cindex) == inodes(1)) then
          id = cal_edge_id(cindex,i,1)
          exit
        end if
      end do

    else if (ctype == cell_type_quad) then

      do i = 1, num_edges_per_cell      ! number of edges
        if(cells(edge_node_mapping_quad(1,i),cindex) == inodes(2) .and.      &
           cells(edge_node_mapping_quad(2,i),cindex) == inodes(1)) then
          id = cal_edge_id(cindex,i,1)
          exit
        end if
      end do

    else if(ctype == cell_type_tetra) then
      do i = 1, num_faces_per_cell      ! number of faces
        if(cells(face_node_mapping_tetra(1,i),cindex) == inodes(3).and.      &
           cells(face_node_mapping_tetra(2,i),cindex) == inodes(2).and.      &
           cells(face_node_mapping_tetra(3,i),cindex) == inodes(1)) then
          id = cal_face_id(cindex,i,2,1)
          exit
        else if(cells(face_node_mapping_tetra(1,i),cindex) == inodes(2).and. &
                cells(face_node_mapping_tetra(2,i),cindex) == inodes(1).and. &
                cells(face_node_mapping_tetra(3,i),cindex) == inodes(3)) then
          id = cal_face_id(cindex,i,1,1)
          exit
        else if(cells(face_node_mapping_tetra(1,i),cindex) == inodes(1).and. &
                cells(face_node_mapping_tetra(2,i),cindex) == inodes(3).and. &
                cells(face_node_mapping_tetra(3,i),cindex) == inodes(2)) then
          id = cal_face_id(cindex,i,0,1)
          exit
        end if
      end do

    else if(ctype == cell_type_hexa) then
      do i = 1, num_faces_per_cell      ! number of faces
        if(cells(face_node_mapping_hexa(1,i),cindex) == inodes(4).and.       &
           cells(face_node_mapping_hexa(2,i),cindex) == inodes(3).and.       &
           cells(face_node_mapping_hexa(3,i),cindex) == inodes(2).and.       &
           cells(face_node_mapping_hexa(4,i),cindex) == inodes(1)) then
          id = cal_face_id(cindex,i,3,1)
          exit
        else if(cells(face_node_mapping_hexa(1,i),cindex) == inodes(3).and.  &
                cells(face_node_mapping_hexa(2,i),cindex) == inodes(2).and.  &
                cells(face_node_mapping_hexa(3,i),cindex) == inodes(1).and.  &
                cells(face_node_mapping_hexa(4,i),cindex) == inodes(4)) then
          id = cal_face_id(cindex,i,2,1)
          exit
        else if(cells(face_node_mapping_hexa(1,i),cindex) == inodes(2).and.  &
                cells(face_node_mapping_hexa(2,i),cindex) == inodes(1).and.  &
                cells(face_node_mapping_hexa(3,i),cindex) == inodes(4).and.  &
                cells(face_node_mapping_hexa(4,i),cindex) == inodes(3)) then
          id = cal_face_id(cindex,i,1,1)
          exit
        else if(cells(face_node_mapping_hexa(1,i),cindex) == inodes(1).and.  &
                cells(face_node_mapping_hexa(2,i),cindex) == inodes(4).and.  &
                cells(face_node_mapping_hexa(3,i),cindex) == inodes(3).and.  &
                cells(face_node_mapping_hexa(4,i),cindex) == inodes(2)) then
          id = cal_face_id(cindex,i,0,1)
          exit
        end if
      end do

    else if(ctype == cell_type_prism) then
      do i = 1, num_faces_per_cell      ! number of faces
        !c top or bottom face of prism
        if (face_node_mapping_prism(1,i) == face_node_mapping_prism(4,i)) then
          if(cells(face_node_mapping_prism(1,i),cindex) == inodes(3).and.      &
             cells(face_node_mapping_prism(2,i),cindex) == inodes(2).and.      &
             cells(face_node_mapping_prism(3,i),cindex) == inodes(1)) then
            id = cal_face_id(cindex,i,2,1)
            exit
          else if(cells(face_node_mapping_prism(1,i),cindex) == inodes(2).and. &
                  cells(face_node_mapping_prism(2,i),cindex) == inodes(1).and. &
                  cells(face_node_mapping_prism(3,i),cindex) == inodes(3)) then
            id = cal_face_id(cindex,i,1,1)
            exit
          else if(cells(face_node_mapping_prism(1,i),cindex) == inodes(1).and. &
                  cells(face_node_mapping_prism(2,i),cindex) == inodes(3).and. &
                  cells(face_node_mapping_prism(3,i),cindex) == inodes(2)) then
            id = cal_face_id(cindex,i,0,1)
            exit
          end if
        else
          if(cells(face_node_mapping_prism(1,i),cindex) == inodes(4).and.      &
             cells(face_node_mapping_prism(2,i),cindex) == inodes(3).and.      &
             cells(face_node_mapping_prism(3,i),cindex) == inodes(2).and.      &
             cells(face_node_mapping_prism(4,i),cindex) == inodes(1)) then
            id = cal_face_id(cindex,i,3,1)
            exit
          else if(cells(face_node_mapping_prism(1,i),cindex) == inodes(3).and. &
                  cells(face_node_mapping_prism(2,i),cindex) == inodes(2).and. &
                  cells(face_node_mapping_prism(3,i),cindex) == inodes(1).and. &
                  cells(face_node_mapping_prism(4,i),cindex) == inodes(4)) then
            id = cal_face_id(cindex,i,2,1)
            exit
          else if(cells(face_node_mapping_prism(1,i),cindex) == inodes(2).and. &
                  cells(face_node_mapping_prism(2,i),cindex) == inodes(1).and. &
                  cells(face_node_mapping_prism(3,i),cindex) == inodes(4).and. &
                  cells(face_node_mapping_prism(4,i),cindex) == inodes(3)) then
            id = cal_face_id(cindex,i,1,1)
            exit
          else if(cells(face_node_mapping_prism(1,i),cindex) == inodes(1).and. &
                  cells(face_node_mapping_prism(2,i),cindex) == inodes(4).and. &
                  cells(face_node_mapping_prism(3,i),cindex) == inodes(3).and. &
                  cells(face_node_mapping_prism(4,i),cindex) == inodes(2)) then
            id = cal_face_id(cindex,i,0,1)
            exit
          end if
        end if
      end do

    end if

  end function cal_faceedge_id

  !>
  !> calculate half-edge ID based on the edge index
  !>
  function cal_edge_id(cindex,eindex,iflag_border) result(id)

    implicit none

    integer, intent(in) :: cindex, eindex,iflag_border
    integer*8 :: id

    id = ishft(cindex,6)+ishft(eindex,3)+iflag_border

  end function cal_edge_id

  !>
  !> calculate half-face ID based on the face index
  !>
  function cal_face_id(cindex,findex,aindex,iflag_border) result(id)

    implicit none

    integer, intent(in) :: cindex,findex,aindex,iflag_border
    integer*8 :: id

    id = ishft(cindex,6)+ishft(findex,3)+ishft(aindex,1)+iflag_border

  end function cal_face_id

  !>
  !> calculate face or cell index (f) based on half-edge or half-face ID <f,e,i>
  !>
  function cal_cellface_index(id) result(cindex)

    implicit none

    integer*8, intent(in) :: id

    integer :: cindex

    cindex = ishft(id,-6)

  end function cal_cellface_index

  !>
  !> calculate edge or face index (e) based on half-edge or half-face ID<f,e,i>
  !>
  function cal_faceedge_index(id) result(eindex)

    implicit none

    integer*8, intent(in) :: id

    integer :: eindex

    !c The bits are numbered from 0 to BIT_SIZE(I)-1, from right to left.
    eindex = ibits(id,3,3)

  end function cal_faceedge_index

  !>
  !> calculate face anchor index (a) based on half-face ID<f,e,a,i>
  !>
  function cal_face_anchor_index(id) result(aindex)

    implicit none

    integer*8, intent(in) :: id

    integer :: aindex

    !c The bits are numbered from 0 to BIT_SIZE(I)-1, from right to left.
    aindex = ibits(id,1,2)

  end function cal_face_anchor_index

  !>
  !> calculate edge indicator (i) based on half-edge ID <f,e,i>
  !> or calculate anchor index (i) based on half-face ID <c,f,i>
  !> to check if an edge is a border edge
  !>
  function cal_border_indicator(id) result(iindex)

    implicit none

    integer*8, intent(in) :: id

    integer :: iindex

    !c The bits are numbered from 0 to BIT_SIZE(I)-1, from right to left.
    iindex = ibits(id,0,1)

  end function cal_border_indicator

  !>
  !> calculate previous of non-border half-edge or non-border half-face <f,e,i>
  !> this only works for triangle or tetrahedra
  !>
  function cal_faceedge_prev(id) result(id_prev)

    implicit none

    integer*8, intent(in) :: id
    integer*8 :: id_prev

    integer :: cindex, eindex, eindexprev

    cindex = cal_cellface_index(id)
    eindex = cal_faceedge_index(id)
    eindexprev = mod(eindex+num_nodes_per_cell-2,num_nodes_per_cell)+1

    id_prev = cell2halfid(eindexprev,cindex)

  end function cal_faceedge_prev

  !>
  !> calculate next of non-border half-edge or non-border half-face <f,e,i>
  !> this only works for triangle or tetrahedra
  !>
  function cal_faceedge_next(id) result(id_next)

    implicit none

    integer*8, intent(in) :: id
    integer*8 :: id_next

    integer :: cindex, eindex,eindexnext

    cindex = cal_cellface_index(id)
    eindex = cal_faceedge_index(id)
    eindexnext = mod(eindex,num_nodes_per_cell)+1

    id_next = cell2halfid(eindexnext,cindex)

  end function cal_faceedge_next

  !>
  !> convert edge id as a border id
  !>
  function cvt_to_border_edge_id(id) result(idcvt)

    implicit none

    integer*8, intent(in) :: id
    integer*8 :: idcvt

    idcvt = ibclr(id,0)

  end function

  !>
  !> check if the edge or face ID is the same
  !>
  function is_same_faceedge_id(id1,id2) result(issame)

    implicit none

    integer*8, intent(in) :: id1, id2

    logical :: issame

    if (ishft(id1,-3) == ishft(id2,-3)) then
      issame = .true.
    else
      issame = .false.
    end if

  end function is_same_faceedge_id

  !>
  !> check if the edge or face id is boundary id
  !>
  function is_border_faceedge(id) result(bflag)

    implicit none

    integer*8, intent(in) :: id

    logical :: bflag

    bflag = .false.

    if(cal_border_indicator(id) == 0) then
      bflag = .true.
    end if

  end function is_border_faceedge


  !>
  !> calculate jacell id based on cell index, first face index and second face index
  !>
  function cal_jacell_id1(cindex,findex1,findex2) result(id)

    implicit none

    integer, intent(in) :: cindex, findex1, findex2
    integer*8 :: id

    id = findex1 + ishft(findex2,3) + ishft(cindex,6)

  end function cal_jacell_id1

  !>
  !> calculate jacell id based on cell index and two node indices
  !>
  function cal_jacell_id2(cindex,inode1,inode2,celltype) result(id)

    use gen, only : ilog

    implicit none

    integer, intent(in) :: cindex, inode1, inode2, celltype
    integer*8 :: id

    !c local variable
    integer :: iface, findex1, findex2, i1, i2, i3, i4
    logical :: bfound

    id = 0
    findex1 = 0
    findex2 = 0
    bfound = .false.

    !c loop over all faces
    if (celltype == cell_type_tetra) then
      do iface = 1, num_faces_per_cell
        i1 = cells(face_node_mapping_tetra(1,iface),cindex)
        i2 = cells(face_node_mapping_tetra(2,iface),cindex)
        i3 = cells(face_node_mapping_tetra(3,iface),cindex)

        if((i1 == inode1 .and. i2 == inode2) .or.                      &
           (i2 == inode1 .and. i3 == inode2) .or.                      &
           (i3 == inode1 .and. i1 == inode2)) then
          findex1 = iface
        end if

        if((i1 == inode2 .and. i2 == inode1) .or.                      &
           (i2 == inode2 .and. i3 == inode1) .or.                      &
           (i3 == inode2 .and. i1 == inode1)) then
          findex2 = iface
        end if

        if (findex1 > 0 .and. findex2 > 0) then
          bfound = .true.
          exit
        end if
      end do
    else if (celltype == cell_type_hexa) then
      do iface = 1, num_faces_per_cell
        i1 = cells(face_node_mapping_hexa(1,iface),cindex)
        i2 = cells(face_node_mapping_hexa(2,iface),cindex)
        i3 = cells(face_node_mapping_hexa(3,iface),cindex)
        i4 = cells(face_node_mapping_hexa(4,iface),cindex)

        if((i1 == inode1 .and. i2 == inode2) .or.                      &
           (i2 == inode1 .and. i3 == inode2) .or.                      &
           (i3 == inode1 .and. i4 == inode2) .or.                      &
           (i4 == inode1 .and. i1 == inode2)) then
          findex1 = iface
        end if

        if((i1 == inode2 .and. i2 == inode1) .or.                      &
           (i2 == inode2 .and. i3 == inode1) .or.                      &
           (i3 == inode2 .and. i4 == inode1) .or.                      &
           (i4 == inode2 .and. i1 == inode1)) then
          findex2 = iface
        end if

        if (findex1 > 0 .and. findex2 > 0) then
          bfound = .true.
          exit
        end if
      end do
    else if (celltype == cell_type_prism) then
      !c top and bottom faces of prism
      do iface = 1, 2
        i1 = cells(face_node_mapping_prism(1,iface),cindex)
        i2 = cells(face_node_mapping_prism(2,iface),cindex)
        i3 = cells(face_node_mapping_prism(3,iface),cindex)

        if((i1 == inode1 .and. i2 == inode2) .or.                      &
           (i2 == inode1 .and. i3 == inode2) .or.                      &
           (i3 == inode1 .and. i1 == inode2)) then
          findex1 = iface
        end if

        if((i1 == inode2 .and. i2 == inode1) .or.                      &
           (i2 == inode2 .and. i3 == inode1) .or.                      &
           (i3 == inode2 .and. i1 == inode1)) then
          findex2 = iface
        end if

        if (findex1 > 0 .and. findex2 > 0) then
          bfound = .true.
          exit
        end if
      end do
      !c side faces of prism
      if (.not. bfound) then
        do iface = 3, num_faces_per_cell
          i1 = cells(face_node_mapping_prism(1,iface),cindex)
          i2 = cells(face_node_mapping_prism(2,iface),cindex)
          i3 = cells(face_node_mapping_prism(3,iface),cindex)
          i4 = cells(face_node_mapping_prism(4,iface),cindex)

          if((i1 == inode1 .and. i2 == inode2) .or.                    &
             (i2 == inode1 .and. i3 == inode2) .or.                    &
             (i3 == inode1 .and. i4 == inode2) .or.                    &
             (i4 == inode1 .and. i1 == inode2)) then
            findex1 = iface
          end if

          if((i1 == inode2 .and. i2 == inode1) .or.                    &
             (i2 == inode2 .and. i3 == inode1) .or.                    &
             (i3 == inode2 .and. i4 == inode1) .or.                    &
             (i4 == inode2 .and. i1 == inode1)) then
            findex2 = iface
          end if

          if (findex1 > 0 .and. findex2 > 0) then
            bfound = .true.
            exit
          end if
        end do
      end if
    else
      write(*,*) "Error: jacell id is not supportted for cell type ",celltype
      write(ilog,*) "Error: jacell id is not supportted for cell type ",celltype
      close(ilog)
      stop
    end if

    if (bfound) then
      id = cal_jacell_id1(cindex,findex1,findex2)
    else
      write(*,'(a,1x,i8,1x,a,2(1x,i8))')                               &
            "Error: jacell id is not found for cell ",cindex,          &
            "node",inode1,inode2
      write(ilog,'(a,1x,i8,1x,a,2(1x,i8))')                            &
            "Error: jacell id is not found for cell ",cindex,          &
            "node",inode1,inode2
      close(ilog)
      stop
    end if

  end function cal_jacell_id2

  !>
  !> calculate cell index based on jacell id
  !>

  function cal_jacell_cellindex(id) result(cindex)

    implicit none

    integer*8, intent(in) :: id
    integer :: cindex

    cindex = ishft(id,-6)

  end function cal_jacell_cellindex

  !>
  !> calculate face index 1 based on jacell id
  !>

  function cal_jacell_faceindex1(id) result(findex)

    implicit none

    integer*8, intent(in) :: id
    integer :: findex

    findex = ibits(id,0,3)

  end function cal_jacell_faceindex1

  !>
  !> calculate face index 2 based on jacell id
  !>

  function cal_jacell_faceindex2(id) result(findex)

    implicit none

    integer*8, intent(in) :: id
    integer :: findex

    findex = ibits(id,3,3)

  end function cal_jacell_faceindex2


  !>
  !> calculate the third and forth node id for the specified cell
  !>
  subroutine get_cell_vol_id(icell,ivol,jvol,nkvols,kvols)

    implicit none

    integer, intent(in) :: icell, ivol, jvol
    integer, intent(inout) :: nkvols, kvols(6)

    !c local variable
    integer :: i

    nkvols = 0
    kvols = 0

    do i = 1, num_nodes_per_cell
      if (cells(i,icell) /= ivol .and. cells(i,icell) /= jvol) then
        nkvols = nkvols + 1
        kvols(nkvols) = cells(i,icell)
      end if
    end do

  end subroutine get_cell_vol_id

  !>
  !> get face-edge index based on the given point
  !>
  function get_face_edge_index(icell,ivol,jvol) result(iface)

    implicit none

    integer, intent(in) :: icell,ivol,jvol
    integer :: iface

    !c local variables
    integer :: i, kvols(2)

    iface = 0
    kvols = 0

    if (cell_type == cell_type_tri) then
      do i = 1, num_edges_per_cell
        kvols(1) = cells(edge_node_mapping_tri(1,i),icell)
        kvols(2) = cells(edge_node_mapping_tri(2,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol)) then
          iface = i
          exit
        end if
      end do
    else if (cell_type == cell_type_quad) then
      do i = 1, num_edges_per_cell
        kvols(1) = cells(edge_node_mapping_quad(1,i),icell)
        kvols(2) = cells(edge_node_mapping_quad(2,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol)) then
          iface = i
          exit
        end if
      end do
    end if

  end function get_face_edge_index

  !>
  !> get face-edge index based on the given point
  !>
  function get_cell_face_index(icell,ivol,jvol,kvol) result(iface)

    implicit none

    integer, intent(in) :: icell,ivol,jvol,kvol
    integer :: iface

    !c local variables
    integer :: i, kvols(4)

    iface = 0
    kvols = 0

    if (cell_type == cell_type_tetra) then
      do i = 1, num_faces_per_cell
        kvols(1) = cells(face_node_mapping_tetra(1,i),icell)
        kvols(2) = cells(face_node_mapping_tetra(2,i),icell)
        kvols(3) = cells(face_node_mapping_tetra(3,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol) .and.      &
            any(kvols .eq. kvol)) then
          iface = i
          exit
        end if
      end do
    else if (cell_type == cell_type_prism) then
      do i = 1, num_faces_per_cell
        kvols(1) = cells(face_node_mapping_prism(1,i),icell)
        kvols(2) = cells(face_node_mapping_prism(2,i),icell)
        kvols(3) = cells(face_node_mapping_prism(3,i),icell)
        kvols(4) = cells(face_node_mapping_prism(4,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol) .and.      &
            any(kvols .eq. kvol)) then
          iface = i
          exit
        end if
      end do
    else if (cell_type == cell_type_hexa) then
      do i = 1, num_faces_per_cell
        kvols(1) = cells(face_node_mapping_hexa(1,i),icell)
        kvols(2) = cells(face_node_mapping_hexa(2,i),icell)
        kvols(3) = cells(face_node_mapping_hexa(3,i),icell)
        kvols(4) = cells(face_node_mapping_hexa(4,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol) .and.      &
            any(kvols .eq. kvol)) then
          iface = i
          exit
        end if
      end do
    end if

  end function get_cell_face_index

  !>
  !> get the face indices with shared edge
  !>
  subroutine get_cell_face_index2(icell,ivol,jvol,iface1,iface2)

    implicit none

    integer, intent(in) :: icell,ivol,jvol
    integer, intent(inout) :: iface1,iface2

    !c local variables
    integer :: i, kvols(4)

    iface1 = 0
    iface2 = 0
    kvols = 0

    if (cell_type == cell_type_tetra) then
      do i = 1, num_faces_per_cell
        kvols(1) = cells(face_node_mapping_tetra(1,i),icell)
        kvols(2) = cells(face_node_mapping_tetra(2,i),icell)
        kvols(3) = cells(face_node_mapping_tetra(3,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol)) then
          if (iface1 == 0) then
            iface1 = i
          else
            iface2 = i
          end if
          if (iface1 > 0 .and. iface2 > 0) then
            exit
          end if
        end if
      end do
    else if (cell_type == cell_type_prism) then
      do i = 1, num_faces_per_cell
        kvols(1) = cells(face_node_mapping_prism(1,i),icell)
        kvols(2) = cells(face_node_mapping_prism(2,i),icell)
        kvols(3) = cells(face_node_mapping_prism(3,i),icell)
        kvols(4) = cells(face_node_mapping_prism(4,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol)) then
          if (iface1 == 0) then
            iface1 = i
          else
            iface2 = i
          end if
          if (iface1 > 0 .and. iface2 > 0) then
            exit
          end if
        end if
      end do
    else if (cell_type == cell_type_hexa) then
      do i = 1, num_faces_per_cell
        kvols(1) = cells(face_node_mapping_hexa(1,i),icell)
        kvols(2) = cells(face_node_mapping_hexa(2,i),icell)
        kvols(3) = cells(face_node_mapping_hexa(3,i),icell)
        kvols(4) = cells(face_node_mapping_hexa(4,i),icell)
        if (any(kvols .eq. ivol) .and. any(kvols .eq. jvol)) then
          if (iface1 == 0) then
            iface1 = i
          else
            iface2 = i
          end if
          if (iface1 > 0 .and. iface2 > 0) then
            exit
          end if
        end if
      end do
    end if

  end subroutine get_cell_face_index2

  !>
  !> convert ivol-jvol control volume interface id to cell basd id
  !>
  subroutine get_cell_edge_cvol_id(idvol,ivol,jvol,icell,idvol_r,iedge_r,rswitch)

    implicit none

    integer, intent(in) :: idvol,ivol,jvol,icell
    integer, intent(inout) :: idvol_r, iedge_r
    real*8, intent(inout), optional :: rswitch

    !c local variables
    integer :: iedge, ivol2, jvol2

    idvol_r = 0
    iedge_r = 0
    if (present(rswitch)) then
      rswitch = 0.0d0
    end if

    if (cell_type == cell_type_tri) then
      do iedge = 1, num_edges_per_cell
        ivol2 = cells(edge_node_mapping_tri(1,iedge),icell)
        jvol2 = cells(edge_node_mapping_tri(2,iedge),icell)
        if (ivol2 == ivol .and. jvol2 == jvol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = 1.0d0
          end if
          return
        else if (ivol2 == jvol .and. jvol2 == ivol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = -1.0d0
          end if
          return
        end if
      end do
    else if (cell_type == cell_type_quad) then
      do iedge = 1, num_edges_per_cell
        ivol2 = cells(edge_node_mapping_quad(1,iedge),icell)
        jvol2 = cells(edge_node_mapping_quad(2,iedge),icell)
        if (ivol2 == ivol .and. jvol2 == jvol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = 1.0d0
          end if
          return
        else if (ivol2 == jvol .and. jvol2 == ivol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = -1.0d0
          end if
          return
        end if
      end do
    else if (cell_type == cell_type_tetra) then
      do iedge = 1, num_edges_per_cell
        ivol2 = cells(edge_node_mapping_tetra(1,iedge),icell)
        jvol2 = cells(edge_node_mapping_tetra(2,iedge),icell)
        if (ivol2 == ivol .and. jvol2 == jvol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = 1.0d0
          end if
          return
        else if (ivol2 == jvol .and. jvol2 == ivol) then
          idvol_r = num_edge_dvols + 1 - idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = -1.0d0
          end if
          return
        end if
      end do
    else if (cell_type == cell_type_hexa) then
      do iedge = 1, num_edges_per_cell
        ivol2 = cells(edge_node_mapping_hexa(1,iedge),icell)
        jvol2 = cells(edge_node_mapping_hexa(2,iedge),icell)
        if (ivol2 == ivol .and. jvol2 == jvol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = 1.0d0
          end if
          return
        else if (ivol2 == jvol .and. jvol2 == ivol) then
          idvol_r = num_edge_dvols + 1 - idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = -1.0d0
          end if
          return
        end if
      end do
    else if (cell_type == cell_type_prism) then
      do iedge = 1, num_edges_per_cell
        ivol2 = cells(edge_node_mapping_prism(1,iedge),icell)
        jvol2 = cells(edge_node_mapping_prism(2,iedge),icell)
        if (ivol2 == ivol .and. jvol2 == jvol) then
          idvol_r = idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = 1.0d0
          end if
          return
        else if (ivol2 == jvol .and. jvol2 == ivol) then
          idvol_r = num_edge_dvols + 1 - idvol
          iedge_r = iedge
          if (present(rswitch)) then
            rswitch = -1.0d0
          end if
          return
        end if
      end do
    end if

    !if (idvol_r == 0 .or. iedge_r == 0) then
    !  write(*,*) "Error: cell_edge_cvol_id not found, icell",icell,    &
    !             "ivol",ivol,"jvol",jvol,"idvol_r",idvol_r,            &
    !             "iedge_r",iedge_r,"ivol2",ivol2,"jvol2",jvol2
    !end if

  end subroutine get_cell_edge_cvol_id

!c********************Section of Data Search and Interpolation********************

  !>
  !> get the closest point id
  !>
  function usg_mesh_data_closest_point(itype,x,y,z) result(vid)

#ifdef CGAL
    use cgal_search_with_point_iface, only :    &
             cgal_search_point_closest_point
#endif
    use gen, only : ilog, rank
    implicit none
    integer, intent(in) :: itype
    real*8, intent(in) :: x, y, z
    integer :: vid

    vid = -1
#ifdef CGAL
    call cgal_search_point_closest_point(itype,x,y,z,vid)
#else
    if (rank == 0) then
      write(*,*) "Error: CGAL is needed to use 'usg_mesh_data_closest_point'"
      write(ilog,*) "Error: CGAL is needed to use 'usg_mesh_data_closest_point'"
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
#endif

  end function usg_mesh_data_closest_point

  !>
  !> check if a given point is inside a cell
  !>
  function usg_mesh_data_check_inside(x,y,z,icell) result(iflag)

#ifdef CGAL
    use cgal_polygon_iface, only : cgal_check_inside
#endif
    use gen, only : ilog, rank
    implicit none

    real*8, intent(in) :: x, y, z
    integer, intent(in) :: icell
    integer :: iflag

    !c local variables
    integer :: i, j
    type(point3d_c) :: pt
    type(point3d_c), allocatable :: pts(:)

    iflag = -999

#ifdef CGAL

    pt%x = x
    pt%y = y
    pt%z = z

    allocate(pts(num_nodes_per_cell))
    do i = 1, num_nodes_per_cell
      j = cells(i,icell)
      pts(i) = point3d_c(nodes(j)%x,nodes(j)%y,nodes(j)%z)
    end do

    iflag = cgal_check_inside(cell_projection,pt,num_nodes_per_cell,   &
                              pts(1:num_nodes_per_cell))
    deallocate(pts)

#else
    if (rank == 0) then
      write(*,*) "Error: CGAL is needed to use 'usg_mesh_data_check_inside'"
      write(ilog,*) "Error: CGAL is needed to use 'usg_mesh_data_check_inside'"
    end if  
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
#endif

  end function usg_mesh_data_check_inside

  !>
  !> get the cell including the specific point
  !>
  function usg_mesh_data_find_cell(x,y,z) result(cid)

    use gen, only : ilog, iavs, javs, jacell

    implicit none

    real*8, intent(in) :: x, y, z
    integer :: cid

    !c local variable
    integer :: vid, istart, iend, jtemp, itype

    itype = 0
    cid = -1
    vid = usg_mesh_data_closest_point(itype,x,y,z)

    if(vid > 0) then
      !c loop over this node to find all the cells
      if(cell_projection == projection_xyz) then
        write(*,*) "error: 3D cell location is not supported at present"
        write(ilog,*) "error: 3D cell location is not supported at present"
        stop
      else
        istart = iavs(vid)+1
        iend = iavs(vid+1)-1
        if(jacell(1,istart) > 0) then
          do jtemp = istart, iend
            cid = jacell(1,jtemp)
            if(cid > 0) then
              if(usg_mesh_data_check_inside(x,y,z,cid) >= 0) then
                exit
              end if
            end if
          end do
        else if(jacell(2,istart) > 0) then
          do jtemp = istart, iend
            cid = jacell(2,jtemp)
            if(cid > 0) then
              if(usg_mesh_data_check_inside(x,y,z,cid) >= 0) then
                exit
              end if
            end if
          end do
        end if
      end if
    else
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      write(*,*) "error: no point is close to the specified location"
      write(ilog,*) "error: no point is close to the specified location"
      stop
    end if

  end function usg_mesh_data_find_cell

  !>
  !> interpolate value using inverse distance method
  !>
  function usg_mesh_data_interpolate_xyz(x,y,z,icell,vals) result(val)

    implicit none

    real*8, intent(in) :: x, y, z
    integer, intent(in) :: icell
    real*8, allocatable, intent(in) :: vals(:)
    real*8 :: val

    !c local variables
    integer :: i, ivol
    real*8 :: dltot
    real*8, allocatable :: dl(:)
    type(point) :: pt
    real*8, parameter :: rverysmall = 1.0d-100

    allocate(dl(num_nodes_per_cell))

    dltot = 0.0d0
    val = 0.0d0
    do i = 1, num_nodes_per_cell
      ivol = cells(i,icell)
      pt = nodes(ivol)
      dl(i) = sqrt((x-pt%x)**2 + (y-pt%y)**2 + (z-pt%z)**2)
      if(dl(i) < rverysmall) then
        val = vals(ivol)
        return
      else
        dl(i) = 1.0d0/dl(i)**grad_spatial_factor
        dltot = dltot + dl(i)
        val = val + dl(i)*vals(ivol)
      end if
    end do

    val = val / dltot

    deallocate(dl)

  end function usg_mesh_data_interpolate_xyz

  !>
  !> interpolate value using inverse distance method
  !>
  function usg_mesh_data_interpolate_center(icell,vals) result(val)

    implicit none

    integer, intent(in) :: icell
    real*8, allocatable, intent(in) :: vals(:)
    real*8 :: val

    !c local variables
    integer :: i, ivol

    val = 0.0d0
    do i = 1, num_nodes_per_cell
      ivol = cells(i,icell)
      val = val + vals(ivol)*CellNodeInversDist(i,icell)
    end do

  end function usg_mesh_data_interpolate_center  

  !>
  !> interpolate value using inverse distance method using zone
  !>
  function usg_mesh_data_interpolate_center2(icell,mprop,vals) result(val)

    implicit none

    integer, intent(in) :: icell
    integer, allocatable, intent(in) :: mprop(:)
    real*8, allocatable, intent(in) :: vals(:)
    real*8 :: val

    !c local variables
    integer :: i, ivol, izn

    val = 0.0d0
    do i = 1, num_nodes_per_cell
      ivol = cells(i,icell)
      izn = mprop(ivol)
      val = val + vals(izn)*CellNodeInversDist(i,icell)
    end do

  end function usg_mesh_data_interpolate_center2  

  !>
  !> interpolate value using inverse distance method
  !>
  function usg_mesh_data_interpolate_center3(ic,icell,vals) result(val)

    implicit none

    integer, intent(in) :: ic,icell
    real*8, allocatable, intent(in) :: vals(:,:)
    real*8 :: val

    !c local variables
    integer :: i, ivol

    val = 0.0d0
    do i = 1, num_nodes_per_cell
      ivol = cells(i,icell)
      val = val + vals(ic,ivol)*CellNodeInversDist(i,icell)
    end do

  end function usg_mesh_data_interpolate_center3

  !>
  !> calculate the intersection with boundary edge and return the interpolation
  !>
  subroutine usg_mesh_data_interpolate_bd(x,y,z,vals,val)

#ifdef CGAL
    use cgal_search_with_point_iface, only :    &
             cgal_search_point_closest_points
#endif
    use gen, only : ilog, rank
    implicit none
    real*8, intent(in) :: x, y
    real*8, allocatable, intent(in) :: vals(:)
    real*8, intent(inout) :: z
    real*8 :: val

    !c local variable
    integer :: i, n, itype, cindex, eindex, eindexprev, ivol, jvol
    integer, allocatable :: indices(:)
    integer*8 :: idedge
    real*8 :: ratio
    real*8, parameter :: rverysmall = 1.0d-100

    if(cell_projection == projection_xyz .or.                          &
       cell_projection == projection_xy) then
      write(*,*) "error: 3D boundary interpolation is not supported at present"
      write(ilog,*) "error: 3D boundary interpolation is not supported at present"
      stop
    end if

    val = 1.0d300

    itype = 1
    n = 10

#ifdef CGAL
    call cgal_search_point_closest_points(itype,n,x,y,z,indices)
#else
    if (rank == 0) then
      write(*,*) "Error: CGAL is needed to use 'usg_mesh_data_interpolate_bd'"
      write(ilog,*) "Error: CGAL is needed to use 'usg_mesh_data_interpolate_bd'"
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
#endif

    do i = 1, n
      ivol = indices(i)
      idedge = node2halfid(ivol)
      cindex = cal_cellface_index(idedge)
      eindex = cal_faceedge_index(idedge)
      !ceindexprev = mod(eindex+num_nodes_per_cell-2,num_nodes_per_cell)+1
      jvol = cells(eindex,cindex)
      !c check if it is vertical line
      if(abs(nodes(ivol)%x-nodes(jvol)%x) < rverysmall .and.           &
         abs(nodes(ivol)%y-nodes(jvol)%y) < rverysmall .and.           &
         abs(nodes(ivol)%x-x) < rverysmall .and.                       &
         abs(nodes(ivol)%y-y) < rverysmall) then
        if(nodes(ivol)%z > nodes(jvol)%z) then
          z = nodes(ivol)%z
          val = vals(ivol)
        else
          z = nodes(jvol)%z
          val = vals(jvol)
        end if
        exit
      else
        if(cell_projection == projection_xz) then
          if((x-nodes(ivol)%x)*(x-nodes(jvol)%x) <= 0) then
            ratio = (x-nodes(jvol)%x)/(nodes(ivol)%x-nodes(jvol)%x)
            z = nodes(jvol)%z + ratio*(nodes(ivol)%z-nodes(jvol)%z)
            val = vals(jvol) + ratio*(vals(ivol)-vals(jvol))
            exit
          end if
        else if(cell_projection == projection_yz) then
          if((y-nodes(ivol)%y)*(y-nodes(jvol)%y) <= 0) then
            ratio = (y-nodes(jvol)%y)/(nodes(ivol)%y-nodes(jvol)%y)
            z = nodes(jvol)%z + ratio*(nodes(ivol)%z-nodes(jvol)%z)
            val = vals(jvol) + ratio*(vals(ivol)-vals(jvol))
            exit
          end if
        end if
      end if
    end do

    if(val >= 1.0d300) then
      write(*,*) "error: 3D boundary interpolation is not found"
      write(ilog,*) "error: 3D boundary interpolation is not found"
      stop
    end if

  end subroutine usg_mesh_data_interpolate_bd

  !>
  !> get adjacent nodes, can be replace with recrusive subroutine
  !> variable description:
  !>   nreq : required number of nodes that needed
  !>
  subroutine usg_mesh_data_get_adj_nodes(nreq)

    use gen, only : ilog, idbg, mem_cur, mem_max, memory_monitor

    implicit none

    integer, intent(in) :: nreq

    !c local variables
    integer :: i, i2, icell, icell2, ivol, ivol2, j, k, ja, nja, nja2, &
               njatotal, nlevel, info_debug, istart, iend, ierr
    integer :: njalevel(10)
    integer, allocatable :: iwork(:)

    external :: checkerr

    !c allocate big enough array at first
    allocate(cell_adj_nodes_ia(num_cells+1), stat = ierr)
    call checkerr(ierr,'cell_adj_nodes_ia',ilog)
    cell_adj_nodes_ia = 0
    call memory_monitor(sizeof(cell_adj_nodes_ia),'cell_adj_nodes_ia',.false.)


    njatotal = nreq*5*num_cells
    allocate(cell_adj_nodes_ja(njatotal), stat = ierr)
    call checkerr(ierr,'cell_adj_nodes_ja',ilog)
    cell_adj_nodes_ja = 0
    call memory_monitor(sizeof(cell_adj_nodes_ja),'cell_adj_nodes_ja',.false.)

    cell_adj_nodes_ia(1) = 1
    ja = 0
    do icell = 1, num_cells
      !c add the directly linked nodes
      nlevel = 1
      nja = 0
      do i = 1, num_nodes_per_cell
        nja = nja + 1
        ja = ja + 1
        if (ja > njatotal) then
          write(*,*) "Error: array size of cell_adj_nodes_ja is less than required"
          write(ilog,*) "Error: array size of cell_adj_nodes_ja is less than required"
          stop
        end if
        cell_adj_nodes_ja(ja) = cells(i,icell)
      end do

      cell_adj_nodes_ia(icell+1) = cell_adj_nodes_ia(icell)+nja

      if (nja >= nreq) then
        cycle
      else
        njalevel(nlevel) = nja
      end if

      !c add the i-level linded cell-nodes
      do while(nja < nreq .and. nlevel < 10)
        nlevel = nlevel + 1
        nja2 = 0
        do i = 1, njalevel(nlevel-1)
          istart = cell_adj_nodes_ia(icell+1)-njalevel(nlevel-1)
          ivol = cell_adj_nodes_ja(istart+i-1)
          do j = 1, node_num_cells(ivol)
            icell2 = node_cells(j,ivol)
            if (icell2 == icell) then
              cycle
            end if
            do i2 = 1, num_nodes_per_cell
              ivol2 = cells(i2,icell2)
              if (all(cell_adj_nodes_ja(istart:ja) /= ivol2)) then
                nja2 = nja2 + 1
                ja = ja + 1
                if (ja > njatotal) then
                  write(*,*) "Error: array size of cell_adj_nodes_ja is less than required"
                  write(ilog,*) "Error: array size of cell_adj_nodes_ja is less than required"
                  stop
                end if
                cell_adj_nodes_ja(ja) = ivol2
              end if
            end do
          end do
        end do

        nja = nja + nja2
        cell_adj_nodes_ia(icell+1) = cell_adj_nodes_ia(icell)+nja

        if (nja >= nreq) then
          exit
        else
          njalevel(nlevel) = nja2
        end if

      end do

      if (nja < nreq) then
        write(*,*) "Warning: number of adjacent nodes is less than required",nreq
      end if

    end do

    !c reallocate memory
    allocate(iwork(ja), stat = ierr)
    call checkerr(ierr,'usg_mesh-data-iwork',ilog)
    call memory_monitor(sizeof(iwork),'iwork',.false.)

    iwork(1:ja) = cell_adj_nodes_ja(1:ja)
    call memory_monitor(-sizeof(cell_adj_nodes_ja),'cell_adj_nodes_ja',.false.)
    deallocate(cell_adj_nodes_ja)


    allocate(cell_adj_nodes_ja(ja), stat = ierr)
    call checkerr(ierr,'cell_adj_nodes_ja',ilog)
    call memory_monitor(sizeof(cell_adj_nodes_ja),'cell_adj_nodes_ja',.false.)

    cell_adj_nodes_ja(1:ja) = iwork(1:ja)
    call memory_monitor(-sizeof(iwork),'iwork',.false.)
    deallocate(iwork)

    cell_ajd_max_nodes = cell_adj_nodes_ia(2) - cell_adj_nodes_ia(1)
    do icell = 2, num_cells
      nja2 = cell_adj_nodes_ia(icell+1) - cell_adj_nodes_ia(icell)
      if (nja2 > cell_ajd_max_nodes) then
        cell_ajd_max_nodes = nja2
      end if
    end do

#ifdef DEBUG
    info_debug = 0
    if (info_debug > 0) then
      write(idbg,*) "--> usg_mesh_data check adjacent nodes"
      write(idbg,*) "--> usg_mesh_data average adjacent nodes", ja*1.0d0/num_cells
      do icell = 1, num_cells
        istart = cell_adj_nodes_ia(icell)
        iend = cell_adj_nodes_ia(icell+1)-1
        write(idbg,'(2(a,1x,i6,1x))') "--->cell",icell,                &
              "number of adjacent nodes",iend-istart+1
        write(idbg,'(a,100(1x,i6))') "--->node",cell_adj_nodes_ja(istart:iend)
      end do
    end if
#endif

  end subroutine usg_mesh_data_get_adj_nodes

  !>
  !> calculate pseudo inverse matrix that will be used in
  !> least-square gradient reconstruction
  !>
  subroutine usg_mesh_data_pseudo_inverse

    use solver_linear, only : solver_linear_ginv
    use gen, only : ilog, idbg

    implicit none

    integer :: icell, iedge, idvol, nc, nr, ic, ir, info_debug, ierr
    real*8, allocatable :: utemp(:,:)
    real*8, allocatable :: aflag(:), atemp(:)

    external :: checkerr

    !call solver_linear_ginv_test
    info_debug = 0

    nc = grad_hls_min_nodes
    allocate(utemp(nc,nc), stat = ierr)
    call checkerr(ierr,'utemp',ilog)

    allocate(aflag(nc), stat = ierr)
    call checkerr(ierr,'aflag',ilog)

    allocate(atemp(nc), stat = ierr)
    call checkerr(ierr,'atemp',ilog)

    do icell = 1, num_cells
      nr = cell_adj_nodes_ia(icell+1)-cell_adj_nodes_ia(icell)
      do iedge = 1, num_edges_per_cell
        do idvol = 1, num_edge_dvols

#ifdef DEBUG
          if (info_debug > 0) then
            write(idbg,'(3(a,1x,i6,1x))')                              &
                  "-->usg_mesh_data check pseudo inverse for cell",    &
                  icell,"edge",iedge,"idvol",idvol
            write(idbg,'(a)') "matrix to be pseudo inversed"
            do ir = 1, nr
              write(idbg,'(4x,19(1pe15.6e3,1x))')                      &
                    grad_hls_matrices(idvol,iedge,icell)%coef(ir,1:nc)
            end do
          end if
#endif

          call solver_linear_ginv(nr,nc,                               &
                 grad_hls_matrices(idvol,iedge,icell)%coef(1:nr,1:nc), &
                 aflag(1:nc),atemp(1:nc),utemp(1:nc,1:nc))

#ifdef DEBUG
              if (info_debug > 0) then
                write(idbg,'(a)') "matrix after pseudo inversed"
                do ic = 1, nc
                  write(idbg,'(4x,40(1pe15.6e3,1x))')                  &
                        grad_hls_matrices(idvol,iedge,icell)%coef(1:nr,ic)
                end do
              end if
#endif

        end do
      end do
    end do

    deallocate(utemp)
    deallocate(aflag)
    deallocate(atemp)

  end subroutine usg_mesh_data_pseudo_inverse

  !>
  !> calculate node to cell center inverse distance for cell-based velocity output
  !>
  subroutine cal_cell_node_inverse_dist

    use gen, only : ilog, rank, b_enable_output, memory_monitor

    implicit none

    integer :: i, icell, ivol, ierr
    real*8 :: dltot, dxij, dyij, dzij, mat_a11, mat_a22, mat_a33,      &
              mat_a12, mat_a13, mat_a23, wij2
    real*8, allocatable :: dl(:)
    logical :: b_flag
    real*8, parameter :: rverysmall = 1.0d-100, r0 = 0.0d0, r1 = 1.0d0
    external :: checkerr


    !c calculate cell node inverse distance coefficient
    allocate(CellNodeInversDist(num_nodes_per_cell,num_cells), stat = ierr)
    CellNodeInversDist = 0.0d0
    call checkerr(ierr,'CellNodeInversDist',ilog)
    call memory_monitor(sizeof(CellNodeInversDist),'CellNodeInversDist',.true.)

    allocate(dl(num_nodes_per_cell))

    do icell = 1, num_cells
      dltot = r0
      b_flag = .true.
      do i = 1, num_nodes_per_cell
        ivol = cells(i,icell)
        dl(i) = geometry_veclength(CellCenter(icell)-nodes(ivol))
        if(dl(i) <= rverysmall) then
          CellNodeInversDist(:,icell) = r0
          CellNodeInversDist(i,icell) = r1
          b_flag = .false.
          cycle
        else
          dl(i) = 1.0d0/dl(i)**grad_spatial_factor
          dltot = dltot + dl(i)
        end if
      end do
      if (b_flag) then
        do i = 1, num_nodes_per_cell
          CellNodeInversDist(i,icell) = dl(i)/dltot
        end do
      end if
    end do

    deallocate(dl)

    !c calculate cell node least squares matrix
    allocate(CellNodeInversDistMatrix(num_cells), stat = ierr)
    call memory_monitor(sizeof(CellNodeInversDistMatrix),'CellNodeInversDistMatrix',.true.)

    do icell = 1, num_cells

      mat_a11 = 0.0d0
      mat_a22 = 0.0d0
      mat_a33 = 0.0d0
      mat_a12 = 0.0d0
      mat_a13 = 0.0d0
      mat_a23 = 0.0d0

      do i = 1, num_nodes_per_cell
        ivol = cells(i,icell)

        dxij = nodes(ivol)%x - CellCenter(icell)%x
        dyij = nodes(ivol)%y - CellCenter(icell)%y
        dzij = nodes(ivol)%z - CellCenter(icell)%z

        if(grad_spatial_weighting) then
          wij2 = 1.0d0/geometry_veclength(CellCenter(icell)-nodes(ivol))
          wij2 = wij2**grad_spatial_factor
        else
          wij2 = 1.0d0
        end if

        mat_a11 = mat_a11 + wij2*dxij**2
        mat_a22 = mat_a22 + wij2*dyij**2
        mat_a33 = mat_a33 + wij2*dzij**2
        mat_a12 = mat_a12 + wij2*dxij*dyij
        mat_a13 = mat_a13 + wij2*dxij*dzij
        mat_a23 = mat_a23 + wij2*dyij*dzij
      end do

      if (cell_projection == projection_xy) then
        CellNodeInversDistMatrix(icell)%det = mat_a11*mat_a22 - mat_a12**2
      else if (cell_projection == projection_yz) then
        CellNodeInversDistMatrix(icell)%det = mat_a22*mat_a33 - mat_a23**2
      else if (cell_projection == projection_xz) then
        CellNodeInversDistMatrix(icell)%det = mat_a11*mat_a33 - mat_a13**2
      else if (cell_projection == projection_xyz) then
        CellNodeInversDistMatrix(icell)%det =                                &
             2.0d0*mat_a12*mat_a13*mat_a23 + mat_a11*mat_a22*mat_a33 -       &
             (mat_a11*mat_a23**2 + mat_a22*mat_a13**2 + mat_a33*mat_a12**2)
      end if

      if (abs(CellNodeInversDistMatrix(icell)%det) < rverysmall) then
        if(rank == 0 .and. b_enable_output) then
          write(ilog,'(2a)') "Warning: least square gradient reconstruction",&
                " matrix is ill-conditioned or singular"
          write(ilog,'(a,1x,i6,1x,a,1x,1pe15.6e3)') "cell",icell,            &
                "determinant",CellNodeInversDistMatrix(icell)%det
        end if
      end if

      if (cell_projection == projection_xy) then
        CellNodeInversDistMatrix(icell)%bcoef11 = mat_a22/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef22 = mat_a11/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef33 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef12 = -mat_a12/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef13 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef23 = 0.0d0
      else if (cell_projection == projection_yz) then
        CellNodeInversDistMatrix(icell)%bcoef11 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef22 = mat_a33/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef33 = mat_a22/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef12 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef13 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef23 = -mat_a23/CellNodeInversDistMatrix(icell)%det
      else if (cell_projection == projection_xz) then
        CellNodeInversDistMatrix(icell)%bcoef11 = mat_a33/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef22 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef33 = mat_a11/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef12 = 0.0d0
        CellNodeInversDistMatrix(icell)%bcoef13 = -mat_a13/CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef23 = 0.0d0
      else if (cell_projection == projection_xyz) then
        CellNodeInversDistMatrix(icell)%bcoef11 = (mat_a22*mat_a33 - mat_a23**2)/      &
                                                   CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef22 = (mat_a11*mat_a33 - mat_a13**2)/      &
                                                   CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef33 = (mat_a11*mat_a22 - mat_a12**2)/      &
                                                   CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef12 = (mat_a13*mat_a23 - mat_a12*mat_a33)/ &
                                                   CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef13 = (mat_a12*mat_a23 - mat_a13*mat_a22)/ &
                                                   CellNodeInversDistMatrix(icell)%det
        CellNodeInversDistMatrix(icell)%bcoef23 = (mat_a12*mat_a13 - mat_a11*mat_a23)/ &
                                                   CellNodeInversDistMatrix(icell)%det
      end if

    end do

  end subroutine cal_cell_node_inverse_dist


!c********************Section of Data Output********************

  !>
  !> write mesh data to VTK ascii file
  !>
  subroutine write_mesh_data_vtk_ascii_z(ifile,strtitle)

    use gen, only : ascii_fmt

    implicit none

    integer, intent(in) :: ifile
    character(len=*), intent(in) :: strtitle

    integer :: i, j

    !c write version information
    write(ifile,'(a)') "# vtk DataFile Version 2.0"

    !c write title
    write(ifile,'(a)') trim(adjustl(strtitle))

    !c indicate ascii or binary data
    write(ifile,'(a)') "ASCII"

    !c write dataset head
    write(ifile,'(a)') "DATASET UNSTRUCTURED_GRID"

    !c write nodes
    write(ifile,'(a,1x,i12,1x,a)') "POINTS",num_nodes,"double"
    if (b_mesh_output_scale) then
      do i = 1, num_nodes
        write(ifile,ascii_fmt) nodes(i)%x*mesh_output_scale%x,         &
                               nodes(i)%y*mesh_output_scale%y,         &
                               nodes(i)%z*mesh_output_scale%z
      end do
    else
      do i = 1, num_nodes
        write(ifile,ascii_fmt) nodes(i)%x,nodes(i)%y,nodes(i)%z
      end do
    end if

    !c write cells
    write(ifile,'(a,2(1x,i12))') "CELLS",num_cells,                    &
                                 num_cells*(num_nodes_per_cell+1)
    do i = 1, num_cells
      write(ifile,'(i3)',advance='no') num_nodes_per_cell
      do j = 1, num_nodes_per_cell
        write(ifile,'(3(1x,i12))',advance='no') cells(j,i)-1
      end do
      write(ifile,'(/,a)') ' '
      backspace(ifile)
    end do

    !c write cell types
    write(ifile,'(a,1x,i12)') "CELL_TYPES",num_cells
    do i = 1, num_cells
      write(ifile,'(i2)') cell_type
    end do

  end subroutine write_mesh_data_vtk_ascii_z

  !>
  !> write mesh data to VTK ascii file with node reordering
  !>
  subroutine write_mesh_data_vtk_ascii_z_order(ifile,strtitle,lorder,invorder)

    use gen, only : ascii_fmt

    implicit none

    integer, intent(in) :: ifile
    character(len=*), intent(in) :: strtitle
    integer, allocatable :: lorder(:), invorder(:)

    integer :: i, j

    !c write version information
    write(ifile,'(a)') "# vtk DataFile Version 2.0"

    !c write title
    write(ifile,'(a)') trim(adjustl(strtitle))

    !c indicate ascii or binary data
    write(ifile,'(a)') "ASCII"

    !c write dataset head
    write(ifile,'(a)') "DATASET UNSTRUCTURED_GRID"

    !c write nodes
    write(ifile,'(a,1x,i12,1x,a)') "POINTS",num_nodes,"double"
    if (b_mesh_output_scale) then
      do i = 1, num_nodes
        write(ifile,ascii_fmt)                                         &
              nodes(lorder(i))%x*mesh_output_scale%x,                  &
              nodes(lorder(i))%y*mesh_output_scale%y,                  &
              nodes(lorder(i))%z*mesh_output_scale%z
      end do
    else
      do i = 1, num_nodes
        write(ifile,ascii_fmt)  nodes(lorder(i))%x,                    &
                                nodes(lorder(i))%y,                    &
                                nodes(lorder(i))%z
      end do
    end if

    !c write cells
    write(ifile,'(a,2(1x,i12))') "CELLS",num_cells,                    &
                                 num_cells*(num_nodes_per_cell+1)

    do i = 1, num_cells
      write(ifile,'(i3)',advance='no') num_nodes_per_cell
      do j = 1, num_nodes_per_cell
        write(ifile,'(3(1x,i12))',advance='no') invorder(cells(j,i))-1
      end do
      write(ifile,'(/,a)') ' '
      backspace(ifile)
    end do

    !c write cell types
    write(ifile,'(a,1x,i12)') "CELL_TYPES",num_cells
    do i = 1, num_cells
      write(ifile,'(i2)') cell_type
    end do

  end subroutine write_mesh_data_vtk_ascii_z_order

  !>
  !> write mesh data to VTK ascii file
  !>
  subroutine write_mesh_data_vtk_ascii_zout(ifile,strtitle,zout)

    use gen, only : ascii_fmt

    implicit none

    integer, intent(in) :: ifile
    character(len=*), intent(in) :: strtitle
    real*8, allocatable :: zout(:)

    integer :: i, j

    !c write version information
    write(ifile,'(a)') "# vtk DataFile Version 2.0"

    !c write title
    write(ifile,'(a)') trim(adjustl(strtitle))

    !c indicate ascii or binary data
    write(ifile,'(a)') "ASCII"

    !c write dataset head
    write(ifile,'(a)') "DATASET UNSTRUCTURED_GRID"

    !c write nodes
    write(ifile,'(a,1x,i12,1x,a)') "POINTS",num_nodes,"double"
    if (b_mesh_output_scale) then
      do i = 1, num_nodes
        write(ifile,ascii_fmt) nodes(i)%x*mesh_output_scale%x,         &
                                nodes(i)%y*mesh_output_scale%y,        &
                                zout(i)*mesh_output_scale%z
      end do
    else
      do i = 1, num_nodes
        write(ifile,ascii_fmt) nodes(i)%x,nodes(i)%y,zout(i)
      end do
    end if

    !c write cells
    write(ifile,'(a,2(1x,i12))') "CELLS",num_cells,                    &
                                 num_cells*(num_nodes_per_cell+1)
    do i = 1, num_cells
      write(ifile,'(i3)',advance='no') num_nodes_per_cell
      do j = 1, num_nodes_per_cell
        write(ifile,'(3(1x,i12))',advance='no') cells(j,i)-1
      end do
      write(ifile,'(/,a)') ' '
      backspace(ifile)
    end do

    !c write cell types
    write(ifile,'(a,1x,i12)') "CELL_TYPES",num_cells
    do i = 1, num_cells
      write(ifile,'(i2)') cell_type
    end do

  end subroutine write_mesh_data_vtk_ascii_zout

  !>
  !> write mesh material id to VTK ascii file
  !>
  subroutine write_mesh_data_vtk_ascii_matids(ifile)

    implicit none

    integer, intent(in) :: ifile

    integer :: i

    !c write node material id
    if (b_use_node_matids) then
      write(ifile,'(a,1x,i0)') "POINT_DATA",num_nodes
      write(ifile,'(a)') "SCALARS node_matids int 1"
      write(ifile,'(a)') "LOOKUP_TABLE default"
      do i = 1, num_nodes
        write(ifile,'(i0)') node_matids(i)
      end do
    end if

    !c write cell material id
    if (b_use_cell_matids) then
      write(ifile,'(a,1x,i0)') "CELL_DATA",num_cells
      write(ifile,'(a)') "SCALARS cell_matids int 1"
      write(ifile,'(a)') "LOOKUP_TABLE default"
      do i = 1, num_cells
        write(ifile,'(i0)') cell_matids(i)
      end do
    end if


  end subroutine write_mesh_data_vtk_ascii_matids


end module usg_mesh_data

#endif
