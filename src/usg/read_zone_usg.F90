!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/read_zone_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c module of zone input for unstructured grid
!c ----------------------
!c
!c
!c written by:      Danyang Su - Apr. 21, 2017
!c
!c definition of variables:
!c
!c
!c
!c common:   -
!c
!c local:    -
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
module read_zone_usg

  use geometry
  use usg_mesh_data, only :                                            &
#ifdef PETSC
                            num_nodes_gbl, num_cells_gbl,              &
#endif
                            cell_projection, is_boundary_node, cells,  &
                            cell_type, num_nodes, nodes, num_cells,    &
                            num_nodes_per_cell, num_nodes_per_layer,   &
                            num_cells_per_layer, node_to_layer_node,   &
                            layer_nodes_top, layer_nodes_bottom,       &
                            b_use_node_matids, node_matids,            &
                            b_use_cell_matids, cell_matids,            &
                            is_boundary_cell

#ifdef PETSC
  use petsc_mpi_common, only : petsc_mpi_finalize
#endif

  implicit none

  !>
  !> condition of zone extention type in bit position
  !> bit pos               meaning of 1
  !>  = 0,        selection for cells, if 0, selection for nodes using general method, extent of zone
  !>  = 1,        boundary nodes/cells in the zone
  !>  = 2,        internal nodes/cells in the zone
  !>  = 3,        all nodes/cells in the zone
  !>  = 4,        boundary nodes/cells by id
  !>  = 5,        internal nodes/cells by id
  !>  = 6,        all nodes/cells by id
  !>  = 7,        boundary nodes/cells by material id
  !>  = 8,        internal nodes/cells by material id
  !>  = 9,        all nodes/cells by material id
  !>
  integer :: type_extent_zone


  !>
  !> condition of zone extention type in bit position, for general method
  !> bit pos               meaning of 1
  !>  = 0,        selection for cells, if 0, selection for nodes using general method, extent of zone
  !>  = 1,        boundary nodes/cells in the zone
  !>  = 2,        internal nodes/cells in the zone
  !>  = 3,        all nodes/cells in the zone
  !>  = 4,        boundary nodes/cells by id
  !>  = 5,        internal nodes/cells by id
  !>  = 6,        all nodes/cells by id
  integer :: type_extent_zone_box

  !>
  !> flow direction in 3D space
  !> only used to calculate the angle for flux vector and boundary interface
  !>  = 0, perpendicular to the boundary interface
  !>  = 1, projection to the boundary interface
  !>  = 2, flux throughout (valid flux) to the boundary interface
  !>
  integer :: type_flux_direction


  !>
  !> flux direction in 3D space
  !>
  type(point) :: flux_direction


  !>
  !> zone data file path if read from external file
  !> note: temporatory file path for the selected zone
  !>
  character*256 :: str_zone_data_file

  !>
  !> number of points in the zone
  !>
  integer :: num_zone_points

  !>
  !> temporatory zone points for polygon
  !>
  type(point), allocatable :: extent_zone_points(:)

  contains

  !>
  !> read zone information from input file
  !>
  subroutine read_zone_usg_input(iunit)

    use gen, only : ilog, rank, iavs, javs, node_iflags, cell_iflags,  &
                    discretization_type, b_use_layered_mesh,           &
                    node_idx_lg2g, cell_idx_lg2g

    implicit none

    integer :: iunit

    !c local variables
    character*72 subsection
    logical :: found_subsection, flag_layerid, flag_ext1, flag_ext2
    integer :: inode, icell, istart, iend, id_min, id_max, id_lg2g,    &
               jtemp, jnode, i, n
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax, dzmin, dzmax,        &
              x, y, z, x1, y1, z1, x2, y2, z2, dist_min, dist_max,     &
              dist2, dist2_min, dist2_max, dist_xy, dist_z, depth,     &
              a, b, c, d
    type(point) :: pt_center

    real*8, parameter :: rsmall = 1.0d-8

    !c external subroutines/functions
    external :: findstrg

    if (cell_projection < projection_xyz) then
      if (type_extent_zone < 0) then
        subsection = 'extent of zone: boundary nodes in polygon'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**1
        end if
      end if


      if (type_extent_zone < 0) then
        subsection = 'extent of zone: internal nodes in polygon'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**2
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: all nodes in polygon'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**3
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: boundary cells in polygon'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**1 + 1
        end if
      end if


      if (type_extent_zone < 0) then
        subsection = 'extent of zone: internal cells in polygon'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**2 + 1
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: all cells in polygon'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**3 + 1
        end if
      end if

    else
      if (type_extent_zone < 0) then
        subsection = 'extent of zone: boundary nodes in polyhedron'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**1
        end if
      end if


      if (type_extent_zone < 0) then
        subsection = 'extent of zone: internal nodes in polyhedron'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**2
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: all nodes in polyhedron'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**3
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: boundary cells in polyhedron'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**1 + 1
        end if
      end if


      if (type_extent_zone < 0) then
        subsection = 'extent of zone: internal cells in polyhedron'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**2 + 1
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: all cells in polyhedron'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**3 + 1
        end if
      end if
    end if

    !c select nodes/cells by id
    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary nodes by id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**4
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal nodes by id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**5
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all nodes by id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**6
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary cells by id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**4 + 1
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal cells by id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**5 + 1
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all cells by id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**6 + 1
      end if
    end if

    !c select nodes/cells by material id
    if (b_use_node_matids) then
      if (type_extent_zone < 0) then
        subsection = 'extent of zone: boundary nodes by material id'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**7
        end if
      end if


      if (type_extent_zone < 0) then
        subsection = 'extent of zone: internal nodes by material id'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**8
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: all nodes by material id'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**9
        end if
      end if
    end if

    if (b_use_cell_matids) then
      if (type_extent_zone < 0) then
        subsection = 'extent of zone: boundary cells by material id'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**7 + 1
        end if
      end if


      if (type_extent_zone < 0) then
        subsection = 'extent of zone: internal cells by material id'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**8 + 1
        end if
      end if

      if (type_extent_zone < 0) then
        subsection = 'extent of zone: all cells by material id'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          type_extent_zone = 2**9 + 1
        end if
      end if
    end if

    !c select nodes/cells layer id, for layered mesh only,
    !c either from top to bottom or from bottom to top.
    !c If nodes/cells are stored from top to bottom, then the top layer id is one and
    !c the bottom layer id is number of node/cell layers. 
    !c If nodes/cells are stored from bottom to top, then the bottom layer id is one and
    !c the top layer id is the number of node/cell layers.
    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary nodes by layer id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**10
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal nodes by layer id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**11
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all nodes by layer id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**12
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary cells by layer id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**10 + 1
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal cells by layer id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2*11 + 1
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all cells by layer id'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**12 + 1
      end if
    end if    

    !c select nodes/cells by specified zone box
    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary nodes in box'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**13
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal nodes in box'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**14
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all nodes in box'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**15
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary cells in box'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**13 + 1
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal cells in box'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**14 + 1
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all cells in box'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**15 + 1
      end if
    end if

    !c select by distance to point
     if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary nodes within distance to point'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**16
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal nodes within distance to point'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**17
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all nodes within distance to point'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**18
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary cells within distance to point'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**16 + 1
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal cells within distance to point'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**17 + 1
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all cells within distance to point'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**18 + 1
      end if
    end if

    !c select by distance to line segment
    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary nodes within distance to line'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**19
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal nodes within distance to line'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**20
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all nodes within distance to line'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**21
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: boundary cells within distance to line'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**19 + 1
      end if
    end if


    if (type_extent_zone < 0) then
      subsection = 'extent of zone: internal cells within distance to line'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**20 + 1
      end if
    end if

    if (type_extent_zone < 0) then
      subsection = 'extent of zone: all cells within distance to line'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone = 2**21 + 1
      end if
    end if

    !c add zone selection for 3D problem

    !c read zone data
    if (type_extent_zone >= 2**1 .and. type_extent_zone <= 2**3+1) then

      if (cell_projection < projection_xyz) then
        subsection = 'read data'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          call usg_mesh_data_read_polygon(iunit)
        else
          subsection = 'read data from file'
          call findstrg(subsection,iunit,found_subsection)
          if (found_subsection) then
            read(iunit,*,err=999,end=999) str_zone_data_file
            call usg_mesh_data_read_polygon(0)
          else
            if (rank == 0) then
              write(*,*) 'Error in reading polygon data'
              write(ilog,*) 'Error in reading polygon data'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
        end if

        if (ibits(type_extent_zone,0,1) == 0) then
          call usg_mesh_data_nodes_in_polygon(type_extent_zone)
        else
          if (discretization_type > 0) then
            call usg_mesh_data_cells_in_polygon(type_extent_zone)
          end if
        end if

      else
        subsection = 'read data from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          call usg_mesh_data_read_polyhedra
        else
          if (rank == 0) then
            write(*,*) 'Error in reading polyhedra data'
            write(ilog,*) 'Error in reading polyhedra data'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
        if (ibits(type_extent_zone,0,1) == 0) then
          call usg_mesh_data_nodes_in_polyhedron(type_extent_zone)
        else
          if (discretization_type > 0) then
            call usg_mesh_data_cells_in_polyhedron(type_extent_zone)
          end if
        end if
      end if
    !c select node/cell by id
    else if (type_extent_zone >= 2**4 .and. type_extent_zone <= 2**6+1) then

        flag_layerid = .false.

        subsection = 'read data'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(iunit,type_extent_zone,.false.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(iunit,type_extent_zone,.false.,flag_layerid)
          end if
          goto 700
        end if

        subsection = 'read data range'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(iunit,type_extent_zone,.true.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(iunit,type_extent_zone,.true.,flag_layerid)
          end if
          goto 700
        end if

        subsection = 'read data from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(0,type_extent_zone,.false.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(0,type_extent_zone,.false.,flag_layerid)
          end if
          goto 700
        end if

        subsection = 'read data range from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(0,type_extent_zone,.true.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(0,type_extent_zone,.true.,flag_layerid)
          end if
          goto 700
        end if

        if (rank == 0) then
          write(*,*) 'Error in reading node/cell id data'
          write(ilog,*) 'Error in reading node/cell id data'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

700     continue
        
    !c select node/cell by material id
    else if (type_extent_zone >= 2**7 .and. type_extent_zone <= 2**9+1) then
        subsection = 'read data'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_node_matid(iunit,type_extent_zone,.false.)
          else
            call usg_mesh_data_read_cell_matid(iunit,type_extent_zone,.false.)
          end if
          goto 800
        end if

        subsection = 'read data range'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_node_matid(iunit,type_extent_zone,.true.)
          else
            call usg_mesh_data_read_cell_matid(iunit,type_extent_zone,.true.)
          end if
          goto 800
        end if

        subsection = 'read data from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_node_matid(0,type_extent_zone,.false.)
          else
            call usg_mesh_data_read_cell_matid(0,type_extent_zone,.false.)
          end if
          goto 800
        end if

        subsection = 'read data range from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_node_matid(0,type_extent_zone,.true.)
          else
            call usg_mesh_data_read_cell_matid(0,type_extent_zone,.true.)
          end if
          goto 800
        end if

        if (rank == 0) then
          write(*,*) 'Error in reading node/cell material id data'
          write(ilog,*) 'Error in reading node/cell material id data'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
    
800     continue

    !c select node/cell layer id
    else if (type_extent_zone >= 2**10 .and. type_extent_zone <= 2**12+1) then

        flag_layerid = .true.

        subsection = 'read data'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(iunit,type_extent_zone,.false.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(iunit,type_extent_zone,.false.,flag_layerid)
          end if
          goto 900
        end if

        subsection = 'read data range'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(iunit,type_extent_zone,.true.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(iunit,type_extent_zone,.true.,flag_layerid)
          end if
          goto 900
        end if

        subsection = 'read data from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(0,type_extent_zone,.false.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(0,type_extent_zone,.false.,flag_layerid)
          end if
          goto 900
        end if

        subsection = 'read data range from file'
        call findstrg(subsection,iunit,found_subsection)
        if (found_subsection) then
          read(iunit,*,err=999,end=999) str_zone_data_file
          if (ibits(type_extent_zone,0,1) == 0) then
            call usg_mesh_data_read_nodeid(0,type_extent_zone,.true.,flag_layerid)
          else
            call usg_mesh_data_read_cellid(0,type_extent_zone,.true.,flag_layerid)
          end if
          goto 900
        end if

        if (rank == 0) then
          write(*,*) 'Error in reading node/cell id data'
          write(ilog,*) 'Error in reading node/cell id data'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

900     continue

    !c select node/cell by specified box range
    else if (type_extent_zone >= 2**13 .and. type_extent_zone <= 2**15+1) then
        read(iunit,*,err=999,end=999) xmin, xmax, ymin, ymax, zmin, zmax

        if (ibits(type_extent_zone,0,1) == 0) then
          call usg_mesh_data_nodes_in_box(type_extent_zone,            &
                    xmin, xmax, ymin, ymax, zmin, zmax)
        else
          if (discretization_type > 0) then
            call usg_mesh_data_cells_in_box(type_extent_zone,          &
                      xmin, xmax, ymin, ymax, zmin, zmax)
          end if
        end if
    
    !c select node/cell by distance range to point
    else if (type_extent_zone >= 2**16 .and. type_extent_zone <= 2**18+1) then
      read(iunit,*,err=999,end=999) x, y, z
      read(iunit,*,err=999,end=999) dist_min, dist_max

      if (ibits(type_extent_zone,0,1) == 0) then
        call usg_mesh_data_nodes_pt_dist(type_extent_zone,             &
                x, y, z, dist_min, dist_max)
      else
        if (discretization_type > 0) then
          call usg_mesh_data_cells_pt_dist(type_extent_zone,           &
                  x, y, z, dist_min, dist_max)
        end if
      end if
    !c select node/cell by distance range to line segment
    else if (type_extent_zone >= 2**19 .and. type_extent_zone <= 2**21+1) then
      read(iunit,*,err=999,end=999) x1, y1, z1, x2, y2, z2
      read(iunit,*,err=999,end=999) dist_min, dist_max, flag_ext1, flag_ext2

      if (ibits(type_extent_zone,0,1) == 0) then
        call usg_mesh_data_nodes_line_dist(type_extent_zone,           &
                x1, y1, z1, x2, y2, z2, dist_min, dist_max,            &
                flag_ext1, flag_ext2)
      else
        if (discretization_type > 0) then
          call usg_mesh_data_cells_line_dist(type_extent_zone,         &
                  x1, y1, z1, x2, y2, z2, dist_min, dist_max,          &
                  flag_ext1, flag_ext2)
        end if
      end if
    end if

    !c further domain constraint for nodes/cells natural id range
    subsection = 'extent of zone: id range constraint'
    call findstrg(subsection,iunit,found_subsection)
    if (found_subsection) then
      read(iunit,*,err=999,end=999) id_min, id_max
      if (ibits(type_extent_zone,0,1) == 0) then
        do inode = 1, num_nodes
          if (node_iflags(inode) > 0) then
#ifdef PETSC
            id_lg2g = node_idx_lg2g(inode)
#else
            id_lg2g = inode
#endif
            if (id_lg2g < id_min .or. id_lg2g > id_max) then
              node_iflags(inode) = -1
            end if
          end if
        end do
      else
        do icell = 1, num_cells
          if (cell_iflags(icell) >= 0) then
#ifdef PETSC
            id_lg2g = cell_idx_lg2g(icell)
#else
            id_lg2g = icell
#endif
            if (id_lg2g < id_min .or. id_lg2g > id_max) then
              cell_iflags(icell) = -1
            end if
          end if
        end do
      end if
    end if

    !c further domain constraint for nodes/cells selection by coordinates
    subsection = 'extent of zone: coordinates constraint'
    call findstrg(subsection,iunit,found_subsection)
    if (found_subsection) then
      read(iunit,*,err=999,end=999) xmin, xmax, ymin, ymax, zmin, zmax
      if (ibits(type_extent_zone,0,1) == 0) then
        do inode = 1, num_nodes
          if (node_iflags(inode) > 0) then
            if (nodes(inode)%x < xmin .or. nodes(inode)%x > xmax .or.  &
                nodes(inode)%y < ymin .or. nodes(inode)%y > ymax .or.  &
                nodes(inode)%z < zmin .or. nodes(inode)%z > zmax) then
              node_iflags(inode) = -1
            end if
          end if
        end do
      else
        do icell = 1, num_cells
          if (cell_iflags(icell) >= 0) then

            pt_center%x = 0.0d0
            pt_center%y = 0.0d0
            pt_center%z = 0.0d0
            do inode = 1, num_nodes_per_cell
              pt_center%x = pt_center%x + nodes(cells(inode,icell))%x
              pt_center%y = pt_center%y + nodes(cells(inode,icell))%y
              pt_center%z = pt_center%z + nodes(cells(inode,icell))%z
            end do

            pt_center%x = pt_center%x/num_nodes_per_cell
            pt_center%y = pt_center%y/num_nodes_per_cell
            pt_center%z = pt_center%z/num_nodes_per_cell

            if (pt_center%x < xmin .or. pt_center%x > xmax .or.  &
                pt_center%y < ymin .or. pt_center%y > ymax .or.  &
                pt_center%z < zmin .or. pt_center%z > zmax) then
              cell_iflags(icell) = -1
            end if
          end if
        end do
      end if
    end if

    !c further domain constraint for nodes/cells selection by distance
    subsection = 'extent of zone: distance constraint'
    call findstrg(subsection,iunit,found_subsection)
    if (found_subsection) then
      read(iunit,*,err=999,end=999) x, y, z, dist2_min, dist2_max
      dist2_min = dist2_min**2
      dist2_max = dist2_max**2

      if (ibits(type_extent_zone,0,1) == 0) then
        do inode = 1, num_nodes
          if (node_iflags(inode) > 0) then
            dist2 = (nodes(inode)%x-x)**2 + (nodes(inode)%y-y)**2 +    &
                    (nodes(inode)%z-z)**2
            if (dist2 < dist2_min .or. dist2 > dist2_max) then
              node_iflags(inode) = -1
            end if
          end if
        end do
      else
        do icell = 1, num_cells
          if (cell_iflags(icell) >= 0) then

            pt_center%x = 0.0d0
            pt_center%y = 0.0d0
            pt_center%z = 0.0d0
            do inode = 1, num_nodes_per_cell
              pt_center%x = pt_center%x + nodes(cells(inode,icell))%x
              pt_center%y = pt_center%y + nodes(cells(inode,icell))%y
              pt_center%z = pt_center%z + nodes(cells(inode,icell))%z
            end do

            pt_center%x = pt_center%x/num_nodes_per_cell
            pt_center%y = pt_center%y/num_nodes_per_cell
            pt_center%z = pt_center%z/num_nodes_per_cell

            dist2 = (pt_center%x-x)**2 + (pt_center%y-y)**2 +          &
                    (pt_center%z-z)**2

            if (dist2 < dist2_min .or. dist2 > dist2_max) then
              cell_iflags(icell) = -1
            end if
          end if
        end do
      end if
    end if

    !c Further domain constraint for nodes/cells selection by distance to plane.
    !c The plane is described as ax+by+cz+d = 0. The distance from (x0,y0,z0) to
    !c the plane is |ax0+by0+cz0+d|/sqrt(a^2+b^2+c^2)
    subsection = 'extent of zone: distance to plane constraint'
    call findstrg(subsection,iunit,found_subsection)
    if (found_subsection) then
      read(iunit,*,err=999,end=999) a, b, c, d, dist2_min, dist2_max
      dist2_min = dist2_min*sqrt(a*a+b*b+c*c)
      dist2_max = dist2_max*sqrt(a*a+b*b+c*c)

      if (ibits(type_extent_zone,0,1) == 0) then
        do inode = 1, num_nodes
          if (node_iflags(inode) > 0) then
            dist2 = abs(nodes(inode)%x*a + nodes(inode)%y*b + nodes(inode)%z*c+ d)
            if (dist2 < dist2_min .or. dist2 > dist2_max) then
              node_iflags(inode) = -1
            end if
          end if
        end do
      else
        do icell = 1, num_cells
          if (cell_iflags(icell) >= 0) then

            pt_center%x = 0.0d0
            pt_center%y = 0.0d0
            pt_center%z = 0.0d0
            do inode = 1, num_nodes_per_cell
              pt_center%x = pt_center%x + nodes(cells(inode,icell))%x
              pt_center%y = pt_center%y + nodes(cells(inode,icell))%y
              pt_center%z = pt_center%z + nodes(cells(inode,icell))%z
            end do

            pt_center%x = pt_center%x/num_nodes_per_cell
            pt_center%y = pt_center%y/num_nodes_per_cell
            pt_center%z = pt_center%z/num_nodes_per_cell

            dist2 = abs(pt_center%x*a + pt_center%y*b + pt_center%z*c + d)

            if (dist2 < dist2_min .or. dist2 > dist2_max) then
              cell_iflags(icell) = -1
            end if
          end if
        end do
      end if
    end if

    !c Further domain constraint for nodes/cells selection by distance to multiple planes.
    !c The plane is described as ax+by+cz+d = 0. The distance from (x0,y0,z0) to
    !c the plane is |ax0+by0+cz0+d|/sqrt(a^2+b^2+c^2)
    subsection = 'extent of zone: distance to planes constraint'
    call findstrg(subsection,iunit,found_subsection)
    if (found_subsection) then      
      read(iunit,*,err=999,end=999) n
      do i = 1, n
        read(iunit,*,err=999,end=999) a, b, c, d, dist2_min, dist2_max
        dist2_min = dist2_min*sqrt(a*a+b*b+c*c)
        dist2_max = dist2_max*sqrt(a*a+b*b+c*c)

        if (ibits(type_extent_zone,0,1) == 0) then
          do inode = 1, num_nodes
            if (node_iflags(inode) > 0) then
              dist2 = abs(nodes(inode)%x*a + nodes(inode)%y*b + nodes(inode)%z*c+ d)
              if (dist2 < dist2_min .or. dist2 > dist2_max) then
                node_iflags(inode) = -1
              end if
            end if
          end do
        else
          do icell = 1, num_cells
            if (cell_iflags(icell) >= 0) then

              pt_center%x = 0.0d0
              pt_center%y = 0.0d0
              pt_center%z = 0.0d0
              do inode = 1, num_nodes_per_cell
                pt_center%x = pt_center%x + nodes(cells(inode,icell))%x
                pt_center%y = pt_center%y + nodes(cells(inode,icell))%y
                pt_center%z = pt_center%z + nodes(cells(inode,icell))%z
              end do

              pt_center%x = pt_center%x/num_nodes_per_cell
              pt_center%y = pt_center%y/num_nodes_per_cell
              pt_center%z = pt_center%z/num_nodes_per_cell

              dist2 = abs(pt_center%x*a + pt_center%y*b + pt_center%z*c + d)

              if (dist2 < dist2_min .or. dist2 > dist2_max) then
                cell_iflags(icell) = -1
              end if
            end if
          end do
        end if
      end do
    end if

    !c further domain constraint for cells using layer thickness
    if (b_use_layered_mesh .and. (cell_type == cell_type_quad .or.     &
        cell_type == cell_type_prism .or. cell_type == cell_type_hexa)) then
      subsection = 'extent of zone: layer thickness constraint'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        read(iunit,*,err=999,end=999) dzmin, dzmax
        if (ibits(type_extent_zone,0,1) == 0) then
          do inode = 1, num_nodes
            if (node_iflags(inode) > 0) then
              istart = iavs(inode)+1       !pointer - start of row
              iend = iavs(inode+1)-1       !pointer - end of row
              do jtemp=istart,iend         !loop over connections     
                jnode = javs(jtemp)        !column pointer
                if (node_matids(inode) == node_matids(jnode)) then
                  !c check if the x and y coordinates are the same for layered mesh
                  dist_xy = sqrt((nodes(inode)%x-nodes(jnode)%x)**2 +  &
                                 (nodes(inode)%y-nodes(jnode)%y)**2)
                  
                  if (dist_xy < rsmall) then
                    dist_z = abs(nodes(inode)%z-nodes(jnode)%z)
                    if (dist_z < dzmin .or. dist_z > dzmax) then
                      node_iflags(inode) = -1
                    end if
                  end if
                end if
              end do
  
            end if
          end do
        else        
          do icell = 1, num_cells
            if (cell_iflags(icell) >= 0) then
              n = num_nodes_per_cell/2
              dist_z = 1.0d100
              do inode = 1, n
                dist_z = min(dist_z, abs(nodes(cells(inode,icell))%z - &
                             nodes(cells(inode+n,icell))%z))
              end do
              
              if (dist_z < dzmin .or. dist_z > dzmax) then
                cell_iflags(icell) = -1
              end if
            end if
          end do
        end if
      end if
    end if

    !c further domain constraint for nodes/cells using depth constraint
    if (b_use_layered_mesh .and. (cell_type == cell_type_quad .or.     &
        cell_type == cell_type_prism .or. cell_type == cell_type_hexa)) then
      subsection = 'extent of zone: layer depth constraint'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        read(iunit,*,err=999,end=999) zmin, zmax
        if (ibits(type_extent_zone,0,1) == 0) then
          do inode = 1, num_nodes
            if (node_iflags(inode) > 0) then
              depth = layer_nodes_top(node_to_layer_node(inode))%z-nodes(inode)%z
              if (depth < zmin .or. depth > zmax) then
                node_iflags(inode) = -1
              end if  
            end if
          end do
        else        
          do icell = 1, num_cells
            if (cell_iflags(icell) >= 0) then
              depth = 0.0d0
              do inode = 1, num_nodes_per_cell
                depth = layer_nodes_top(node_to_layer_node(cells(inode,icell)))%z- &
                        nodes(cells(inode,icell))%z + depth
              end do
              depth = depth / num_nodes_per_cell
              
              if (depth < zmin .or. depth > zmax) then
                cell_iflags(icell) = -1
              end if
            end if
          end do
        end if
      end if 
    end if

    !c further domain constraint for nodes/cells using top layer elevation constraint
    if (b_use_layered_mesh .and. (cell_type == cell_type_quad .or.     &
        cell_type == cell_type_prism .or. cell_type == cell_type_hexa)) then
      subsection = 'extent of zone: top layer coordinates constraint'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        read(iunit,*,err=999,end=999) zmin, zmax
        if (ibits(type_extent_zone,0,1) == 0) then
          do inode = 1, num_nodes
            if (node_iflags(inode) > 0) then
              z = layer_nodes_top(node_to_layer_node(inode))%z
              if (z < zmin .or. z > zmax) then
                node_iflags(inode) = -1
              end if  
            end if
          end do
        else        
          do icell = 1, num_cells
            if (cell_iflags(icell) >= 0) then
              z = 0.0d0
              do inode = 1, num_nodes_per_cell
                z = layer_nodes_top(node_to_layer_node(cells(inode,icell)))%z + z
              end do
              z = z / num_nodes_per_cell
              
              if (z < zmin .or. z > zmax) then
                cell_iflags(icell) = -1
              end if
            end if
          end do
        end if
      end if 
    end if

    !c further domain constraint for nodes/cells using bottom layer elevation constraint
    if (b_use_layered_mesh .and. (cell_type == cell_type_quad .or.     &
        cell_type == cell_type_prism .or. cell_type == cell_type_hexa)) then
      subsection = 'extent of zone: bottom layer coordinates constraint'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        read(iunit,*,err=999,end=999) zmin, zmax
        if (ibits(type_extent_zone,0,1) == 0) then
          do inode = 1, num_nodes
            if (node_iflags(inode) > 0) then
              z = layer_nodes_bottom(node_to_layer_node(inode))%z
              if (z < zmin .or. z > zmax) then
                node_iflags(inode) = -1
              end if  
            end if
          end do
        else        
          do icell = 1, num_cells
            if (cell_iflags(icell) >= 0) then
              z = 0.0d0
              do inode = 1, num_nodes_per_cell
                z = layer_nodes_bottom(node_to_layer_node(cells(inode,icell)))%z + z
              end do
              z = z / num_nodes_per_cell
              
              if (z < zmin .or. z > zmax) then
                cell_iflags(icell) = -1
              end if
            end if
          end do
        end if
      end if 
    end if    

    !c process the second type boundary condition when flux is not normal to boundary face
    type_flux_direction = 0
    flux_direction = vector_zero
    subsection = 'boundary flow direction'
    call findstrg(subsection,iunit,found_subsection)
    if (found_subsection) then
      type_flux_direction = 2
      read(iunit,*,err=999,end=999) flux_direction%x, flux_direction%y, &
                                    flux_direction%z
    else
      subsection = 'boundary flux direction'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_flux_direction = 2
        read(iunit,*,err=999,end=999) flux_direction%x, flux_direction%y, &
                                      flux_direction%z
      end if
    end if

    !c add nodes selection control for general method, select of zone
    !c this part should be put last, as further data read (xbmin, xbmax, ...)
    !c may be required.
    if (type_extent_zone < 0 .and. type_extent_zone_box < 0) then
      subsection = 'extent of zone: boundary nodes only'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone_box = 2
        type_extent_zone = 0
      end if
    end if

    if (type_extent_zone < 0 .and. type_extent_zone_box < 0) then
      subsection = 'extent of zone: internal nodes only'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone_box = 4
        type_extent_zone = 0
      end if
    end if

    if (type_extent_zone < 0 .and. type_extent_zone_box < 0) then
      subsection = 'extent of zone: all nodes'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone_box = 8
        type_extent_zone = 0
      end if
    end if

    if (type_extent_zone < 0 .and. type_extent_zone_box < 0) then
      subsection = 'extent of zone: boundary cells only'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone_box = 2 + 1
        type_extent_zone = 0
      end if
    end if

    if (type_extent_zone < 0 .and. type_extent_zone_box < 0) then
      subsection = 'extent of zone: internal cells only'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone_box = 4 + 1
        type_extent_zone = 0
      end if
    end if

    if (type_extent_zone < 0 .and. type_extent_zone_box < 0) then
      subsection = 'extent of zone: all cells'
      call findstrg(subsection,iunit,found_subsection)
      if (found_subsection) then
        type_extent_zone_box = 8 + 1
        type_extent_zone = 0
      end if
    end if

    return

!c  write error information if 'extent of zone' is missing
999 continue
    if (rank == 0) then
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error reading zone data from input file'
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error reading zone data from input file'
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine read_zone_usg_input

  !>
  !> read polygon zone data from the input file or external data file
  !>
  subroutine usg_mesh_data_read_polygon(iunit)

    use gen, only : ilog, rank, mem_cur, mem_max, memory_monitor
    use file_unit, only : lun_get, lun_free
    use file_utility, only : readnextline

    implicit none

    integer, intent(in) :: iunit

    !c local variables
    integer :: i, iunit_zone, ierr
    logical :: bexist
    character(2048) :: strbuffer

    external :: checkerr

    !c read polygon data from input file (converted)
    if (iunit > 0) then
      read(iunit,*) num_zone_points
      if (allocated(extent_zone_points)) then
        call memory_monitor(-sizeof(extent_zone_points),'extent_zone_points',.true.)
        deallocate(extent_zone_points)
      end if
      allocate(extent_zone_points(num_zone_points), stat = ierr)
      call checkerr(ierr,'extent_zone_points',ilog)
      call memory_monitor(sizeof(extent_zone_points),'extent_zone_points',.true.)

      do i = 1, num_zone_points
        read(iunit,*,err=990) extent_zone_points(i)%x,                 &
                              extent_zone_points(i)%y,                 &
                              extent_zone_points(i)%z
      end do

    !c read polygon data from external file (not converted)
    else
      inquire(file = trim(str_zone_data_file), exist = bexist)
      if(bexist) then
        iunit_zone = lun_get()
        open(iunit_zone,file=trim(str_zone_data_file),status='old',    &
             form='formatted',access='sequential',err=990)

        if(readnextline(iunit_zone, strbuffer))then
          read(strbuffer,*) num_zone_points
          if (allocated(extent_zone_points)) then
            call memory_monitor(-sizeof(extent_zone_points),'extent_zone_points',.true.)
            deallocate(extent_zone_points)
          end if

          allocate(extent_zone_points(num_zone_points), stat = ierr)
          call checkerr(ierr,'extent_zone_points',ilog)
          call memory_monitor(sizeof(extent_zone_points),'extent_zone_points',.true.)

          do i = 1, num_zone_points
            if(readnextline(iunit_zone, strbuffer)) then
              read(strbuffer,*,err=990) extent_zone_points(i)%x,       &
                                        extent_zone_points(i)%y,       &
                                        extent_zone_points(i)%z
            end if
          end do
        end if
        close(iunit_zone)
        call lun_free(iunit_zone)
      else
        goto 990
      end if

    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening/reading zone data file'
      write(ilog,*) 'check file ',trim(str_zone_data_file)
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening/reading zone data file'
      write(*,*) 'check file ',trim(str_zone_data_file)
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_read_polygon

  !>
  !> find node data within polygon using the selected zone points
  !> passing parameters
  !>  itype  = 1, boundary nodes only
  !>         = 2, internal nodes only
  !>         = 3 or other number, all nodes
  !>
#ifdef CGAL
  !> use the kernel from CGAL library
  subroutine usg_mesh_data_nodes_in_polygon(itype)

    use cgal_polygon_iface, only :              &
             allocate_storage_point3d,          &
             deallocate_storage,                &
             check_inside

    use gen, only : ilog, rank, node_iflags

    implicit none

    !c passing parameters
    integer :: itype

    !c local variable
    integer :: i, n, ierr
    type(point), allocatable :: pts(:)
    type(c_ptr) :: ptr
    type(point3d_c), dimension(:), pointer :: pts_p
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax

    external :: checkerr

    n = num_zone_points
    allocate(pts(n), stat = ierr)
    call checkerr(ierr,'pts',ilog)
    pts(1:n) = extent_zone_points(1:n)

    node_iflags = -1

    !c check if the polygon is simple
    if(.not.geometry_is_polygon_simple(cell_projection,n,pts)) then
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      write(*,*) "Error: specified polygon is not simple polygon"
      write(ilog,*) "Error: specified polygon is not simple polygon"
      stop
    end if

    !c allocate memory
    ptr = allocate_storage_point3d(n+1)
    call c_f_pointer(ptr,pts_p,[n+1])

    xmin = pts(1)%x
    xmax = pts(1)%x
    ymin = pts(1)%y
    ymax = pts(1)%y
    zmin = pts(1)%z
    zmax = pts(1)%z

    !c set polygon vertices
    do i = 1, n
      pts_p(i+1)%x = pts(i)%x
      pts_p(i+1)%y = pts(i)%y
      pts_p(i+1)%z = pts(i)%z

      if (pts(i)%x < xmin) then
        xmin = pts(i)%x
      else if (pts(i)%x > xmax) then
        xmax = pts(i)%x
      end if

      if (pts(i)%y < ymin) then
        ymin = pts(i)%y
      else if (pts(i)%y > ymax) then
        ymax = pts(i)%y
      end if

      if (pts(i)%z < zmin) then
        zmin = pts(i)%z
      else if (pts(i)%z > zmax) then
        zmax = pts(i)%z
      end if
    end do

    !c loop over all the nodes to check if the node is inside the polygon
    do i = 1, num_nodes
      if(btest(itype,1)) then
        if(.not.(is_boundary_node(i))) then
          cycle
        end if
      else if(btest(itype,2)) then
        if(is_boundary_node(i)) then
          cycle
        end if
      end if

      pts_p(1)%x = nodes(i)%x
      pts_p(1)%y = nodes(i)%y
      pts_p(1)%z = nodes(i)%z

      !c check if the node is outside box
      if (nodes(i)%x < xmin .or. nodes(i)%x > xmax .or.                &
          nodes(i)%y < ymin .or. nodes(i)%y > ymax .or.                &
          nodes(i)%z < zmin .or. nodes(i)%z > zmax) then
        node_iflags(i) = -1
      else
        node_iflags(i) = check_inside(cell_projection,n+1,ptr)
      end if
    end do

    !c release memory
    call deallocate_storage(ptr)

  end subroutine usg_mesh_data_nodes_in_polygon
#else
  !> use the self-developed algorithm
  subroutine usg_mesh_data_nodes_in_polygon(itype)

    use gen, only : ilog, rank, node_iflags, zone_buffer

    implicit none

    !c passing parameters
    integer :: itype

    !c local variable
    integer :: i, n, ierr
    type(point), allocatable :: pts(:)
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax

    external :: checkerr


    n = num_zone_points
    allocate(pts(n), stat = ierr)
    call checkerr(ierr,'pts',ilog)

    pts(1:n) = extent_zone_points(1:n)

    xmin = pts(1)%x
    xmax = pts(1)%x
    ymin = pts(1)%y
    ymax = pts(1)%y
    zmin = pts(1)%z
    zmax = pts(1)%z

    do i = 2, n
      if (pts(i)%x < xmin) then
        xmin = pts(i)%x
      else if (pts(i)%x > xmax) then
        xmax = pts(i)%x
      end if

      if (pts(i)%y < ymin) then
        ymin = pts(i)%y
      else if (pts(i)%y > ymax) then
        ymax = pts(i)%y
      end if

      if (pts(i)%z < zmin) then
        zmin = pts(i)%z
      else if (pts(i)%z > zmax) then
        zmax = pts(i)%z
      end if
    end do

    xmin = xmin - zone_buffer
    xmax = xmax + zone_buffer
    ymin = ymin - zone_buffer
    ymax = ymax + zone_buffer
    zmin = zmin - zone_buffer
    zmax = zmax + zone_buffer

    node_iflags = -1

    !c loop over all the nodes to check if the node is inside the polygon
    do i = 1, num_nodes
      if(btest(itype,1)) then
        if(.not.is_boundary_node(i)) then
          cycle
        end if
      else if(btest(itype,2)) then
        if(is_boundary_node(i)) then
          cycle
        end if
      end if

      !c check if the node is outside box
      if (nodes(i)%x < xmin .or. nodes(i)%x > xmax .or.                &
          nodes(i)%y < ymin .or. nodes(i)%y > ymax .or.                &
          nodes(i)%z < zmin .or. nodes(i)%z > zmax) then
        node_iflags(i) = -1
      else
        node_iflags(i) = geometry_is_point_inside_2d(cell_projection,  &
                                  nodes(i),n,pts,zone_buffer)
      end if
    end do

    deallocate(pts)

  end subroutine usg_mesh_data_nodes_in_polygon
#endif

  !>
  !> find node data within polygon using the selected zone points
  !> passing parameters
  !>  itype  = 1, boundary cells only
  !>         = 2, internal cells only
  !>         = 3 or other number, all cells
  !>
#ifdef CGAL
  !> use the kernel from CGAL library
  subroutine usg_mesh_data_cells_in_polygon(itype)

    use cgal_polygon_iface, only :              &
             allocate_storage_point3d,          &
             deallocate_storage,                &
             check_inside

    use gen, only : ilog, rank, cell_iflags

    implicit none

    !c passing parameters
    integer :: itype

    !c local variable
    integer :: i, j, n, ierr
    type(point), allocatable :: pts(:)
    type(c_ptr) :: ptr
    type(point3d_c), dimension(:), pointer :: pts_p
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax

    external :: checkerr

    n = num_zone_points
    allocate(pts(n), stat = ierr)
    call checkerr(ierr,'pts',ilog)

    pts(1:n) = extent_zone_points(1:n)

    cell_iflags = -1

    !c check if the polygon is simple
    if(.not.geometry_is_polygon_simple(cell_projection,n,pts)) then
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      write(*,*) "Error: specified polygon is not simple polygon"
      write(ilog,*) "Error: specified polygon is not simple polygon"
      stop
    end if

    !c allocate memory
    ptr = allocate_storage_point3d(n+1)
    call c_f_pointer(ptr,pts_p,[n+1])

    xmin = pts(1)%x
    xmax = pts(1)%x
    ymin = pts(1)%y
    ymax = pts(1)%y
    zmin = pts(1)%z
    zmax = pts(1)%z

    !c set polygon vertices
    do i = 1, n
      pts_p(i+1)%x = pts(i)%x
      pts_p(i+1)%y = pts(i)%y
      pts_p(i+1)%z = pts(i)%z

      if (pts(i)%x < xmin) then
        xmin = pts(i)%x
      else if (pts(i)%x > xmax) then
        xmax = pts(i)%x
      end if

      if (pts(i)%y < ymin) then
        ymin = pts(i)%y
      else if (pts(i)%y > ymax) then
        ymax = pts(i)%y
      end if

      if (pts(i)%z < zmin) then
        zmin = pts(i)%z
      else if (pts(i)%z > zmax) then
        zmax = pts(i)%z
      end if
    end do

    !c loop over all the nodes to check if the node is inside the polygon
    do i = 1, num_cells
      if(btest(itype,1)) then
        if(.not.is_boundary_cell(i)) then
          cycle
        end if
      else if(btest(itype,2)) then
        if(is_boundary_cell(i)) then
          cycle
        end if
      end if

      pts_p(1)%x = 0.0d0
      pts_p(1)%y = 0.0d0
      pts_p(1)%z = 0.0d0
      do j = 1, num_nodes_per_cell
        pts_p(1)%x = pts_p(1)%x + nodes(cells(j,i))%x
        pts_p(1)%y = pts_p(1)%y + nodes(cells(j,i))%y
        pts_p(1)%z = pts_p(1)%z + nodes(cells(j,i))%z
      end do

      pts_p(1)%x = pts_p(1)%x/num_nodes_per_cell
      pts_p(1)%y = pts_p(1)%y/num_nodes_per_cell
      pts_p(1)%z = pts_p(1)%z/num_nodes_per_cell

      !c check if the node is outside box
      if (pts_p(1)%x < xmin .or. pts_p(1)%x > xmax .or.      &
          pts_p(1)%y < ymin .or. pts_p(1)%y > ymax .or.      &
          pts_p(1)%z < zmin .or. pts_p(1)%z > zmax) then
        cell_iflags(i) = -1
      else
        cell_iflags(i) = check_inside(cell_projection,n+1,ptr)
      end if
    end do

    !c release memory
    call deallocate_storage(ptr)

  end subroutine usg_mesh_data_cells_in_polygon
#else
  !> use the self-developed algorithm
  subroutine usg_mesh_data_cells_in_polygon(itype)

    use gen, only : ilog, rank, cell_iflags, zone_buffer

    implicit none

    !c passing parameters
    integer :: itype

    !c local variable
    integer :: i, j, n, ierr
    type(point), allocatable :: pts(:)
    type(point) :: pt_center
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax

    external :: checkerr

    n = num_zone_points
    allocate(pts(n), stat = ierr)
    call checkerr(ierr,'pts',ilog)

    pts(1:n) = extent_zone_points(1:n)

    xmin = pts(1)%x
    xmax = pts(1)%x
    ymin = pts(1)%y
    ymax = pts(1)%y
    zmin = pts(1)%z
    zmax = pts(1)%z

    do i = 2, n
      if (pts(i)%x < xmin) then
        xmin = pts(i)%x
      else if (pts(i)%x > xmax) then
        xmax = pts(i)%x
      end if

      if (pts(i)%y < ymin) then
        ymin = pts(i)%y
      else if (pts(i)%y > ymax) then
        ymax = pts(i)%y
      end if

      if (pts(i)%z < zmin) then
        zmin = pts(i)%z
      else if (pts(i)%z > zmax) then
        zmax = pts(i)%z
      end if
    end do

    xmin = xmin - zone_buffer
    xmax = xmax + zone_buffer
    ymin = ymin - zone_buffer
    ymax = ymax + zone_buffer
    zmin = zmin - zone_buffer
    zmax = zmax + zone_buffer

    cell_iflags = -1

    !c loop over all the nodes to check if the node is inside the polygon
    do i = 1, num_cells
      if(btest(itype,1)) then
        if(.not.is_boundary_cell(i)) then
          cycle
        end if
      else if(btest(itype,2)) then
        if(is_boundary_cell(i)) then
          cycle
        end if
      end if

      pt_center%x = 0.0d0
      pt_center%y = 0.0d0
      pt_center%z = 0.0d0
      do j = 1, num_nodes_per_cell
        pt_center%x = pt_center%x + nodes(cells(j,i))%x
        pt_center%y = pt_center%y + nodes(cells(j,i))%y
        pt_center%z = pt_center%z + nodes(cells(j,i))%z
      end do

      pt_center%x = pt_center%x/num_nodes_per_cell
      pt_center%y = pt_center%y/num_nodes_per_cell
      pt_center%z = pt_center%z/num_nodes_per_cell

      !c check if the node is outside box
      if (pt_center%x < xmin .or. pt_center%x > xmax .or.      &
          pt_center%y < ymin .or. pt_center%y > ymax .or.      &
          pt_center%z < zmin .or. pt_center%z > zmax) then
        cell_iflags(i) = -1
      else
        cell_iflags(i) = geometry_is_point_inside_2d(cell_projection,  &
                                  pt_center,n,pts,zone_buffer)
      end if
    end do

    deallocate(pts)

  end subroutine usg_mesh_data_cells_in_polygon
#endif

  !> select nodes by specified box
  subroutine usg_mesh_data_nodes_in_box(itype, xmin, xmax, ymin, ymax, zmin, zmax)

    use gen, only : ilog, rank, node_iflags

    implicit none

    !c passing parameters
    integer :: itype
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax

    !c local variable
    integer :: i

    node_iflags = -1

    !c loop over all the nodes to check if the node is inside the box
    do i = 1, num_nodes
      if(btest(itype,13)) then
        if(.not.is_boundary_node(i)) then
          cycle
        end if
      else if(btest(itype,14)) then
        if(is_boundary_node(i)) then
          cycle
        end if
      end if

      !c check if the node is outside box
      if (nodes(i)%x >= xmin .and. nodes(i)%x <= xmax .and.            &
          nodes(i)%y >= ymin .and. nodes(i)%y <= ymax .and.            &
          nodes(i)%z >= zmin .and. nodes(i)%z <= zmax) then
        node_iflags(i) = 1
      end if
    end do


  end subroutine usg_mesh_data_nodes_in_box


  !> select cells by specified box
  subroutine usg_mesh_data_cells_in_box(itype, xmin, xmax, ymin, ymax, zmin, zmax)

    use gen, only : ilog, rank, cell_iflags

    implicit none

    !c passing parameters
    integer :: itype
    real*8 :: xmin, xmax, ymin, ymax, zmin, zmax

    !c local variable
    integer :: i, j
    type(point) :: pt_center
    
    cell_iflags = -1

    !c loop over all the nodes to check if the node is inside the box
    do i = 1, num_cells
      if(btest(itype,13)) then
        if(.not.is_boundary_cell(i)) then
          cycle
        end if
      else if(btest(itype,14)) then
        if(is_boundary_cell(i)) then
          cycle
        end if
      end if

      pt_center%x = 0.0d0
      pt_center%y = 0.0d0
      pt_center%z = 0.0d0
      do j = 1, num_nodes_per_cell
        pt_center%x = pt_center%x + nodes(cells(j,i))%x
        pt_center%y = pt_center%y + nodes(cells(j,i))%y
        pt_center%z = pt_center%z + nodes(cells(j,i))%z
      end do

      pt_center%x = pt_center%x/num_nodes_per_cell
      pt_center%y = pt_center%y/num_nodes_per_cell
      pt_center%z = pt_center%z/num_nodes_per_cell

      !c check if the node is outside box
      if (pt_center%x >= xmin .and. pt_center%x <= xmax .and.          &
          pt_center%y >= ymin .and. pt_center%y <= ymax .and.          &
          pt_center%z >= zmin .and. pt_center%z <= zmax) then
        cell_iflags(i) = 1
      end if
    end do

  end subroutine usg_mesh_data_cells_in_box

  !> select nodes by distance range to specified point
  subroutine usg_mesh_data_nodes_pt_dist(itype, x, y, z, dist_min, dist_max)

    use gen, only : ilog, rank, node_iflags

    implicit none

    !c passing parameters
    integer :: itype
    real*8 :: x, y, z, dist_min, dist_max

    !c local variable
    integer :: i
    real*8 :: dist

    node_iflags = -1

    !c loop over all the nodes to check if the node is inside the box
    do i = 1, num_nodes
      if(btest(itype,16)) then
        if(.not.is_boundary_node(i)) then
          cycle
        end if
      else if(btest(itype,17)) then
        if(is_boundary_node(i)) then
          cycle
        end if
      end if

      dist = sqrt((nodes(i)%x-x)**2+(nodes(i)%y-y)**2+(nodes(i)%z-z)**2)
      if (dist >= dist_min .and. dist <= dist_max) then
        node_iflags(i) = 1
      end if
    end do

  end subroutine usg_mesh_data_nodes_pt_dist


  !> select cells by distance range to specified point
  subroutine usg_mesh_data_cells_pt_dist(itype, x, y, z, dist_min, dist_max)

    use gen, only : ilog, rank, cell_iflags

    implicit none

    !c passing parameters
    integer :: itype
    real*8 :: x, y, z, dist_min, dist_max

    !c local variable
    integer :: i, j
    real*8 :: dist
    type(point) :: pt_center
    
    cell_iflags = -1

    !c loop over all the nodes to check if the node is inside the box
    do i = 1, num_cells
      if(btest(itype,16)) then
        if(.not.is_boundary_cell(i)) then
          cycle
        end if
      else if(btest(itype,17)) then
        if(is_boundary_cell(i)) then
          cycle
        end if
      end if

      pt_center%x = 0.0d0
      pt_center%y = 0.0d0
      pt_center%z = 0.0d0
      do j = 1, num_nodes_per_cell
        pt_center%x = pt_center%x + nodes(cells(j,i))%x
        pt_center%y = pt_center%y + nodes(cells(j,i))%y
        pt_center%z = pt_center%z + nodes(cells(j,i))%z
      end do

      pt_center%x = pt_center%x/num_nodes_per_cell
      pt_center%y = pt_center%y/num_nodes_per_cell
      pt_center%z = pt_center%z/num_nodes_per_cell

      dist = sqrt((pt_center%x-x)**2+(pt_center%y-y)**2+(pt_center%z-z)**2)
      if (dist >= dist_min .and. dist <= dist_max) then
        cell_iflags(i) = 1
      end if
    end do

  end subroutine usg_mesh_data_cells_pt_dist

  !> select nodes by distance range to specified line segment
  subroutine usg_mesh_data_nodes_line_dist(itype, x1, y1, z1, x2, y2, z2,&
                      dist_min, dist_max, flag_ext1, flag_ext2)

    use gen, only : ilog, rank, node_iflags

    implicit none

    !c passing parameters
    integer :: itype
    real*8 :: x1, y1, z1, x2, y2, z2, dist_min, dist_max
    logical :: flag_ext1, flag_ext2

    !c local variable
    integer :: i
    real*8 :: dist
    type(point) :: pt1, pt2

    node_iflags = -1

    pt1%x = x1
    pt1%y = y1
    pt1%z = z1

    pt2%x = x2
    pt2%y = y2
    pt2%z = z2

    !c loop over all the nodes to check if the node is inside the box
    do i = 1, num_nodes
      if(btest(itype,19)) then
        if(.not.is_boundary_node(i)) then
          cycle
        end if
      else if(btest(itype,20)) then
        if(is_boundary_node(i)) then
          cycle
        end if
      end if

      dist = geometry_point_to_line(nodes(i),pt1,pt2,flag_ext1,flag_ext2)
      if (dist >= dist_min .and. dist <= dist_max) then
        node_iflags(i) = 1
      end if
    end do

  end subroutine usg_mesh_data_nodes_line_dist


  !> select cells by distance range to specified line segment
  subroutine usg_mesh_data_cells_line_dist(itype, x1, y1, z1, x2, y2, z2,&
                      dist_min, dist_max, flag_ext1, flag_ext2)

    use gen, only : ilog, rank, cell_iflags

    implicit none

    !c passing parameters
    integer :: itype
    real*8 :: x1, y1, z1, x2, y2, z2, dist_min, dist_max
    logical :: flag_ext1, flag_ext2

    !c local variable
    integer :: i, j
    real*8 :: dist
    type(point) :: pt1, pt2, pt_center
    
    cell_iflags = -1

    pt1%x = x1
    pt1%y = y1
    pt1%z = z1

    pt2%x = x2
    pt2%y = y2
    pt2%z = z2

    !c loop over all the nodes to check if the node is inside the box
    do i = 1, num_cells
      if(btest(itype,19)) then
        if(.not.is_boundary_cell(i)) then
          cycle
        end if
      else if(btest(itype,20)) then
        if(is_boundary_cell(i)) then
          cycle
        end if
      end if

      pt_center%x = 0.0d0
      pt_center%y = 0.0d0
      pt_center%z = 0.0d0
      do j = 1, num_nodes_per_cell
        pt_center%x = pt_center%x + nodes(cells(j,i))%x
        pt_center%y = pt_center%y + nodes(cells(j,i))%y
        pt_center%z = pt_center%z + nodes(cells(j,i))%z
      end do

      pt_center%x = pt_center%x/num_nodes_per_cell
      pt_center%y = pt_center%y/num_nodes_per_cell
      pt_center%z = pt_center%z/num_nodes_per_cell

      dist = geometry_point_to_line(pt_center,pt1,pt2,flag_ext1,flag_ext2)
      if (dist >= dist_min .and. dist <= dist_max) then
        cell_iflags(i) = 1
      end if
    end do

  end subroutine usg_mesh_data_cells_line_dist

  !>
  !> read polyhedra data from external file, in '.off' format
  !>
  subroutine usg_mesh_data_read_polyhedra

    use gen, only : ilog, rank
#ifdef CGAL
    use cgal_polyhedra_iface, only : cgal_initialize_polydomain_3d,    &
                                     cgal_set_polydomain_iofile,       &
                                     cgal_make_polydomain_surface_mesh,&
                                     cgal_make_polydomain_polyhedra
#endif
    implicit none

    !c local variables
    logical :: bexist

#ifdef CGAL
    !c read polygon data from input file (converted)
    inquire(file = trim(str_zone_data_file), exist = bexist)
    if(bexist) then
      call cgal_initialize_polydomain_3d()
      call cgal_set_polydomain_iofile(trim(str_zone_data_file), "")
      call cgal_make_polydomain_surface_mesh()
      call cgal_make_polydomain_polyhedra()
    else
      goto 990
    end if
#else
    if (rank == 0) then
      write(*,*) "Error: CGAL is needed to use 'usg_mesh_data_read_polyhedra'"
      write(ilog,*) "Error: CGAL is needed to use 'usg_mesh_data_read_polyhedra'"
    end if
    goto 999
#endif

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening/reading zone data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening/reading zone data file'
      close(ilog)
    end if

999 continue
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_read_polyhedra


  !>
  !> find node data within polyhedron
  !> passing parameters
  !>  n      = number of points in the given points set
  !>  pts    = points set array
  !>  itype  = 1, boundary nodes only
  !>         = 2, internal nodes only
  !>         = 3 or other number, all nodes
  !>
  subroutine usg_mesh_data_nodes_in_polyhedron(itype)

#ifdef CGAL
    use cgal_polyhedra_iface, only :              &
             cgal_check_inside_polydomain
#endif
    use gen, only : ilog, rank, node_iflags
    implicit none

    !c passing parameters
    integer :: itype

    !c local variable
    integer :: i

    node_iflags = -1

#ifdef CGAL
    !c loop over all the nodes to check if the node is inside the polygon
    do i = 1, num_nodes
      if(btest(itype,1)) then
        if(.not.is_boundary_node(i)) then
          cycle
        end if
      else if(btest(itype,2)) then
        if(is_boundary_node(i)) then
          cycle
        end if
      end if

      node_iflags(i) = cgal_check_inside_polydomain(nodes(i)%x,        &
                            nodes(i)%y,nodes(i)%z)
    end do
#else
    if (rank == 0) then
      write(*,*) "Error: CGAL is needed to use 'usg_mesh_data_nodes_in_polyhedron'"
      write(ilog,*) "Error: CGAL is needed to use 'usg_mesh_data_nodes_in_polyhedron'"
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
#endif

  end subroutine usg_mesh_data_nodes_in_polyhedron

  !>
  !> find cell data within polyhedron
  !> passing parameters
  !>  n      = number of points in the given points set
  !>  pts    = points set array
  !>  itype  = 1, boundary cells only
  !>         = 2, internal cells only
  !>         = 3 or other number, all cells
  !>
  subroutine usg_mesh_data_cells_in_polyhedron(itype)

#ifdef CGAL
    use cgal_polyhedra_iface, only :              &
             cgal_check_inside_polydomain
#endif
    use gen, only : ilog, rank, cell_iflags
    implicit none

    !c passing parameters
    integer :: itype

    !c local variable
    integer :: i, j
    type(point) :: pt_center

    cell_iflags = -1

#ifdef CGAL
    !c loop over all the nodes to check if the node is inside the polygon
    do i = 1, num_cells
      if(btest(itype,1)) then
        if(.not.is_boundary_cell(i)) then
          cycle
        end if
      else if(btest(itype,2)) then
        if(is_boundary_cell(i)) then
          cycle
        end if
      end if

      pt_center%x = 0.0d0
      pt_center%y = 0.0d0
      pt_center%z = 0.0d0
      do j = 1, num_nodes_per_cell
        pt_center%x = pt_center%x + nodes(cells(j,i))%x
        pt_center%y = pt_center%y + nodes(cells(j,i))%y
        pt_center%z = pt_center%z + nodes(cells(j,i))%z
      end do

      pt_center%x = pt_center%x/num_nodes_per_cell
      pt_center%y = pt_center%y/num_nodes_per_cell
      pt_center%z = pt_center%z/num_nodes_per_cell

      cell_iflags(i) = cgal_check_inside_polydomain(pt_center%x,       &
                            pt_center%y,pt_center%z)
    end do
#else
    if (rank == 0) then
      write(*,*) "Error: CGAL is needed to use 'usg_mesh_data_cells_in_polyhedron'"
      write(ilog,*) "Error: CGAL is needed to use 'usg_mesh_data_cells_in_polyhedron'"
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
#endif

  end subroutine usg_mesh_data_cells_in_polyhedron

  !>
  !> read node id list from the input file or external data file
  !>
  subroutine usg_mesh_data_read_nodeid(iunit,itype,is_range,flag_layerid)

    use gen, only : ilog, rank, nprcs, node_iflags, node_idx_g2lg,     &
                    b_use_layered_mesh
    use file_unit, only : lun_get, lun_free
    use file_utility, only : readnextline

    implicit none

    integer, intent(in) :: iunit, itype
    logical, intent(in) :: is_range, flag_layerid

    !c local variables
    integer :: i, id, id1, id2, idgbl, n, iunit_zone
    logical :: bexist
    character(2048) :: strbuffer

    node_iflags = -1

    if (flag_layerid .and. .not.b_use_layered_mesh) then      
      return
    end if

    !c read node id list from input file (converted)
    if (iunit > 0) then
      read(iunit,*) n

      do i = 1, n
        if (is_range) then
          read(iunit,*,err=990) id1, id2
        else
          read(iunit,*,err=990) id1
          id2 = id1
        end if

        !c convert node layer id to global node id
        if (flag_layerid) then
          id1 = (id1-1)*num_nodes_per_layer+1
          id2 = id2*num_nodes_per_layer
        end if

        !c skip invalid id
        do idgbl = id1, id2
#ifdef PETSC
          if (idgbl < 1 .or. idgbl > num_nodes_gbl) then
            cycle
          end if

          id = node_idx_g2lg(idgbl)
          if (id < 1 .or. id > num_nodes) then
            cycle
          end if
#else  
          if (idgbl < 1 .or. idgbl > num_nodes) then
            cycle
          end if
          id = idgbl
#endif
          if (flag_layerid) then
            if ((btest(itype,10) .and. is_boundary_node(id)) .or.      &
                (btest(itype,11) .and. .not.is_boundary_node(id)) .or. &
                 btest(itype,12)) then
              node_iflags(id) = 1
            end if
          else
            if ((btest(itype,4) .and. is_boundary_node(id)) .or.       &
                (btest(itype,5) .and. .not.is_boundary_node(id)) .or.  &
                 btest(itype,6)) then
              node_iflags(id) = 1
            end if
          end if        
        end do
      end do

    !c read node data from external file (not converted)
    else
      inquire(file = trim(str_zone_data_file), exist = bexist)
      if(bexist) then
        iunit_zone = lun_get()
        open(iunit_zone,file=trim(str_zone_data_file),status='old',    &
             form='formatted',access='sequential',err=990)

        if(readnextline(iunit_zone, strbuffer))then
          read(strbuffer,*) n
          do i = 1, n
            if (is_range) then
              read(iunit_zone,*,err=990) id1, id2
            else
              read(iunit_zone,*,err=990) id1
              id2 = id1
            end if

            !c convert node layer id to global node id
            if (flag_layerid) then
              id1 = (id1-1)*num_nodes_per_layer+1
              id2 = id2*num_nodes_per_layer
            end if

            !c skip invalid id
            do idgbl = id1, id2
#ifdef PETSC
              if (idgbl < 1 .or. idgbl > num_nodes_gbl) then
                cycle
              end if
              id = node_idx_g2lg(idgbl)
              if (id < 1 .or. id > num_nodes) then
                cycle
              end if
#else
              if (idgbl < 1 .or. idgbl > num_nodes) then
                cycle
              end if
              id = idgbl
#endif
              if (flag_layerid) then
                if ((btest(itype,10) .and. is_boundary_node(id)) .or.     &
                    (btest(itype,11) .and. .not.is_boundary_node(id)) .or.&
                     btest(itype,12)) then
                  node_iflags(id) = 1
                end if
              else
                if ((btest(itype,4) .and. is_boundary_node(id)) .or.     &
                    (btest(itype,5) .and. .not.is_boundary_node(id)) .or.&
                     btest(itype,6)) then
                  node_iflags(id) = 1
                end if
              end if
            end do
          end do

        end if
        close(iunit_zone)
        call lun_free(iunit_zone)
      else
        goto 990
      end if

    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening/reading zone data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening/reading zone data file'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_read_nodeid

  !>
  !> read cell id list from the input file or external data file
  !>
  subroutine usg_mesh_data_read_cellid(iunit,itype,is_range,flag_layerid)

    use gen, only : ilog, rank, nprcs, cell_iflags, cell_idx_g2lg,     &
                    b_use_layered_mesh
    use file_unit, only : lun_get, lun_free
    use file_utility, only : readnextline

    implicit none

    integer, intent(in) :: iunit, itype
    logical, intent(in) :: is_range, flag_layerid

    !c local variables
    integer :: i, id, id1, id2, idgbl, n, iunit_zone
    logical :: bexist
    character(2048) :: strbuffer

    cell_iflags = -1

    if (flag_layerid .and. .not.b_use_layered_mesh) then
      return
    end if

    !c read cell id list from input file (converted)
    if (iunit > 0) then
      read(iunit,*) n
      do i = 1, n
        if (is_range) then
          read(iunit,*,err=990) id1, id2
        else
          read(iunit,*,err=990) id1
          id2 = id1
        end if

        !c convert cell layer id to global cell id
        if (flag_layerid) then
          id1 = (id1-1)*num_cells_per_layer+1
          id2 = id2*num_cells_per_layer
        end if

        !c skip invalid id
        do idgbl = id1, id2
#ifdef PETSC
          if (idgbl < 1 .or. idgbl > num_cells_gbl) then
            cycle
          end if
          id = cell_idx_g2lg(idgbl)
          if (id < 1 .or. id > num_cells) then
            cycle
          end if
#else
          if (idgbl < 1 .or. idgbl > num_cells) then
            cycle
          end if
          id = idgbl
#endif
          if (flag_layerid) then
            if ((btest(itype,10) .and. is_boundary_cell(id)) .or.     &
                (btest(itype,11) .and. .not.is_boundary_cell(id)) .or.&
                 btest(itype,12)) then
              cell_iflags(id) = 1
            end if            
          else
            if ((btest(itype,4) .and. is_boundary_cell(id)) .or.       &
                (btest(itype,5) .and. .not.is_boundary_cell(id)) .or.  &
                 btest(itype,6)) then
              cell_iflags(id) = 1
            end if
          end if
        end do
      end do

    !c read cell data from external file (not converted)
    else
      inquire(file = trim(str_zone_data_file), exist = bexist)
      if(bexist) then
        iunit_zone = lun_get()
        open(iunit_zone,file=trim(str_zone_data_file),status='old',    &
             form='formatted',access='sequential',err=990)

        if(readnextline(iunit_zone, strbuffer))then
          read(strbuffer,*) n
          do i = 1, n
            if (is_range) then
              read(iunit_zone,*,err=990) id1, id2
            else
              read(iunit_zone,*,err=990) id1
              id2 = id1
            end if

            !c convert cell layer id to global cell id
            if (flag_layerid) then
              id1 = (id1-1)*num_cells_per_layer+1
              id2 = id2*num_cells_per_layer
            end if

            !c skip invalid id
            do idgbl = id1, id2
#ifdef PETSC
              if (idgbl < 1 .or. idgbl > num_cells_gbl) then
                cycle
              end if
              id = cell_idx_g2lg(idgbl)
              if (id < 1 .or. id > num_cells) then
                cycle
              end if
#else
              if (idgbl < 1 .or. idgbl > num_cells) then
                cycle
              end if
              id = idgbl
#endif
              if (flag_layerid) then
                if ((btest(itype,10) .and. is_boundary_cell(id)) .or.     &
                    (btest(itype,11) .and. .not.is_boundary_cell(id)) .or.&
                     btest(itype,12)) then
                  cell_iflags(id) = 1
                end if
              else
                if ((btest(itype,4) .and. is_boundary_cell(id)) .or.     &
                    (btest(itype,5) .and. .not.is_boundary_cell(id)) .or.&
                     btest(itype,6)) then
                  cell_iflags(id) = 1
                end if
              end if
            end do
          end do

        end if
        close(iunit_zone)
        call lun_free(iunit_zone)
      else
        goto 990
      end if

    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening/reading zone data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening/reading zone data file'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_read_cellid

  !>
  !> read node material id list from the input file or external data file
  !>
  subroutine usg_mesh_data_read_node_matid(iunit,itype,is_range)

    use gen, only : ilog, rank, nprcs, node_iflags, node_idx_g2lg
    use file_unit, only : lun_get, lun_free
    use file_utility, only : readnextline

    implicit none

    integer, intent(in) :: iunit, itype
    logical, intent(in) :: is_range

    !c local variables
    integer :: i, inode, id, id2, n, iunit_zone
    logical :: bexist
    character(2048) :: strbuffer

    node_iflags = -1

    !c read node id list from input file (converted)
    if (iunit > 0) then
      read(iunit,*) n
      do i = 1, n
        if (is_range) then
          read(iunit,*,err=990) id, id2
        else
          read(iunit,*,err=990) id
        end if
        do inode = 1, num_nodes
          if ((btest(itype,7) .and. is_boundary_node(inode)) .or.      &
              (btest(itype,8) .and. .not.is_boundary_node(inode)) .or. &
               btest(itype,9)) then
            if (is_range) then
              if (node_matids(inode) >= id .and. node_matids(inode) <= id2) then
                node_iflags(inode) = 1
              end if
            else 
              if (node_matids(inode) == id) then
                node_iflags(inode) = 1
              end if
            end if
          end if
        end do
      end do

    !c read node data from external file (not converted)
    else
      inquire(file = trim(str_zone_data_file), exist = bexist)
      if(bexist) then
        iunit_zone = lun_get()
        open(iunit_zone,file=trim(str_zone_data_file),status='old',    &
             form='formatted',access='sequential',err=990)

        if(readnextline(iunit_zone, strbuffer))then
          read(strbuffer,*) n
          do i = 1, n
            if (is_range) then
              read(iunit_zone,*,err=990) id, id2
            else
              read(iunit_zone,*,err=990) id
            end if
            do inode = 1, num_nodes
              if ((btest(itype,7) .and. is_boundary_node(inode)) .or.     &
                  (btest(itype,8) .and. .not.is_boundary_node(inode)) .or.&
                   btest(itype,9)) then
                if (is_range) then
                  if (node_matids(inode) >= id .and. node_matids(inode) <= id2) then
                    node_iflags(inode) = 1
                  end if
                else    
                  if (node_matids(inode) == id) then
                    node_iflags(inode) = 1
                  end if
                end if
              end if
            end do
          end do

        end if
        close(iunit_zone)
        call lun_free(iunit_zone)
      else
        goto 990
      end if

    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening/reading material id data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening/reading material data file'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_read_node_matid

  !>
  !> read cell material id list from the input file or external data file
  !>
  subroutine usg_mesh_data_read_cell_matid(iunit,itype,is_range)

    use gen, only : ilog, rank, nprcs, cell_iflags, cell_idx_g2lg
    use file_unit, only : lun_get, lun_free
    use file_utility, only : readnextline

    implicit none

    integer, intent(in) :: iunit, itype
    logical, intent(in) :: is_range

    !c local variables
    integer :: i, id, id2, icell, n, iunit_zone
    logical :: bexist
    character(2048) :: strbuffer

    cell_iflags = -1

    !c read cell id list from input file (converted)
    if (iunit > 0) then
      read(iunit,*) n
      do i = 1, n
        if (is_range) then
          read(iunit,*,err=990) id, id2
        else
          read(iunit,*,err=990) id
        end if

        do icell = 1, num_cells
          if ((btest(itype,7) .and. is_boundary_cell(icell)) .or.      &
              (btest(itype,8) .and. .not.is_boundary_cell(icell)) .or. &
               btest(itype,9)) then
            if (is_range) then
              if (cell_matids(icell) >= id .and. cell_matids(icell) <= id2) then
                cell_iflags(icell) = 1
              end if
            else    
              if (cell_matids(icell) == id) then
                cell_iflags(icell) = 1
              end if
            end if
          end if
        end do
      end do

    !c read cell data from external file (not converted)
    else
      inquire(file = trim(str_zone_data_file), exist = bexist)
      if(bexist) then
        iunit_zone = lun_get()
        open(iunit_zone,file=trim(str_zone_data_file),status='old',    &
             form='formatted',access='sequential',err=990)

        if(readnextline(iunit_zone, strbuffer))then
          read(strbuffer,*) n
          do i = 1, n
            if (is_range) then
              read(iunit_zone,*,err=990) id, id2
            else
              read(iunit_zone,*,err=990) id
            end if
            do icell = 1, num_cells
              if ((btest(itype,7) .and. is_boundary_cell(icell)) .or.     &
                  (btest(itype,8) .and. .not.is_boundary_cell(icell)) .or.&
                   btest(itype,9)) then
                if (is_range) then
                  if (cell_matids(icell) >= id .and. cell_matids(icell) <= id2) then
                    cell_iflags(icell) = 1
                  end if
                else
                  if (cell_matids(icell) == id) then
                    cell_iflags(icell) = 1
                  end if
                end if
              end if
            end do
          end do

        end if
        close(iunit_zone)
        call lun_free(iunit_zone)
      else
        goto 990
      end if

    end if

    return

990 continue
    if (rank == 0) then
      write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error when opening/reading material id data file'
      write(*,*) 'SIMULATION TERMINATED'
      write(*,*) 'error when opening/reading material data file'
      close(ilog)
    end if
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop

  end subroutine usg_mesh_data_read_cell_matid

end module read_zone_usg
#endif
