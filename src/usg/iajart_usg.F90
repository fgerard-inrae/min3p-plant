!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 608 $
!> $Author: dsu $
!> $Date: 2018-09-11 11:26:48 -0700 (Tue, 11 Sep 2018) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/iajart_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine iajart
!c -----------------
!c
!c set up ia-ja data-structure for n-d scalar matrix
!c make use of known block structure of jacobian matrix
!c all diagonal blocks have the same structure
!c all off-diagobnal blocks have the same structure
!c      
!c                z
!c                     y
!c                7  
!c                |  5                  local connection list 
!c                | /                   for ja pointer array
!c                |/                    
!c       2--------1----------3  x     
!c               /|
!c              / |
!c             4  |
!c                6
!c
!c nonexistent connections (1D-2D-boundary effects) are skipped:
!c
!c      z
!c            
!c      4                     e.g.
!c      |                     x-z plane - on boundary x=0
!c      |                     
!c      |                     
!c      1----------2  x     
!c      |
!c      |
!c      |
!c      3
!c
!c based on iajart.F90
!c
!c written by:      Danyang Su - Aug 04, 2016
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.inc: mnjart             = max. number of entries in art,jart  + -
!c
!c gen.f:    integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook                + -
!c           n                  = number of primary unknowns          + -
!c           iart(nn*n+1)       = row pointer array for art           * +
!c           jart(njart)        = connectivity list                   * +
!c           lart(njavs+1)      = pointer array                       * +
!c           kart(njart)        = mapping pointer                     * +
!c                                (global block -> nd-scalar)
!c           iadbl(n+1)         = row pointer array (diagonal block   + -
!c                                matrices)
!c           jadbl(n*n)         = column pointer array (diagonal      + -
!c                                block matrices)
!c           iaobl(n+1)         = row pointer array                   + -
!c                                (off-diagonal block matrices)       + -
!c           jaobl(n*n)         = column pointer array                + -
!c                                (diagonal block matrices)
!c           njart              = number of global connections        * +
!c           njadbl             = actual number of entries in         + -
!c                                diagonal block matrices
!c           njaobl             = actual number of entries in         + -
!c                                off-diagonal block matrices
!c
!c local:    integer*4:
!c           ----------
!c           jtemp              = pointer to colum entries
!c           ibl                = row pointer (block matrix)
!c           igl                = row pointer (global matrix)
!c           istart             = pointer (first entry of row)
!c           iend               = pointer (last entry of row)
!c           irow1              = counter (rows)
!c           icol1              = pointer (columns)
!c           istart1            = pointer (first entry of row)
!c           iend1              = pointer (last entry of row)
!c           i1                 = counter (column entries in row)
!c           irow2              = counter (rows)
!c           icol2              = pointer (columns)
!c           istart2            = pointer (first entry of row)
!c           iend2              = pointer (last entry of row)
!c           i2                 = counter (column entries in row)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
      subroutine iajart_usg
 
      use parm
      use gen
      use geometry
      use chem, only : ng
      use usg_mesh_data, only : num_cells, num_nodes,                  &
                                num_nodes_per_cell,                    &
                                num_edge_maxcells, num_edge_dvols,     &
                                grad_hls_min_nodes
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef DEBUG
      use matrix_utility, only : export_mmformat_pattern
#endif

      implicit none
      
      integer :: i0, i1, i2, i3, icol,icol1, icol2, irow, info_debug,  &
                 ibl, igl, istart, iend, istart2, iend2,               &
                 istart3, iend3, ivol, jbl, jgl, jtemp, jvol, jvol1,   &
                 ltemp, lstart, lend, ktemp, icon, icon_start, icon_end

      info_debug = 0

!c  define initial row pointer
   
      iart(1) = 1
      jtemp = 0
      igl = 0
!c  loop over control volumes
      do ivol = 1, nngl

        do ibl = 1,n                       !loop over rows of block matrices

          igl = igl+1                      !global row pointer

!c  assign entries of diagonal block
          istart = iadbl(ibl)              !start of row (block matrix
          iend = iadbl(ibl+1)-1            !end of row (block matrix)
          do jbl = istart,iend             !loop over row entries
            jtemp = jtemp+1                !pointer to next entry
            if (jtemp.gt.mnjart) then      !exit if dimensions violated
               goto 100
            end if
            jgl = (ivol-1)*n+jadbl(jbl)    !global column pointer
            jart(jtemp) = jgl              !assign global column pointer
#ifdef PETSC
            col_idx_l2pg_rt(jtemp) = &
                (node_idx_lg2pg(ivol)-1)*n + jadbl(jbl)
#endif
          end do

!c  assign column pointers for off-diagonal entries
          icon_start = iavs(ivol)+1
          icon_end = iavs(ivol+1)-1
          do icon = icon_start, icon_end   !loop over node connections
            jvol = javs(icon)
            istart = iaobl(ibl)            !start of row (block matrix
            iend = iaobl(ibl+1)-1          !end of row (block matrix)
            do jbl = istart,iend           !loop over row entries
              if (jtemp+1.gt.mnjart) then  !exit if dimensions violated
                goto 100
              end if
              if(sparse_blocks) then
                if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie
                  cycle                                 !components for off-dialog entries
                end if
              end if
              jtemp = jtemp+1             !pointer to next entry
              jgl = (jvol-1)*n+jaobl(jbl)        !global column pointer
              jart(jtemp) = jgl           !assign global column pointer

#ifdef PETSC
              col_idx_l2pg_rt(jtemp) = &
                  (node_idx_lg2pg(jvol)-1)*n + jaobl(jbl)
#endif
            end do
          end do                        !loop over node connections
     
          iart(igl+1) = jtemp+1         !next row pointer
              
#ifdef PETSC
          row_idx_l2pg_rt(igl) = (node_idx_lg2pg(ivol)-1)*n + ibl
          if(node_idx_lg2l(ivol) < 0) then
            row_idx_l2pg_rt(igl) = - row_idx_l2pg_rt(igl)
          end if
#endif
        end do                          !loop over rows of block matrices
      end do                            !loop over control volumes

!c  assign actual number of entries

      njart = jtemp

!c  assign mapping pointer array for assembly

      ltemp = 1
      ktemp = 0
      lart(1) = 1

      do ivol=1,nngl                !loop - control volumes
        istart = iavs(ivol)       
        iend = iavs(ivol+1)-1     
        do i1 = istart,iend         !loop - connections
          jvol1 = javs(i1)

!c  diagonal block 

          if (ivol.eq.jvol1) then
            do ibl=1,n                  !loop - rows of block matrix
              istart2 = iadbl(ibl)
              iend2 = iadbl(ibl+1)-1
              irow = (ivol-1)*n+ibl       !row - global scalar matrix
              do i2 = istart2,iend2       !loop - columns in block matrix
                ktemp = ktemp+1
                icol1 = (jvol1-1)*n+jadbl(i2) !column - global scalar matrix
                istart3 = iart(irow)
                iend3   = iart(irow+1)

!c  search row in global scalar matrix

                do i3 = istart3,iend3   
                  icol2 = jart(i3)          !column - global scalar matrix
                  if (icol1.eq.icol2) then
                    kart(ktemp) = i3        !define pointer array
                    goto 110
                  end if
                end do
 110            continue
              end do
            end do

!c  off-diagonal blocks

          elseif (ivol.ne.jvol1) then 
            do ibl=1,n                  !loop - rows of block matrix
              istart2 = iaobl(ibl)
              iend2 = iaobl(ibl+1)-1
              irow = (ivol-1)*n+ibl
              do i2 = istart2,iend2       !loop - columns in block matrix
                if(sparse_blocks) then
                    if(kblsorb(ibl,jaobl(i2))==1) then     !skip connections of sorbed specie 
                        cycle                               !components for off-dialog entries
                    end if
                end if
                ktemp = ktemp+1
                icol1 = (jvol1-1)*n+jaobl(i2)  !current column
                istart3 = iart(irow)
                iend3   = iart(irow+1)

!c  search row in global scalar matrix

                do i3 = istart3,iend3
                  icol2 = jart(i3)
                  if (icol1.eq.icol2) then
                    kart(ktemp) = i3          !define pointer array
                    goto 120
                  end if
                end do
 120            continue
              end do
            end do
          end if
          ltemp = ltemp+1
          lart(ltemp) = ktemp+1
        end do                            !loop - connections
      end do                           !loop - control volumes
      
!cdbg
#ifdef DEBUG
      if (info_debug.gt.0) then
        write(idbg,'(/a/)')                                             &
             'memory requirements for reactive transport simulation:'
        write(idbg,'(a,i10/a,i10/)')                                    &
             'max. number of entries in stiffness matrix:   = ',mnjart, &
             'actual number of entries in stiffness matrix: = ',njart
      end if
#endif

!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then

!c  row pointer array for global scalar matrix

        do irow=1,nngl*n+1
          write(idbg,*) 'ia(',irow,')=',iart(irow)
        end do

!c  column pointer array for global scalar matrix

        do irow=1,nngl*n
          istart = iart(irow)
          iend = iart(irow+1)-1
          write(idbg,*) ('ja(',i1,')=',jart(i1),i1=istart,iend)
        end do

!c  pointer array to first entry of block for global block matrix
!c  and symmetric entry

        do i1=1,njavs
          i2 = isymvs(i1)
          write(idbg,*)'la(',i1,')=',lart(i1),'la_sym(',i1,')=',lart(i2)
        end do

!c  mapping pointer (block by block) to (row by row)
!c                  (global block)   to (global scalar)

        do irow = 1,nngl
          write(idbg,*)'irow = ',irow
          istart = iavs(irow)
          iend =   iavs(irow+1)-1
          do i1 = istart,iend
            icol = javs(i1)
            write(idbg,*) 'icol = ',icol
            lstart = lart(i1)
            lend   = lart(i1+1)-1
            write(idbg,*) ('ka(',i2,')=',kart(i2),i2=lstart,lend)
          end do
        end do

        if (info_debug.eq.2) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if

      if(info_debug > 0) then
        call export_mmformat_pattern(nngl*n,njart,iart,jart,"react_nat")
      end if
#endif
!cdbg

      return

!c  exit if array bounds are violated
     
100   continue
      if (rank == 0) then
        write(ilog,*) 'stop in routine iajart' 
        write(ilog,*) 'check array dimensions of mnjart'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

      end
#endif
