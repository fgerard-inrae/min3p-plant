!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/usg/iajavs_usg.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine iajavs
!c -----------------
!c
!c set up ia-ja data-structure for variably saturated flow for usg mesh
!c      
!c                z
!c                     y
!c                7  
!c                |  5                  local connection list 
!c                | /                   for ja pointer array
!c                |/                    
!c       2--------1----------3  x     
!c               /|
!c              / |
!c             4  |
!c                6
!c
!c nonexistent connections (1D-2D-boundary effects) are skipped:
!c
!c      z
!c            
!c      4                     e.g.
!c      |                     x-z plane - on boundary x=0
!c      |                     
!c      |                     
!c      1----------2  x     
!c      |
!c      |
!c      |
!c      3
!c
!c written by:      Danyang Su - July 27, 2016 
!c
!c last modified:   -
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.f:   integer*4:
!c           ----------
!c           mnjavs             = max. number of entries in avs,javs  + -
!c           ncon_usg           = number of node connections          + -
!c
!c gen.f:    integer*4:
!c           ---------- 
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook                + -
!c           nn                 = total number of control volumes     + -
!c           iavs(nn+1)         = row pointer array for avs           * +
!c           javs(njavs)        = connectivity list                   * +
!c           isymvs(njavs)      = symmetry pointer array              * +
!c           njavs              = number of global connections        * +
!c
!c local:    idebug             = key for activation of debig output
!c           jtemp              = pointer to colum entries
!c           nedge              = number of adjacent control volumes
!c           irow1              = counter (rows)
!c           icol1              = pointer (columns)
!c           istart1            = pointer (first entry of row)
!c           iend1              = pointer (last entry of row)
!c           i1                 = counter (column entries in row)
!c           irow2              = counter (rows)
!c           icol2              = pointer (columns)
!c           istart2            = pointer (first entry of row)
!c           iend2              = pointer (last entry of row)
!c           i2                 = counter (column entries in row)
!c           found              = .true.  -> exit loop over columns
!c
!c external: -
!c ----------------------------------------------------------------------
#ifdef USG
      subroutine iajavs_usg

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
 
      use gen
      use geometry
      use geometry_definition
      use parm, only : ncon_usg
      use file_unit, only : lun_get, lun_free
      use usg_mesh_data, only : num_nodes_per_cell,num_cells,num_nodes,&
                                cells,nodes,get_cell_vol_id,           &
                                node2halfid,cell2halfid,               &
                                cal_cellface_index, cal_faceedge_index,&
                                cal_border_indicator,cal_faceedge_next,&
                                cal_edge_id,cell_type,CellCenter,      &
                                cell_projection,cell_volumes,          &
                                cell_adj_nodes_ia, cell_adj_nodes_ja,  &
                                grad_hls_min_nodes, grad_ls_matrices,  &
                                grad_method, grad_spatial_factor,      &
                                grad_spatial_weighting,                &
                                b_use_face_based_flux,                 &
                                node_num_cells,node_cells,             &
                                get_cell_face_index2,                  &
                                get_edge_shared_cells,                 &
                                cal_jacell_id, cal_jacell_cellindex,   &
                                cal_jacell_faceindex1,                 &
                                cal_jacell_faceindex2,                 &
                                num_edge_dvols, num_edge_maxcells,     &
                                num_faces_per_cell, CellFaceCenter,    &
                                cvol_method, get_face_edge_index,      &
                                usg_mesh_data_get_adj_nodes,           &
                                usg_mesh_data_pseudo_inverse,          &
                                usg_mesh_data_build_interface
                                
      use gradient_usg, only : gradient_green_gauss_tri,               &
                               gradient_green_gauss_tetra,             &
                               gradient_least_square_cvol,             &
                               gradient_hls_cvol                                
                                
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef DEBUG
      use matrix_utility, only : export_mmformat_pattern
#endif

      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: i1, i2, irow1, irow2, icol1, icol2, ivol, ivol_next,  &
                 jvol, istart1, istart2, iend1, iend2, jtemp, nedge,   &
                 cindex, eindex, cindex_next, eindex_next, iindex,     &
                 j1, j2, jtemp2, jvol2, nedge2, k1, kvol1,             &
                 kvol2, kvol3, kvol4, i0, icell, findex1, findex2,     &
                 icell2, idvol, ivol_index, iadj, nadj, ifaceedge

      integer :: nkvols, kvols(6)

      integer*8 :: id, id_next, id_stop

      integer*4, allocatable :: iwork_i4(:)
      integer*8, allocatable :: iwork_i8(:)
!c jacell_id is 64bit integer, for the tetrahedra cell,
!c the last 3 digits is the first face index,
!c the second last digits is the second face index
      integer*8, allocatable :: jacell_id_jtemp(:)
      integer*8, allocatable :: jacell_id(:,:)
      type(point) :: pt0, pt1, pt2, pt3, pt4, ptfc
      type(point) :: pts(3)
      real*8 :: weight_total
      real*8 :: wij2, dxij, dyij, dzij, mat_a11, mat_a22, mat_a33,     &
                mat_a12, mat_a13, mat_a23, rtemp, weight_i, weight_j
      real*8, parameter :: pi=3.14159265359d0, r2 = 2.0d0, r6 = 6.0d0, &
                           rverysmall = 1.0d-30

      integer :: info_debug, ierr

      logical :: found, bflag

      external :: checkerr

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif

!c  for gradient unit test only
!c      integer :: iunit, ncount
!c      real*8 :: tot_norm1, tot_norm2
!c      real*8, allocatable :: vol_vals(:)
!c      type(point) :: grad_mid, grad_mid_ana
!c      type(point), allocatable :: vol_grads(:), vol_grad_ana(:)
!c      type(grad_hls_term) :: grad_hls(1)

 
!c  loop over control volumes

      if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then

!c  define initial row pointer
!c  this part cannot be parallelized because of "jtemp = iavs(ivol)"
        allocate(janumcell(mnjavs), stat = ierr)
        call checkerr(ierr,'janumcell',ilog)
        janumcell = 0
        call memory_monitor(sizeof(janumcell),'janumcell',.false.)

        allocate(jacell_id(num_edge_maxcells,mnjavs), stat = ierr)
        call checkerr(ierr,'jacell_id',ilog)
        jacell_id = 0
        call memory_monitor(sizeof(jacell_id),'jacell_id',.false.)

        iavs(1) = 1
        jtemp = 0

        do ivol = 1, nngl

          jtemp = iavs(ivol)            ! pointer to diagonal entry

!c  assign diagonal entry 
          javs(jtemp) = ivol            ! diagonal entry
          jacell_id(:,jtemp) = ivol


          jtemp = jtemp+1               ! pointer to next entry

!c  assign variables for set up of colum pointer for off-diagonal entries

          nedge = 0                     ! max. number of adjacent volumes

!c  assign column pointers for off-diagonal entries in all directions
          id = node2halfid(ivol)
          cindex = cal_cellface_index(id)
          eindex = cal_faceedge_index(id)
          iindex = cal_border_indicator(id)
          
          if(iindex == 0) then                     ! this is a border vertex
            id_next = cal_edge_id(cindex,eindex,1) ! force the id_next to a non-border id
            cindex_next = cindex
            eindex_next = eindex
            jacell_id(1,jtemp) = 0
            jacell_id(2,jtemp) = cindex
          else
            id_next = cell2halfid(eindex,cindex)
            cindex_next = cal_cellface_index(id_next)
            eindex_next = cal_faceedge_index(id_next)
            jacell_id(1,jtemp) = cindex
            jacell_id(2,jtemp) = cindex_next
          end if


          id_stop = id_next

          do while (id_next /= id)

            ivol_next = cells(eindex_next,cindex_next)
            nedge = nedge+1
            javs(jtemp) = ivol_next
            jtemp = jtemp+1

            !c next edge following current processed edge
            cindex = cindex_next

            id_next = cal_faceedge_next(id_next)
            cindex_next = cal_cellface_index(id_next)
            eindex_next = cal_faceedge_index(id_next)
            iindex = cal_border_indicator(id_next)

            if (id_next == id_stop) then
              exit
            end if

            jacell_id(1,jtemp) = cindex
            if(iindex == 0) then
              jacell_id(2,jtemp) = 0
            else
              jacell_id(2,jtemp) = cindex_next
            end if


            if(iindex == 0) then                  ! this is a border vertex
              if (eindex_next == num_nodes_per_cell) then
                ivol_next = cells(1,cindex_next)
              else
                ivol_next = cells(eindex_next+1,cindex_next)
              end if
              nedge = nedge+1
              javs(jtemp) = ivol_next
              jtemp = jtemp+1

              exit
            end if

          end do

!c  assign next row pointer
     
          iavs(ivol+1) = iavs(ivol)+nedge+1
          
          do jtemp = iavs(ivol), iavs(ivol+1)-1
            if (jacell_id(1,jtemp) > 0 .or. jacell_id(2,jtemp) > 0) then
              janumcell(jtemp) = 2
            else
              janumcell(jtemp) = 1
            end if
          end do

        end do                              ! number of control volumes

!c  assign number of entries
        njavs = iavs(nngl+1) - 1

        allocate(iwork_i4(njavs), stat = ierr)
        call checkerr(ierr,'iwork_i4',ilog)
        call memory_monitor(sizeof(iwork_i4),'iwork_i4',.false.)

        iwork_i4(1:njavs) = janumcell(1:njavs)
        call memory_monitor(-sizeof(janumcell),'janumcell',.false.)
        deallocate(janumcell)

        allocate(janumcell(njavs), stat = ierr)
        call checkerr(ierr,'janumcell',ilog)
        call memory_monitor(sizeof(janumcell),'janumcell',.false.)

        janumcell(1:njavs) = iwork_i4(1:njavs)
        call memory_monitor(-sizeof(iwork_i4),'iwork_i4',.false.)
        deallocate(iwork_i4)

      else if (cell_type == cell_type_tetra .or.                       &
               cell_type == cell_type_hexa .or.                        &
               cell_type == cell_type_prism) then

        allocate(janumcell(mnjavs), stat = ierr)
        call checkerr(ierr,'janumcell',ilog)
        janumcell = 0
        call memory_monitor(sizeof(janumcell),'janumcell',.false.)

!c  define initial row pointer
        !c jacell_id is memory intensive for large scale 3d problem, use alternative procedure
        !allocate(jacell_id(num_edge_maxcells+1,mnjavs), stat = ierr)
        !call checkerr(ierr,'jacell_id',ilog)
        !jacell_id = 0
        !call memory_monitor(sizeof(jacell_id),'jacell_id',.false.)
        allocate(jacell_id_jtemp(num_edge_maxcells+1), stat = ierr)
        call checkerr(ierr,'jacell_id_jtemp',ilog)
        jacell_id_jtemp = 0
        call memory_monitor(sizeof(jacell_id_jtemp),'jacell_id_jtemp',.false.)

        iavs(1) = 1
        jtemp = 0

        do ivol = 1, nngl

          jtemp = iavs(ivol)            ! pointer to diagonal entry

!c  assign diagonal entry

          javs(jtemp) = ivol            ! diagonal entry
          !jacell_id(:,jtemp) = ivol
          jacell_id_jtemp(:) = ivol
          jtemp = jtemp+1               ! pointer to next entry

!c  assign variables for set up of colum pointer for off-diagonal entries

          nedge = 0                     ! max. number of adjacent volumes

!c  assign column pointers for off-diagonal entries in all directions
          do i1 = 1, node_num_cells(ivol)
            cindex = node_cells(i1,ivol)

            if (cell_type == cell_type_hexa .or. cell_type == cell_type_prism) then
              do i2 = 1, num_nodes_per_cell                 !find node index in cell
                if (cells(i2,cindex) == ivol) then
                  ivol_index = i2
                  exit
                end if
              end do
            end if

            do i2 = 1, num_nodes_per_cell                 !number of nodes

              if (cell_type == cell_type_hexa) then
                if (edge_node_link_hexa(ivol_index,i2) == 0) then
                  cycle
                end if
              else if (cell_type == cell_type_prism) then
                if (edge_node_link_prism(ivol_index,i2) == 0) then
                  cycle
                end if
              end if

              jvol = cells(i2,cindex)

              if (all(javs(iavs(ivol):iavs(ivol)+nedge) /= jvol)) then
                nedge = nedge + 1
                javs(jtemp) = jvol

                !c check if the edge ivol-jvol is on the boundary
                found = .false.
                do j1 = 1, node_num_cells(ivol)
                  cindex_next = node_cells(j1,ivol)
                  do j2 = 1, num_faces_per_cell           !number of faces
                    if (cal_border_indicator(cell2halfid(j2,cindex_next)) == 0) then
                      if (cell_type == cell_type_tetra) then
                        kvol1 = cells(face_node_mapping_tetra(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_tetra(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_tetra(3,j2),cindex_next)
                        if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                            (jvol == kvol2 .and. ivol == kvol3) .or.           &
                            (jvol == kvol3 .and. ivol == kvol1)) then
                          eindex_next = j2
                          found = .true.
                          exit
                        end if
                      else if (cell_type == cell_type_hexa) then
                        kvol1 = cells(face_node_mapping_hexa(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_hexa(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_hexa(3,j2),cindex_next)
                        kvol4 = cells(face_node_mapping_hexa(4,j2),cindex_next)
                        if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                            (jvol == kvol2 .and. ivol == kvol3) .or.           &
                            (jvol == kvol3 .and. ivol == kvol4) .or.           &
                            (jvol == kvol4 .and. ivol == kvol1)) then
                          eindex_next = j2
                          found = .true.
                          exit
                        end if
                      else if (cell_type == cell_type_prism) then
                        if (j2 <= 2) then       !top and bottom face
                          kvol1 = cells(face_node_mapping_prism(1,j2),cindex_next)
                          kvol2 = cells(face_node_mapping_prism(2,j2),cindex_next)
                          kvol3 = cells(face_node_mapping_prism(3,j2),cindex_next)
                          if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                              (jvol == kvol2 .and. ivol == kvol3) .or.           &
                              (jvol == kvol3 .and. ivol == kvol1)) then
                            eindex_next = j2
                            found = .true.
                            exit
                          end if
                        else
                          kvol1 = cells(face_node_mapping_prism(1,j2),cindex_next)
                          kvol2 = cells(face_node_mapping_prism(2,j2),cindex_next)
                          kvol3 = cells(face_node_mapping_prism(3,j2),cindex_next)
                          kvol4 = cells(face_node_mapping_prism(4,j2),cindex_next)
                          if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                              (jvol == kvol2 .and. ivol == kvol3) .or.           &
                              (jvol == kvol3 .and. ivol == kvol4) .or.           &
                              (jvol == kvol4 .and. ivol == kvol1)) then
                            eindex_next = j2
                            found = .true.
                            exit
                          end if
                        end if
                      end if

                    end if
                  end do

                  if (found) then
                    exit
                  end if
                end do

                !c if this edge is a border edge
                nedge2 = 0
                if (found) then
                  nedge2 = nedge2 + 1
                  !jacell_id(nedge2,jtemp) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)
                  jacell_id_jtemp(nedge2) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)

                  do while (.true.)
                    if (cell_type == cell_type_tetra) then
                      do j2 = 1, num_faces_per_cell           !number of faces
                        kvol1 = cells(face_node_mapping_tetra(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_tetra(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_tetra(3,j2),cindex_next)
                        if ((ivol == kvol1 .and. jvol == kvol2) .or.           &
                            (ivol == kvol2 .and. jvol == kvol3) .or.           &
                            (ivol == kvol3 .and. jvol == kvol1)) then
                          cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                          exit
                        end if
                      end do
                    else if (cell_type == cell_type_hexa) then
                      do j2 = 1, num_faces_per_cell           !number of faces
                        kvol1 = cells(face_node_mapping_hexa(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_hexa(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_hexa(3,j2),cindex_next)
                        kvol4 = cells(face_node_mapping_hexa(4,j2),cindex_next)
                        if ((ivol == kvol1 .and. jvol == kvol2) .or.           &
                            (ivol == kvol2 .and. jvol == kvol3) .or.           &
                            (ivol == kvol3 .and. jvol == kvol4) .or.           &
                            (ivol == kvol4 .and. jvol == kvol1)) then
                          cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                          exit
                        end if
                      end do
                    else if (cell_type == cell_type_prism) then
                      bflag = .true.
                      do j2 = 1, 2                            !top and bottom faces of prism
                        kvol1 = cells(face_node_mapping_prism(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_prism(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_prism(3,j2),cindex_next)
                        if ((ivol == kvol1 .and. jvol == kvol2) .or.           &
                            (ivol == kvol2 .and. jvol == kvol3) .or.           &
                            (ivol == kvol3 .and. jvol == kvol1)) then
                          cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                          bflag = .false.
                          exit
                        end if
                      end do

                      if (bflag) then
                        do j2 = 3, num_faces_per_cell           !side faces of prism
                          kvol1 = cells(face_node_mapping_prism(1,j2),cindex_next)
                          kvol2 = cells(face_node_mapping_prism(2,j2),cindex_next)
                          kvol3 = cells(face_node_mapping_prism(3,j2),cindex_next)
                          kvol4 = cells(face_node_mapping_prism(4,j2),cindex_next)
                          if ((ivol == kvol1 .and. jvol == kvol2) .or.         &
                              (ivol == kvol2 .and. jvol == kvol3) .or.         &
                              (ivol == kvol3 .and. jvol == kvol4) .or.         &
                              (ivol == kvol4 .and. jvol == kvol1)) then
                            cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                            exit
                          end if
                        end do
                      end if
                    end if

                    !if(cindex_next == cal_jacell_cellindex(jacell_id(nedge2,jtemp))) then
                    if(cindex_next == cal_jacell_cellindex(jacell_id_jtemp(nedge2))) then
                      exit
                    else
                      nedge2 = nedge2 + 1
                      !jacell_id(nedge2,jtemp) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)
                      jacell_id_jtemp(nedge2) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)
                    end if
                  end do

                else

                  cindex_next = cindex
                  nedge2 = nedge2 + 1
                  !jacell_id(nedge2,jtemp) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)
                  jacell_id_jtemp(nedge2) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)

                  do while (.true.)
                    if (cell_type == cell_type_tetra) then
                      do j2 = 1, num_faces_per_cell           !number of faces
                        kvol1 = cells(face_node_mapping_tetra(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_tetra(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_tetra(3,j2),cindex_next)
                        if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                            (jvol == kvol2 .and. ivol == kvol3) .or.           &
                            (jvol == kvol3 .and. ivol == kvol1)) then
                          cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                          exit
                        end if
                      end do
                    else if (cell_type == cell_type_hexa) then
                      do j2 = 1, num_faces_per_cell           !number of faces
                        kvol1 = cells(face_node_mapping_hexa(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_hexa(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_hexa(3,j2),cindex_next)
                        kvol4 = cells(face_node_mapping_hexa(4,j2),cindex_next)
                        if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                            (jvol == kvol2 .and. ivol == kvol3) .or.           &
                            (jvol == kvol3 .and. ivol == kvol4) .or.           &
                            (jvol == kvol4 .and. ivol == kvol1)) then
                          cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                          exit
                        end if
                      end do
                    else if (cell_type == cell_type_prism) then
                      bflag = .true.
                      do j2 = 1, 2                            !top and bottom faces of prism
                        kvol1 = cells(face_node_mapping_prism(1,j2),cindex_next)
                        kvol2 = cells(face_node_mapping_prism(2,j2),cindex_next)
                        kvol3 = cells(face_node_mapping_prism(3,j2),cindex_next)
                        if ((jvol == kvol1 .and. ivol == kvol2) .or.           &
                            (jvol == kvol2 .and. ivol == kvol3) .or.           &
                            (jvol == kvol3 .and. ivol == kvol1)) then
                          cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                          bflag = .false.
                          exit
                        end if
                      end do

                      if (bflag) then
                        do j2 = 3, num_faces_per_cell           !side faces of prism
                          kvol1 = cells(face_node_mapping_prism(1,j2),cindex_next)
                          kvol2 = cells(face_node_mapping_prism(2,j2),cindex_next)
                          kvol3 = cells(face_node_mapping_prism(3,j2),cindex_next)
                          kvol4 = cells(face_node_mapping_prism(4,j2),cindex_next)
                          if ((jvol == kvol1 .and. ivol == kvol2) .or.         &
                              (jvol == kvol2 .and. ivol == kvol3) .or.         &
                              (jvol == kvol3 .and. ivol == kvol4) .or.         &
                              (jvol == kvol4 .and. ivol == kvol1)) then
                            cindex_next = cal_cellface_index(cell2halfid(j2,cindex_next))
                            exit
                          end if
                        end do
                      end if
                    end if

                    !if(cindex_next == cal_jacell_cellindex(jacell_id(1,jtemp))) then
                    if(cindex_next == cal_jacell_cellindex(jacell_id_jtemp(1))) then
                      exit
                    else
                      nedge2 = nedge2 + 1
                      !jacell_id(nedge2,jtemp) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)
                      jacell_id_jtemp(nedge2) = cal_jacell_id(cindex_next,ivol,jvol,cell_type)
                    end if
                  end do

                end if

                janumcell(jtemp) = nedge2

                jtemp = jtemp+1
              end if
            end do
          end do

!c  assign next row pointer

          iavs(ivol+1) = iavs(ivol)+nedge+1

        end do                              ! number of control volumes

!c  assign number of entries
        njavs = iavs(nngl+1) - 1

        if (mnjavs > njavs) then

          allocate(iwork_i4(njavs), stat = ierr)
          call checkerr(ierr,'iwork_i4',ilog)
          call memory_monitor(sizeof(iwork_i4),'iwork_i4',.false.)

          iwork_i4(1:njavs) = janumcell(1:njavs)
          call memory_monitor(-sizeof(janumcell),'janumcell',.false.)
          deallocate(janumcell)

          allocate(janumcell(njavs), stat = ierr)
          call checkerr(ierr,'janumcell',ilog)
          call memory_monitor(sizeof(janumcell),'janumcell',.false.)

          janumcell(1:njavs) = iwork_i4(1:njavs)
          call memory_monitor(-sizeof(iwork_i4),'iwork_i4',.false.)
          deallocate(iwork_i4)

        end if

      end if

      !c return if the function is used for graph generation only
      if (btest(usg_mesh_ordering,0) .and. .not. btest(usg_mesh_ordering,1)) then
        !c release unused variables

        call memory_monitor(-sizeof(janumcell),'janumcell',.false.)
        deallocate(janumcell, stat = ierr)
        call checkerr(ierr,'janumcell',ilog)

        if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then
          call memory_monitor(-sizeof(jacell_id),'jacell_id',.false.)
          deallocate(jacell_id, stat = ierr)
          call checkerr(ierr,'jacell_id',ilog)
        else if (cell_type == cell_type_tetra .or.                     &
                 cell_type == cell_type_hexa .or.                      &
                 cell_type == cell_type_prism) then
          call memory_monitor(-sizeof(jacell_id_jtemp),'jacell_id_jtemp',.false.)
          deallocate(jacell_id_jtemp, stat = ierr)
          call checkerr(ierr,'jacell_id_jtemp',ilog)
        end if


        if (allocated(node_num_cells)) then
          call memory_monitor(-sizeof(node_num_cells),'node_num_cells',.false.)
          deallocate(node_num_cells, stat = ierr)
          call checkerr(ierr,'node_num_cells',ilog)
        end if

        if (allocated(node_cells)) then
          call memory_monitor(-sizeof(node_cells),'node_cells',.false.)
          deallocate(node_cells, stat = ierr)
          call checkerr(ierr,'node_cells',ilog)
        end if

        return
      end if

!c  reset the jacell value for 3d problem, where id information was stored
!c  to calculate the above information

      if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then
        num_edge_dvols = 1

        allocate(jacell(num_edge_maxcells,njavs), stat = ierr)
        call checkerr(ierr,'jacell',ilog)
        jacell = 0
        call memory_monitor(sizeof(jacell),'jacell',.true.)

        do ivol = 1, nngl
          istart1 = iavs(ivol)+1
          iend1 = iavs(ivol+1)-1
          do jtemp = istart1, iend1
            do icell = 1, janumcell(jtemp)
              jacell(icell,jtemp) = int(jacell_id(icell,jtemp))
            end do
          end do
        end do
      else if (cell_type == cell_type_tetra .or.                       &
               cell_type == cell_type_hexa .or.                        &
               cell_type == cell_type_prism) then
        num_edge_dvols = 2

        allocate(jacell(num_edge_maxcells,njavs), stat = ierr)
        call checkerr(ierr,'jacell',ilog)
        jacell = 0
        call memory_monitor(sizeof(jacell),'jacell',.true.)

        do ivol = 1, nngl
          istart1 = iavs(ivol)+1
          iend1 = iavs(ivol+1)-1
          do jtemp = istart1, iend1
            jvol = javs(jtemp)
            call get_edge_shared_cells(                                &
                     node_num_cells(ivol),node_num_cells(jvol),        &
                     node_cells(1:node_num_cells(ivol),ivol),          &
                     node_cells(1:node_num_cells(jvol),jvol),          &
                     jacell(1:janumcell(jtemp),jtemp))
            !do icell = 1, janumcell(jtemp)
            !  jacell(icell,jtemp) = cal_jacell_cellindex(jacell_id(icell,jtemp))
            !end do
          end do
        end do
      end if


      if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then

        grad_hls_min_nodes = 0

!c  calculate the adjacent node distance and interfacial area

        allocate(jaedgelen(njavs), stat = ierr)
        jaedgelen = 0.0d0
        call memory_monitor(sizeof(jaedgelen),'jaedgelen',.true.)

        allocate(jaedgeunitdirection(njavs), stat = ierr)
        call memory_monitor(sizeof(jaedgeunitdirection),'jaedgeunitdirection',.true.)
        do i2 = 1, njavs
          call math_common_zero(jaedgeunitdirection(i2))
        end do

        allocate(jagradweight(njavs), stat = ierr)
        call checkerr(ierr,'jagradweight',ilog)
        jagradweight = 0.0d0
        call memory_monitor(sizeof(jagradweight),'jagradweight',.true.)

        if (b_grad_interpolate_cell) then
          allocate(jacrossdifficvnum(2,njavs), stat = ierr)
          call checkerr(ierr,'jacrossdifficvnum',ilog)
          jacrossdifficvnum = 0
          call memory_monitor(sizeof(jacrossdifficvnum),'jacrossdifficvnum',.true.)

          allocate(jacrossdifficv(num_nodes_per_cell,2,njavs), stat = ierr)
          call checkerr(ierr,'jacrossdifficv',ilog)
          jacrossdifficv = 0
          call memory_monitor(sizeof(jacrossdifficv),'jacrossdifficv',.true.)

          allocate(jacrossdiffweight(num_nodes_per_cell,2,njavs), stat = ierr)
          call checkerr(ierr,'jacrossdiffweight',ilog)
          jacrossdiffweight = 0.0d0
          call memory_monitor(sizeof(jacrossdiffweight),'jacrossdiffweight',.true.)

          num_crossdifficv_max = 0
        else
          num_crossdifficv_max = 2
        end if

        !c calculate control volume relative geometry data
        do ivol = 1, nngl
          istart1 = iavs(ivol)+1
          iend1 = iavs(ivol+1)-1
          do jtemp = istart1, iend1
            jvol = javs(jtemp)

            jaedgelen(jtemp) = geometry_veclength(nodes(jvol)-nodes(ivol))
            jaedgeunitdirection(jtemp) = math_common_vector_unit(nodes(jvol)-nodes(ivol))

            !c calculate interface area and distance between cell center and edge mid-point
            pt1 = (nodes(ivol)+nodes(jvol))*0.5d0

            icell = jacell(1,jtemp)

            if (cvol_method == cvol_method_cc .and. icell > 0) then
              ifaceedge = get_face_edge_index(icell,ivol,jvol)
              if (ifaceedge > 0) then
                pt1 = CellFaceCenter(ifaceedge,icell)
              end if
            end if

            if (cvol_method == cvol_method_cc) then
              weight_i = 1.0d0/(geometry_veclength(pt1 - nodes(ivol)))**grad_spatial_factor
              weight_j = 1.0d0/(geometry_veclength(pt1 - nodes(jvol)))**grad_spatial_factor
              jagradweight(jtemp) = weight_i/(weight_i+weight_j)
            else
              jagradweight(jtemp) = 0.5d0
            end if

            icell = 0
           
            if(jacell(1,jtemp) > 0) then
              pt2 = CellCenter(jacell(1,jtemp))

              if (b_use_face_based_flux) then
                ptfc = (pt1+pt2)/2.0d0
              else
                ptfc = pt1
              end if

              if (b_grad_interpolate_cell) then
                icell = icell + 1
                weight_total = 0.0d0
                jacrossdifficvnum(icell,jtemp) = 2
                jacrossdifficv(1,icell,jtemp) = ivol
                jacrossdifficv(2,icell,jtemp) = jvol

                if(grad_spatial_weighting) then
                  wij2 = 1.0d0/geometry_veclength(ptfc-nodes(ivol))**grad_spatial_factor
                else
                  wij2 = 1.0d0
                end if

                jacrossdiffweight(1,icell,jtemp) = wij2
                weight_total = weight_total + jacrossdiffweight(1,icell,jtemp)

                if(grad_spatial_weighting) then
                  wij2 = 1.0d0/geometry_veclength(ptfc-nodes(jvol))**grad_spatial_factor
                else
                  wij2 = 1.0d0
                end if

                jacrossdiffweight(2,icell,jtemp) = wij2
                weight_total = weight_total + jacrossdiffweight(2,icell,jtemp)

                call get_cell_vol_id(jacell(1,jtemp),ivol,jvol,nkvols,kvols)
                if (kvols(1) > 0) then
                  jacrossdifficvnum(icell,jtemp) = jacrossdifficvnum(icell,jtemp) + 1
                  ivol_next = jacrossdifficvnum(icell,jtemp)
                  jacrossdifficv(ivol_next,icell,jtemp) = kvols(1)

                  if(grad_spatial_weighting) then
                    wij2 = 1.0d0/geometry_veclength(ptfc-nodes(kvols(1)))**grad_spatial_factor
                  else
                    wij2 = 1.0d0
                  end if

                  jacrossdiffweight(ivol_next,icell,jtemp) = wij2
                  weight_total = weight_total + jacrossdiffweight(ivol_next,icell,jtemp)
                end if
                if (kvols(2) > 0) then
                  jacrossdifficvnum(icell,jtemp) = jacrossdifficvnum(icell,jtemp) + 1
                  ivol_next = jacrossdifficvnum(icell,jtemp)
                  jacrossdifficv(ivol_next,icell,jtemp) = kvols(2)

                  if(grad_spatial_weighting) then
                    wij2 = 1.0d0/geometry_veclength(ptfc-nodes(kvols(2)))**grad_spatial_factor
                  else
                    wij2 = 1.0d0
                  end if
                  jacrossdiffweight(ivol_next,icell,jtemp) = wij2
                  weight_total = weight_total + jacrossdiffweight(ivol_next,icell,jtemp)
                end if

                do ivol_next = 1, jacrossdifficvnum(icell,jtemp)
                  jacrossdiffweight(ivol_next,icell,jtemp) = jacrossdiffweight(ivol_next,icell,jtemp)/weight_total
                end do

                if (jacrossdifficvnum(icell,jtemp) > num_crossdifficv_max) then
                  num_crossdifficv_max = jacrossdifficvnum(icell,jtemp)
                end if

              end if

            end if

            if(jacell(2,jtemp) > 0) then
              pt2 = CellCenter(jacell(2,jtemp))

              if (b_use_face_based_flux) then
                ptfc = (pt1+pt2)/2.0d0
              else
                ptfc = pt1
              end if

              if (b_grad_interpolate_cell) then
                icell = icell + 1
                weight_total = 0.0d0
                jacrossdifficvnum(icell,jtemp) = 2
                jacrossdifficv(1,icell,jtemp) = ivol
                jacrossdifficv(2,icell,jtemp) = jvol

                if(grad_spatial_weighting) then
                  wij2 = 1.0d0/geometry_veclength(ptfc-nodes(ivol))**grad_spatial_factor
                else
                  wij2 = 1.0d0
                end if
                jacrossdiffweight(1,icell,jtemp) = wij2
                weight_total = weight_total + jacrossdiffweight(1,icell,jtemp)

                if(grad_spatial_weighting) then
                  wij2 = 1.0d0/geometry_veclength(ptfc-nodes(jvol))**grad_spatial_factor
                else
                  wij2 = 1.0d0
                end if
                jacrossdiffweight(2,icell,jtemp) = wij2
                weight_total = weight_total + jacrossdiffweight(2,icell,jtemp)

                call get_cell_vol_id(jacell(2,jtemp),ivol,jvol,nkvols,kvols)
                if (kvols(1) > 0) then
                  jacrossdifficvnum(icell,jtemp) = jacrossdifficvnum(icell,jtemp) + 1
                  ivol_next = jacrossdifficvnum(icell,jtemp)
                  jacrossdifficv(ivol_next,icell,jtemp) = kvols(1)

                  if(grad_spatial_weighting) then
                    wij2 = 1.0d0/geometry_veclength(ptfc-nodes(kvols(1)))**grad_spatial_factor
                  else
                    wij2 = 1.0d0
                  end if

                  jacrossdiffweight(ivol_next,icell,jtemp) = wij2
                  weight_total = weight_total + jacrossdiffweight(ivol_next,icell,jtemp)
                end if
                if (kvols(2) > 0) then
                  jacrossdifficvnum(icell,jtemp) = jacrossdifficvnum(icell,jtemp) + 1
                  ivol_next = jacrossdifficvnum(icell,jtemp)
                  jacrossdifficv(ivol_next,icell,jtemp) = kvols(2)

                  if(grad_spatial_weighting) then
                    wij2 = 1.0d0/geometry_veclength(ptfc-nodes(kvols(2)))**grad_spatial_factor
                  else
                    wij2 = 1.0d0
                  end if
                  jacrossdiffweight(ivol_next,icell,jtemp) = wij2
                  weight_total = weight_total + jacrossdiffweight(ivol_next,icell,jtemp)
                end if

                do ivol_next = 1, jacrossdifficvnum(icell,jtemp)
                  jacrossdiffweight(ivol_next,icell,jtemp) = jacrossdiffweight(ivol_next,icell,jtemp)/&
                                                             weight_total
                end do

                if (jacrossdifficvnum(icell,jtemp) > num_crossdifficv_max) then
                  num_crossdifficv_max = jacrossdifficvnum(icell,jtemp)
                end if

              end if

            end if


          end do
        end do
        !c calculate least square gradient reconstruction matrix
        if (grad_method == grad_method_ls) then
          do ivol = 1, nngl
            mat_a11 = 0.0d0
            mat_a22 = 0.0d0
            mat_a33 = 0.0d0
            mat_a12 = 0.0d0
            mat_a13 = 0.0d0
            mat_a23 = 0.0d0

            istart1 = iavs(ivol)+1
            iend1 = iavs(ivol+1)-1
            do jtemp = istart1, iend1
              jvol = javs(jtemp)

              dxij = nodes(jvol)%x - nodes(ivol)%x
              dyij = nodes(jvol)%y - nodes(ivol)%y
              dzij = nodes(jvol)%z - nodes(ivol)%z

              if(grad_spatial_weighting) then
                wij2 = 1.0d0/jaedgelen(jtemp)**grad_spatial_factor
              else
                wij2 = 1.0d0
              end if

              mat_a11 = mat_a11 + wij2*dxij**2
              mat_a22 = mat_a22 + wij2*dyij**2
              mat_a33 = mat_a33 + wij2*dzij**2
              mat_a12 = mat_a12 + wij2*dxij*dyij
              mat_a13 = mat_a13 + wij2*dxij*dzij
              mat_a23 = mat_a23 + wij2*dyij*dzij
            end do

            if (cell_projection == projection_xy) then
              grad_ls_matrices(ivol)%det = mat_a11*mat_a22 - mat_a12**2
            else if (cell_projection == projection_yz) then
              grad_ls_matrices(ivol)%det = mat_a22*mat_a33 - mat_a23**2
            else if (cell_projection == projection_xz) then
              grad_ls_matrices(ivol)%det = mat_a11*mat_a33 - mat_a13**2
            else if (cell_projection == projection_xyz) then
              grad_ls_matrices(ivol)%det = 2.0d0*mat_a12*mat_a13*mat_a23 + mat_a11*mat_a22*mat_a33 - &
                   (mat_a11*mat_a23**2 + mat_a22*mat_a13**2 + mat_a33*mat_a12**2)
            end if

            if (abs(grad_ls_matrices(ivol)%det) < rverysmall) then
              if(rank == 0 .and. b_enable_output) then
                write(ilog,'(a)') "Warning: least square gradient reconstruction matrix is ill-conditioned or singular"
                write(ilog,'(a,1x,i6,1x,a,1x,1pe15.6e3)') "control volume",ivol,"determinant",grad_ls_matrices(ivol)%det
              end if
            end if

            if (cell_projection == projection_xy) then
              grad_ls_matrices(ivol)%bcoef11 = mat_a22/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef22 = mat_a11/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef33 = 0.0d0
              grad_ls_matrices(ivol)%bcoef12 = -mat_a12/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef13 = 0.0d0
              grad_ls_matrices(ivol)%bcoef23 = 0.0d0
            else if (cell_projection == projection_yz) then
              grad_ls_matrices(ivol)%bcoef11 = 0.0d0
              grad_ls_matrices(ivol)%bcoef22 = mat_a33/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef33 = mat_a22/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef12 = 0.0d0
              grad_ls_matrices(ivol)%bcoef13 = 0.0d0
              grad_ls_matrices(ivol)%bcoef23 = -mat_a23/grad_ls_matrices(ivol)%det
            else if (cell_projection == projection_xz) then
              grad_ls_matrices(ivol)%bcoef11 = mat_a33/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef22 = 0.0d0
              grad_ls_matrices(ivol)%bcoef33 = mat_a11/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef12 = 0.0d0
              grad_ls_matrices(ivol)%bcoef13 = -mat_a13/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef23 = 0.0d0
            else if (cell_projection == projection_xyz) then
              grad_ls_matrices(ivol)%bcoef11 = (mat_a22*mat_a33 - mat_a23**2)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef22 = (mat_a11*mat_a33 - mat_a13**2)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef33 = (mat_a11*mat_a22 - mat_a12**2)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef12 = (mat_a13*mat_a23 - mat_a12*mat_a33)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef13 = (mat_a12*mat_a23 - mat_a13*mat_a22)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef23 = (mat_a12*mat_a13 - mat_a11*mat_a23)/grad_ls_matrices(ivol)%det
            end if
          end do
        else if (grad_method >= grad_method_ls2 .and. grad_method <= grad_method_ls4) then
          !c get adjacent nodes for the specified cells
          if (grad_method == grad_method_ls2) then
            grad_hls_min_nodes = min_num_nodes_ls2_2d
          else if (grad_method == grad_method_ls3) then
            grad_hls_min_nodes = min_num_nodes_ls3_2d
          else if (grad_method == grad_method_ls4) then
            grad_hls_min_nodes = min_num_nodes_ls4_2d
          end if

        end if

        if (grad_method >= grad_method_ls2) then
          call usg_mesh_data_get_adj_nodes(grad_hls_min_nodes)
        end if

        call usg_mesh_data_build_interface

        if (grad_method >= grad_method_ls2) then
          call usg_mesh_data_pseudo_inverse
        end if

      else if (cell_type == cell_type_tetra .or.                       &
               cell_type == cell_type_hexa .or.                        &
               cell_type == cell_type_prism) then

        grad_hls_min_nodes = 0

!c  calculate the adjacent node distance and interfacial area
        
        allocate(jaedgelen(njavs), stat = ierr)
        call checkerr(ierr,'jaedgelen',ilog)
        jaedgelen = 0.0d0
        call memory_monitor(sizeof(jaedgelen),'jaedgelen',.true.)

        allocate(jaedgeunitdirection(njavs), stat = ierr)
        call checkerr(ierr,'jaedgeunitdirection',ilog)
        call memory_monitor(sizeof(jaedgeunitdirection),'jaedgeunitdirection',.true.)
        do i2 = 1, njavs
          call math_common_zero(jaedgeunitdirection(i2))
        end do

        allocate(jagradweight(njavs), stat = ierr)
        call checkerr(ierr,'jagradweight',ilog)
        jagradweight = 0.0d0
        call memory_monitor(sizeof(jagradweight),'jagradweight',.true.)

        if (b_grad_interpolate_cell) then
          allocate(jacrossdifficvnum(num_edge_maxcells,njavs), stat = ierr)
          call checkerr(ierr,'jacrossdifficvnum',ilog)
          jacrossdifficvnum = 0
          call memory_monitor(sizeof(jacrossdifficvnum),'jacrossdifficvnum',.true.)

          allocate(jacrossdifficv(num_nodes_per_cell,num_edge_maxcells,njavs), stat = ierr)
          call checkerr(ierr,'jacrossdifficv',ilog)
          jacrossdifficv = 0
          call memory_monitor(sizeof(jacrossdifficv),'jacrossdifficv',.true.)

          allocate(jacrossdiffweight(num_nodes_per_cell,num_edge_maxcells,njavs), stat = ierr)
          call checkerr(ierr,'jacrossdiffweight',ilog)
          jacrossdiffweight = 0.0d0
          call memory_monitor(sizeof(jacrossdiffweight),'jacrossdiffweight',.true.)

          num_crossdifficv_max = 0
        else
          num_crossdifficv_max = 2
        end if

        !c calculate control volume relative geometry data
        rtemp = 0.0d0
        do ivol = 1, nngl
          istart1 = iavs(ivol)+1
          iend1 = iavs(ivol+1)-1
          do jtemp = istart1, iend1
            jvol = javs(jtemp)
            jaedgelen(jtemp) = geometry_veclength(nodes(jvol)-nodes(ivol))
            jaedgeunitdirection(jtemp) = math_common_vector_unit(nodes(jvol)-nodes(ivol))

            !c calculate interface area and distance between cell center and edge mid-point
            pt0 = (nodes(ivol)+nodes(jvol))*0.5d0

            if (cvol_method == cvol_method_cc) then
              weight_i = 1.0d0/(geometry_veclength(pt0 - nodes(ivol)))**grad_spatial_factor
              weight_j = 1.0d0/(geometry_veclength(pt0 - nodes(jvol)))**grad_spatial_factor
              jagradweight(jtemp) = weight_i/(weight_i+weight_j)
            else
              jagradweight(jtemp) = 0.5d0
            end if

            do icell = 1, janumcell(jtemp)

              !cindex = cal_jacell_cellindex(jacell_id(icell,jtemp))
              !findex1 = cal_jacell_faceindex1(jacell_id(icell,jtemp))
              !findex2 = cal_jacell_faceindex2(jacell_id(icell,jtemp))

              cindex = jacell(icell,jtemp)
              call get_cell_face_index2(cindex,ivol,jvol,findex1,findex2)

              pt1 = CellFaceCenter(findex1,cindex)
              pt2 = CellFaceCenter(findex2,cindex)
              pt3 = CellCenter(cindex)

              if (b_use_face_based_flux) then
                ptfc = (pt0+pt1+pt2+pt3)/4.0d0
              else
                ptfc = pt0
              end if

              if (b_grad_interpolate_cell) then

                weight_total = 0.0d0
                jacrossdifficvnum(icell,jtemp) = 2
                jacrossdifficv(1,icell,jtemp) = ivol
                jacrossdifficv(2,icell,jtemp) = jvol

                if(grad_spatial_weighting) then
                  wij2 = 1.0d0/geometry_veclength(ptfc-nodes(ivol))**grad_spatial_factor
                else
                  wij2 = 1.0d0
                end if

                jacrossdiffweight(1,icell,jtemp) = wij2
                weight_total = weight_total + jacrossdiffweight(1,icell,jtemp)

                if(grad_spatial_weighting) then
                  wij2 = 1.0d0/geometry_veclength(ptfc-nodes(jvol))**grad_spatial_factor
                else
                  wij2 = 1.0d0
                end if
                jacrossdiffweight(2,icell,jtemp) = wij2
                weight_total = weight_total + jacrossdiffweight(2,icell,jtemp)

                call get_cell_vol_id(jacell(icell,jtemp),ivol,jvol,nkvols,kvols)
                do k1 = 1, 6
                  if (kvols(k1) > 0) then
                    jacrossdifficvnum(icell,jtemp) = jacrossdifficvnum(icell,jtemp) + 1
                    ivol_next = jacrossdifficvnum(icell,jtemp)
                    jacrossdifficv(ivol_next,icell,jtemp) = kvols(k1)

                    if(grad_spatial_weighting) then
                      wij2 = 1.0d0/geometry_veclength(ptfc-nodes(kvols(k1)))**grad_spatial_factor
                    else
                      wij2 = 1.0d0
                    end if
                    jacrossdiffweight(ivol_next,icell,jtemp) = wij2
                    weight_total = weight_total + jacrossdiffweight(ivol_next,icell,jtemp)
                  end if
                end do

                do ivol_next = 1, jacrossdifficvnum(icell,jtemp)
                  jacrossdiffweight(ivol_next,icell,jtemp) = jacrossdiffweight(ivol_next,icell,jtemp)/&
                                                             weight_total
                end do

                if (jacrossdifficvnum(icell,jtemp) > num_crossdifficv_max) then
                  num_crossdifficv_max = jacrossdifficvnum(icell,jtemp)
                end if

              end if

            end do

          end do
        end do

        !c calculate least square gradient reconstruction matrix
        if (grad_method == grad_method_ls) then
          do ivol = 1, nngl
            mat_a11 = 0.0d0
            mat_a22 = 0.0d0
            mat_a33 = 0.0d0
            mat_a12 = 0.0d0
            mat_a13 = 0.0d0
            mat_a23 = 0.0d0

            istart1 = iavs(ivol)+1
            iend1 = iavs(ivol+1)-1
            do jtemp = istart1, iend1
              jvol = javs(jtemp)

              dxij = nodes(jvol)%x - nodes(ivol)%x
              dyij = nodes(jvol)%y - nodes(ivol)%y
              dzij = nodes(jvol)%z - nodes(ivol)%z

              if(grad_spatial_weighting) then
                wij2 = 1.0d0/jaedgelen(jtemp)**grad_spatial_factor
              else
                wij2 = 1.0d0
              end if

              mat_a11 = mat_a11 + wij2*dxij**2
              mat_a22 = mat_a22 + wij2*dyij**2
              mat_a33 = mat_a33 + wij2*dzij**2
              mat_a12 = mat_a12 + wij2*dxij*dyij
              mat_a13 = mat_a13 + wij2*dxij*dzij
              mat_a23 = mat_a23 + wij2*dyij*dzij
            end do

            if (cell_projection == projection_xy) then
              grad_ls_matrices(ivol)%det = mat_a11*mat_a22 - mat_a12**2
            else if (cell_projection == projection_yz) then
              grad_ls_matrices(ivol)%det = mat_a22*mat_a33 - mat_a23**2
            else if (cell_projection == projection_xz) then
              grad_ls_matrices(ivol)%det = mat_a11*mat_a33 - mat_a13**2
            else if (cell_projection == projection_xyz) then
              grad_ls_matrices(ivol)%det = 2.0d0*mat_a12*mat_a13*mat_a23 + mat_a11*mat_a22*mat_a33 - &
                   (mat_a11*mat_a23**2 + mat_a22*mat_a13**2 + mat_a33*mat_a12**2)
            end if

            if (abs(grad_ls_matrices(ivol)%det) < rverysmall) then
              if(rank == 0 .and. b_enable_output) then
                write(ilog,'(a)') "Warning: least square gradient reconstruction matrix is ill-conditioned or singular"
                write(ilog,'(a,1x,i6,1x,a,1x,1pe15.6e3)') "control volume",ivol,"determinant",grad_ls_matrices(ivol)%det
              end if
            end if

            if (cell_projection == projection_xy) then
              grad_ls_matrices(ivol)%bcoef11 = mat_a22/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef22 = mat_a11/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef33 = 0.0d0
              grad_ls_matrices(ivol)%bcoef12 = -mat_a12/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef13 = 0.0d0
              grad_ls_matrices(ivol)%bcoef23 = 0.0d0
            else if (cell_projection == projection_yz) then
              grad_ls_matrices(ivol)%bcoef11 = 0.0d0
              grad_ls_matrices(ivol)%bcoef22 = mat_a33/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef33 = mat_a22/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef12 = 0.0d0
              grad_ls_matrices(ivol)%bcoef13 = 0.0d0
              grad_ls_matrices(ivol)%bcoef23 = -mat_a23/grad_ls_matrices(ivol)%det
            else if (cell_projection == projection_xz) then
              grad_ls_matrices(ivol)%bcoef11 = mat_a33/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef22 = 0.0d0
              grad_ls_matrices(ivol)%bcoef33 = mat_a11/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef12 = 0.0d0
              grad_ls_matrices(ivol)%bcoef13 = -mat_a13/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef23 = 0.0d0
            else if (cell_projection == projection_xyz) then
              grad_ls_matrices(ivol)%bcoef11 = (mat_a22*mat_a33 - mat_a23**2)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef22 = (mat_a11*mat_a33 - mat_a13**2)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef33 = (mat_a11*mat_a22 - mat_a12**2)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef12 = (mat_a13*mat_a23 - mat_a12*mat_a33)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef13 = (mat_a12*mat_a23 - mat_a13*mat_a22)/grad_ls_matrices(ivol)%det
              grad_ls_matrices(ivol)%bcoef23 = (mat_a12*mat_a13 - mat_a11*mat_a23)/grad_ls_matrices(ivol)%det
            end if
          end do
        else if (grad_method >= grad_method_ls2 .and. grad_method <= grad_method_ls4) then

          !c get adjacent nodes for the specified cells
          if (grad_method == grad_method_ls2) then
            grad_hls_min_nodes = min_num_nodes_ls2_3d
          else if (grad_method == grad_method_ls3) then
            grad_hls_min_nodes = min_num_nodes_ls3_3d
          else if (grad_method == grad_method_ls4) then
            grad_hls_min_nodes = min_num_nodes_ls4_3d
          end if

        end if

        if (grad_method >= grad_method_ls2) then
          call usg_mesh_data_get_adj_nodes(grad_hls_min_nodes)
        end if

        call usg_mesh_data_build_interface

        if (grad_method >= grad_method_ls2) then
          call usg_mesh_data_pseudo_inverse
        end if

      else
        if(rank == 0) then
          write(*,*) "Error: interfacial area calculation is currently not supported"
          write(ilog,*) "Error: interfacial area calculation is currently not supported"
        end if
        stop
      end if


!c  symmetry pointer
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_iajavs_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, i2, icol1, icol2, iend1, iend2,                &
    !$omp irow1, irow2, istart1, istart2, found)
    !$omp do schedule(static)
#endif
      do irow1=1,nngl                   ! loop over rows (control volumes)
        istart1 = iavs(irow1)
        iend1 = iavs(irow1+1)-1
        do i1=istart1,iend1           ! loop over column entries
          icol1=javs(i1)              ! current column 
          irow2=icol1                 ! row to be searched
          istart2=iavs(irow2)
          iend2 = iavs(irow2+1)-1
          i2 = istart2
          found = .false.
 
!c  search row for pointer to corresponding symmetric entry

          do while ((.not.found).and.(i2.le.iend2))  
            icol2 = javs(i2)           
            if (icol2.eq.irow1) then
              isymvs(i1) = i2         ! assign symmetry pointer
              found = .true.
            end if
            i2 = i2+1
          end do
        end do
      end do 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef PETSC  
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_iajavs_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, irow1, istart1, iend1)
    !$omp do schedule(static)
#endif
      do irow1=1,nngl                   ! loop over rows (control volumes)
        istart1 = iavs(irow1)
        iend1 = iavs(irow1+1)-1
        if(node_idx_lg2l(irow1) > 0) then
          row_idx_l2pg_vs(irow1) = node_idx_lg2pg(irow1)
        else
          row_idx_l2pg_vs(irow1) = - node_idx_lg2pg(irow1)  
        end if
        do i1=istart1,iend1           ! loop over column entries
          col_idx_l2pg_vs(i1) = node_idx_lg2pg(javs(i1))
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
#endif

      !c free unused memory
      if (cell_type == cell_type_tri .or. cell_type == cell_type_quad) then
        call memory_monitor(-sizeof(jacell_id),'jacell_id',.false.)
        deallocate(jacell_id, stat = ierr)
        call checkerr(ierr,'jacell_id',ilog)
      else if (cell_type == cell_type_tetra .or.                     &
               cell_type == cell_type_hexa .or.                      &
               cell_type == cell_type_prism) then
        call memory_monitor(-sizeof(jacell_id_jtemp),'jacell_id_jtemp',.false.)
        deallocate(jacell_id_jtemp, stat = ierr)
        call checkerr(ierr,'jacell_id_jtemp',ilog)
      end if

!cdbg
#ifdef DEBUG
      info_debug = 0
      if(info_debug.gt.0) then
        do irow1=1,nngl + 1
          write(idbg,*) 'ia(',irow1,') = ',iavs(irow1)
        end do
        do irow1=1,nngl
          istart1 = iavs(irow1)
          iend1 = iavs(irow1+1)-1
          write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart1,iend1)
        end do

        do irow1=1,nngl
          istart1 = iavs(irow1)
          iend1 = iavs(irow1+1)-1
          write(idbg,*) ('isymvs(',i1,') = ',isymvs(i1),i1=istart1,iend1)
        end do
        
        write(idbg,*) 'end of iajavs'

        do ivol = 1, nngl
          istart1 = iavs(ivol)
          iend1 = iavs(ivol+1)-1
          do jtemp = istart1, iend1
            jvol = javs(jtemp)
            do icell = 1, janumcell(jtemp)
              do i1 = 1, num_edge_dvols
                write(idbg,*) "-->ivol-jvol-icell-idvol",ivol,jvol,    &
                              icell,i1,"jacell",jacell(icell,jtemp)
                write(idbg,*) "--->edgeunitdirection",                 &
                              jaedgeunitdirection(jtemp)%x,            &
                              jaedgeunitdirection(jtemp)%y,            &
                              jaedgeunitdirection(jtemp)%z
              end do
            end do

            write(idbg,*) "--> check weight for vol ",ivol,jvol
            write(idbg,*) jacrossdiffweight(1:jacrossdifficvnum(icell,jtemp),icell,jtemp)

          end do
        end do
      end if

      if(info_debug > 0) then
        call export_mmformat_pattern(nngl, njavs, iavs, javs, "vsflow_nat")
      end if
#endif
   
      return
      end
#endif
