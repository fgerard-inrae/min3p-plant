!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 878 $
!> $Author: dsu $
!> $Date: 2024-02-14 20:08:49 -0800 (Wed, 14 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcpvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpvs
!c -------------------
!c
!c control parameters for variably saturated flow
!c
!c written by:      Uli Mayer - May 28, 96
!c
!c last modified:   Uli Mayer - July 24, 01
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           deltol_vs          = solver update tolerance             * +
!c           dinc_vs            = increment for numerical             * +
!c                                differentiation
!c           perm_fac(nn)       = scaling factor for permeability     * +
!c                                as a function of porosity changes 
!c           restol_vs          = solver residual tolerance           * +
!c           srelfac_vs         = user specified underrelaxation      * +
!c                                factor
!c           sw_star            = anticipated change in saturation    * +
!c                                per time step
!c           tol_vs             = convergence tolerance               * +
!c                                (variably saturated flow)
!c           uvslim             = max. allowed update                 * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           idetail_vs         = solver information level            * +
!c           level_vs           = incomplete factorization level      * +
!c           maxit_vs           = max. number of newton iterations    * +
!c                                (variably saturated flow)
!c           msolvit_vs         = max. number of solver iterations    * +
!c           nn                 = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   * +
!c                                           factor
!c           hydraulic_head     = .true.  -> initial condition in     * +
!c                                           terms of hydraulic head
!c           mass_balance_vs    = .true.  -> compute mass balance     * +
!c                                           (variably_saturated
!c                                            flow)
!c           pressure_head      = .true.  -> initial condition in     * +
!c                                           terms of pressure head
!c           rcm_ordering_vs    = .true.  -> rcm ordering for         * +
!c                                           1d scalar matrix
!c           under_relax        = .true.  -> underrelaxation          * +
!c           upstream           = .true.  -> upstream weighting       * +
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c local:    integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpvs
 
      use parm
      use gen
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, ivol, l_string, itemp, ntemp, ierr, ierrcd

      real*8 :: rdeltemp, rtemp, relcond
      real*8, external :: relcond_freezing

      external findstrg, readbloc

      external checkerr

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rkelvin=273.15d0

      logical found_section, found_subsection
      character*72 :: subsection
 
!c  define or read control parameters for variably saturated flow
!c  and write to temporary file

      ierrcd = 0
   
      section_header = 'control parameters - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (.not. found_section) then
        !c the following keyword was modified in FG's code, not recomment to use.
        section_header = 'control parameters - water flow'
        call readbloc (idat,itmp,section_header,found_section,.true.)
      end if

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for control parameters for variably saturated flow

!c  general control parameters

      b_check_div_vs = .false.
      mass_balance_vs = .true.
      pressure_head = .false.
      tol_vs = 1.0d-6
      rtol_relbalance_vs = 1.0d100
      rtol_absbalance_vs = 1.0d100
      relbalance_vs = 0.0d0
      absbalance_vs = 0.0d0

      if (variably_saturated) then
        upstream = .true.
      elseif (fully_saturated) then
        upstream = .false.
      end if

!c  hydraulic conductivity or permeability tensor
      type_cond_perm = 1

!c  Picard iteration for seepage boundary
      maxit_seepage = 15

!c  Newton iteration

      dinc_vs = 1.0d-4
      maxit_vs = 15
      sw_star = 0.1

!c  underrelaxation

      !c DSU, 2019-11-26
      !c update from variably_saturated to varsat_flow, 
      !c to allow underrelaxation for both saturated and unsaturated flow
      if (varsat_flow) then
        under_relax = .false.
        comp_relax = .false.
      end if

!c  solver settings

      level_vs = 0
      msolvit_vs = 100
      idetail_vs = 1
      restol_vs = 0.1d0 * tol_vs
      deltol_vs = 0.1d0 * tol_vs

      iter_vs_ant = 0

      if(i_solver_type_flow == 0) then
        rcm_ordering_vs = .true.
        metis_ordering_vs = .true.
      else
        rcm_ordering_vs = .false.
        metis_ordering_vs = .false.
      end if

!c  extimated fractorization coefficient for linear solver, default value is 3 before
      coeff_fac_conn_vs = 4

!c  initialize scaling factor for permeability update
 
      do ivol = 1,nngl
        perm_fac(ivol) = r1
      end do

      if (found_section) then

!c  mass balance settings - new definition

        subsection = 'mass balance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
        else
          mass_balance_vs = .false.
        end if

!c  mass balance settings - old definition

        subsection = 'mass balance settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 1
          read(itmp,*,err=999,end=999) mass_balance_vs
        end if

        subsection = 'relative mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          ierrcd = 2
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
        end if

        subsection = 'absolute mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          ierrcd = 3
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if

        subsection = 'mass balance convergence tolerance settings'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          ierrcd = 4
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if

!c  input units for boundary and initial conditions

        subsection = 'input units for boundary and initial conditions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 5
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'pressure head') then
            pressure_head = .true.
          elseif (subsection.eq.'hydraulic head' .or.                  &
                  subsection.eq.'freshwater head') then
            pressure_head = .false.
          else
            ierrcd = 6
            goto 999
          end if
        end if

!cdsu user specified fixed flow velocity, unit m/day
        subsection = 'fixed flow velocity'
        b_use_fixed_flow_vel = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_use_fixed_flow_vel = .true.
          ierrcd = 7
          read(itmp,*,err=999,end=999) fixed_flow_vel%x,               &
               fixed_flow_vel%y,fixed_flow_vel%z
        end if

        subsection = 'zero flow velocity'
        b_use_zero_flow_vel = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_use_zero_flow_vel = .true.
          b_use_fixed_flow_vel = .true.
          fixed_flow_vel%x = r0
          fixed_flow_vel%y = r0
          fixed_flow_vel%z = r0
        end if

#ifdef USG
        subsection = 'two-point upstream weighting'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_mpfa_upstream = .false.
        else
          b_mpfa_upstream = .true.
        end if

        subsection = 'use full hydraulic conductivity tensor'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          type_cond_perm = 2
        end if

        subsection = 'use full permeability tensor'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          type_cond_perm = 2
        end if
#endif


        if (variably_saturated) then

!c  upstream weighting - old definition, deprecated

          subsection = 'upstream weighting'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            !c the old version require to specify true or false after the keyword
            read(itmp,*,err=997,end=997) upstream
997         continue            
          end if

!c  upstream weighting - new definition

          subsection = 'centered weighting'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            upstream = .false.
          else
            upstream = .true.
          end if
        end if

        !c DSU, 2019-11-26
        !c update from variably_saturated to varsat_flow, 
        !c to allow underrelaxation for both saturated and unsaturated flow
        if (varsat_flow) then
!c  user specified underrelaxation factor

          subsection = 'user specified underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            ierrcd = 8
            read(itmp,*,err=999,end=999) srelfac_vs
          end if

          if (under_relax) then
            srelrange_vs_min = -1.0d100
            srelrange_vs_max = 1.0d100
            subsection = 'user specified underrelaxation range'
            call findstrg(subsection,itmp,found_subsection)  
            if (found_subsection) then
              under_relax_range_vs = .true.
              ierrcd = 9
              read(itmp,*,err=999,end=999) srelrange_vs_min,srelrange_vs_max
            end if
          end if

!c  compute underrelaxation factor

          subsection = 'compute underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            comp_relax = .true.
            ierrcd = 10
            read(itmp,*,err=999,end=999) uvslim
          end if

        end if              !(variably saturated)

!cdsu  water freezing parameters
        subsection = 'water freezing temperature'
        water_freezing_tempkel = rkelvin
        b_water_freezing = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_water_freezing = .true.
          ierrcd = 11
          read(itmp,*,err=999,end=999) water_freezing_tempkel
          water_freezing_tempkel = water_freezing_tempkel + rkelvin
        end if

!cdsu compute pressure melting point or use specified water freezing temperature as the default ice melting point
        b_pressure_melting = .false.
        subsection = 'compute pressure melting point'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_pressure_melting = .true.
          b_water_freezing = .true.
        end if
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(a,l1)')                                         &
                'compute pressure melting poing                  = ',  &
                b_pressure_melting
        end if        

        b_water_freezing_cond = .false.
        b_water_freezing_curve = .false.
        b_water_freezing_func = .false.
        b_water_freezing_pts = .false.
        water_freezing_cond = 0.0d0
        if (b_water_freezing) then
          subsection = 'water freezing conductivity'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 12
            read(itmp,*,err=999,end=999) water_freezing_cond
            water_freezing_cond = water_freezing_cond*sec_per_days
            if (water_freezing_cond < 0.0d0) then
              water_freezing_cond = 0.0d0
            end if
            b_water_freezing_cond = .true.
          else
            subsection = 'water freezing relative conductivity curve'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              b_water_freezing_curve = .true.
              call findstrg(subsection,itmp,found_subsection)
              ierrcd = 13
              read(itmp,*,err=999,end=999)                             &
                   water_freezing_curve_a,                             &
                   water_freezing_curve_b,                             &
                   water_freezing_curve_c,                             &
                   water_freezing_curve_d
              ierrcd = 14
              read(itmp,*,err=999,end=999)                             &
                   water_freezing_curve_tempmin,                       &
                   water_freezing_curve_tempmax,                       &
                   water_freezing_relcond_min,                         &
                   water_freezing_relcond_max
            end if

            subsection = 'water freezing relative conductivity function'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              b_water_freezing_curve = .true.
              b_water_freezing_func = .true.
              call findstrg(subsection,itmp,found_subsection)
              ierrcd = 15
              read(itmp,*,err=999,end=999)                             &
                   water_freezing_curve_tempmin,                       &
                   water_freezing_curve_tempmax,                       &
                   water_freezing_relcond_min,                         &
                   water_freezing_relcond_max
            end if

            subsection = 'water freezing relative conductivity points'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              b_water_freezing_curve = .true.
              b_water_freezing_pts = .true.
              ierrcd = 16
              read(itmp,*,err=999,end=999) ntemp

              allocate(water_freezing_pts(ntemp,2), stat = ierr)
              water_freezing_pts=0 
              call checkerr(ierr,'water_freezing_pts',ilog)
              call memory_monitor(sizeof(water_freezing_pts),'water_freezing_pts',.true.)

              ierrcd = 17
              do itemp = 1, ntemp
                read(itmp,*,err=999,end=999) water_freezing_pts(itemp,1:2)
              end do      
            end if

          end if
        end if

        b_freezing_adjacent_bd = .false.
        subsection = 'disable freezing boundary connection'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_freezing_adjacent_bd = .true.
        end if

        b_freezing_no_pond = .false.
        subsection = 'apply pressure head tolerance of ponding boundary'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_freezing_no_pond = .true.
        end if

!cprovi----------------------------------------------------
!cprovi Update porosity for flow processes
!cprovi----------------------------------------------------
        subsection = 'update porosity'
        update_porosity_flow=.false.
        facpormin=1.0d-10
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 18
          read(itmp,*,err=999,end=999) facpormin
          update_porosity_flow=.true.
        end if

!c  check divergence for newton iteration
        subsection = 'enable divergence check'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_check_div_vs = .true.
        end if

!cdsu Run steady state flow in transient mode.
!cdsu For some steady state flow, because of transient effect, the simulation
!cdsu may encounter convergence problem if using steady state flow directly.
!cdsu In this case, transient flow can be used until flow reaches steady state condition.
!cdsu To use this feature, please set flow to transient flow and add the following keywords
        tran_steady_flow = .false.
        tran_steady_flow_converged = .false.
        tran_steady_stop = .false.
        tran_steady_exit_time = 1.0d300
        rtol_tran_steady_flow = 1.0d-6
        atol_tran_steady_flow = 1.0d-6
        if (.not. steady_flow) then
          subsection = 'run steady state flow in transient mode'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            tran_steady_flow = .true.
          end if

          if (tran_steady_flow) then
            subsection = 'tolerance for steady state'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              ierrcd = 19
              read(itmp,*,err=999,end=999) rtol_tran_steady_flow
              read(itmp,*,err=999,end=999) atol_tran_steady_flow
            end if
          end if

          subsection = 'maximum time of transient steady state'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 20
            read(itmp,*,err=999,end=999) tran_steady_exit_time
            tran_steady_exit_time = tran_steady_exit_time*time_factor
          end if

          subsection = 'stop after transient steady state'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            tran_steady_stop = .true.
          end if
        end if

!c  picard iteration settings for seepage face boundary conditions
      subsection = 'maximum number of seepage face iterations'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 21
        read(itmp,*,err=999,end=999) maxit_seepage
      end if

!c  newton iteration settings

      subsection = 'newton iteration settings plus'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 22
        read(itmp,*,err=999,end=999) dinc_vs
        read(itmp,*,err=999,end=999) iter_vs_ant
        read(itmp,*,err=999,end=999) maxit_vs
        read(itmp,*,err=999,end=999) tol_vs
        read(itmp,*,err=999,end=999) sw_star
      end if

      subsection = 'anticipated number of newton iterations'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 23
        read(itmp,*,err=999,end=999) iter_vs_ant
      end if

      subsection = 'newton iteration settings'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 24
        read(itmp,*,err=999,end=999) dinc_vs
        read(itmp,*,err=999,end=999) maxit_vs
        read(itmp,*,err=999,end=999) tol_vs
        read(itmp,*,err=999,end=999) sw_star
      end if

      subsection = 'coefficient of factored connections'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 27
        read(itmp,*,err=999,end=999) coeff_fac_conn_vs 
      end if

!c  solver settings

      subsection = 'solver settings'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 25
        read(itmp,*,err=999,end=999) level_vs 
        read(itmp,*,err=999,end=999) msolvit_vs
        read(itmp,*,err=999,end=999) idetail_vs
        read(itmp,*,err=999,end=999) restol_vs
        read(itmp,*,err=999,end=999) deltol_vs
        read(itmp,*,err=998,end=998) rcm_ordering_vs      !old
      end if

998    subsection = 'natural ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .false.
        end if
        
        subsection = 'rcm ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .true.
        end if

#ifdef METIS
        subsection = 'metis ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          metis_ordering_vs = .true.
          rcm_ordering_vs = .false.
        else
          metis_ordering_vs = .false.
        end if
#endif

      end if                 !(found_section)

!c  assign related control parameters

      if (.not.pressure_head) then
         hydraulic_head = .true.
      end if
      
      if (b_enable_output .and. b_enable_output_gen) then

!c  write control parameters for reactive transport
!c  to generic output file
 
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

      if (pressure_head) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'pressure head'
      elseif (hydraulic_head) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'hydraulic head'
      end if

      if (variably_saturated) then    
        if (upstream) then
          write(igen,'(a)')                                       &
     &    'upstream weighting of relative permeabilities        '
        else
          write(igen,'(a)')                                       &
     &    'centered weighting of relative permeabilities        '
        end if

        if (under_relax) then
          if (comp_relax) then
            write(igen,'(a)')                                     &
     &      'computation of underrelaxation factor                '
            write(igen,'(a,1pe15.6e3)')                           &
     &      'max. allowed update                             = ', &
     &       uvslim 
          else
            write(igen,'(a,1pe15.6e3)')                           &
     &      'user specified underrelaxation factor           = ', &
     &       srelfac_vs
          end if
        end if
   
        write(igen,'(a,1pe15.6e3)')                               &
     &  'increment for numerical differentiation         = ',     &
     &   dinc_vs
        write(igen,'(a,i10)')                                     &
     &  'max. number of newton iterations                = ',     &
     &   maxit_vs
        write(igen,'(a,1pe15.6e3)')                               &
     &  'convergence tolerance                           = ',     &
     &   tol_vs
        write(igen,'(a,1pe15.6e3)')                               &
     &  'anticipated change in saturation per time step  = ',     &
     &   sw_star
      end if
      write(igen,'(a,i10)')                                       &
     &'incomplete factorization level                  = ',       &
     & level_vs
      write(igen,'(a,i10)')                                       &
     &'max. number of solver iterations                = ',       &
     & msolvit_vs
      write(igen,'(a,i10)')                                       &
     &'solver information level                        = ',       &
     & idetail_vs
      write(igen,'(a,1pe15.6e3)')                                 &
     &'solver residual tolerance                       = ',       &
     & restol_vs  
      write(igen,'(a,1pe15.6e3)')                                 &
     &'solver update tolerance                         = ',       &
     & deltol_vs
      if (rcm_ordering_vs) then
        write(igen,'(a)')'reverse Cuthill McKee ordering'
#ifdef METIS
      else if (metis_ordering_vs) then
        write(igen,'(a)')'metis fill-reducing ordering'
#endif
      else
        write(igen,'(a)')'natural ordering'
      end if
      
      if (b_water_freezing_cond) then
        write(igen,'(/a,1x,1pe15.6e3,1x,a)')                      &
             'water freezing conductivity ',                      &
             water_freezing_cond,'m/day'
      else if (b_water_freezing_curve) then

        write(igen,'(/a)') 'water freezing conductivity curve'
        write(igen,'(72a)')('-',i=1,72)
        write(igen,'(a,10x,a)') 'temperature °C','relative conductivity'

        if (.not. b_water_freezing_pts) then
          rtemp = water_freezing_curve_tempmin
          relcond = water_freezing_relcond_min
          write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond

          rdeltemp = (water_freezing_curve_tempmax -                   &
                      water_freezing_curve_tempmin)/20.0
          do i = 1, 19
            rtemp = water_freezing_curve_tempmin+rdeltemp*i
            relcond = relcond_freezing(rtemp,r0)
            write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond
          end do

          rtemp = water_freezing_curve_tempmax
          relcond = water_freezing_relcond_max
          write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond
        else
          if (ntemp == 1) then
            write(igen,'(1pe15.6e3,6x,1pe15.6e3)') water_freezing_pts(1,1:2)
          else if (ntemp >= 2) then
            rdeltemp = (water_freezing_pts(ntemp,1) -                   &
                        water_freezing_pts(1,1))/20.0
            do i = 1, 21
              rtemp = water_freezing_pts(1,1)+rdeltemp*(i-1)
              relcond = relcond_freezing(rtemp,r0)
              write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond
            end do
          end if
        end if

      end if

      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file in initcpvs, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
