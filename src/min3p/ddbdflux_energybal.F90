!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/ddbdflux_energybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function ddbdflux
!c ------------------------
!c
!c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!c have to add storage here ...... for transient conditions
!c i.e. do local mass balance ....(only needed for seepage face in case 
!c switching bewteen types)
!c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!c compute water flux across boundary control volumes
!c calculates water volume flux (not water mass flux)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - October 22, 2002
!c
!c last modified:   Tom Henderson - January 30, 2003
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           ddbdflux           = water flux across boundary face     * + 
!c
!c           integer*4:
!c           ----------
!c           ivol               = pointer to current control volume   + -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           relperm(nn)        = relative permeability               + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  + -
!c
!c           integer*4:
!c           ----------
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           iups(ncon-1)       = upstream pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           upstream           = .true.  -> upstream weighting       + -
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c                                'free-drainage' = free-drainage
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + -  
!c           viscosity(nn)      = fluid viscosity                     + -
!c           dvolcoef           = volume flux coefficient             + -
!c                                (viscosity, relative k)
!c                                viscosity, and relative 
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c        
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control 
!c                                volumes)
!c           icon               = counter (off-diagonal 
!c                                connections)
!c           iend               = pointer (end)
!c           istart             = pointer (start) 
!c           ivolvs             = pointer (control volume)
!c           jvol               = pointer (column in 1d-scalar 
!c                                matrix)
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit
!c                                search
!c
!c external: fluxdd    = water flux at interface for density
!c                       dependent flow
!c ----------------------------------------------------------------------
 
      real*8 function ddbdflux_energybal(ivol,rho_ivol,   &
                                        visco_ivol)
 
      use parm
      use gen
      use dens
      use phys, only : is_cell_based_relp
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols,num_edge_maxcells
      use gradient_usg, only : gradient_cross_diff_dd
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxdd_usg, only : fluxdd_usg
#endif

      implicit none
      
      integer :: ivol
      real*8 :: rho_ivol, visco_ivol      
      
      real(type_r8)    :: rho_av_loc
      real(type_r8)    :: vsflux_loc
      real(type_r8)    :: dcoef_loc
     
      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1 = 1.0d0,      &
                           r2 = 2.0d0, r3 = 3.0d0

      integer :: i1, i2, icon, ibvs, istart, iend, jvol
      real*8 :: delp_dd, delz_dd, relperm_av, visco_av
      
      real*8, external :: fluxdd

#ifdef USG
      integer :: icell, idvol, ndvol, kvol, ncell, nrelp
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_ddflow_locs(num_crossdifficv_max),           &
                     grad_ddflow_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif

      ddbdflux_energybal = r0             !initialize boundary flux
      ibvs = 0
      
      ibvs = ivol2bvs(ivol)
      if (ibvs == 0) then
        return    
      end if
      

!      if (ibvs==0) then
!        if(rank == 0 .and. b_enable_output) then
!          write(ilog,*) ' warning .....................'
!          write(ilog,*) ' no water flux across boundary'
!          write(ilog,*) ' execution stopped'          
!          !write(igen,*) ' warning .....................'
!          !write(igen,*) ' no water flux across boundary'
!          !write(igen,*) ' execution stopped'
!          write(*,*) ' warning .....................'
!          write(*,*) ' no water flux across boundary'
!          write(*,*) ' execution stopped'
!        end if
!#ifdef PETSC
!          call petsc_mpi_finalize
!#endif
!          stop
!      end if

!c  fluxes at first type control volumes or zero pressure seepage
!c  control volumes

      if ((btypevs(ibvs).eq.'first').or.           & !first type (Dirichlet)
         ((btypevs(ibvs).eq.'seepage'.or.          &
           btypevs(ibvs).eq.'seepage-second').and. & !first type (seepage)
           ibits(seepage_bits(ibvs),0,1).eq.1)) then

        istart = iavs(ivol)+1     !pointer - start of row
        iend = iavs(ivol+1)-1     !pointer - end of row
        icon = 0                  !counter (connections)

        do i1=istart,iend         !loop over connections

          jvol = javs(i1)         !column pointer
          icon = icon+1           !counter (connections)

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          delp_dd = uvsnew(jvol) - uvsnew(ivol)
          delz_dd = zg(jvol) - zg(ivol)

          if (delz_dd .ne. r0) then
            rho_av_loc = rhalf * (rho_ivol + density(jvol))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total 
            if (av_dens_z) then
               delp_dd=rho_av_loc*                   &
                      (uvsnew(jvol)/density(jvol)-   &
                       uvsnew(ivol)/rho_ivol)
            end if


            delz_dd = delz_dd * rho_av_loc * gacc

            delp_dd = delp_dd + delz_dd

          end if
                
!c  assign coefficients for upstream weighting
!c calculate water volume (not mass!!) fluxes
!cprovi-----------------------------------------------------------                   
!cprovi We have changed this 
!cprovi-----------------------------------------------------------

          if (is_cell_based_relp) then
            if (delp_dd > r0) then
              visco_av = ups_heat*viscosity(jvol)+   &
                          (r1-ups_heat)*visco_ivol
            else
              visco_av = ups_heat*visco_ivol+        &
                          (r1-ups_heat)*viscosity(jvol)
            end if
            dcoef_loc = 1.0 / visco_av
          else
            if (delp_dd > r0) then
              relperm_av = ups_heat*relperm(jvol)+   &
                          (r1-ups_heat)*relperm(ivol)
              visco_av = ups_heat*viscosity(jvol)+   &
                          (r1-ups_heat)*visco_ivol
            else
              relperm_av = ups_heat*relperm(ivol)+   &
                          (r1-ups_heat)*relperm(jvol)
              visco_av = ups_heat*visco_ivol+        &
                          (r1-ups_heat)*viscosity(jvol)
            end if

            dcoef_loc = relperm_av / visco_av
          end if
!cprovi-----------------------------------------------------------                   
!cprovi-----------------------------------------------------------                   
!cprovi-----------------------------------------------------------
          if (b_use_fixed_flow_vel) then
              
            if (b_use_zero_flow_vel) then
              vsflux_loc = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
            if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_ddflow_mids = vector_zero
              flux_ddflow_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_dd(i1,ivol,jvol,              &
                              grad_ddflow_locs,grad_ddflow_mids,       &
                              grad_weights,flux_ddflow_hls_corr,       &
                              grad_ddflow_hls_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 > 0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = 1.0d0
              end if

              vsflux_loc = -fluxdd_usg(delp_dd,num_edge_dvols,ncell,               &
                                   grad_ddflow_mids(1:num_edge_dvols,1:ncell),     &
                                   flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell), &
                                   cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                                   cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell), &
                                   is_cell_based_relp,nrelp,                       &
                                   relps_loc(1:nrelp)*dcoef_loc)
            else
#endif

              vsflux_loc = - fluxdd(delp_dd,cinfvs_a(i1),dcoef_loc)
#ifdef USG
            end if
#endif
          end if

!c  water volume (not mass!) flux calculations

          ddbdflux_energybal = ddbdflux_energybal + vsflux_loc

        end do                    !loop over connections

!c  fluxes at specified flux control volumes

      elseif ((btypevs(ibvs).eq.'second') .or.        &
              (btypevs(ibvs).eq.'free-drainage') .or. &
              (btypevs(ibvs).eq.'point') .or.         &
              (btypevs(ibvs).eq.'seepage-second' .and.&
              ibits(seepage_bits(ibvs),1,1).eq.1)) then

        ddbdflux_energybal = bcondvs(ibvs)

      end if                      
 
      return
      end
