!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/mbal_mcd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mbal_mcd
!c -----------------
!c mass balance (reactive transport)
!c
!c written by:      Uli Mayer - September 5, 96
!c
!c last modified:   Uli Mayer - July 26, 01
!c                  Uli Mayer - November 12, 01
!c                  added new database format
!c                  for dissolution-precipitation reactions
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   - 
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third and mixed 
!c                                type b.c.       -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (gaseous phase)
!c                                third and mixed 
!c                                type b.c.       -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for + -
!c                                diffusive mass fluxes across
!c                                boundary (excluding diffusion 
!c                                coefficient)
!c           cinfrt_da(njavs)   = influence coefficients              + -
!c                                (dispersion - aqueous phase)
!c           cinfrt_va(njavs)   = influence coefficients              + -
!c                                (advection - aqueous phase)
!c           hhead(nn)          = hydraulic head                      + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species
!c           gbrt(ng,nbrt)      = gas concentrations in boundary      + -
!c                                control volumes
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           gold(ng,nn)        = gas concentrations                  + -
!c                                - old time level [moles / l air]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           cmold(nm,nn)       = mineral concentrations              + -
!c                                - old time level [moles/l bulk]]
!c           cculabsbal(n)      = accumulative absolute mass balance  + +
!c                                error for dissolved species 
!c                                [moles/elapsed time]
!c           cmculabsbal(n)     = accumulative absolute mass balance  + +
!c                                error for minerals 
!c                                [moles/elapsed time]
!c           cculrelbal(n)      = accumulative relative mass balance  + +
!c                                error for dissolved species [%]
!c           cmculrelbal(n)     = accumulative relative mass balance  + +
!c                                for minerals [%]
!c           gculabsbal(ng)     = accumulative absolute mass balance  + +
!c                                error for gaseous species
!c                                [moles/elapsed time]
!c           gculrelbal(ng)     = accumulative relative mass balance  + +
!c                                error for gaseous species [%]
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = current time step                   + -
!c           dpdiff(nc+nm-1)    = source-sink term due to phase       * * 
!c                                exchange with minerals 
!c           dpdiffp(ndr*nm)    = individual source-sink terms due    * *
!c                                to parallel dissolution-
!c                                precipitation reactions
!c           cfluxin(n)         = mass gain due to inflow in water    * *
!c                                phase in terms of total aqueous
!c                                component concentrations
!c           cfluxout(n)        = mass loss due to outflow in water   * *
!c                                phase in terms of total aqueous
!c                                component concentrations
!           cfluxin_diff(n)    = mass gain due to diffusion in water  
!                                phase in terms of total aqueous 
!                                component concentrations
!           cfluxout_diff(n)   = mass loss due to diffusion in water 
!                                phase in terms of total aqueous
!                                component concentrations
!           cfluxin_mig(n)     = mass gain due to electrochemical    
!                                migration in water phase in terms  
!                                of total aqueous component 
!                                concentrations
!           cfluxout_mig(n)    = mass loss due to electrochemical    
!                                migration in water phase in terms  
!                                of total aqueous component 
!                                concentrations
!c           contaqtot(naq)     = contribution of intra-aqueous       + +
!c                                kinetic reactions to mass balance
!c                                [moles/elapsed time]
!c           contmintot(nm)     = contribution of dissolution-        + +
!c                                precipitation reactions to mass
!c                                balance [moles/elapsed time]
!c           gfluxtbdy(ng)      = mass flux across boundary           * *
!c                                (gaseous phase)
!c           gfluxin(n)         = mass gain due to inflow in air      * *
!c                                phase in terms of total gaseous
!c                                component concentrations
!c           gfluxout(n)        = mass loss due to outflow in air     * *
!c                                phase in terms of total gaseous
!c                                component concentrations
!c           ordiff(n)          = global source-sink term due to      * *
!c                                oxidation-reduction reactions
!c           intradiff(n)       = global source-sink term due to      * *
!c                                intra-aqueous kinetic reactions
!c           pornew(nn)         = porosity                            + -
!c           ratemdp(nm,nn)     = absolute dissolution-precipitation  + -
!c                                rates of minerals
!c           cstordiff(nc+nm-1) = change in storage in terms of total * *
!c                                aqueous component concentrations
!c           gdegas(n)          = mass loss from aqueous phase due to * *
!c                                degassing 
!c           gstordiff(n)       = change in storage in terms of total * *
!c                                gaseous component concentrations
!c           phi(nm,nn)         = volume fractions of minerals        + -
!c           phiold(nm,nn)      = volume fractions of minerals        + -
!c                                (old time level)
!c           rateaqtot(naq)     = total rate of intra-aqueous kinetic * * 
!c                                reaction in solution domain
!c                                [moles/day]
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           sbdiff(n)          = source-sink term due to phase       * *
!c                                exchange with sorbed phase
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            + -
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             + +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c
!c           totcnew(nc-1,nn)   = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totcold(nc-1,nn)   = total aqueous component             + -
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgnew(nc-1,nn)   = total gaseous component             + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totgold(n,nn)      = total gaseous component             + -
!c                                concentrations
!c                                - old time level [moles/l air]
!c           tmass(n)           = total mass in aqueous and gaseous   + -
!c                                phase in terms of total component
!c                                concentrations [moles] 
!c           time_io            = current solution time (I/O units)   + -
!c           totmdp(nc-1,nn)    = total source/sink term towards      + -
!c                                total aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c           totcflux(n)        = total mass fluxes (aqueous phase)   * *
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * *
!c           totsold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              + -
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              + -
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           totcfluxin(nc)     = total mass gain due to inflow in    + +
!c                                auqueous phase in terms of total
!c                                aqueous component concentrations
!c           totcfluxout(nc)    = total mass loss due to inflow in    + +
!c                                aqueous phase in terms of total
!c                                aqueous component concentrations
!c           totcstordiff(nc)   = total change in storage in          + +
!c                                aqueous phase in terms of total
!c                                aqueous component concentrations
!c           totordiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to oxidation/reduction
!c                                reactions
!c           totintradiff(nc)   = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to intra-aqueous kinetic 
!c                                reactions
!c           totdpdiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to dissolution-precipitation 
!c                                reactions
!c           totdpdiffp(ndr*nm) = individual contribution of parallel + +
!c                                reaction pathways of dissolution-
!c                                precipitation reactions to mass
!c                                balance [moles/elapsed time]
!c           totgdegas(nc)      = total mass loss from aquoeus phase  + +
!c                                due to degassing
!c           totgdiff(nc)       = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to gas dissolution-esolution
!c                                reactions
!c           totgfluxin(nc)     = total mass gain due to inflow in    + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totgfluxout(nc)    = total mass loss due to inflow in    + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totgstordiff(nc)   = total change in storage in          + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totsbdiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to sorption or ion-exchange
!c                                reactions
!c
!c
!c           integer*4:
!c           ----------
!c           i2up(nn)           = pointer array to second upstream    + -
!c                                point
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           idbg               = unit number - debugging file        + -
!c           imcd               = unit number, mass balance -         + -
!c                                             reactive transport
!c           jabrt(nbrt)        = pointer array - boundary conditions + -
!c                                (reactive transport)
!c           l_time_unit        = length of time unit for output      + -
!c           m_time             = current time step                   + -
!c           nbrt               = number of specified boundary        + -
!c                                control volumes
!c           nn                 = total number of control volumes     + -
!c
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (specified dispersive flux, 
!c                                            free mass outflux for aqueous
!c                                            phase, free exit)
!c                                'third'  = Cauchy
!c                                           (specified dispersive and advective flux, 
!c                                            for aqueous phase)
!c                                'third-evap'
!c                                         = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase, for outflux,
!c                                            use closed boundary for transport,
!c                                            like evaporation)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c                            'mixed-evap' = mixed-evap
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and gaseous phase,
!c                                            for outflux, use closed boundary
!c                                            for transport for aqueous phase,
!c                                            like evaporation)
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c
!c chem.f:   real*8:
!c           -------
!c           acth2omin          = min. activity for h2o               + -
!c           adav               = coefficient for Davies equation     + -
!c           bdav               = coefficient for Davies equation     + -
!c           dhac(nc)           = debye-huckel a for free species     + -
!c           dhad(nthreads)     = Debye Huckel constant a_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhax(nx)           = debye-huckel a for secondary        + -
!c                                aqueous species
!c           dhbc(nc)           = debye-huckel b for free species     + -
!c           dhbd(nthreads)     = Debye Huckel constant b_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhbx(nx)           = debye-huckel b for secondary        + -
!c                                aqueous species
!c           rateaq(naq,nthreads)
!c                              = reaction rates of intra-aqueous     * *
!c                                kinetic reaction
!c           rateg(ng,nthreads) = degassing rates                     * *
!c           rateor(nr,nthreads)= oxidation-reduction rate for        * *
!c                                redox couple [moles/(l h2o*day)
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           totaq(nc-1,nthreads)
!c                              = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           totor(nc-1)        = total source/sink term towards      * *
!c                                aqueous component concentrations
!c                                due to oxidation-reduction
!c                                reactions [moles/(l bulk*day)]
!c           totrateg(nc-1)     = total rate for removal of aqueous   * *
!c                                components due to degassing
!c                                [mol L^-1 s^-1]
!c
!c           logical:
!c           --------
!c           gas_removal        = .true.  -> degassing of dissolved   + -
!c                                           gases, if confining
!c                                           pressure exceeded
!c           new_database       = .true.  -> use new database format  + -
!c           noncompetitive_sorption = logical array for activation   + -  
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           integer*4:
!c           ----------
!c           l_namec(nc)        = length of component names           + -
!c           naq                = number of intra-aqueous kinetic     + -
!c                                reactions
!c           nc                 = number of components                + -
!c           nx                 = number of secondary species         + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c           nameaq(naq)        = names of intra-aqueous kinetic      + -
!c                                reactions
!c           namec(nc)          = component names                     + -
!c           namem(nm)          = mineral names                       + -
!c           sorption_group     = 'ion-exchange'
!c                                'surface-complexation'
!c                                'undefined'
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c local:    real*8:
!c           -------
!c           absbalance         = absolute mass balance in 
!c                                [moles/timestep]
!c           bdyinfrt_da        = boundary influence coefficient 
!c                                for diffusive mass flux (aqueous
!c                                phase)
!c           bdyinfrt_dg        = boundary influence coefficient 
!c                                for diffusive mass flux (gaseous
!c                                phase)
!c           conv3              = conversion factor [l/m^3]
!c           diff_eff           = effective diffusion coefficient
!c           r0                 = constant
!c           r100               = constant
!c           relbalance         = relative mass balance in %
!c           totvsflux          = total water flux across boundary
!c
!c           integer*4:
!c           ----------
!c           iaq                = counter (intra-aqueous kinetic
!c                                         reactions)
!c           ibrt               = counter (source control volumes)
!c           ic                 = counter (components)
!c           im                 = counter (minerals)
!c           ir                 = counter (redox couples)
!c           ivol               = counter (control volumes)
!c
!c external: acoff     = compute activity coefficient
!c           bdryflux  = compute water flux across boundary control 
!c                       volumes
!c           bulkconc  = convert from [moles/l water] to
!c                       [moles/l bulk]
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           diffcoff  = compute effective diffusion coefficient
!c           fluxv     = advective flux
!c           fluxd     = diffusive/dispersive flux
!c           molconc   = compute average molar concentration for
!c                       organic mixture
!c           msysrt    = compute total system mass (reactive 
!c                       transport) 
!c           rategas   = compute degassing rates
!c           rateint   = compute rate for intra-aqueous kinetic
!c                       reactions
!c           rateint_new   = compute rate for intra-aqueous kinetic
!c                       reactions (new database format)
!c           ratemin   = compute dissolution-precipitation
!c                       rate for mineral phase
!c           ratemin_new   = compute dissolution-precipitation
!c                       rate for mineral phase (new database format)
!c           rateredx  = compute total oxidation-reduction rates 
!c                       for redox couples 
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totint    = compute total source-sink terms towards
!c                       total aqueous component concentrations
!c                       due to intra-aqueous reactions
!c           totredx   = compute total source/sink term towards total 
!c                       aqueous component concentrations due to
!c                       oxidation-reduction reactions or derivative 
!c                       thereof
!c           zero_r8   = clear real*8 array
!c ----------------------------------------------------------------------
  
      subroutine mbal_mcd

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use phys
      use chem
      use writeversion
      use file_utility, only : reposition_file
      use mod_diffcoff, only : diffcoff
      use multidiff, only: cinfrt_mcd
      use biol !HG for rwu mass balance 28 Mar 2019

#ifdef OPENMP
      use omp_lib 
#endif
#ifdef USG
      use math_common
      use geometry
      use mod_fluxd_usg
      use usg_mesh_data, only : num_edge_dvols,num_edge_maxcells,      &
                                num_nodes_per_cell
                                
      use gradient_usg, only : gradient_cross_diff_rt,                 &
                               gradient_cross_diff_md,                 &
                               gradient_cross_diff_rt_average
      use usg_face_utility, only : usg_face_utility_cinfrt_da,         &
                                   usg_face_utility_cinfrt_mcd
#endif
      use module_binary_mpiio, only : binary_write_data

#ifdef OPENMP
      use omp_lib 
#endif 

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: i1, ibrt, ic, ivol, istart, iend, imb, jvol,irecord,  &
                 idim, tid
      
      real*8 :: totvsflux, bdyinfrt_da, diff_eff, diff_loc
      real*8, external :: bulkconc, bdryflux, fluxd 

      real*8 :: rdummys(17)
      
!c root water uptake varaibles (HG 28 Mar 2019)
      real*8 :: rootdiff(n)
      real*8 :: qrootloc, roottmp, trtmp
      
#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif

      external acoff, comptotc, msysrt, zero_r8
      
!c root water uptake mass balance addition (HG 28 Mar 2019)
      real*8, external :: rootwat

      real*8, external :: pressure_melt_k

#ifdef USG
      integer :: icell, idvol, kvol, ncell, ndvol
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_totcnew_hls_corr(num_edge_dvols,num_edge_maxcells),       &
                flux_totviscnew_hls_corr(num_edge_dvols,num_edge_maxcells),    &
                flux_electro_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_totcnew_locs(num_crossdifficv_max),                  &
                     grad_totviscnew_locs(num_crossdifficv_max),               &
                     grad_electro_locs(num_crossdifficv_max),                  &
                     grad_totcnew_ivol(n), grad_totcnew_jvol(n),               &
                     grad_totviscnew_ivol(n), grad_totviscnew_jvol(n),         &
                     grad_electro_ivol(n), grad_electro_jvol(n),               &
                     grad_totcnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_totviscnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_electro_kvol(n,num_nodes_per_cell,num_edge_maxcells)

      type(point) :: grad_totcnew_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_totviscnew_mids(num_edge_dvols,num_edge_maxcells),   &
                     grad_electro_mids(num_edge_dvols,num_edge_maxcells)

      type(grad_hls_term) :: grad_totcnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_totviscnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_electro_hls_loc(n,num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_da_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_da_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_mcd_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_mcd_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      type(point) :: grad_cgg_totcnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_totviscnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_electro(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_totgnew(n,num_edge_dvols,num_edge_maxcells)
#endif

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0,r100 = 100.0d0,      &
                           conv3 = 1.0d3
      
      integer :: nvarsimcd
      
!cdsu added for dgm model
      real*8 :: so_av

!c  zero arrays
 
      call zero_r8(totcflux_diff,n,1,1)  
      call zero_r8(totcflux_mig,n,1,1)  
      call zero_r8(cfluxin_diff,n,1,1)  
      call zero_r8(cfluxin_mig,n,1,1)  
      call zero_r8(cfluxin,n,1,1)  
      call zero_r8(cfluxout_diff,n,1,1)  
      call zero_r8(cfluxout_mig,n,1,1)  
      call zero_r8(cfluxout,n,1,1)
      call zero_r8(cstordiff,n,1,1)
      call zero_r8 (rootdiff,n,1,1) 

!c  compute total system mass at current time step
 
      call msysrt
 
!c  compress total aqueous component concentration vector and
!c  total gaseous component concentration vector for mass 
!c  balance calculations

      if (redox_equil.and.nr.gt.0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mcd_1)                          &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)   
    !$omp do schedule(static)
#endif   
        do ivol = 1,nngl
          call comptotc(totcnew(1,ivol))
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif        
      end if

!c  calculate mass balance for water phase in terms of total 
!c  aqueous component concentrations [moles/unit time]

!c  flux contributions
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mcd_2)                          &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(                                                    &
#ifdef USG
    !$omp icell, idvol, kvol, ncell, ndvol,                           &
    !$omp grad_totcnew_mids, grad_totviscnew_mids, grad_electro_mids, &
    !$omp grad_totcnew_locs, grad_totviscnew_locs,                    &
    !$omp grad_electro_locs, grad_weights,                            &
    !$omp flux_totcnew_hls_corr, flux_totviscnew_hls_corr,            &
    !$omp flux_electro_hls_corr,                                      &
    !$omp grad_totcnew_ivol, grad_totcnew_jvol, grad_totcnew_kvol,    &
    !$omp grad_totviscnew_ivol, grad_totviscnew_jvol,                 &
    !$omp grad_totviscnew_kvol,                                       &
    !$omp grad_electro_ivol, grad_electro_jvol, grad_electro_kvol,    &
    !$omp grad_totcnew_hls_loc, grad_totviscnew_hls_loc,              &
    !$omp grad_electro_hls_loc,                                       &
    !$omp cinfrt_da_usg_loc, cinfrt_da_usg_cross_loc,                 &
    !$omp cinfrt_mcd_usg_loc, cinfrt_mcd_usg_cross_loc,               &
    !$omp grad_cgg_totcnew, grad_cgg_totviscnew, grad_cgg_electro,    &
    !$omp grad_cgg_totgnew,                                           &
#endif
    !$omp i1, ibrt, ic, iend, istart, ivol, jvol, idim, tid,          &
    !$omp delta_totviscnew, delta_electromignew,                      &
    !$omp qrootloc, so_av, diff_eff, diff_loc, bdyinfrt_da,           &                                         
    !$omp totcflux, totvsflux)                                        &
    !$omp reduction(+:totcflux_diff, totcflux_mig, rootdiff,          &
    !$omp cfluxin_diff, cfluxin_mig, cfluxin,                         &
    !$omp cfluxout_diff, cfluxout_mig, cfluxout)
    !$omp do schedule(static)
#endif
      do ibrt = 1,nbrt                 !boundary control volumes
          
        ivol = jabrt(ibrt)             !pointer to control volume
        if (ivol < 0) then
          cycle
        end if

        if (compute_ice_sheet_loading) then
          if (.not. b_jabrt_ice(ibrt)) then
            cycle
          end if
        end if


#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif

#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif

!c  Dirichlet type boundary conditions

        if (btypert(ivol).eq.'first') then

          istart = iavs(ivol)+1 
          iend = iavs(ivol+1)-1

          do i1 = istart,iend        !loop over local connections

#ifdef USG
            if (discretization_type > 0) then
              ncell = janumcell(i1)
            end if
#endif

            jvol = javs(i1)

! cdsu -------------------------------------------------------
! cdsu gradient reconstruction for reactive transport
! cdsu -------------------------------------------------------
#ifdef USG
            if (discretization_type > 0 .and.                          &
                any(component_type .eq.'aqueous', 1) ) then
              if (b_use_cross_diffusion_react) then
                if (multi_diff) then
                  call gradient_cross_diff_md(i1,ivol,jvol,            &
                       grad_totviscnew_ivol,grad_totviscnew_jvol,      &
                       grad_totviscnew_kvol,grad_electro_ivol,         &
                       grad_electro_jvol,grad_electro_kvol,            &
                       grad_totviscnew_hls_loc,grad_electro_hls_loc,   &
                       grad_cgg_totviscnew,grad_cgg_electro)
                else
                  call gradient_cross_diff_rt(i1,ivol,jvol,n,totcnew,  &
                       grad_totcnew_ivol,grad_totcnew_jvol,            &
                       grad_totcnew_kvol,grad_totcnew_hls_loc,         &
                       grad_cgg_totcnew)
                end if
              end if

              call usg_face_utility_cinfrt_da(ivol,jvol,i1,            &
                       cinfrt_da_usg_loc,cinfrt_da_usg_cross_loc)

              if (multi_diff) then
                call usg_face_utility_cinfrt_mcd(ivol,jvol,i1,         &
                         cinfrt_mcd_usg_loc,cinfrt_mcd_usg_cross_loc)
              end if
            end if
#endif

            if (multi_diff) then
              call totdyvisc(ivol,jvol,cnew(:,ivol),cx(:,ivol),        &
                             cnew(:,jvol),cx(:,jvol),                  &
                             delta_totviscnew(:,tid))

              call elecmigration(ivol,jvol,cnew(:,ivol),cx(:,ivol),    &
                                 cnew(:,jvol),cx(:,jvol),              &
                                 delta_electromignew(:,tid))
            end if

            do ic=1,n              !loop over components

              if (component_type(ic).eq.'aqueous') then

!!!!!! For now Advective flux is neglected !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   !ToDo
                
                if (multi_diff) then 
                   
#ifdef USG
                  if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                    grad_totcnew_mids = vector_zero
                    grad_totviscnew_mids = vector_zero
                    grad_electro_mids = vector_zero
                    flux_totcnew_hls_corr = r0
                    flux_totviscnew_hls_corr = r0
                    flux_electro_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_totviscnew_ivol,grad_totviscnew_jvol, &
                           grad_totviscnew_kvol,grad_totviscnew_hls_loc,   &
                           grad_weights,grad_totviscnew_locs,              &
                           grad_totviscnew_mids,flux_totviscnew_hls_corr,  &
                           grad_cgg_totviscnew)
  
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_electro_ivol,grad_electro_jvol,       &
                           grad_electro_kvol,grad_electro_hls_loc,         &
                           grad_weights,grad_electro_locs,                 &
                           grad_electro_mids,flux_electro_hls_corr,        &
                           grad_cgg_electro)
                    end if

                    totcflux_diff(ic) = totcflux_diff(ic) - conv3 *                    &  !Diffusive Flux
                        fluxd_usg(r0,delta_totviscnew(ic,tid),                         & !diffusive term
                              num_edge_dvols,janumcell(i1),                            &
                              grad_totviscnew_mids(1:num_edge_dvols,1:janumcell(i1)),     &
                              flux_totviscnew_hls_corr(1:num_edge_dvols,1:janumcell(i1)), &
                              cinfrt_mcd_usg_loc(1:num_edge_dvols,1:janumcell(i1)),    &
                              cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1)))

                    totcflux_mig(ic) = totcflux_mig(ic) - conv3 *                      &  !Electromigration Flux
                        fluxd_usg(r0,delta_electromignew(ic,tid),                      & !electromigration term
                              num_edge_dvols,janumcell(i1),                            &
                              grad_electro_mids(1:num_edge_dvols,1:janumcell(i1)),     &
                              flux_electro_hls_corr(1:num_edge_dvols,1:janumcell(i1)), &
                              cinfrt_mcd_usg_loc(1:num_edge_dvols,1:janumcell(i1)),    &
                              cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1)))
                  else
#endif
                    totcflux_diff(ic) = totcflux_diff(ic) - conv3*             &
                                        fluxd(r0,delta_totviscnew(ic,tid),     & !diffusive term
                                              cinfrt_mcd(i1))
                    totcflux_mig(ic) = totcflux_mig(ic) - conv3*               &
                                        fluxd(r0,delta_electromignew(ic,tid),  & !electromigration term
                                              cinfrt_mcd(i1))
#ifdef USG
                  end if
#endif
                       
                  totcflux(ic) = totcflux_diff(ic) + totcflux_mig(ic)
                  
                else
#ifdef USG
                  if (discretization_type > 0) then
                    grad_totcnew_mids = vector_zero
                    flux_totcnew_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_totcnew_ivol,grad_totcnew_jvol,       &
                           grad_totcnew_kvol,grad_totcnew_hls_loc,         &
                           grad_weights,grad_totcnew_locs,                 &
                           grad_totcnew_mids,flux_totcnew_hls_corr,        &
                           grad_cgg_totcnew)
                    end if

                    totcflux_diff(ic) = totcflux_diff(ic) - conv3 *                    &  !Diffusive Flux
                       (fluxd_usg(totcnew(ic,ivol),totcnew(ic,jvol),                   &
                              num_edge_dvols,janumcell(i1),                            &
                              grad_totcnew_mids(1:num_edge_dvols,1:janumcell(i1)),     &
                              flux_totcnew_hls_corr(1:num_edge_dvols,1:janumcell(i1)), &
                              cinfrt_da_usg_loc(1:num_edge_dvols,1:janumcell(i1)),     &
                              cinfrt_da_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1))))
                  else
#endif
                    totcflux_diff(ic) = totcflux_diff(ic) - conv3 *    &    !Diffusive Flux
                                         (fluxd(totcnew(ic,ivol),      &
                                          totcnew(ic,jvol),            &
                                          cinfrt_da(i1)))                
#ifdef USG
                  end if
#endif
                  totcflux(ic) = totcflux_diff(ic)

                end if

              end if
   
            end do                   !loop over components

          end do                       !loop over local connections

!c  Neumann, Cauchy or mixed type boundary conditions

        else

!c  compute water flux axcross boundary

          totvsflux = bdryflux(ivol) 

!c  total mass fluxes across Neumann type boundary control volumes
 
          if (btypert(ivol).eq.'second') then

            do ic = 1,n
              if (component_type(ic).eq.'aqueous') then
                totcflux(ic) = conv3 * totvsflux          &    !advective flux
     &                       * totcnew(ic,ivol)
              end if
            end do

!c  total mass fluxes across Cauchy type boundary control volumes

          elseif (btypert(ivol).eq.'third' .or.            &
                  btypert(ivol).eq.'third-evap') then
            if (b_fluxd_bcond(ivol)) then      
              diff_eff = r0
              diff_loc = r0
              so_av=dmin1(r1, sonew(ivol))  
              if (type_diff_ic_coeff == 0) then
                diff_loc = diff_a
              else if (type_diff_ic_coeff > 0) then
                idim = diff_brt_dim(ibrt)
                if (idim == 1) then
                  diff_loc = diff_a_tensor%xx
                else if (idim == 2) then
                  diff_loc = diff_a_tensor%yy
                else if (idim == 3) then
                  diff_loc = diff_a_tensor%zz  
                end if
              end if

              diff_eff = diffcoff(diff_loc,sanew(ivol),pornew(ivol),     &
                                  tortuosity_corr,assigned_tau,          &
                                  tau(ivol)*tau_fac(ivol),               &
                                  type_tortuosity,marchies(ivol),so_av,  &
                                  tor_corr_a_mq, tor_corr_b_mq)     
              bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
              if(b_water_freezing) then
                if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                  bdyinfrt_da = bdyinfrt_da*frozen_diff_a
                end if
              end if 
            end if

!cbdy-start
            if (totvsflux.gt.0) then
!cbdy-end
!cbdy - flux enters domain

              do ic = 1,n
                if (component_type(ic).eq.'aqueous') then
                  if (b_fluxd_bcond(ivol)) then
                    totcflux(ic) = conv3 *                             &
                                   (totvsflux * bcondrt_a(ic,ibrt) +   &     !advective flux
                                    fluxd(totcnew(ic,ivol),            &     ! diffusive flux
                                          bcondrt_a(ic,ibrt),          &
                                          bdyinfrt_da))
                  else
                    totcflux(ic) = conv3 *                             &
                                   totvsflux * bcondrt_a(ic,ibrt)            !advective flux
                  end if
                end if
              end do
!cbdy-start
!cbdy - flux leaves domain

            else
              
              do ic = 1,n
                if (component_type(ic).eq.'aqueous') then
                  if (btypert(ivol).eq.'third-evap') then                    !evaporation type, mass is retained
                    totcflux(ic) = conv3 * totvsflux * r0                    !advective flux
                  else
                    if (b_fluxd_bcond(ivol)) then
                      totcflux(ic) = conv3 *                           &
                                     (totvsflux * totcnew(ic,ivol) +   &     !advective flux 
                                      fluxd(totcnew(ic,ivol),          &     !diffusive flux
                                            bcondrt_a(ic,ibrt),        &
                                            bdyinfrt_da))
                    else
                      totcflux(ic) = conv3 *                           &
                                     totvsflux * totcnew(ic,ivol)            !advective flux
                    end if
                  end if
                end if
              end do

          end if

!cbdy-end

!c  total mass fluxes across mixed type boundary control volumes

        elseif (btypert(ivol).eq.'mixed' .or. btypert(ivol).eq.'mixed-evap') then
              
            diff_eff = r0
            diff_loc = r0
            so_av=dmin1(r1, sonew(ivol))  
            if (type_diff_ic_coeff == 0) then
              diff_loc = diff_a
            else if (type_diff_ic_coeff > 0) then
              idim = diff_brt_dim(ibrt)
              if (idim == 1) then
                diff_loc = diff_a_tensor%xx
              else if (idim == 2) then
                diff_loc = diff_a_tensor%yy
              else if (idim == 3) then
                diff_loc = diff_a_tensor%zz  
              end if
            end if

            diff_eff = diffcoff(diff_loc,sanew(ivol),pornew(ivol),     &
                                tortuosity_corr,assigned_tau,          &
                                tau(ivol)*tau_fac(ivol),               &
                                type_tortuosity,marchies(ivol),so_av,  &
                                tor_corr_a_mq, tor_corr_b_mq)     
            bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
            if(b_water_freezing) then
              if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                bdyinfrt_da = bdyinfrt_da*frozen_diff_a
              end if
            end if            
 
            do ic = 1,n
              if (component_type(ic).eq.'aqueous') then
                if (totvsflux > r0) then                                 ! influx
                  if (b_fluxd_bcond(ivol)) then
                    totcflux(ic) = conv3 *                             &
                                   (totvsflux * bcondrt_a(ic,ibrt) +   & ! advective flux
                                    fluxd(totcnew(ic,ivol),            & ! diffusive flux
                                          bcondrt_a(ic,ibrt),          &
                                          bdyinfrt_da))
                  else
                    totcflux(ic) = conv3 *                             &
                                   (totvsflux * bcondrt_a(ic,ibrt))      ! advective flux only
                  end if
                else if (totvsflux <= r0) then                           ! outflux
                  if (btypert(ivol).eq.'mixed-evap') then
                    totcflux(ic) = conv3 * totvsflux * r0 
                  else
                    if (b_fluxd_bcond(ivol)) then
                      totcflux(ic) = conv3 *                           &
                                     (totvsflux * totcnew(ic,ivol) +   & ! advective flux
                                      fluxd(totcnew(ic,ivol),          & ! diffusive flux
                                            bcondrt_a(ic,ibrt),        &
                                            bdyinfrt_da))
                    else
                      totcflux(ic) = conv3 *                           &
                                     (totvsflux * totcnew(ic,ivol))      ! advective flux only
                    end if
                  end if
                end if
              end if
            end do

          end if

!c mass flux due to root water uptake and solute uptake (HG 28 Mar 2019)
          if (passive_uptake) then 
            do ivol = 1,nngl 
              if (btypert(ivol).ne.'first') then 
                !c root uptake, positive means source and negative means sink here
                qrootloc = - cvol(ivol)*rootwat(sanew,ivol,rsum_vprop)
                if (rootwateruptake_field) then
                  qrootloc = qrootloc*uptakefactor_vol(ivol)
                else
                  qrootloc = qrootloc*uptakefactor(mpropvs(ivol))
                end if
                do ic = 1,n    
                  rootdiff(ic) = rootdiff(ic) + conv3 * qrootloc * totcnew(ic,ivol)
                end do 
              end if   
            end do     
          end if 

        end if                !boundary type (transport) 

!c  assign flux contributions

        do ic = 1,n
          if (component_type(ic).eq.'aqueous') then
            if (totcflux(ic).gt.r0 ) then
              if (btypert(ivol).eq.'first') then  
                cfluxin_diff(ic) = cfluxin_diff(ic) + totcflux_diff(ic)  !mass in
                cfluxin_mig(ic) = cfluxin_mig(ic) + totcflux_mig(ic)     !mass in
              end if
              cfluxin(ic) = cfluxin(ic) + totcflux(ic)                   !mass in
            else
              if (btypert(ivol).eq.'first') then  
                cfluxout_diff(ic) = cfluxout_diff(ic) - totcflux_diff(ic)!mass out
                cfluxout_mig(ic) = cfluxout_mig(ic) - totcflux_mig(ic)   !mass out
              end if

              if (btypert(ivol).eq.'mixed-evap') then
                !c 'mixed-evap' boundary, no mass out for aqueous phase
              else
                cfluxout(ic) = cfluxout(ic) - totcflux(ic)               !mass out
              end if
            end if
          end if
        end do

      end do                  !loop over boundary control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(cfluxin_diff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxin_diff(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(cfluxin_mig, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxin_mig(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(cfluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxin(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(cfluxout_diff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxout_diff(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(cfluxout_mig, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxout_mig(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(cfluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxout(1:n) = mpireduce_n(1:n) 

      call MPI_Allreduce(rootdiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      rootdiff(1:n) = mpireduce_n(1:n) 
#endif
 
!c  change in storage [moles/unit time]
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mcd_3)                          &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ic, ivol)                                           &
    !$omp reduction(+:cstordiff)
    !$omp do schedule(static)
#endif
      do ivol = 1,nngl
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif
        do ic = 1,n
          cstordiff(ic) = cstordiff(ic)                                &
                        + cvol(ivol)                                   &
                        * (bulkconc(totcnew(ic,ivol),                  &
                                    sanew(ivol),                       &
                                    pornew(ivol))                      &
                        -  bulkconc(totcold(ic,ivol),                  &
                                    saold(ivol),                       &
                                    porold(ivol)))
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif   

#ifdef PETSC
      call MPI_Allreduce(cstordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cstordiff(1:n) = mpireduce_n(1:n)
#endif

      cstordiff(1:n) = cstordiff(1:n) * conv3 / delt


!c  compute mass balance for selected species in aqueous phase
!c  only if selected species are specified
!c ----------------------------------------------------------------------

      imcd = imcd_first

      !c add code for masmcd output, code is missing here
      !c file creating for masmcd is disabled as output is not availabe

      if (nmb.gt.0) then

        imcd = imcd + 1

        !c add code for mssmcd output, code is missing here
        !c file creating for masmcd is disabled as output is not availabe

      end if


      do ic = 1,n

!c compute accumulative changes over time
        totcfluxin_diff(ic) = totcfluxin_diff(ic)     &
                            + cfluxin_diff(ic)*delt

        totcfluxin_mig(ic) = totcfluxin_mig(ic)     &
                            + cfluxin_mig(ic)*delt

        totcfluxin(ic) = totcfluxin(ic) + cfluxin(ic)*delt

        totcfluxout_diff(ic) = totcfluxout_diff(ic)     &
                             + cfluxout_diff(ic)*delt

        totcfluxout_mig(ic) = totcfluxout_mig(ic)     &
                             + cfluxout_mig(ic)*delt

        totcfluxout(ic) = totcfluxout(ic) + cfluxout(ic)*delt
        
        if(passive_uptake) then    ! HG passive uptake 28 Mar 2019
          totrootdiff(ic) = totrootdiff(ic) + rootdiff(ic)*delt
        end if
        

!c  write results
 
        imcd = imcd+1
        
        if(rank == 0 .and. b_enable_output) then
          if (b_output_trans_binary) then
            nvarsimcd = 17
            realbuffer_gb(1:nvarsimcd)=(/time_io,                      &
                                        cfluxin_diff(ic),              &
                                        cfluxin_mig(ic),               &
                                        cfluxin(ic),                   &
                                        cfluxout_diff(ic),             &
                                        cfluxout_mig(ic),              &
                                        cfluxout(ic),                  &
                                        cstordiff(ic),                 &
                                        rootdiff(ic),                  &
                                        totcfluxin_diff(ic),           &
                                        totcfluxin_mig(ic),            &
                                        totcfluxin(ic),                &
                                        totcfluxout_diff(ic),          &
                                        totcfluxout_mig(ic),           &
                                        totcfluxout(ic),               &
                                        totcstordiff(ic),              &
                                        totrootdiff(ic)/)
            call binary_write_data(imcd_mpi(imcd), 1,          &
                         (/mtime/),offset_imcd_ijk(imcd),.true.)
            call binary_write_data(imcd_mpi(imcd), nvarsimcd,  &
                         realbuffer_gb,offset_imcd(imcd),.true.) 

            offset_imcd(imcd) = offset_imcd(imcd) + nvarsimcd*nfloatbit
   
          else

            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imcd,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(imcd,irecord,time_io_rs)
                read(imcd,*,end=10,err=10) rdummys(1:17)
                !c reposition to the line to append results
                call reposition_file(imcd,irecord)

                totcfluxin_diff(ic) = totcfluxin_diff(ic) + rdummys(10)
                totcfluxin_mig(ic) = totcfluxin_mig(ic) + rdummys(11)
                totcfluxin(ic) = totcfluxin(ic) + rdummys(12)
                totcfluxout_diff(ic) = totcfluxout_diff(ic) + rdummys(13)
                totcfluxout_mig(ic) = totcfluxout_mig(ic) + rdummys(14)
                totcfluxout(ic) = totcfluxout(ic) + rdummys(15)
                totcstordiff(ic) = totcstordiff(ic) + rdummys(16)
                totrootdiff(ic) = totrootdiff(ic) + rdummys(17)
              end if
10            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imcd,ascii_fmt) time_io,                           &
                                        cfluxin_diff(ic),              &
                                        cfluxin_mig(ic),               &
                                        cfluxin(ic),                   &
                                        cfluxout_diff(ic),             &
                                        cfluxout_mig(ic),              &
                                        cfluxout(ic),                  &
                                        cstordiff(ic),                 &
                                        rootdiff(ic),                  &
                                        totcfluxin_diff(ic),           &
                                        totcfluxin_mig(ic),            &
                                        totcfluxin(ic),                &
                                        totcfluxout_diff(ic),          &
                                        totcfluxout_mig(ic),           &
                                        totcfluxout(ic),               &
                                        totcstordiff(ic),              &
                                        totrootdiff(ic)
            end if
          end if      
        end if
      
      end do   ! do ic

!c  absolute mass balance error [moles/time unit]
!c  relative mass balance error in [%] = [moles/moles in system] x 100
!c  accumulative mass balance error [moles]
!c  relative accumulative mass balance error in [%] = 
!c  [moles/moles in system] x 100
! 
!      do ic = 1,n
!        absbalance = (cfluxin(ic) - cfluxout(ic)
!     &             - cstordiff(ic))*delt
!        relbalance = dabs(absbalance)/tmass(ic)*r100
!        cculabsbal(ic) = cculabsbal(ic) + absbalance
!        cculrelbal(ic) = cculabsbal(ic)/tmass(ic)*r100
!        imcd = imcd+1
!
!        if (mtime.eq.1) then
!        write(imcd,'(3a)') 'title = "dataset ',prefix(:l_prfx),'"'
!          write(imcd,'(11a)') 'variables = "time [',
!     &            time_unit(:l_time_unit),']", ',
!     &           '"absolute mass balance error [mol]", ',
!     &           '"relative mass balance error ',
!     &           '[% of system mass]", ',
!     &           '"absolute cumulative mass balance error ',
!     &           '[mol] ", ',    
!     &           '"relative cumulative mass balance error ',
!     &           '[% of system mass]"' 
!          write(imcd,'(4a)') 
!     &              'zone t = "mass balance error for component ',
!     &           namec(ic)(:l_namec(ic)),' - ',
!     &           ' reactive transport", f=point'
!    end if
!
!        write(imcd,'(4(1pe15.6e3,4x))') time_io,absbalance,
!     &                                relbalance,cculabsbal(ic),
!     &                                cculrelbal(ic)
!      end do
!   
!c ----------------------------------------------------------------------

      return
      end
