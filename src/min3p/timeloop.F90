!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 880 $
!> $Author: dsu $
!> $Date: 2024-02-19 14:19:39 -0800 (Mon, 19 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/timeloop.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine timeloop
!c -------------------
!c
!c driver subroutine for transient flow and/or reactive transport
!c modified for optional density dependent flow simulation and 
!c picard iterations between solution of flow and transport/reaction
!c equations
!c
!c written by:      Uli Mayer - May 9, 96
!c
!c last modified:   Tom Henderson - March 3, 2004
!c                  Sergi Molins - May 2, 2006
!c                  added skip and nskip
!c                  intialize iupsg
!c                  Sergi Molins - June 7, 2006
!c                  added chemical_water
!c                  Sergi Molins - Jan 30, 2007
!c                  added restart option
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c                  Celine Blitz Frayret (CBF) for Frederic Gerard, december 14, 2018
!c            Update etp and canopy dependent parameters
!c            Update RLD
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c bbls.f:      real*8
!c           ------
!c           sanew_b(nn)         = water saturation prior to reactran and gasbub
!c                                   for convergence check of outer bubble loop
!c              cx_b(nx,nn)         = species concentrations prior to gasbub
!c                                   for convergence check of inner bubble loop
!c              c_update(nc,nn)     = component concentration at previous inner
!c                                   bubble iteration. 
!c          
!c           integer*4
!c               ---------
!c              ibub                 = counter for inner bubble iteration loop
!c              ibubflow             = counter for outer bubble iteration loop
!c            maxibub            = maximum number of inner iterations
!c            maxibubflow        = maximum number of outer iterations
!c          
!c           logical
!c               --------
!c              gas_bubbles         =.true. -> gas phase saturation       + -
!c                                            is calculated
!c                                             below the water table
!c            double_bubble           = .true. -> double bubble iterations
!c              bub_not_converged          = .true.-> inner bubble loop not converged
!c            bubflow_not_converged      = .true.-> outer bubble loop not converged
!c
!c gen.f:    real*8:
!c           -------
!c           area(nm,nn)        = mineral reactivity term             + -
!c                                (global system)
!c           cnew(nc,nn)        = concentrations of free species      + *
!c                                - new time level [moles/l water]
!c           cmnew(nm,nn)       = mineral concentrations              + +
!c                                - new time level [moles/l bulk]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cpuint             = cpu-time (intermediate) [seconds]   + +
!c           cx(nx,nn)          = concentrations of secondary aqueous + *
!c                                species [moles/l water]
!c           delt               = time step                           + -
!c           delt_io            = time step (I/O units)               + -
!c           delt_rt            = estimated time step                 * *
!c                                (reactive transport)
!c           delt_vs            = estimated time step                 * * 
!c                                (variably saturated flow)
!c           delt_courant       = estimated time step                 * *                
!c                                (courant target)
!c           deltmax            = maximum time step                   + -
!c           deltmin            = minimum time step                   + -
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients for aqueous   + -
!c                                species
!c           gnew(ng,nn)        = gas concentrations                  + *
!c                                - new time level [moles/l air]
!c           gs_tout(ngs)       = specified output times for          + -
!c                                contour data
!c           hhead(nn)          = hydraulic head                      + -
!c           phi(nm,nn)         = volume fractions of minerals        + *
!c           phiold(nm,nn)      = volume fractions of minerals        + *
!c                                - old time level
!c           pornew(nn)         = porosity                            + -
!c           qwater(nn)         = rate of water production/consumpt.  * +
!c                                due to geochemical reactions 
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                (new time level)
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tfinal             = final solution time                 + -
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           time               = current solution time               * +
!c           time_bcvs          = next read time for flow boundary    + + 
!c                                conditions
!c           time_io            = current solution time (I/O units)   * +
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           time_soi           = next read time for soil specific    + +
!c                                parameters
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           tsrc(ntsrc)        = target read times - transient       + -
!c                                source chemistry
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log file               + -
!c           idelt              = unit mumber, magnitude of current   + -
!c                                             time step
!c           idetail_rt         = information level                   + -
!c                                (reactive transport)
!c           idetail_vs         = information level                   + -
!c                                (variably saturated flow)
!c           igbb               = unit number, concentrations of      + -
!c                                sorbed species
!c           igbc               = unit number, free species and       + -
!c                                             secondary aqueous
!c                                             species concentrations
!c                                             - transient data
!c                                               global system
!c           igbac              = unit number, activity coefficient   + -
!c                                              - transient data
!c                                                global system
!c           igbd               = unit number, reaction rates for     + -
!c                                             dissolution-
!c                                             precipitation
!c                                             reactions
!c                                             - transient data
!c                                               global system
!c           igbg               = unit number, gas concentrations     + -
!c                                             - transient data
!c                                                global system
!c           igbg               = unit number, degassing rates        + -
!c                                             - transient data
!c                                                global system
!c           igbm               = unit number, master variables       + -
!c                                             - transient data
!c                                               global system
!c           igbi               = unit number, rates of intra-aqueous + -
!c                                             kinetic reactions
!c                                             - transient data
!c                                               global system
!c           igbs               = unit number, saturation indices     + -
!c                                             - transient data
!c                                               global system
!c           igbt               = unit number, total aqueous          + -
!c                                             component
!c                                             concentrations
!c                                             - transient data
!c                                               global system
!c           igbv               = unit number, mineral volume         + -
!c                                             fractions
!c                                             - transient data
!c                                             - global system
!c           igbx               = unit number, saturation indicea     + -
!c                                             (excluded minerals)
!c                                             - transient data
!c                                               global system
!c           igstime            = pointer to next output time for     + +
!c                                contour data
!c           itsolvtot_rt       = total number of solver              * +
!c                                iterations
!c                                (reactive transport)
!c           itsrc              = pointer to target read times for    + -
!c                                transient source chemistry
!c           ittot_rt           = total number of iterations          * +
!c                                (reactive transport)
!c           l_zone_name        = length of zone name                 * *
!c           mtime              = current time step                   * +
!c           mtime_f            = number of failed time steps         * +
!c           ngs                = number of output times for          + -
!c                                contour data
!c           ngb                = number of output locations for      + -
!c                                transient data
!c           ngb_step           = number of time steps between        + -
!c                                output of transient data
!c           ngb_tstep          = number of total time steps in       + -
!c                                output of transient data
!c           ngb_vol(ngb)       = control volume numbers for output   + -
!c                                of transient data
!c           nn                 = total number of control volumes     + -
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        * +
!c           iupsg(njavs)       = upstream node for gas transport     * +
!c
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           gb_output          = .true.  -> output of transient data + -
!c           gs_output          = .true.  -> output of contour data   + -
!c           mass_balance_vs    = .true.  -> compute mass balance     + -
!c                                           variably saturated flow  
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           reduce_timestep    = .true.  -> restart with reduced     + -
!c                                           timestep
!c           root_uptake        = .true.  -> calculate root water     + -
!c                                           uptake
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           transient_source   = .true.  -> transient source         + -
!c                                           chemistry
!c                                .false. -> constant source
!c                                           chemistry
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c           chemical_water     = .true.  -> account for production   + -
!c                                           or consumption of water
!c                                           due to geochemical 
!c                                           reactions in flow eq.
!c           root_uptake        = .true.  -> calculate root water     + -
!c                                           uptake CBF
!c           character:
!c           ----------
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c           update_activity_rt = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c           update_bcvs        = .true.  -> transient boundary       + -  
!c                                           condition for variably 
!c                                           saturated flow
!c           zone_name          = name of zone                        * *
!c
!c chem.f:   integer*4:
!c           ----------
!c           nc                 = number of components including h2o  + -
!c
!c           logical:
!c           --------
!c           temp_field         = .true.  -> nodal temperatures       + -
!c
!c dens.f:   real*8:
!c           -------
!c           delt_tds           = lagged time step for tds storage    - + 
!c                                derivative
!c           density(nn)        = fluid density                       + -
!c           densold(nn)        = fluid density from previous         * + 
!c                                iteration/time step
!c           integer*4:
!c           ----------
!c           msia               = total number of sequential          * +           
!c                                iterations
!c           maxit_sia          = maximum number of Picard iterations * -
!c           iter_sia           = iteration counter -Picard iteration * +  
!c           iter_target        = target number of Picard iterations  * -
!c           ts_sia             = picard iterations per time step     * +
!c 
!c           logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c phys.F90: integer*4:
!c         ----------
!c           nzn                = number of material property zones   + - CBF RLD
!c
!c biol.F90: real*8:
!c         ------
!c           time_soi           = next read time for soil specific    + +
!c           pure_evap          = .true.  -> pure evaporation 
!c                     (when root_uptake = false) CBF
!c         rootlengthdens(nzn)= root length density read from *.dat file CBF RLD
!c
!c           logical:
!c           --------
!c         coupled_as        = .true. -> update root length density by coupling with ArchiSimple root architecture software ! CBF RLD
!c         coupled_rt        = .true. -> update root length density by coupling with Root Typ root architecture software ! CBF RLD
!c         inside_rld        = .true. -> update root length density by a law in MIN3P CBF RLD
!c           rootlengthdens_field = .true. -> read root length density field CBF RLD
!c
!c local:    real*8:
!c           -------
!c           cpuint_old         = cputime (intermediate) [seconds]
!c           r0                 = constant
!c           r86400             = constant
!c           rhalf              = constant
!c           tiny               = tiny increment
!c           c_diff             = change in component concentration before and
!c                                after gasbub
!c           c_tol              = convergence tolerance for inner bubble loop
!c           sa_diff            = change in saturation in before and after gasbub
!c           sa_tol             = convergence tolerance for outer bubble loop
!c
!c           integer*4:
!c           ----------
!c           igb                = counter
!c           igb_step           = counter for output of transient 
!c                                data
!c           ibubreact_tol      = counter - convergence of inner bubble loop
!c           ibubflow_tol       = counter - convergence of outer bubble loop
!c
!c           izn                = counter (zones) CBF RLD
!c
!c external: mbalvs   = compute mass balance - variably saturated 
!c                      flow
!c           mbaldd   = compute mass balance - variably saturated 
!c                      density dependent flow
!c           nexttime = prepare for next time step
!c           outputvs = write contour data to output file for
!c                      postprocessing (variably saturated flow)
!c           outputdd = write contour data to output file for
!c                      postprocessing (density dependent flow)
!c           outputrt = write contour data to output file for 
!c                      postprocessing (reactive transport)
!c           reactran = driver subroutine for reactive transport
!c           updtbcvs = update boundary conditions for 
!c                      variably saturated flow
!c           updtbcdd = update boundary conditions for 
!c                      density dependent flow
!c           updtetp  = update etp and canopy dependent variables     CBF
!c          updtrootdensity = update root density field CBF RLD
!c           updtsoil = update soil specific parameters
!c           tcorr    = temperature correction for debye-huckel,
!c                      equilibrium and rate constants
!c           tprfrtlc = write transient data to output file for
!c                      postprocessing (reactive transport)
!c           tprfdd   = write transient data to output file for
!c                      postprocessing (density dependent 
!c                      flow parameters)
!c           tprfvs   = write transient data to output file for
!c                      postprocessing (flow parameters)
!c           tranflow = driver subroutine for transient flow
!c           trddflow = driver subroutine for transient 
!c                      density dependent flow
!c           tranunit = assign unit numbers for output of transient 
!c                      data
!c ----------------------------------------------------------------------

      subroutine timeloop

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use dens
      use phys
      use bbls
      use writeversion
      use math_common
      use serveParams
      use nobleGasIngrowth
      use mip_bubble, only : mip_mt_enable,mip_mt_not_converged,       &
                             mip_solver_input,mip_solver,              &
                             mip_solver_output
      use mip_output, only : mip_output_spatial,mip_output_transient
      use root_output, only : root_output_spatial,root_output_transient
      use file_unit, only : lun_get, lun_free
      use file_utility, only : find_append_time, reposition_file,      &
                               check_rewind_status
      use biol

#ifdef USG
      use geometry
      use usg_mesh_data, only : cvol_method, num_cells, CellCenter
      use usg_ice_sheet, only : usg_ice_compute_dpicedt,               &
                                ice_thickness_new, ice_thickness_old
#endif
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize, petsc_mpi_barrier
#endif

      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: tid, i, i1, igb, iprint, igb_step, ivol,              &
                 igs, igb_step_ijface, ngb_tstep_ijface, iter_vs_tot,  &
                 iter_rt_tot, ipest, istatus, ierrcode, ngb_tstep,     &
                 iunit, itid, itz, itz_stage, itz_start, itz_stop,     &
                 info_debug, delt_debug
      real*8 :: cputime, cpuint_old, bubm, drho_dc_saved,              &
                drho_dt_saved, time_init, tfinal_init,                 &
                dist, dist_min, dist_max,                              &
                delt_init, deltmin_io, tiny_delt
      real*8, external :: porosity_flow
      
#ifdef PETSC
      real*8 :: delta_pice_max_gbl
      real*8 :: rcm_totcvol_gbl(nzn)
#endif

      external updtetp, updtrootdensity, updtrootdensity_ext,          &              
               mbalvs, mbaldd, nexttime, outputvs, outputmech,         &
               outputdd, outputrt, reactran, tranbcrt,                 &
               tprfrtlc, tprfdd, tprfvs, tranflow, trddflow,           &
               tranunit, updtbcvs, updtbcdd, updtbcice, velodd,        &
               initfaceflux, tprfvs_faceflux, tprfrtlc_faceflux
               
#ifdef USG
      external infevap_usg, outputvs_usg, outputdd_usg, outputrt_usg,  &
               velodd_usg, outputice_usg, outputmech_usg
#endif

                                                                       
      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1 = 1.0d0,      &
                           r2 = 2.0d0, r86400 = 8.64d4,                &
                           tiny = 1.0d-300, bignum = 1.0d+30,          &
                           zerokelvin = 273.15d0, rd_16 = 1.0d-16,     &
                           rd_12 = 1.0d-12, rd_9 = 1.0d-9,             &
                           rd_10 = 1.0d-10, r365 = 3.65d2,             &
                           r3 = 3.0d0, r10 = 10.0d0

#ifdef PETSC
      integer :: ibubreact_tol_gbl, ibubflow_tol_gbl
#endif
     
      logical :: iserror
      !Flag to indicate if the current time step is reduced
      real(type_r8) :: cputime_start
      
      !Local variables
      character(256) :: str_filepath

      integer :: ibubreact_tol, ibubflow_tol, ic, im, izn, irecord
      integer :: iiz, niz, istart, iend, iskip

      real(type_r8) :: c_tol, c_diff, uvs_tol, uvs_diff, aentry_loc, rdummy

      real(type_r8) :: delta_pice, delta_pice_max, time_append, time_check
      
      logical :: b_rewind_valid, b_rld_update

      external tcorr

#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
      
      info_debug = 0
      delt_debug = 0

100   continue
      
!c  initialize time stepping and iteration parameters for 
!c  reactive transport 
      mtime = 0
      iter_sia = 0
      iter_seep = 0
      iter_vs = 0
      ittot_vs = 0

      msia = 0
      mtime_f = 0
      igb_step = 0
      ngb_tstep = 0
      igb_step_ijface = 0
      ngb_tstep_ijface = 0
      reduce_timestep = .false.

      time_append = r0

!cprovi----------------------------------------------------------
!cprovi Restart process
!cprovi 9/07/2009 
!cprovi this is based on Richard Amos implementation 
!cprovi----------------------------------------------------------
!cprovi  Parallelized, OpenMP, DSU
      rsrt_cnt=0

      deltmin_io = deltmin/time_factor
    
!c     initialize skip variable
      nskip_time = 0
!cc    skip = 10 ! hardwired

      if (restart_sim) then
        time_io_ini = time_io
        call restart_r       
        restart_sim = .false.

!c  use timestep saved in the restart file
        time=time_io*time_factor
        delt_vs = delt                                !- variably saturated flow
        delt_heat = delt                              !- heat transport
        delt_rt = delt                                !- reactive transport        
        delt_tds = delt                               !- tds
      end if

!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------

!c time-step limiting parameters set to arbitrary large values for 
!c simulations with constant density fluid or groundwater flow
!c verification problems

      sia_ts_mult = 0.05d0
      delt_sia = bignum     !arbitrary large number
      delt_courant = bignum !arbitrary large number

      if (reactive_transport) then
        ittot_rt = 0
        itsolvtot_rt = 0
        if (update_activity_rt.eq.'no_update') then
          update_activity(tid) = 'no_update'
        elseif (update_activity_rt.eq.'time_lagged') then
          update_activity(tid) = 'time_lagged'
        elseif (update_activity_rt.eq.'double_update') then
          update_activity(tid) = 'double_update'
        endif
      end if

      if(rank == 0) then      !if MPI rank 0
        if (b_enable_output) then  
          write(*,'(/1x,a)')'enter timeloop'
          write(*,'(1x,72a)')('-',i=1,72)
        end if
        if(.not. b_enable_output) then
            write(*,'(/1x,a)')'output is disabled, please wait ...'
        end if
        
        if (b_enable_output) then
          write(ilog,'(a)')'enter timeloop'
          write(ilog,'(72a)')('-',i=1,72)
        end if
        if(.not. b_enable_output) then
            write(ilog,'(/1x,a)')'output is disabled, please wait ...'
        end if
      end if                  !end if MPI rank 0

      tiny_delt = max(min((deltmax-deltmin)/r10,deltmin),tinytime_global)

!cdsu for steady state flow running in transient mode, mark the start time and final time
!cdsu and then revert them after steady state is achieved.
      if (tran_steady_flow) then
        delt_init = delt
        time_init = time
        tfinal_init = tfinal
        tfinal = 1.0d100
        if (tran_steady_drho_0) then
          !c density change caused by tds
          drho_dc_saved = drho_dc
          drho_dc = r0
          !c density change caused by temperature
          drho_dt_saved = drho_dt
          drho_dt = r0
        end if
      end if

!c  check if current timestep is controlled by transient maximum timestep
      i_transient_deltmax = 0
      if (n_transient_deltmax > 0) then
        do i = 1, n_transient_deltmax
          if (time >= transient_deltmax(1,i) .and. &
              time <= transient_deltmax(2,i)) then
            i_transient_deltmax = i
            exit
          end if
        end do
      end if

!c  output spatial data immediately after restart
      if (b_enable_output .and. gs_output .and. b_output_restart) then
             
        if(rank == 0) then  
!c  report to log file
          write(ilog,'(/a)') 'write contour data after restart'
          write(ilog,'(72a/)')('-',i=1,72) 

!c  report to screen
          write(*,'(/1x,a)') 'write contour data after restart'
          write(*,'(1x,72a/)')('-',i=1,72)          
        end if

        if(discretization_type == 0) then
          if (varsat_flow.and.transient_flow) then
            if (density_dependence) then
              call outputdd
            else
              call outputvs
            end if
          end if
          if (compute_ice_sheet_loading) then
            call outputmech
          end if
          if (reactive_transport) then
            call outputrt
          end if
#ifdef USG
        else
          if (varsat_flow.and.transient_flow) then
            if (density_dependence) then
              call outputdd_usg
            else
              call outputvs_usg
            end if
            if (compute_ice_sheet_loading) then
              call outputmech_usg
            end if
            if (compute_ice_sheet_loading .and. ice_sheet_type == 1) then
              call outputice_usg
            end if
          end if
          if (reactive_transport) then
            call outputrt_usg
          end if
#endif
        end if

        !c the following output is to be updated when usg capability is implemented 
        if (varsat_flow) then
          if (root_uptake) then
            call root_output_spatial  
          end if
        end if

        if (reactive_transport) then
          if (gas_bubbles.and.bubble_out) then                  
            call gasbub(.false., .true.) 
          end if
          if (mip_mt_enable) then
            call mip_output_spatial  
          end if
        end if  
        
        b_output_restart = .false.
      end if

!c  time loop
!c  exit time loop based upon final solution time

!c option look for file pest.stp, which will cause simulation to abort
      ipest = 0 !(0/1) -> 1 = activate PEST termination function
      do while (time.lt.tfinal)       !start time loop
         
        prt_timestep_tot = cputime()
        
        b_mpi_process_flag = .false.

        if (b_relax_timestep) then
          time_check = 1.0d300
        end if
        
        if(ipest .eq.1) then  
          if (rank == 0) then       !if MPI rank 0
            !iunit = 99  
            iunit = lun_get()
            open (iunit,file='../pest.stp',status='old',iostat=istatus)
            if(istatus .eq. 0) then
              write(ilog,'(a)')'execution halted due to pest.stp'
              close(iunit)
              open (iunit,file='pslave.fin',status='unknown') ! terminate slave
              write(iunit,'(a)') 'F'
              close(iunit)
            end if
            call lun_free(iunit)
          end if                    !end if MPI rank 0

#ifdef PETSC
          call MPI_BCAST(istatus, 1, MPI_INTEGER4, 0,                  &
                       Petsc_Comm_World, ierrcode)
          CHKERRQ(ierrcode)
#endif
          if(istatus .eq. 0) then
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
          
        end if

        mtime = mtime+1
        ts_sia = 0           !picard iterations per given time step
        
        b_rld_update = .false.
        
        if ((skip_time.gt.0).and.(nskip_time.lt.skip_time)) then
          nskip_time = nskip_time + 1
        else
          nskip_time = 0
        end if

!c  variable time stepping            
        if (mtime.eq.1) then
          if (varsat_flow.and.reactive_transport) then
!c           initialize iupsg variable 
!c           (updated after each N-R iteration, in reactran) 
            do i1 = 1,njavs
              iupsg(i1) = 'a'
            enddo
          
          endif
        end if

!c  check if current timestep is controlled by transient maximum timestep
        if (n_transient_deltmax > 0) then
          deltmax = deltmax_global
          if (i_transient_deltmax > 0) then
            !calculate maximum transient time step with linear interpolation
            deltmax = math_common_linear(transient_deltmax(1,i_transient_deltmax),   &
                                         transient_deltmax(2,i_transient_deltmax),   &
                                         transient_deltmax(3,i_transient_deltmax),   &
                                         transient_deltmax(4,i_transient_deltmax),   &
                                         time)
            if (time < transient_deltmax(1,i_transient_deltmax) .or. &
                time > transient_deltmax(2,i_transient_deltmax)) then
              i_transient_deltmax = 0
              do i = 1, n_transient_deltmax
                if (time >= transient_deltmax(1,i) .and. &
                    time <= transient_deltmax(2,i)) then
                  i_transient_deltmax = i
                  exit
                end if
              end do
              if (i_transient_deltmax > 0) then
                !calculate maximum transient time step with linear interpolation
                deltmax = math_common_linear(transient_deltmax(1,i_transient_deltmax),   &
                                             transient_deltmax(2,i_transient_deltmax),   &
                                             transient_deltmax(3,i_transient_deltmax),   &
                                             transient_deltmax(4,i_transient_deltmax),   &
                                             time)
              end if
            end if
          else
            if (time >= transient_deltmax(1,1) .and. &
                time <= transient_deltmax(2,n_transient_deltmax)) then
              i_transient_deltmax = 0
              do i = 1, n_transient_deltmax
                if (time >= transient_deltmax(1,i) .and. &
                    time <= transient_deltmax(2,i)) then
                  i_transient_deltmax = i
                  exit
                end if
              end do
              if (i_transient_deltmax > 0) then
                !calculate maximum transient time step with linear interpolation
                deltmax = math_common_linear(transient_deltmax(1,i_transient_deltmax),   &
                                             transient_deltmax(2,i_transient_deltmax),   &
                                             transient_deltmax(3,i_transient_deltmax),   &
                                             transient_deltmax(4,i_transient_deltmax),   &
                                             time)
              end if
            end if
          end if
        end if

        if (mtime.gt.1) then

!c  save previous time step length for tds storage derivative

          delt_tds = delt

!c calculate new time step length using Courant criteria and # of Picard iterations

          if (density_dependence) then  !available for DD flow only

            delt_courant = delt * courant_target / courant_max         

!c  limit time-step lengths when the the number of Picard iterations exceeds
!c the use-defined target.  This limiter deactivated by setting the target to
!c a large integer e.g. 100

            if (iter_sia .gt. iter_target) then
              delt_sia = (r1 - (sia_ts_mult * r2)) * delt 
            elseif (iter_sia .lt. iter_target) then
              delt_sia = bignum  !no time step control
            elseif (iter_sia .eq. iter_target) then
              delt_sia = (r1 + sia_ts_mult) * delt
            end if
          end if !(density_dependence)

          continue

!c  assign new time step for global simulation
!c  flow and reactive transport
!c  Courant criteria added July 14, 2003

!c  steady state flow running in transient mode
          if (varsat_flow .and. reactive_transport .and.               &
              (.not.tran_steady_flow)) then
            !cdsu for now, only variably saturated flow consider delt_vs in timestep calculation.  
            !cdsu remove variably_saturated below to consider delt_vs for full saturated flow.
            if (transient_flow.and.variably_saturated) then             
              delt = dmin1(delt_vs,delt_rt,delt_courant,delt_sia)              
              delt = dmax1(delt,deltmin)
            else
              delt = dmin1(delt_rt,delt_courant,delt_sia)
              delt = dmax1(delt,deltmin) 
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - b: ', delt
            end if

!c  steady state flow running in transient mode
          else if (varsat_flow .and. reactive_transport .and.          &
                   tran_steady_flow) then
            !cdsu consider delt_vs for both variably saturated flow and full saturated flow 
            !cdsu since delt_courant and delt_sia may not be calculated and delt_rt is not
            !cdsu during transient steady flow stage.
            if (transient_flow) then
              delt = dmin1(delt_vs,delt_courant,delt_sia)
              delt = dmax1(delt,deltmin)
            else
              delt = dmin1(delt_courant,delt_sia)
              delt = dmax1(delt,deltmin)
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - c: ', delt
            end if
!c  flow only

          elseif (varsat_flow.and.(.not.reactive_transport)) then
            if (transient_flow) then
              delt = delt_vs  
            else
              delt = delt     
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - d: ', delt
            end if

!c  reactive transport only

          elseif ((.not.varsat_flow).and.(reactive_transport)) then
            delt = delt_rt 
          else
            delt = delt_vs
          end if

          if (delt_debug > 0 .and. rank == 0) then
            write(*,*) 'delt - e: ', delt
          end if

!c  decoupled heat transport
          if (heat_transport .and. decoupled_type_vs_heat > 1) then
            delt = min(delt,delt_heat)
            delt = max(delt,deltmin)
          end if

          if (delt_debug > 0 .and. rank == 0) then
            write(*,*) 'delt - f: ', delt
          end if

!c  gas bubbles
          if (gas_bubbles) then
            if (ibub.gt.bub_exp.or.ibubflow.gt.bub_exp) then
              bubm = max0(ibub,ibubflow) 
              delt = delt*dmin1(1.0,bub_exp/bubm)
            end if
          end if

          if (delt_debug > 0 .and. rank == 0) then
            write(*,*) 'delt - g: ', delt
          end if

!cdsu MIP_MT model
          if (mip_mt_enable) then
            !c add time step control for MIP_MT model
          end if

!c  save controlling factor for time step length

          if (delt .eq. delt_vs) then
            ts_min = 'varsat'
          elseif (delt .eq. delt_rt) then
            ts_min = 'reactive'
          elseif (delt .eq. delt_courant) then
            ts_min = 'courant'
          elseif (delt .eq. delt_sia) then
            ts_min = 'picard'
          end if

          if (.not.gas_bubbles .and. .not.mip_mt_enable) then
!c  adjust time step to target read times for transient boundary conditions
!c  for variably saturated flow

            if (update_bcvs .and. .not.tran_steady_flow) then
              if (b_relax_timestep) then
                time_check = min(time_check,time_bcvs*time_factor)
              end if

              if ((time+delt>time_bcvs*time_factor .and.               &
                  (time_bcvs*time_factor-time>tiny_delt .or.           &
                  b_updtbc_min_timestep)) .or.                         &
                  (time+delt.lt.time_bcvs*time_factor+tiny_delt .and.  &
                  time+delt.gt.time_bcvs*time_factor-tiny_delt)) then
                delt = time_bcvs*time_factor-time
                delt = dmax1(delt, deltmin)
              end if
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - h: ', delt
            end if
         
!c  adjust time step to target read times for atmospheric parameters           
            if (evaporation.and.read_atm .and. .not.tran_steady_flow) then
              if (b_relax_timestep) then
                time_check = min(time_check,time_atm*time_factor)
              end if

              if ((time+delt.gt.time_atm*time_factor .and.             &
                  (time_atm*time_factor-time > tiny_delt .or.          &
                  b_updtbc_min_timestep)) .or.                         &
                  (time+delt.lt.time_atm*time_factor+tiny_delt .and.   &
                  time+delt.gt.time_atm*time_factor-tiny_delt)) then
                delt = time_atm*time_factor-time
                delt = dmax1(delt, deltmin)
              end if
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - i: ', delt
            end if

!c  adjust time step to target read times for transient boundary conditions
!c  for ice sheet model
            if (update_bcice .and. .not.tran_steady_flow) then              
              if (b_relax_timestep) then
                time_check = min(time_check,time_bcice*time_factor)
              end if

              if ((time+delt.gt.time_bcice*time_factor .and.           &
                  (time_bcice*time_factor-time > tiny_delt .or.        &
                  b_updtbc_min_timestep)) .or.                         &
                  (time+delt.lt.time_bcice*time_factor+tiny_delt .and. &
                  time+delt.gt.time_bcice*time_factor-tiny_delt)) then
                delt = time_bcice*time_factor-time
                delt = dmax1(delt, deltmin)
              end if
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - j: ', delt
            end if

!c  adjust time step to target read times for transient boundary conditions
!c  for ice sheet model
            if (update_ice_scalfac .and. .not.tran_steady_flow) then              
              if (b_relax_timestep) then
                time_check = min(time_check,time_ice_scalfac*time_factor)
              end if

              if ((time+delt.gt.time_ice_scalfac*time_factor .and.           &
                  (time_ice_scalfac*time_factor-time > tiny_delt .or.        &
                  b_updtbc_min_timestep)) .or.                         &
                  (time+delt.lt.time_ice_scalfac*time_factor+tiny_delt .and. &
                  time+delt.gt.time_ice_scalfac*time_factor-tiny_delt)) then
                delt = time_ice_scalfac*time_factor-time
                delt = dmax1(delt, deltmin)
              end if
            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - j2: ', delt
            end if

!c  adjust time step to target read times for updating soil specific
!c  parameters

            if (root_uptake .and. .not.tran_steady_flow) then
              if (b_relax_timestep) then
                time_check = min(time_check,time_soi*time_factor)
              end if

              if ((time+delt.gt.time_soi*time_factor .and.             &
                  (time_soi*time_factor-time > tiny_delt .or.          &
                  b_updtbc_min_timestep)) .or.                         &
                  (time+delt.lt.time_soi*time_factor+tiny_delt .and.   &
                  time+delt.gt.time_soi*time_factor-tiny_delt)) then
                delt = time_soi*time_factor-time
                delt = dmax1(delt, deltmin)
              end if

              if (delt_debug > 0 .and. rank == 0) then
                write(*,*) 'delt - k: ', delt
              end if

!c  check if the solution time exceeds the next root density update time
              if (rld_field_update .and. rld_update_index <= rld_update_num) then
                if (b_relax_timestep) then
                  time_check = min(time_check,rld_update_time(rld_update_index))
                end if

                if ((time+delt.gt.rld_update_time(rld_update_index) .and.            &
                    (rld_update_time(rld_update_index)-time > tiny_delt .or.         &
                    b_updtbc_min_timestep)) .or.                                     &
                    (time+delt.lt.rld_update_time(rld_update_index)+tiny_delt .and.  &
                    time+delt.gt.rld_update_time(rld_update_index)-tiny_delt)) then
                  delt = rld_update_time(rld_update_index)-time
                  delt = dmax1(delt, deltmin)
                  b_rld_update = .true.
                end if
              end if

              if (delt_debug > 0 .and. rank == 0) then
                write(*,*) 'delt - l: ', delt
              end if

            end if
          
          end if
         
        end if          !(mtime.gt.1)
        
        prt_timestep_nonlinear = 0.0

        goto 1000

!c  maximum number of iterations exceeded, time step guess was poor,
!c  reduce time step size 

999     continue

 
        time = time-delt
             
        mtime_f = mtime_f+1

        !c disable root length density update if current timestep is failed
        b_rld_update = .false.

        if (mtime > 1 .and. real(mtime_f,8)/real(mtime,8) > mtime_f_ratio) then
          if(rank == 0) then
            write(*,'(a)') 'failure in timeloop'
            write(*,'(a,1x,f4.1)') 'failed timestep ratio exceeds',mtime_f_ratio
            write(*,'(a)') 'bye now ...'

            write(ilog,'(72a)') ('-',i=1,72)
            write(ilog,'(a)') 'failure in timeloop'
            write(ilog,'(a,1x,f4.1)') 'failed timestep ratio exceeds',mtime_f_ratio
            write(ilog,'(a)') 'bye now ...'
          end if

          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(72a)') ('-',i=1,72)
            write(igen,'(a)') 'failure in timeloop'
            write(igen,'(a,1x,f4.1)') 'failed timestep ratio exceeds',mtime_f_ratio
            write(igen,'(a)') 'bye now ...'
          end if

#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if

!c automatic (constant) time step reduction for vs flow or reactive transport
!c timestep reduction for failed Picard iterations = total number
!c of coupling iterations / Picard iteration target

!c time step reduction based on non-convergence of flow or
!c transport/reaction solutions

        if (reduce_timestep) then
          !c  reset primary and secondary flow equation unknowns
          !c  Geochemical variables are reseted in reactran

          if (varsat_flow) then
            uvsnew = uvsold
          end if

          if (varsat_flow) then
            pornew = porold
          end if

          if (varsat_flow) then
            sanew = saold
          end if

          if (variably_saturated) then
            sgnew = sgold
          end if

!cdsu--------------------------------------------------------------
!cdsu note: for density dependent flow, densold2, tds_old2 and saold2 mean the value in the 
!cdsu previous timestep while densold, tds_old means the value in the previous picard iteration.
!cdsu-------------------------------------------------------------- 
          if (density_dependence) then
            density = densold2
            densold = densold2
            !densold1 = densold
            tds_new = tds_old2
            tds_old = tds_old2
            sanew = saold2
            saold = saold2
          end if

          if (heat_transport .and. ispitzerdens) then
            density_pitzer = densold2_pitzer
            densold_pitzer = densold2_pitzer
          end if

          if (heat_transport) then
            tempnew = tempold
          end if

          if (heat_transport .and. update_viscosity_temp) then
            viscosity = viscoold
          end if

          if (heat_transport .and. evaporation) then
            densvnew = densvold
            latvapnew = latvapold
          end if

          if (reactive_transport) then
            sionnew = sionold
            cnew(1:n,:) = c(1:n,:)
          end if

#ifdef USG
          if (compute_ice_sheet_loading .and. ice_sheet_type == 1) then
            ice_thickness_new = ice_thickness_old
          end if
#endif

          delt_tds = delt
          delt = rhalf*delt            !constant time step reduction
          reduce_timestep = .false.
          ts_sia = 0

          b_updtbc_recall = .true.

          if (delt_debug > 0 .and. rank == 0) then
            write(*,*) 'delt - m: ', delt
          end if

        end if


!c  correct total number of sequential iterations

        msia = msia - ts_sia
        
!c  emergency exit if time step becomes too small

1000    continue

        !c get the legacy append time from prefix_o.dt file when 'append results in legacy mode'
        !c is used. this is necessary to adjust the next timestep to avoid blips in transient output
        !c mtime_append is presetn to maximum integer*4 value
        if (mtime > 1 .and. mtime_append == 2147483647) then
          if (i_append_sim == 1) then
            if (time_io-time_io_rs > delt_io_rs) then
              mtime_append = mtime+1
            end if
          else
            if(b_enable_output) then
              if (rank == 0) then
                !c when prefix_o.dt exist, get time_append value from this file
                if (time_append > r0) then
                  if (time+delt-time_append*time_factor > tiny_delt) then
                    delt = min(time_append*time_factor-time,delt)
                    delt = dmax1(delt, deltmin)
                    mtime_append = mtime+1
                  end if
                else
                  !c when prefix_o.dt does not exist, use time step instead
                  if (mtime == backup_frequency) then
                    mtime_append = mtime+1
                  end if
                end if
              end if
#ifdef PETSC
              call MPI_BCAST(delt, 1, MPI_REAL8, 0,Petsc_Comm_World, ierrcode)
              CHKERRQ(ierrcode)

              call MPI_BCAST(mtime_append, 1, MPI_INTEGER4, 0,Petsc_Comm_World, ierrcode)
              CHKERRQ(ierrcode)
#endif
            end if
            if (delt < r0) then
              if (rank == 0) then
                write(*,*)'Error in appending results in legacy mode, please check'
                write(ilog,*)'Error in appending results in legacy mode, please check'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if
          end if
        end if

        if (delt_debug > 0 .and. rank == 0) then
          write(*,*) 'delt - n: ', delt
        end if

        b_mpi_process_flag = .false. 

        if (delt.lt.deltmin) then  
            
          if(rank == 0) then
              
            write(*,*)'no further time step reduction possible'
            write(*,*)'Optimal time increment computed by MIN3P',delt_io
            write(*,*)'Minimum time increment specified by user',deltmin_io
            write(*,*)'Please, reduce the MINIMUM TIME INCREMENT'
            write(*,*)"stop signal in time step reduction failed"
            
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(a)')'failure in timeloop'

!c  time step reduction for courant criteria
            if (courant_target .lt. courant_max) then
              write(ilog,'(a)')'courant criteria exceeded'
            end if
            
            write(ilog,'(a)')'no further time step reduction possible'
            write(ilog,'(a)')'bye now ...'
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(72a)')('-',i=1,72)
          
          end if 
          
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(a)')'failure in timeloop'
            if (courant_target .lt. courant_max) then
                write(igen,'(a)')'courant criteria exceeded'
            end if
            write(igen,'(a)')'no further time step reduction possible'
            write(igen,'(a)')'bye now ...'
          end if
                    
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
          
        end if

        time = time + delt                !new solution time

!cdsu  make sure transient time step range is not skipped
        if (n_transient_deltmax > 0) then
          do i = 1, n_transient_deltmax
            if (time-delt < transient_deltmax(1,i)-tiny_delt .and. &
                time > transient_deltmax(1,i)+tiny_delt) then
              i_transient_deltmax = i
              delt = delt - (time-transient_deltmax(1,i))
              time = transient_deltmax(1,i)
              !calculate maximum transient time step with linear interpolation
              deltmax = math_common_linear(transient_deltmax(1,i_transient_deltmax),   &
                                           transient_deltmax(2,i_transient_deltmax),   &
                                           transient_deltmax(3,i_transient_deltmax),   &
                                           transient_deltmax(4,i_transient_deltmax),   &
                                           time)
              exit
            else if (time-delt < transient_deltmax(2,i)-tiny_delt .and. &
                time > transient_deltmax(2,i)+tiny_delt) then
              i_transient_deltmax = i
              delt = delt - (time-transient_deltmax(2,i))
              time = transient_deltmax(2,i)
              !calculate maximum transient time step with linear interpolation
              deltmax = math_common_linear(transient_deltmax(1,i_transient_deltmax),   &
                                           transient_deltmax(2,i_transient_deltmax),   &
                                           transient_deltmax(3,i_transient_deltmax),   &
                                           transient_deltmax(4,i_transient_deltmax),   &
                                           time)
              exit
            end if
          end do
        end if

        if (delt_debug > 0 .and. rank == 0) then
          write(*,*) 'delt - o: ', delt
        end if

!c  make sure solution will be computed at specified output times
!c  check if the restart time is the same as the first output time
        if (b_relax_timestep) then
          time_check = min(time_check,gs_tout(igstime))
        end if

        if (b_check_restart_time .and. .not.tran_steady_flow) then
          !c skip output before the restart time
          do igs = 1, ngs
            !if (time-delt+tiny_delt > gs_tout(igstime)) then      !cdsu minimum timestep is applied
            if (time-delt > gs_tout(igstime)) then                 !cdsu minimum timestep is not applied and 
              igstime = igstime + 1                                !cdsu delt may be smaller than minimum timestep
            end if
          end do
          
          b_check_restart_time = .false.
        end if

        if ((time > gs_tout(igstime).and.                              &
            gs_tout(igstime)-time+delt > tiny_delt) .or.               &
            (time.lt.gs_tout(igstime)+tiny_delt .and.                  &
            time.gt.gs_tout(igstime)-tiny_delt)) then
          
          delt = delt+(gs_tout(igstime)-time)
          time = gs_tout(igstime)
        end if

        if (delt_debug > 0 .and. rank == 0) then
          write(*,*) 'delt - p: ', delt
        end if

!c  make sure solution time will be consistent with target read times for
!c  source chemistry
        if (transient_source .and. .not.tran_steady_flow) then
          if (b_relax_timestep) then
            time_check = min(time_check,tsrc(itsrc))
          end if

          if (time > tsrc(itsrc)+tiny_delt) then  
            delt = delt + (tsrc(itsrc)-time)
            time = tsrc(itsrc)
          end if  
        end if

        if (delt_debug > 0 .and. rank == 0) then
          write(*,*) 'delt - q: ', delt
        end if

!c  make sure solution time will be consistent with intermittent reaction of minerals.
!c  This feature is zone dependent. 
      if (flag_intermittent_react) then
        niz = size(iairm) - 1
        do iiz = 1, niz
          
          istart = iairt(iiz)
          iend = iairt(iiz+1)-1

          do i = istart, iend            
            if (time-delt < irt(i) .and. time > irt(i)) then
              delt = delt + (irt(i)-time)
              time = irt(i)
            end if
          end do

        end do
      end if

!c  make sure the solution will be consistent with the ice loading/unloading
!c  timeline, DSU
        if (compute_ice_sheet_loading .and. .not.tran_steady_flow) then
          !c find the initial ice loading/unloading stage
          if (mtime == 1 .and. icestage < 0 .and. nicestages < 0) then
            icestage = 0
            nicestages = size(icetimeline,2)
            if (nicestages > 0) then
              !c check if timeline is continuous
              do i = 1, nicestages-1
                if ((icetimeline(1,i+1)-icetimeline(2,i)>=tiny_delt).or.&
                    (icetimeline(2,i)-icetimeline(1,i)<=tiny_delt).or.  &
                    (icetimeline(2,nicestages)-                        &
                     icetimeline(1,nicestages)<=tiny_delt)) then
                  if (rank == 0) then
                    write(*,*) 'SIMULATION TERMINATED'
                    write(*,*) 'ice loading/unloading timeline is not correct'
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'ice loading/unloading timeline is not correct'
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
              end do

              !c convert unit to the same as internal timestep
              do i = 1, nicestages
                icetimeline(1,i) = icetimeline(1,i)*time_factor
                icetimeline(2,i) = icetimeline(2,i)*time_factor
              end do

              !c check the current stage
              if (time < icetimeline(1,1)) then
                icestage = 0
              else if (time > icetimeline(2,nicestages)) then
                icestage = nicestages + 1
              else
                do i = 1, nicestages
                  if (time >= icetimeline(1,i) .and.                   &
                      time < icetimeline(2,i)) then
                    icestage = i
                    exit
                  end if
                end do
              end if
            end if
          end if

          !c check if current time spans two stages
          if (icestage > 0 .and. icestage < nicestages + 1) then
            if (b_relax_timestep) then
              time_check = min(time_check,icetimeline(2,icestage))
            end if

            if (time >= icetimeline(2,icestage)) then
              delt = delt + (icetimeline(2,icestage)-time)
              time = icetimeline(2,icestage)
              icestage = icestage + 1

              if (idetail_vs > 0 .and. rank == 0 .and. b_enable_output) then
                write(*,*) " Adjust timestep for ice loading/unloading, icestage ",icestage
                write(ilog,*) " Adjust timestep for ice loading/unloading, icestage ",icestage
              end if

            end if

            if (delt_debug > 0 .and. rank == 0) then
              write(*,*) 'delt - r: ', delt
            end if
          end if
        end if
       
!cdsu check if the current time spans component-mineral recycle time period
        if ((passive_uptake .or. root_uptake) .and. nrcm_tz > 0) then
          ircm_stage = 0
          itz_start = max(ircm_tz-1,1)
          itz_stop = min(ircm_tz+1,nrcm_tz)

          do itz = itz_start, itz_stop
            do itz_stage = 1, 3
              if (time-delt < rcm_time(itz_stage,itz) .and.        &
                  time > rcm_time(itz_stage,itz)) then
                delt = delt + (rcm_time(itz_stage,itz)-time)
                time = rcm_time(itz_stage,itz)
                exit
              end if
            end do

            if (time > rcm_time(1,itz) .and. time <= rcm_time(3,itz)) then
              !c reset the value in current cycle for component-mineral recycle
              if (ircm_tz /= itz .or. ircm_tz_restart) then
                
                if (.not.ircm_tz_restart) then
                  totrcm_c_tz(:) = r0
                  totrcm_m_tz(:) = r0
                  totrcm_c_nz(:,:) = r0
                end if

                ircm_tz_restart = .false.
                ircm_tz = itz

                !c calculate leaf reclying zone
                rcm_totcvol = r0
                rcm_flag_cvol = 0

                do izn = 1, nzn
                  if (rcm_zone_type(izn) == 1) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)
    !$omp do schedule(static)
#endif                                  
                    do ivol = 1, nngl
                      if (xg(ivol) >= rcm_zone(1,itz,izn) .and.        &
                          xg(ivol) <= rcm_zone(2,itz,izn) .and.        &
                          yg(ivol) >= rcm_zone(3,itz,izn) .and.        &
                          yg(ivol) <= rcm_zone(4,itz,izn) .and.        &
                          zg(ivol) >= rcm_zone(5,itz,izn) .and.        &
                          zg(ivol) <= rcm_zone(6,itz,izn)) then
                        if (flag_overlap_rcm) then
                          rcm_flag_cvol(ivol) = ibset(rcm_flag_cvol(ivol),izn-1)
                        else
                          rcm_flag_cvol(ivol) = 2**(izn-1)
                        end if
                      end if
                    end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                  else if (rcm_zone_type(izn) == 2) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, dist, dist_min, dist_max)
    !$omp do schedule(static)
#endif 
                      do ivol = 1, nngl
                        if (zg(ivol) >= rcm_zone(3,itz,izn) .and.        &
                            zg(ivol) <= rcm_zone(4,itz,izn)) then
                          dist = (xg(ivol)-rcm_zone(1,itz,izn))**2+      &
                                 (yg(ivol)-rcm_zone(2,itz,izn))**2
                          dist_min = rcm_zone(5,itz,izn)**2
                          dist_max = rcm_zone(6,itz,izn)**2
                          if (dist >= dist_min .and. dist <= dist_max) then
                            if (flag_overlap_rcm) then
                              rcm_flag_cvol(ivol) = ibset(rcm_flag_cvol(ivol),izn-1)
                            else
                              rcm_flag_cvol(ivol) = 2**(izn-1)
                            end if
                          end if
                        end if
                      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                  end if
                end do
                
                do izn = 1, nzn
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                                               &
    !$omp reduction(+:rcm_totcvol)
    !$omp do schedule(static)
#endif                                  
                  do ivol = 1, nngl
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif
                    if (ibits(rcm_flag_cvol(ivol),izn-1,1) > 0) then
                      rcm_totcvol(izn) = rcm_totcvol(izn) + cvol(ivol)
                    end if
                  end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                end do
                
#ifdef PETSC
                call MPI_Allreduce(rcm_totcvol, rcm_totcvol_gbl,nzn,   &
                          MPI_REAL8,MPI_SUM, Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
                rcm_totcvol = rcm_totcvol_gbl
#endif                
              end if
              
              if (time > rcm_time(1,itz) .and. time <= rcm_time(2,itz)) then
                ircm_stage = 1
              else
                ircm_stage = 2
              end if
            end if            
          end do
        end if
     
!cprovi------------------------------------------------------------------------
!cprovi Check the time increment 
!cprovi------------------------------------------------------------------------ 
        b_mpi_process_flag = .false. 

        if (delt<=r0) then
          if (rank == 0) then  
            write(*,*) 'SIMULATION TERMINATED'
            write(*,*) 'computed time increment delt <= 0'
            write(*,*) "stop signal in time increment delt <= 0"          
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'computed time increment delt <= 0'
          end if
                    
#ifdef PETSC
          call petsc_mpi_finalize
#endif  
          stop        
        end if

!cprovi------------------------------------------------------------------------                
!cprovi------------------------------------------------------------------------               
!cprovi------------------------------------------------------------------------        
!c  convert current solution time and time step to I/O units

        if (b_relax_timestep) then
          if (time_check > time .and. time_check < time + 0.1*delt) then                        
            delt = delt*0.5d0
            time = time - delt
          end if
        end if

        if (delt_debug > 0 .and. rank == 0) then
          write(*,*) 'delt - s: ', delt
        end if

!c  check if the new timestep should be the last timestep
        if ((time<tfinal .and. tfinal-time<min(deltmax-deltmin,deltmin)) .or.  &
             time>tfinal) then
          delt = delt + (tfinal-time)
          time = tfinal
        end if

        if (delt_debug > 0 .and. rank == 0) then
          write(*,*) 'delt - t: ', delt
        end if

        time_io = time/time_factor
        delt_io = delt/time_factor
        
!cdsu Update boundary condition here because temperature and uvsnew is reset to 
!cdsu the value of old timestep, which is not consistent with the updated 
!cdsu boundary condition. Only flow and heat boundary condition is required.
!cdsu fix bug here by Danyang Su on May 22, 2020 
        if (b_updtbc_recall) then

!cdsu update boundary conditions for variably saturated flow      
          if (update_bcvs .and. .not.tran_steady_flow) then
            if (density_dependence) then
              call updtbcdd
            else 
              call updtbcvs
            end if
          end if

!cdsu update boundary conditions for heat transport 
          if (update_bcheat .and. .not.tran_steady_flow) then
            call updtbcenergybal
          end if

!c update transient dispersivity
          if (reactive_transport .and. update_disprt .and.             &
              .not. tran_steady_flow) then
            call updtdisprt
          end if

          b_updtbc_recall = .false.
        end if


!cprovi----------------------------------------------------
!cprovi Ice sheet loading/unloding is computed
!cprovi----------------------------------------------------        
!c  update the boundary conditions 

        if (compute_ice_sheet_loading .and. .not.tran_steady_flow) then
          if (density_dependence) then
              
            !Parallelized, OpenMP, DSU
            call comp_bc_ice_sheet

            if (reduce_timestep) then
              goto 999
            end if

            if (compute_permafrost.and.permeability_field) then
              if (useAnisoCondCorr .or. type_cond_perm == 2) then
                perm_tensor = perm0_tensor
              else if (type_cond_perm == 1) then
                permx=permx0
                permy=permy0
                permz=permz0
              end if
              !Parallelized, OpenMP, DSU
              if (ice_sheet_type == 0) then
#ifdef USG
                if (discretization_type > 0 .and.                      &
                    is_cell_based_perm_cond) then
                  call modify_for_permafrost_ (ice_sheet,permx,        &
                          permy,permz,num_cells,time_io,               &
                          CellCenter(:)%x,CellCenter(:)%z,             &
                          numofthreads_global, numofloops_thred_global,&
                          iserror)
                else
#endif
                  call modify_for_permafrost_ (ice_sheet,permx,        &
                          permy,permz,nngl,time_io,xg,zg,              &
                          numofthreads_global, numofloops_thred_global,&
                          iserror)
#ifdef USG
                end if
#endif
              else if (ice_sheet_type == 1) then
#ifdef USG
                !c use freezing/thawing model to modify hydraulic conductivity
                !c or permeability, no modification is required here
#endif
              end if

              if (iserror) then
                if(rank == 0) then
                  write(*,*) 'Error when update for permafrost'
                  write(*,*) "stop signal in update for permafrost"
                end if

#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

              end if 
            end if
          end if 
        end if  
        
       
!cprovi------------------------------------------------------------------------ 
!cprovi------------------------------------------------------------------------ 
!cprovi------------------------------------------------------------------------ 
!cprovi------------------------------------------------------------------------
!cdsu bug here, this may cause boundary update of reactive transport one timestep
!cdsu earlier than it should be. Moved after current timestep.
!cdsu fix on May 31, 2019. Danyang Su
!cdsu ------------------------------------------------------------------------
      !if ((transient_source .or. transient_source_function) .and.      &
      !    (.not. tran_steady_flow)) then
      !
      !  if (transient_source) then
      !    if (itsrc.le.ntsrc.and.abs(tsrc(itsrc)-time).le.tinytime_global) then
      !      call tranbcrt(tid)
      !      itsrc = itsrc + 1
      !      if (itsrc.gt.ntsrc) then
      !        tsrc(itsrc) = tfinal+tinytime_global
      !      end if
      !    end if
      !  else if (transient_source_function) then
      !    call tranbcrt(tid)
      !  end if
      !
      !  if (update_activity_rt.eq.'no_update') then
      !   update_activity(tid) = 'no_update'
      !  elseif (update_activity_rt.eq.'time_lagged') then
      !    update_activity(tid) = 'time_lagged'
      !  elseif (update_activity_rt.eq.'double_update') then
      !    update_activity(tid) = 'double_update'
      !  endif
      !
      !end if

!c  calculate rate coefficient for intermittent reaction of minerals. 
      call serveParams_irm

!c  sequential iterative coupling between flow and transport/reaction equations
!c  Picard iterative loop begins here
!c  ---------------------------------------------------------------------------

      not_converged_sia = .true.
      iter_sia = 0
      
      b_mpi_process_flag = .false.

      if ((.not.density_dependence).or.(flow_verification)) then
        maxit_sia = 1
      end if
            
      
      if (density_dependence) then
          
        b_mpi_process_flag = .false.

        !c  allocate mask for porosities
        modify_por=.true.
        if (nbvs>0) then
          modify_por(abs(iabvs(1:nbvs)))=.false.
        end if

        if (compute_ice_sheet_loading  .and. .not.tran_steady_flow) then

          delta_pice = 0.0d0
          delta_pice_max = 0.0d0


#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_timeloop_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, iserror, delta_pice)
    !$omp do schedule(static) lastprivate (delta_pice_max)
#endif 
          do ivol=1,nngl
            !cprovi--------------------------------------------------------
            !cprovi--------------------------------------------------------
            !cprovi--------------------------------------------------------
            if(.not. b_mpi_process_flag) then

              !por_stress(ivol) = por_stress(ivol) + por_stress_dt(ivol)
              !important note: por_stress is acculumative here, 
              !need to be added to the restart file when restart is used.

              if (ice_sheet_type == 0) then
                call compute_dpicedt_ (ice_sheet,por_stress_dt(ivol),  &
                        time_io-delt_io,time_io,xg(ivol),              &
                        stor(ivol),r1,skempton(ivol),                  &
                        loading_factor(ivol),'pressure',iserror)
              else if (ice_sheet_type == 1) then
#ifdef USG
                call usg_ice_compute_dpicedt(ivol,stor(ivol),          &
                             skempton(ivol),loading_factor(ivol),      &
                             por_stress_dt(ivol),gacc)
                iserror = .false.
#endif
              end if

              if (iserror) then
                if(rank == 0) then
                  write(*,*) 'Error when call service compute_dpicedt_'
                  write(*,*) "stop signal in call service compute_dpicedt_"
                  write(ilog,*) 'Error when call service compute_dpicedt_'
                  close(ilog)
                end if
                b_mpi_process_flag = .true.
              end if
            end if

            if(.not. b_mpi_process_flag) then
               ! Compute first approximation for porosity
               ! Only make sense if vertical stress is computed
               ! because pak+1 = pak
               if (modify_por(ivol)) then
                   pornew(ivol)=porosity_flow(porold(ivol),uvsnew(ivol),&
                                              uvsold(ivol),stor(ivol),  &
                                              por_stress_dt(ivol),      &
                                              por_init(ivol),facpormin)
               end if
            end if

          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
        end if

#ifdef PETSC
        iserror = b_mpi_process_flag
        call MPI_Allreduce(iserror, b_mpi_process_flag,1,MPI_LOGICAL,  &
                           MPI_LOR,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
#endif

        if(b_mpi_process_flag) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
            
      end if

      
      cputime_start = cputime()

#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(*,'(a, 3(1x, i4), 1x, l1)')                            &
                "rank, iter_sia, maxit_sia, not_converged_sia ",       &
                rank, iter_sia, maxit_sia, not_converged_sia
        end if
      end if
#endif
       
      iter_vs_tot = 0
      iter_rt_tot = 0

      do while ((iter_sia .lt. maxit_sia) .and. (not_converged_sia))
          
        prt_nonlinear_tot = cputime()

!c ts_sia = number of Picard iterations since last successful time step 

!c iter_sia = number of Picard iterations in current time step

!c msia = cumulative number of coupling iterations for all successful
!c time steps 

        iter_sia = iter_sia + 1
        ts_sia = ts_sia + 1
        msia = msia + 1     

!c  write run specific information to log file
        if(rank == 0 .and. b_enable_output .and.                      &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then

          if (idetail_vs.gt.0 .and. transient_flow .or.               &
            idetail_rt.gt.0) then
                                                                       
            write(ilog,'(/72a)')('-',i=1,72)                           
            write(ilog,'(a,i8,1x,a,1pe15.6e3,1x,a7,1x,a,1pe15.6e3,    &
      &                  1x,a7,1x,a,i3)')                             &
                  'timestep:',mtime,'time:',time_io,time_unit,        &
                                    'delt:',delt_io,time_unit,        &
                                    'picard iter:',iter_sia
            write(ilog,'(72a/)')('-',i=1,72)
                                                                       
          elseif (idetail_vs.eq.0 .and. transient_flow .or.           &
                  idetail_rt.eq.0) then
                                                                       
            write(ilog,'(1x,a,i8,1x,a,1pe15.6e3,1x,a7,1x,a,1pe15.6e3, &
      &             1x,a7,1x,a,i3)')                                  &
                'timestep:',mtime,'time:',time_io,time_unit,          &
                                  'delt:',delt_io,time_unit,          &
                                  'picard iter:',iter_sia
          end if

!c  write run specific information to screen

          write(*,'(/1x,a,i8,1x,a,1pe15.6e3,1x,a7,1x,a,1pe15.6e3,     &
       &            1x,a7,1x,a,i3)')                                  &
                'timestep:',mtime,'time:',time_io,time_unit,          &
                                  'delt:',delt_io,time_unit,          &
                                  'picard iter:',iter_sia
        end if                  !end if MPI rank 0
        
        prt_nonlinear_flow = cputime()
        
        

!c  store current densities and compute change in porosity by vertical stress 
!c  cdsu add tds_old and densold_pitzer here, previous version only has denold here only.
        if (density_dependence) then
          !densold1 = density
          tds_old = tds_new
          densold = density
        end if

        if (heat_transport .and. ispitzerdens) then
          densold_pitzer = density_pitzer
        end if
        
!c_bubbles if not gas_bubbles then go to tranflow and reactran only
!c  transient flow
        if (.not.gas_bubbles .and. .not.mip_mt_enable) then
            
          ibub=1
          ibubflow=1
           
          if (varsat_flow.and.transient_flow) then              
              
            if (density_dependence) then
               if (heat_transport) then      
!cprovi---------------------------------------------------------------
!cprovi Compute the influence coefficient for dispersive fluxes
!cprovi It is updated for the velocities
!cprovi---------------------------------------------------------------
                 if(discretization_type == 0) then
                   !infheat_d is parallelized, OpenMP, DSU
                   call infheat_d(nvxgl,nvygl,nvzgl,iavs,javs,isymvs,  &
                                  cinfheat_d,cinfvs_a,dimcv,           &
                                  disheatx,disheaty,disheatz,          &
                                  pornew, sanew, uvsnew,               &
                                  density, zg,viscosity,relperm,       &
                                  idbg, ilog, njavs, nngl, half_cells, &
                                  cinfrad,radial_coord,                &
                                  ups_heat,av_dens_z,gacc)
#ifdef USG
                 else
                   call infheat_d_usg
#endif
                 end if
!cprovi---------------------------------------------------------------
!cprovi If thermal heat conductity of water is updated or for the 
!cprovi case of variable saturated flow, then thermal conductivity 
!cprovi tensor is updated 
!cprovi---------------------------------------------------------------     
                 if (update_heatcondw.or.variably_saturated) then
                   if(discretization_type == 0) then
                     !infheat_c is parallelized, OpenMP, DSU
                     call infheat_c (nvxgl,nvygl,nvzgl,iavs,javs,      &
                                    isymvs,cinfheat_c,dimcv,heatcondw, &
                                    heatconds,heatcondg,heatcondi,     &
                                    tempnew,pornew,sanew,uvsnew,       &
                                    zg,idbg,ilog,njavs,nngl,           &
                                    half_cells,cinfrad,                &
                                    radial_coord,heatcond_model,       &
                                    nheatcond)
#ifdef USG
                   else
                     call infheat_c_usg
#endif
                   end if
                 end if
!cprovi--------------------------------------------------------------------
!cproovi Compute the maximum velocities for van leer spatial interpolation          
!cprovi--------------------------------------------------------------------         
                 if (sp_weight_heat=='vanleer'.or.                     &
                     sp_weight_heat=='vanleer2') then
                     !i2upfind_heat is parallelized, OpenMP, DSU
                     call i2upfind_heat
                 end if
!cprovi--------------------------------------------------------------------
!cprovi If evaporation is computed, compute the corresponding influence
!cprovi coefficients
!cprovi--------------------------------------------------------------------                     
                 if (evaporation) then
                   if(discretization_type == 0) then
                   !infevap is parallelized, OpenMP, DSU
                     call infevap(nvxgl,nvygl,nvzgl,iavs,javs,         &
                         isymvs, cinfevap_pa,cinfevap_t,cinfvs_t,      &
                         cinfvs,density,ddensvdpa,ddensvdt,dimcv,      &
                         tempnew,mpropvs,nzn,diffv0,                   &
                         pornew,sanew,idbg,ilog,njavs,nngl,            &
                         half_cells,marchies,cinfrad,radial_coord,     &
                         isenhfactor,fclay_nabla,                      &
                         cte_nabla,ref_dens,nabla_qhv,split_divdensv,  &
                         gacc,gainwt,dsurftensdt,gammaw0)
#ifdef USG
                   else
                     call infevap_usg
#endif
                   end if
                 end if
               end if
               
               !Parallelized, OpenMP, DSU
               call trddflow
               
            else 
              !Parallelized, OpenMP, DSU
              call tranflow
            end if

            !cdsu check the convergence status for transient steady state flow
            if (tran_steady_flow .and. (tran_steady_flow_converged .or. &
                time.gt.tran_steady_exit_time)) then
              if (.not.density_dependence) then
                if (gs_output .and. b_enable_output) then
                  if(discretization_type == 0) then
                    call outputvs
                    if (compute_ice_sheet_loading) then
                      call outputmech
                    end if
#ifdef USG
                  else
                    call outputvs_usg
                    if (compute_ice_sheet_loading) then
                      call outputmech_usg
                    end if
                    if (compute_ice_sheet_loading .and. ice_sheet_type == 1) then
                      call outputice_usg
                    end if 
#endif
                  end if
                end if

                if (.not. update_permeability) then
                  steady_flow = .true.
                  transient_flow = .false.
                end if

              else if (density_dependence) then
                if (gs_output .and. b_enable_output) then
                  if(discretization_type == 0) then
                    call outputdd
#ifdef USG
                  else
                    call outputdd_usg
                    if (compute_ice_sheet_loading .and. ice_sheet_type == 1) then
                      call outputice_usg
                    end if                     
#endif
                  end if
                end if

                if (tran_steady_drho_0) then                
                  drho_dc = drho_dc_saved
                  drho_dt = drho_dt_saved
  
                  !cdsu--------------------------------------------------------------------------
                  !cdsu Compute densities (also viscosity) as a function of water composition
                  !cdsu and temperature
                  !cdsu--------------------------------------------------------------------------
                  !cdsu  Parallelized, OpenMP, DSU
                  if (.not.flow_verification) then
                    if (heat_transport) then
                       call ddtds_energybal(.true.)
                    else
                       call ddtds
                    end if
                  end if  

                  tran_steady_drho_0 = .false.
                end if

              end if  !.not.density_dependence

              tran_steady_flow = .false.

              if(rank == 0 .and. b_enable_output) then
                write(*,'(/,72a)') ('-',i=1,72)
                write(ilog,'(/,72a)') ('-',i=1,72)

                if (tran_steady_flow_converged) then
                  write(*,'(a)') 'Transient steady state is reached at specified tolerance'
                  write(ilog,'(a)') 'Transient steady state is reached at specified tolerance'
                else
                  write(*,'(a)') 'Transient steady state is reached at specified time'
                  write(ilog,'(a)') 'Transient steady state is reached at specified time'                 
                end if

                if (reactive_transport) then
                  if (tran_steady_stop) then
                    write(*,'(a)') 'Exit timeloop'
                    write(ilog,'(a)') 'Exit timeloop'
                  else
                    write(*,'(a)') 'Enter reactive transport'
                    write(ilog,'(a)') 'Enter reactive transport'
                  end if
                else
                  write(*,'(a)') 'Exit timeloop'
                  write(ilog,'(a)') 'Exit timeloop'
                end if

                write(*,'(72a,/)') ('-',i=1,72)
                write(ilog,'(72a,/)') ('-',i=1,72)
              end if

              if (reactive_transport .and. .not.tran_steady_stop) then
                delt = delt_init
                time = time_init
                tfinal = tfinal_init
                !c close transient flow time step output as a separated file prefix_o_flow.dt
                close(idelt)
                goto 100
              else
                return
              end if

            end if
          
#ifdef ARCHISIMPLE
! CBF RLD
!FG July 2017 : update root density, moved after time step reduction process due to tranflow.
!FG Was put here since Feb 2015. Remind this for testing with other version as there should be
!FG little differences in simulations where time step cuts due to flow occur and/or RT calculations below.
!DSU: Here is before time step reduction process!!!
    !if ((inside_rld).or.(coupled_as)) then
    !  call updtrootdensity
    !endif   ! CBF RLD
#endif
          
!c  convergence failure - restart newton iteration with reduced timestep
         
            if (reduce_timestep) then
              prt_timestep_nonlinear =  prt_timestep_nonlinear +       &
                                        cputime() - cputime_start

              if(rank == 0 .and. b_enable_output .and. .not.           &
                 ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                if (mass_balance_vs .and. idetail_vs.gt.2) then
                  write(*,'(2(a,1x,1pe15.6e3,1x))')                    &
                        'Relative mass balance error', relbalance_vs,  &
                        'tolerance',rtol_relbalance_vs
                  write(ilog,'(2(a,1x,1pe15.6e3,1x))')                 &
                        'Relative mass balance error', relbalance_vs,  &
                        'tolerance',rtol_relbalance_vs
                end if

                if (mass_balance_vs .and. idetail_vs.gt.2) then
                  write(*,'(2(a,1x,1pe15.6e3,1x))')                    &
                        'Absolute mass balance error',absbalance_vs,   &
                        'tolerance',rtol_absbalance_vs
                  write(ilog,'(2(a,1x,1pe15.6e3,1x))')                 &
                        'Absolute mass balance error',absbalance_vs,   &
                        'tolerance',rtol_absbalance_vs
                end if

                if (heat_transport) then
                  write(*,*) 'Reduce time step for flow and/or heat transport'
                  write(ilog,*) 'Reduce time step for flow and/or heat transport'
                else
                  write(*,*) 'Reduce time step for flow'
                  write(ilog,*) 'Reduce time step for flow'
                end if

              end if                  !end if MPI rank 0  
           
              goto 999
            end if

          end if
                    
          prt_nonlinear_flow = cputime() - prt_nonlinear_flow
          
         
!c  reactive transport
            
          prt_nonlinear_react = cputime()
          
          
          if (reactive_transport .and. .not.tran_steady_flow) then
         
!cprovi-----------------------------------------------------------------
!cprovi Update the temperature vector for reactive transport 
!cprovi-----------------------------------------------------------------          
            if (heat_transport) then
#ifdef OPENMP
    !$omp parallel                                                    &                                                              
    !$omp if (nngl > numofloops_thred_global)                         & 
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)                                              
    !$omp do schedule(static)
#endif 
               do ivol=1,nngl
                  tkel(ivol) = tempnew(ivol) + zerokelvin                  
               end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            end if
          
!cprovi-----------------------------------------------------------------
!cprovi Compute reactive transport 
!cprovi Parallelized, OpenMP, DSU
!cprovi-----------------------------------------------------------------
            call reactran

!c  convergence failure - restart newton iteration with reduced timestep

            if (reduce_timestep) then
                
             prt_timestep_nonlinear =  prt_timestep_nonlinear + cputime() - cputime_start  
             
             if(rank == 0 .and. b_enable_output .and.                         &
              .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
               write(*,*) 'Reduce time step for reactive transport'
               write(ilog,*) 'Reduce time step for reactive transport'
             end if                  !end if MPI rank 0
             
             goto 999
            
            end if
          
          else

            ! for non reactive transport energy balance
            not_converged_sia=.false.

          end if
          
          prt_nonlinear_react = cputime() - prt_nonlinear_react
        
          prt_nonlinear_tot = cputime() - prt_nonlinear_tot
          
!c  write runtime to file
          if(rank == 0 .and. b_prtfile) then      !if MPI rank 0
            write(iprt_nonlinear, "(3(i8, 1x),4(1pe15.6e3,2x))")               &
                  mtime,iter_sia,msia,prt_nonlinear_flow,prt_nonlinear_react,  &
                  (prt_nonlinear_tot-prt_nonlinear_flow-prt_nonlinear_react),  &
                  prt_nonlinear_tot
          end if                  !end if MPI rank 0  
        
        else if (gas_bubbles) then
            
          if (double_bubble) then
              
            if (rank == 0 .and. b_enable_output .and. .not.            &
                ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
              write(ilog,'(a)') "enter gas bubble: double_bubble"
            end if
                    
            solvegb=.false.
            bubflow_not_converged=.true.
            ibubflow=0            
            updatefactor = r1

            do while (bubflow_not_converged)
            
              ibubflow=ibubflow+1
              ibubflow_tol=0
              
              if (rank == 0 .and. b_enable_output .and. .not.          &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                write(ilog,'(a,1x,i6,1x)') "ibubflow",ibubflow
              end if
              
              uvsnew_b(:) = uvsnew(:)
              sanew_b(:)  = sanew(:)
              
              call tranflow

!c  convergence failure - restart newton iteration with reduced timestep

              if (reduce_timestep) goto 999


!c  set variables for convergence check

              bub_not_converged=.true.
              ibub=0

              do while (bub_not_converged)

                ibub=ibub+1
                ibubreact_tol=0
                
                if (rank == 0 .and. b_enable_output .and. .not.        &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                  write(*,'(/1x,a,1x,i6,1x)') "Bubble iteration",ibub
                  write(ilog,'(/1x,a,1x,i6,1x)') "Bubble iteration",ibub
                end if


                call reactran

!c  convergence failure - restart newton iteration with reduced timestep

                if (reduce_timestep) goto 999

!c set variables to update non-gas components and for convergence check

                c_update(:,:) = cnew(:,:)
                sanew_c(:)=sanew(:)

!c  calculate gas phase saturation due to bubbles
#ifdef DEBUG
                call gasbub(.true., .false.)
#else
                call gasbub(.false., .false.)
#endif

                if (reduce_timestep) goto 999

!c  check for convergence
                if (sgsolved) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, ic, c_diff, c_tol)                            &
    !$omp reduction(+:ibubreact_tol)
    !$omp do schedule(static)
#endif
                  do ivol=1,nngl
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif

                    !skip solution update check when gas saturation is below the threshold
                    if (sgnew(ivol) < bub_sgmin) then
                      cycle
                    end if

                    do ic=1,nc-1
                      c_diff=c_update(ic,ivol)-cnew(ic,ivol)
                      c_tol=c_update(ic,ivol)*bubreact_tol                   

                      if (dabs(c_diff).gt.tol_rt)then
                        ibubreact_tol=ibubreact_tol+1
                      end if
                    end do 
                  end do 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
                  call MPI_Allreduce(ibubreact_tol, ibubreact_tol_gbl,1,         &
                                     MPI_INTEGER4,MPI_SUM,             &
                                     Petsc_Comm_World,ierrcode)
                  CHKERRQ(ierrcode)
                  ibubreact_tol = ibubreact_tol_gbl
#endif
                end if
            
                if (ibubreact_tol.eq.0)then
                  bub_not_converged=.false.
                end if        

                if (ibub>maxibub) then
                  if(rank == 0) then  
                    write(ilog,'(72a)')('-',i=1,72)                    
                    write(ilog,'(a)')'bubble model fails to converge'
                    write(ilog,'(a)')'maximum number of bubble iterations exceeded'
                    write(ilog,'(a)')'reduce timestep'
                    
                    write(*,'(72a)')('-',i=1,72)                    
                    write(*,'(a)')'bubble model fails to converge'
                    write(*,'(a)')'maximum number of bubble iterations exceeded'
                    write(*,'(a)')'reduce timestep'
                  end if
                  reduce_timestep = .true.
                  goto 999
                end if

              end do        !bub_not_converged

!c_bubbles check for convergence, outer bubble loop
              if (sgsolved) then
                if (ibubflow.eq.1) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, uvs_diff, uvs_tol, aentry_loc)           &
    !$omp reduction(+:ibubflow_tol)
    !$omp do schedule(static)
#endif
                  do ivol=1,nngl 
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif
                    !skip solution update check when gas saturation is below the threshold
                    if (sgnew(ivol) < bub_sgmin) then
                      cycle
                    end if

                    if (soilhydrfunc_field) then
                      aentry_loc = aentry_vol(ivol)
                    else
                      izn = mpropvs(ivol)                     !material property zone
                      aentry_loc = aentry(izn)
                    end if

                    if (uvsnew(ivol).ge.aentry_loc) then    ! if saturated
                      uvs_diff=sanew_b(ivol)-sanew(ivol)
                      uvs_tol=sanew_b(ivol)*bubflow_tol
                      if (dabs(uvs_diff).gt.tol_vs)then
                         ibubflow_tol=ibubflow_tol+1
                      end if 
                    end if
                  end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                else
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, uvs_diff, uvs_tol, aentry_loc)           &
    !$omp reduction(+:ibubflow_tol)
    !$omp do schedule(static)
#endif 
                  do ivol=1,nngl 
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif
                    if (soilhydrfunc_field) then
                      aentry_loc = aentry_vol(ivol)
                    else
                      izn = mpropvs(ivol)                   !material property zone
                      aentry_loc = aentry(izn)
                    end if

                    if (uvsnew(ivol).ge.aentry_loc) then    ! if saturated
                      uvs_diff=uvsnew_b(ivol)-uvsnew(ivol)
                      uvs_tol=uvsnew_b(ivol)*bubflow_tol
                      if (dabs(uvs_diff).gt.tol_vs)then
                         ibubflow_tol=ibubflow_tol+1
                      end if 
                    end if
                  end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                end if
#ifdef PETSC
                  call MPI_Allreduce(ibubflow_tol, ibubflow_tol_gbl,1, &
                                     MPI_INTEGER4,MPI_SUM,             &
                                     Petsc_Comm_World,ierrcode)
                  CHKERRQ(ierrcode)
                  ibubflow_tol = ibubflow_tol_gbl
#endif
              end if

              if (ibubflow_tol.eq.0)then
                 bubflow_not_converged=.false.
              else if (rank == 0 .and. b_enable_output .and. .not.     &
                ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                if (ibubflow_tol.gt.0) then                 
                  write(*,'(/1x,a,1x,i6,1x)') "Bubble iteration for flow",ibub
                  write(ilog,'(/1x,a,1x,i6,1x)') "Bubble iteration for flow",ibub
                end if
              end if
              
            
              if (ibubflow>maxibubflow) then
                if (rank == 0) then 
                   write(ilog,'(72a)')('-',i=1,72)                    
                   write(ilog,'(a)')'bubble model fails to converge'
                   write(ilog,'(a)')'maximum number of bubble iterations exceeded'
                   write(ilog,'(a)')'reduce timestep'
                   
                   write(*,'(72a)')('-',i=1,72)                    
                   write(*,'(a)')'bubble model fails to converge'
                   write(*,'(a)')'maximum number of bubble iterations exceeded'
                   write(*,'(a)')'reduce timestep'
                end if
                reduce_timestep = .true.
                goto 999
              end if

            end do !bubflow_not_converged

!c_bubbles call second half of reactran

            call reactran_2

!c_bubbles  if not double bubble then loop over tranflow,reactan and gasbub

          else
              
            if (rank == 0 .and. b_enable_output .and. .not.            &
                ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
              write(ilog,'(a)') "enter gas bubble: no double_bubble"
            end if
        
            bubflow_not_converged=.true.
            ibubflow=0
            bub_not_converged=.true.
            ibub=0
            updatefactor = r1
            solvegb = .false.    
        
            do ivol=1,nngl
              sanew_b(ivol)=sanew(ivol)
            end do    

            do while (bubflow_not_converged.or.bub_not_converged)
            
              ibubflow=ibubflow+1
              ibubflow_tol=0
              ibub=ibub+1
              ibubreact_tol=0
              
              if (rank == 0 .and. b_enable_output .and. .not.          &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                write(ilog,'(2(a,1x,i6,1x))') "ibubflow",ibubflow,"ibub",ibub
              end if

              do ivol=1,nngl
                uvsnew_b(ivol)=uvsnew(ivol)
              end do

              call tranflow

!c  convergence failure - restart newton iteration with reduced timestep

              if (reduce_timestep) goto 999

!c  set variables for convergence check

              call reactran

!c  convergence failure - restart newton iteration with reduced timestep

              if (reduce_timestep) goto 999

!c set variables to update non-gas components

              c_update(:,:)=cnew(:,:)
              sanew_c(:)=sanew(:)

!c  calculate gas phase saturation due to bubbles
#ifdef DEBUG
              call gasbub(.true., .false.)
#else
              call gasbub(.false., .false.)
#endif
              if (reduce_timestep) goto 999
              
!c  if new gas saturation was solved for then check for convergence
              if (sgsolved) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, ic, c_diff, c_tol, uvs_diff, uvs_tol)         &
    !$omp reduction(+:ibubreact_tol,ibubflow_tol)
    !$omp do schedule(static)
#endif
                do ivol=1,nngl
#ifdef PETSC
                  if(node_idx_lg2l(ivol) < 0) then
                    cycle
                  end if
#endif
                  !skip solution update check when gas saturation is below the threshold
                  if (sgnew(ivol) < bub_sgmin) then
                    cycle
                  end if

                  do ic=1,nc-1
                    c_diff=c_update(ic,ivol)-cnew(ic,ivol)
                    c_tol=c_update(ic,ivol)*bubreact_tol
                    if (dabs(c_diff).gt.tol_rt)then
                      ibubreact_tol=ibubreact_tol+1
              
!c    if (ibub.gt.10) then
!c      write(ilog,'(a,i6,a14,4(1pe15.6e3))') 'bub',ivol,namec(ic),        &
!c            c_update(ic,ivol),cnew(ic,ivol),c_diff,c_tol
!c      write(ilog,'(a,1x,l2)')'unsaturated', unsaturated(ivol)
!c    end if
                    end if
                  end do 
                  uvs_diff=uvsnew_b(ivol)-uvsnew(ivol)
                  uvs_tol=uvsnew_b(ivol)*bubflow_tol
                  if (dabs(uvs_diff).gt.tol_vs)then
                     ibubflow_tol=ibubflow_tol+1
!c    if (ibub.gt.10) then
!c      write(ilog,'(a,i6,4(1pe15.6e3))')'flow',ivol, uvsnew_b(ivol),      &
!c            uvsnew(ivol),uvs_diff,uvs_tol
!c      write(ilog,'(a,1x,l2)')'unsaturated', unsaturated(ivol)
!c    end if
                  end if
                end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
                call MPI_Allreduce(ibubreact_tol, ibubreact_tol_gbl,1, &
                                   MPI_INTEGER4,MPI_SUM,               &
                                   Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
                ibubreact_tol = ibubreact_tol_gbl
                
                call MPI_Allreduce(ibubflow_tol, ibubflow_tol_gbl,1,   &
                                   MPI_INTEGER4,MPI_SUM,               &
                                   Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
                ibubflow_tol = ibubflow_tol_gbl
#endif
              end if

              if ((ibubreact_tol.eq.0).and.(ibubflow_tol.eq.0))then
                bub_not_converged=.false.
                bubflow_not_converged=.false.
              else if (rank == 0 .and. b_enable_output .and. .not.     &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                if(ibubreact_tol.gt.0)then
                  write(*,'(/1x,a,1x,i6,1x)') "Bubble iteration for reactive transport",ibub
                  write(ilog,'(/1x,a,1x,i6,1x)') "Bubble iteration for reactive transport",ibub
                end if
                if (ibubflow_tol.gt.0) then
                  write(*,'(/1x,a,1x,i6,1x)') "Bubble iteration for flow",ibub
                  write(ilog,'(/1x,a,1x,i6,1x)') "Bubble iteration for flow",ibub
                end if
              end if

              if ((ibubflow>maxibubflow).or.(ibub>maxibub)) then
                if (rank == 0) then  
                  write(ilog,'(72a)')('-',i=1,72)                    
                  write(ilog,'(a)')'bubble model fails to converge'
                  write(ilog,'(a)')'maximum number of bubble iterations exceeded'
                  write(ilog,'(a)')'reduce timestep'

                  write(*,'(72a)')('-',i=1,72)                    
                  write(*,'(a)')'bubble model fails to converge'
                  write(*,'(a)')'maximum number of bubble iterations exceeded'
                  write(*,'(a)')'reduce timestep'
                end if
                reduce_timestep = .true.
                goto 999
              end if

            end do !bubflow_not_converged

!c_bubbles call second half of reactran
     
            call reactran_2

          end if    !double bubbles

!cdsu MIP_MT bubble formation
        else if (mip_mt_enable) then
          mip_mt_not_converged = .true.
          do while (mip_mt_not_converged)  
            
            if (varsat_flow.and.transient_flow) then              
                
              !Parallelized, OpenMP, DSU
              call tranflow          
          
!c  convergence failure - restart newton iteration with reduced timestep
         
              if (reduce_timestep) then                
                goto 999
              end if
         
            end if
                    
            if (reactive_transport) then
!cprovi-----------------------------------------------------------------
!cprovi Compute reactive transport 
!cprovi Parallelized, OpenMP, DSU
!cprovi-----------------------------------------------------------------
              call reactran

!c  convergence failure - restart newton iteration with reduced timestep
              if (reduce_timestep) then                
                goto 999
              end if              
            
            else
              not_converged_sia = .false.
            end if
            
            !c pass MIN3P variable to MIP model
            call mip_solver_input
            !c solve MIP model
            call mip_solver
            !c pass MIP variable back to MIN3P
            call mip_solver_output
          end do          
         
          call reactran_2

        end if       !gas bubbles

        if(rank == 0 .and. b_enable_output) then
          if(density_dependence) then
            write(*,'(2a,/,2a,/,i6,9x,2(1pe15.6e3,1x),4x,l1)')         &
                  " Picard Iteration Convergence Summary",             &
                  " For Density Dependent Flow:",                      &
                  " iteration          max.sia         ",              &
                  "tol.sia    converged",                              &
                  iter_sia,sia_max,tol_sia,(.not.not_converged_sia)
            write(ilog,'(/,2a,/,2a,/,i6,9x,2(1pe15.6e3,1x),4x,l1)')    &
                  " Picard Iteration Convergence Summary",             &
                  " For Density Dependent Flow:",                      &
                  " iteration          max.sia         ",              &
                  "tol.sia    converged",                              &
                  iter_sia,sia_max,tol_sia,(.not.not_converged_sia)
          end if
        end if

        iter_vs_tot = iter_vs_tot + iter_vs
        iter_rt_tot = iter_rt_tot + iter_rt
         
!c skip ahead for flow verification problems and 

!c call ddtds moved to reactran

      end do  !while ((iter_sia .lt. maxit_sia) .and. (not_converged_sia))

      prt_timestep_nonlinear =  prt_timestep_nonlinear + cputime() - cputime_start

      if (abs(relbalance_vs) .le. rtol_relbalance_vs .or.              &
          abs(absbalance_vs) .le. rtol_absbalance_vs) then

        if (flow_verification) go to 1001

        if (.not.density_dependence) go to 1001
      
      end if

    
!c  non-convergence of coupling iterations

        if (((iter_sia.ge.maxit_sia).and.(not_converged_sia)) .or.    &
            ((abs(relbalance_vs) .gt. rtol_relbalance_vs ) .and.      &
            (abs(absbalance_vs) .gt. rtol_absbalance_vs ))) then

          reduce_timestep = .true.

          if(rank == 0 .and. b_enable_output .and. .not.               &
             ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then

            if (abs(relbalance_vs) .le. rtol_relbalance_vs .or. &
                abs(absbalance_vs) .le. rtol_absbalance_vs) then

              write(*,*) 'Time step is reduced for sia'

              write(ilog,*)                                            &
               '----------------------------------------------------'
              write(ilog,*)                                            &
               '   maximum number of coupling iterations exceeded   '
              write(ilog,*)                                            &
               '             reducing time step                     '
              write(ilog,*)                                            &
               '----------------------------------------------------'
            end if

            if (abs(relbalance_vs) .gt. rtol_relbalance_vs .and.       &
                idetail_vs.gt.2) then
              write(*,'(2(a,1x,1pe15.6e3,1x))')                             &
               'Relative mass balance error', relbalance_vs,                &
               'tolerance of relative mass balance error',rtol_relbalance_vs
              write(ilog,'(2(a,1x,1pe15.6e3,1x))')                          &
               'Relative mass balance error', relbalance_vs,                &
               'tolerance of relative mass balance error',rtol_relbalance_vs
              write(ilog,*)                                                 &
               '----------------------------------------------------'
            end if

            if (abs(absbalance_vs) .gt. rtol_absbalance_vs .and.       &
                idetail_vs.gt.2) then
              write(*,'(2(a,1x,1pe15.6e3,1x))')                             &
               'Absolute mass balance error',absbalance_vs,                 &
               'tolerance of absolute mass balance error',rtol_absbalance_vs
              write(ilog,'(2(a,1x,1pe15.6e3,1x))')                          &
               'Absolute mass balance error',absbalance_vs,                 &
               'tolerance of absolute mass balance error',rtol_absbalance_vs
              write(ilog,*)                                                 &
               '----------------------------------------------------'
            end if
!c  write sequential iteration non-convergence history to log file

            if (density_dependence .and. idetail_vs.gt.0) then
              write(ilog,'(/72a)')('-',i=1,72)
              write(ilog,'(/2a)') ' Sequential Iteration Convergence',  &
                      ' Summary:'                                        
              write(ilog,'(a)') ' Sequential   maximum'                  
              write(ilog,'(2a)')' iteration    update      ',           &
                              ' maxvol       nexvol'
                                                                         
              do i1 = 1,iter_sia                                         
                write(ilog,'(i6,7x,1pe11.4,3x,i6,7x,i6)')               &
                      i1,sia_dens(i1),sia_maxvol(i1), sia_nexvol(i1)
              end do
            
            end if
  
          end if                  !end if MPI rank 0
          
!c  reset primary and secondary flow equation unknowns
!c  and geochemical system for reduced time step


          goto 999

        end if !(iter_sia.ge.maxit_sia).and.(not_converged_sia)

        if(b_enable_output) then      !if enable output

!c error in sequential iterations or input parameter

          if (msia .eq. 0 .and. rank == 0) then 
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(a)')'failure in timeloop'
            write(ilog,'(a)')'error in sequential iterative coupling'
            write(ilog,'(a)')'bye now ...'
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(72a)')('-',i=1,72)
            if (b_enable_output_gen) then
              write(igen,'(a)')'failure in timeloop'
              write(igen,'(a)')'error in sequential iterative coupling'
              write(igen,'(a)')'bye now ...'
            end if
          end if

!c  write sequential iteration convergence history to log file

          if (density_dependence .and. idetail_vs.gt.0 .and. rank == 0 &
              .and..not.((skip_time.gt.0).and.                         &
              (nskip_time.lt.skip_time))) then
            write(ilog,'(/72a)')('-',i=1,72)
            write(ilog,'(/2a)') ' Sequential Iteration Convergence',   &
                      ' Summary:'                                        
            write(ilog,'(a)') ' Sequential   maximum'                    
            write(ilog,'(2a)')' iteration    update      ',            &
                              ' maxvol       nexvol'
                                                                         
            do i1 = 1,iter_sia                                           
              write(ilog,'(i6,7x,1pe11.4,3x,i6,7x,i6)')                &
                    i1,sia_dens(i1),sia_maxvol(i1), sia_nexvol(i1)
            end do

          end if

        end if                  !end if enable output


!c  mass balance for density dependent and variably saturated flow
!c  Parallelized, OpenMP, DSU

1001    continue

        if (varsat_flow .and. mass_balance_vs .and. ngb_step == ngb_step_bk) then
          if (density_dependence) then
            call mbaldd
          else  
            call mbalvs
          end if
        end if
        
!cprovi-------------------------------------------------------------------
!cprovi  Compute energy balance 
!cprovi  Parallelized, OpenMP, DSU
!cprovi-------------------------------------------------------------------
        if (heat_transport.and.energy_balance) then
          call energy_bal
        end if

!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi------------------------------------------------------------------- 
!c  write magnitude of current time step,number of 
!c  coupling iterations, and time step size controller to file

        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
          if (idetail_vs.gt.0 .and. transient_flow .or.                &
     &        idetail_rt.gt.0) then

            if (mtime.eq.1) then
!c  magnitude of current time step
              !idelt = 24
              idelt = lun_get()
              
              if (tran_steady_flow) then
                str_filepath = prefix(:l_prfx)//'_o_flow.dt'
              else
                str_filepath = prefix(:l_prfx)//'_o.dt'
              end if

              b_rewind_valid = check_rewind_status(trim(str_filepath))
              if (b_rewind_valid .and. i_append_sim > 0) then
                open(idelt,file=trim(str_filepath),status='unknown',   &
                     form='formatted',position='rewind')
              else
                open(idelt,file=trim(str_filepath),status='unknown',   &
                     form='formatted')
              end if

!c  version information
              if (i_append_sim < 1 .or. .not.b_rewind_valid) then
                if (b_writeversion_tecplot ) then
                  call writeversion2file(idelt, "#")
                end if

!c  title and variables        
                write(idelt,'(3a)') 'title = "dataset ',prefix(:l_prfx),'"'
                write(idelt,'(4a)') 'variables = "time", "delta t", ',    &
     &                              '"courant_max", "courant_num", ',     &
     &                              '"iter_ts", "iter_vs", "iter_rt", ',  &
     &                              '"ts_min"'
                write(idelt,'(2a)') 'zone t = "time step data", f=point'
              end if
!c  no limiter on initial time step length

              ts_min = 'none'

            end if

            !c get the time to append results for legacy mode
            if (mtime == mtime_append .and. i_append_sim == 2) then
              call find_append_time(idelt,backup_frequency,time_append)
            end if
          
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(idelt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(idelt,'(3es13.5,i8,3i4,a12)') time_io,delt_io,     &
                                        courant_max,courant_num,       &
                                        ts_sia,iter_vs_tot,iter_rt_tot,&
                                        ts_min
            end if
  
          end if
     
        end if

!c  write contour data to output file at specified output times
   
        if (gs_output .and. .not.tran_steady_flow) then

          if (time.ge.(gs_tout(igstime)-tiny_delt)) then

            if (b_enable_output) then  
              
              if(rank == 0) then  
!c  report to log file

                write(ilog,'(/a,1pe15.6e3,1x,a)')                      &
                     'write contour data, T = ', time_io, time_unit
                write(ilog,'(72a/)')('-',i=1,72)
                
!c  report to screen

                write(*,'(/1x,a,1pe15.6e3,1x,a)')                      &
                     'write contour data, T = ', time_io, time_unit
                write(*,'(1x,72a/)')('-',i=1,72)
              
              end if

              if(discretization_type == 0) then
                if (varsat_flow.and.transient_flow) then
                  if (density_dependence) then
                    call outputdd
                  else
                    call outputvs
                  end if
                end if
                if (compute_ice_sheet_loading) then
                  call outputmech
                end if
                if (reactive_transport) then
                  call outputrt
                end if
#ifdef USG
              else
                if (varsat_flow.and.transient_flow) then
                  if (density_dependence) then
                    call outputdd_usg
                  else
                    call outputvs_usg
                  end if
                  if (compute_ice_sheet_loading) then
                    call outputmech_usg
                  end if
                  if (compute_ice_sheet_loading .and. ice_sheet_type == 1) then
                    call outputice_usg
                  end if  
                  
                end if
                if (reactive_transport) then
                  call outputrt_usg
                end if
#endif
              end if

              !c the following output is to be updated when usg capability is implemented
              if (varsat_flow) then
                if (root_uptake) then
                  call root_output_spatial  
                end if
              end if

              if (reactive_transport) then
                if (gas_bubbles.and.bubble_out) then                  
                  call gasbub(.false., .true.) 
                end if
                if (mip_mt_enable) then
                  call mip_output_spatial  
                end if
              end if

            end if
            
            igstime = igstime + 1
          end if
        end if               !(gs_output)
 
!c  write transient data to output file
!c  every ngb_step time step and after completion of solution
 
        if (b_enable_output) then
          
          if (skip_time_gb) then
            if (time.ge.skip_time_gb_start .and. time.le.skip_time_gb_end) then
              ngb_step = 2147483647      !maximum interger*4 value
            else
              ngb_step = ngb_step_bk
              igb_step = 0
            end if
          end if
       
          igb_step = igb_step + 1
          if (ngb_step == ngb_step_bk .and.                            &   !DSU: no output during skip time range
             (igb_step.eq.ngb_step .or. time.ge.tfinal-tiny_delt .or.  &   !DSU: normal timestep skip
             (mtime == mtime_append .and. i_append_sim >= 1) .or.      &   !DSU: locate and append results when simulation is restarted (requrired)
             (mod(rsrt_cnt+1,backup_frequency) .eq. 0))) then              !DSU: write current timestep when restart point is reached (required)
            
            ngb_tstep = ngb_tstep + 1  

            if (transient_flow.or.reactive_transport) then
              if (gb_output) then
                do igb = 1,ngb
                  ivol = ngb_vol(igb)
                
                  if (ivol < 0) then
                    cycle
                  end if
                  
!c  assign unit numbers for output of transient data

                  call tranunit(igb)

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants
                  if (temp_corr.or.heat_transport) then
                    do itid = 1, nthreads
                      call tcorr(tkel(ivol),ivol,itid)
                    end do
                  end if

!c  write transient data to output file

                  if (transient_flow) then
                    if (density_dependence) then
                      call tprfdd(ivol,igb,ngb_tstep)      
                    else
                      call tprfvs(ivol,igb,ngb_tstep)
                    end if

                    if (root_uptake) then
                      if (b_output_binary) then                    
                        igbroot = igbroot_mpi(igb)
                      end if
                      call root_output_transient(ivol,igbroot,mtime,time_io)
                    end if
                  end if

                  if (reactive_transport .and. .not.tran_steady_flow) then
                    
                    if (b_output_trans_binary) then                    
                      igbt  = igbt_mpi(igb)
                      igbc  = igbc_mpi(igb)
                      igbm  = igbm_mpi(igb)
                      igbgr = igbgr_mpi(igb)
                      igbg  = igbg_mpi(igb)
                      igbi  = igbi_mpi(igb)
                      igbb  = igbb_mpi(igb)
                      igbs  = igbs_mpi(igb)
                      igbv  = igbv_mpi(igb)
                      igbd  = igbd_mpi(igb)
                      igbx  = igbx_mpi(igb)
                      igbis = igbis_mpi(igb)
                      igbac  = igbac_mpi(igb)
!cdsu concentration of radioelement related to noble gas ingrowth
                      if (b_use_ngi .and. ngre_i > 0) then
                        igbre = igbre_mpi(igb)
                      end if
                    end if

!cdsu concentration of radioelement related to noble gas ingrowth
                    if (b_use_ngi .and. ngre_i > 0) then
                      conc_ngre_loc(:) = conc_ngre(:,ivol)
                    end if
                    
                    if (density_dependence) then
                      call tprfrtlc(totcnew(1,ivol),cnew(1,ivol),        &
                             cx(1,ivol),gamma(1,ivol),                   &
                             gamma(nc+1,ivol),cmnew(1,ivol),             &
                             gnew(1,ivol),cec_g(ivol),                   &
                             distcoff_rt(1,ivol),area(1,ivol),           &
                             phi(1,ivol),phiold(1,ivol),                 &
                             sionnew(ivol),tkel(ivol),                   &
                             uvsnew(ivol),xg(ivol),yg(ivol),zg(ivol),    &
                             time_io,delt,sanew(ivol),pornew(ivol),      &
                             igbt,igbc,igbm,igbg,igbgr,igbi,igbb,        &
                             igbs,igbv,igbd,igbx,igbis,igbac,igbre,      &
                             offset_igbt(igb),offset_igbc(igb),          &
                             offset_igbm(igb),offset_igbg(igb),          &
                             offset_igbgr(igb),offset_igbi(igb),         &
                             offset_igbb(igb),offset_igbs(igb),          &
                             offset_igbv(igb),offset_igbd(igb),          &
                             offset_igbx(igb),offset_igbis(igb),         &
                             offset_igbac(igb),offset_igbre(igb),        &
                             offset_igbt_ijk(igb),offset_igbc_ijk(igb),  &
                             offset_igbm_ijk(igb),offset_igbg_ijk(igb),  &
                             offset_igbgr_ijk(igb),offset_igbi_ijk(igb), &
                             offset_igbb_ijk(igb),offset_igbs_ijk(igb),  &
                             offset_igbv_ijk(igb),offset_igbd_ijk(igb),  &
                             offset_igbx_ijk(igb),offset_igbis_ijk(igb), &
                             offset_igbac_ijk(igb),offset_igbre_ijk(igb),&
                             prefix,l_prfx,tec_header,                   &
                             ivol,tid,mtime,ngb_tstep+1,zone_name,       &
                             l_zone_name,update_porosity,                &
                             mtime,i_append_sim,mtime_append)
                    else
                      call tprfrtlc(totcnew(1,ivol),cnew(1,ivol),        &
                             cx(1,ivol),gamma(1,ivol),                   &
                             gamma(nc+1,ivol),cmnew(1,ivol),             &
                             gnew(1,ivol),cec_g(ivol),                   &
                             distcoff_rt(1,ivol),area(1,ivol),           &
                             phi(1,ivol),phiold(1,ivol),                 &
                             sionnew(ivol),tkel(ivol),                   &
                             hhead(ivol),xg(ivol),yg(ivol),zg(ivol),     &
                             time_io,delt,sanew(ivol),pornew(ivol),      &
                             igbt,igbc,igbm,igbg,igbgr,igbi,igbb,        &
                             igbs,igbv,igbd,igbx,igbis,igbac,igbre,      &
                             offset_igbt(igb),offset_igbc(igb),          &
                             offset_igbm(igb),offset_igbg(igb),          &
                             offset_igbgr(igb),offset_igbi(igb),         &
                             offset_igbb(igb),offset_igbs(igb),          &
                             offset_igbv(igb),offset_igbd(igb),          &
                             offset_igbx(igb),offset_igbis(igb),         &
                             offset_igbac(igb),offset_igbre(igb),        &
                             offset_igbt_ijk(igb),offset_igbc_ijk(igb),  &
                             offset_igbm_ijk(igb),offset_igbg_ijk(igb),  &
                             offset_igbgr_ijk(igb),offset_igbi_ijk(igb), &
                             offset_igbb_ijk(igb),offset_igbs_ijk(igb),  &
                             offset_igbv_ijk(igb),offset_igbd_ijk(igb),  &
                             offset_igbx_ijk(igb),offset_igbis_ijk(igb), &
                             offset_igbac_ijk(igb),offset_igbre_ijk(igb),&
                             prefix,l_prfx,tec_header,                   &
                             ivol,tid,mtime,ngb_tstep+1,zone_name,       &
                             l_zone_name,update_porosity,                &
                             mtime,i_append_sim,mtime_append)
                    end if !density dependence

                    if (mip_mt_enable) then
                      if (b_output_binary) then                    
                        igbmip = igbmip_mpi(igb)
                      end if
                      call mip_output_transient(ivol,igbmip,mtime,time_io)
                    end if
                  end if ! reactive_transport
                end do
              end if

              !cprovi----------------------------------------------------    
              !cprovi  Write transient evaporation info
              !cprovi---------------------------------------------------- 
 
              if(rank == 0) then
                if (evaporation.and.write_evap_info) then  
                  call trans_evap_info (.false.,ngb_tstep)
                end if
              end if
            end if

            igb_step = 0

          end if
        end if                !(gb_output)

!cdsu  set the time index of component-mineral recycle
        if ((passive_uptake .or. root_uptake) .and. nrcm_tz > 0) then
          if (ircm_tz < nrcm_tz) then
            if (time > rcm_time(1,ircm_tz+1)) then
              if (time <= rcm_time(3,ircm_tz+1)) then
                ircm_tz = ircm_tz + 1
                !c reset the value in current cycle for component-mineral recycle
                totrcm_c_tz(:) = r0
                totrcm_m_tz(:) = r0
                totrcm_c_nz(:,:) = r0
              else
                ircm_tz = nrcm_tz+1
                !c reset the value in current cycle for component-mineral recycle
                totrcm_c_tz(:) = r0
                totrcm_m_tz(:) = r0
                totrcm_c_nz(:,:) = r0
              end if
            end if
          else if (ircm_tz == nrcm_tz) then
            if (time > rcm_time(3,ircm_tz)) then
              ircm_tz = nrcm_tz+1
              !c reset the value in current cycle for component-mineral recycle
              totrcm_c_tz(:) = r0
              totrcm_m_tz(:) = r0
              totrcm_c_nz(:,:) = r0
            end if
          end if
        end if
       
!c  write transient data of interface flux to output file
!c  every ngb_step_faceflux time step and after completion of solution
 
        if (gb_output_faceflux .and. b_enable_output) then         !**Note: Output is not parallelized yet, DSU
          if (mtime.eq.1) then
            call initfaceflux
          end if
          igb_step_ijface = igb_step_ijface + 1
          if (igb_step_ijface.eq.ngb_step_ijface.or.time.ge.tfinal-tiny_delt) then
            ngb_tstep_ijface = ngb_tstep_ijface + 1  
            if (transient_flow) then                
              do igb = 1,ngb_ijface
                call tprfvs_faceflux(ngb_vol_ijface(1,igb),            &
                                     ngb_vol_ijface(2,igb),igb,        &
                                     ngb_tstep_ijface+1)  
              end do
            end if
            if (reactive_transport) then                
              do igb = 1,ngb_ijface
                call tprfrtlc_faceflux(ngb_vol_ijface(1,igb),          &
                                       ngb_vol_ijface(2,igb),igb,      &
                                       ngb_tstep_ijface+1)  
              end do
            end if
            igb_step_ijface = 0
          end if
        end if                !(gb_output_faceflux)  

!c calculate maximum courant number for groundwater flow

        iprint = 0
        if ((density_dependence).and.(.not.flow_verification).and.     &
            (.not.tran_steady_flow).and.courant_target<bignum) then
          if(discretization_type == 0) then
            !velodd seems not necessary to call to calculate courant
            !if user specified maximum courant is very large.
            call velodd(nvxgl,nvygl,nvzgl,iavs,javs,cinfvs_a,dimcv, xg,&
                        yg, zg, uvsnew, density, viscosity,            &
                        relperm, idbg, ilog,ivel, fully_saturated,     &
                        njavs, nngl, nn, half_cells, pornew, sanew,    &
                        delt, courant_max, courant_num, iprint,time_io,&
                        cinfrad,radial_coord,0)
#ifdef USG
          else if (discretization_type > 0) then
            !velodd_usg seems not necessary to call to calculate courant
            !if user specified maximum courant is very large.
            call velodd_usg(iprint)
#endif

          end if
        else
          delt_courant = bignum  !arbitrary large number
        end if

!cprovi----------------------------------------------------    
!cprovi  Prepare for next time step
!cprovi  Parallelized, OpenMP, DSU
!cprovi----------------------------------------------------
        call nexttime

!cprovi----------------------------------------------------
!cprovi Write the backup files for the restart process 
!cprovi Sergio Andres Bea Jofre 
!cprovi----------------------------------------------------
        if(b_enable_output .and. .not.tran_steady_flow)  then
          call restart_w
        end if

!cprovi----------------------------------------------------
!cprovi Update atmospheric parameters  
!cprovi----------------------------------------------------       
        if (evaporation .and. variably_saturated .and. .not.tran_steady_flow) then
           call updtbcatm
        end if  
!cprovi----------------------------------------------------
!cprovi update boundary conditions for variably 
!cprovi saturated flow
!cprovi----------------------------------------------------        
        if (update_bcvs .and. .not.tran_steady_flow) then
          if (density_dependence) then
            call updtbcdd
          else 
            call updtbcvs
          end if
        end if

!cprovi----------------------------------------------------
!cprovi update boundary conditions for heat transport 
!cprovi----------------------------------------------------        
        if (update_bcheat .and. .not.tran_steady_flow) then
          call updtbcenergybal
        end if        

!c update transient dispersivity
        if (reactive_transport .and. update_disprt .and.               &
            .not. tran_steady_flow) then
          call updtdisprt
        end if

!c CBF RLD 
!c FG July 2017 - root density update (see previous comment on an alternative position for this call,
!c FG set from Feb 2015).
        if (root_uptake .and. .not.tran_steady_flow) then
          if ((coupled_as).or.(coupled_rt).or.(inside_rld)) then
            call updtrootdensity
          else
            if(rootlengthdens_field)then
              if (rld_field_update .and. b_rld_update) then
                !c update root length density
                call updtrootdensity_ext
                if (b_enable_output .and. rank == 0) then
                  write(*,'(/1x,a/)') 'RLD UPDATED FROM EXTERNAL *.rld FILE'
                  write(ilog,'(/1x,a/)') 'RLD UPDATED FROM EXTERNAL *.rld FILE'
                end if

                rld_update_index = rld_update_index + 1
                if (rld_update_index > rld_update_num) then
                  close(irld)
                  call lun_free(irld)
                end if
              else
                if (rank == 0 .and. b_enable_output) then
                  write(*,'(/1x,a/)') 'RLD NOT UPDATED, PREVIOUSLY READ FROM *.rld FILE'
                  write(ilog,'(/1x,a/)') 'RLD NOT UPDATED, PREVIOUSLY READ FROM *.rld FILE'
                end if
              end if
            else
              if (rank == 0 .and. b_enable_output) then
                write(*,'(/1x,a/)') 'RLD NOT UPDATED, INITIALLY READ FROM *.dat FILE : '
                write(ilog,'(/1x,a/)') 'RLD NOT UPDATED, INITIALLY READ FROM *.dat FILE : '
              endif
            end if
          endif
        end if

!c  update etp and canopy dependent parameters    !CBF
        if ((root_uptake .or. pure_evap) .and. .not.tran_steady_flow) then
#ifdef ARCHISIMPLE
          call updtetp
#endif
        end if


!c  update temperature field
        if (temp_field .and. .not.tran_steady_flow) then  
          call readtemp

          if (update_temp) then
            call intpolt
          end if
        end if

!c  update noble gas ingrowth related variables
        if (b_use_ngi) then
          !c this function only updates the concentration of radioelements 
          !c that are used to generate noble gas
          !call update_ngi_conc

          !c this function updates the concentration of all radioelements 
          !c that are specified in the input file
          call update_ngi_conc_all
        end if

!cdsu ------------------------------------------------------------------------
!cdsu move boundary condition update of reactive tranport here
!cdsu so that the boundary update for both flow and reactive transport are at
!cdsu the same timestep. The unit for comparison is also update to be same as
!cdsu flow boundary update.
!cdsu Please note tsrc is in unit day while time_bcvs in updtbcvs is original
!cdsu input unit.
!cdsu fix on May 31, 2019. Danyang Su
!cdsu ------------------------------------------------------------------------
      if ((transient_source .or. transient_source_function) .and.      &
          (.not. tran_steady_flow)) then

        if (transient_source) then
          if (itsrc.le.ntsrc .and.                                     &
              time_io.ge.tsrc(itsrc)/time_factor-tiny_delt) then

            if(rank == 0 .and. b_enable_output)  then

              write(*,*)
              write(*,*) 'update boundary conditions - reactive transport'
              write(*,*) ('-',i=1,72)
              write(*,*)

              write(ilog,*)
              write(ilog,'(a)') 'update boundary conditions - reactive transport'
              write(ilog,'(72a)')('-',i=1,72)
              write(ilog,*)

            end if

            call tranbcrt(tid)
            itsrc = itsrc + 1
            if (itsrc.gt.ntsrc) then
              tsrc(itsrc) = tfinal
            end if
          end if
        else if (transient_source_function) then
          call tranbcrt(tid)
        end if

        if (update_activity_rt.eq.'no_update') then
         update_activity(tid) = 'no_update'
        elseif (update_activity_rt.eq.'time_lagged') then
          update_activity(tid) = 'time_lagged'
        elseif (update_activity_rt.eq.'double_update') then
          update_activity(tid) = 'double_update'
        endif

      end if

!c  update cputime

        cpuint_old = cpuint
        cpuint = cputime()
        if (cpuint.lt.cpuint_old) then
          csec = csec + cpuint - cpuint_old + r86400
        else
          csec = csec + cpuint - cpuint_old
        end if
        
        prt_timestep_tot = cputime() - prt_timestep_tot
!c  write runtime to file
        if(rank == 0 .and. b_prtfile) then
          write(iprt_timestep,"(i8,2x,3(1pe15.6e3,2x))")               &
                mtime, prt_timestep_nonlinear,                         &
               (prt_timestep_tot-prt_timestep_nonlinear),              &
               prt_timestep_tot
        end if

      end do                  !end time loop
 
!cprovi----------------------------------------------------
!cprovi Write backup file for the last time 
!cprovi It was added by Sergio Andres Bea Jofre
!cprovi It was based on Richard Amos implementation and 
!cprovi Sergi Molins Implementation 
!cprovi----------------------------------------------------
      igstime = igstime - 1
      rsrt_cnt = backup_frequency*2 - 1
      if(b_enable_output)  then
        call restart_w
      end if

!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------

      return
      end
