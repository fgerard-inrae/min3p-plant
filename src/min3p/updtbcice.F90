!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updtbcice.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updtbcice
!c -------------------
!c
!c update boundary conditions (ice sheet boundary) 
!c
!c first type boundary conditions: 
!c -> define zone by delineating nodes located within zone
!c
!c
!c written by:      Danyang Su - April 16, 2020
!c
!c last modified:   
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c ----------------------------------------------------------------------
 
      subroutine updtbcice
      
#ifdef USG

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif 
      use gen
      use math_common
      use chem, only : nc, ncorder, component_type, namec
      use file_unit, only : lun_get, lun_free
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif


      use geometry
      use usg_ice_sheet
      use usg_mesh_surface
      use usg_mesh_data, only : nodes, is_boundary_node,               &
                                layer_nodes_top, layer_nodes_bottom,   &
                                cell_projection,                       &
                                node_to_layer_node, num_nodes_per_layer
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box

      implicit none

#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif
      
      integer :: i, ic, ibz, ivol, ivol_sn, ivol_ln, ibice, nbice,     &
                 ierr, ierrcd, nbicep, l_string, iflag, nparms
      integer :: itype_grad       !0: normal, 1: bottom, 2: top (layered mesh)
      
      integer, allocatable :: iabice(:)

      real*8 :: xbmin, xbmax, ybmin, ybmax, zbmin, zbmax ,factiny,     &
                pos_grad, temp_grad, temp_slope_grad, bcond_temp,      &
                thick_grad, thick_slope_grad, bcond_thick, rdummy

      character*1   :: dir_grad
      character*32  :: btypezn
      character*72  :: subsection 
      character*256 :: strbuffer

      external readbloc
 
      logical :: found_section, found_subsection, iserror
      logical :: b_updt_next_only, b_updtbc_back

      real*8, parameter :: r0 = 0.0d0, tiny = 1.0d-8

      ierrcd = 0
      b_updt_next_only = .false.
      b_updtbc_back = .false.

      if ((.not. b_interpolation_bcice .and.                            &
          time_io >= time_bcice_prev .and. time_io < time_bcice) .or.    &
          time_bcice > tfinal/time_factor) then
        return
      end if

      !c check if the current timestep right after boundary condition update is failed
      if (.not. b_first_update_bcice .and. &
        (time_io < time_bcice_prev .or. time_io > time_bcice)) then        
        b_updtbc_back = .true.
      end if
          
      !c check if the new boundary condition update is necessary
      if (time_io.ge.time_bcice .or.                                   &
          b_restart_update_bcice .or. b_first_update_bcice .or.        &
          b_updtbc_recall .or. b_updtbc_back) then
          
        if(rank == 0 .and. b_enable_output)  then   
                                                                       
          write(*,*)
          write(*,*) 'update boundary conditions - ',                  &
                     'ice sheet loading/unloading'
          write(*,*) ('-',i=1,72)
          write(*,*)

          write(ilog,*)
          write(ilog,'(2a)') 'update boundary conditions - ',          &
                             'ice sheet loading/unloading'
          write(ilog,'(72a)')('-',i=1,72)
          write(ilog,*)
        
        end if

!c  read section header for boundary conditions of ice sheet model
        if (update_bcice_value_only) then
          goto 100
        else
         section_header = 'boundary conditions - ice sheet loading/unloading'
         call readbloc (idat,itmp,section_header,found_section,.true.)
        end if
!c  define length of section header

        l_string = index(section_header,'  ')-1
        if (l_string.eq.-1.or.l_string.gt.72) then
           l_string=72
        end if

!c  read number of boundary zones
 
        ierrcd = 1
        read(itmp,*,err=999,end=999) nbzice

!c  read values of new boundary conditions
100     continue

!c  allocate array for reading new boundary conditions, 
!c  including ocean temperature and ocean ice thickness
!c  update the size of rwork and rwork_next if icesheet model 
!c  has more than 7 parameters

        allocate (rwork(7,nbzice), stat = ierr)
        rwork=0.0d0 
        call checkerr(ierr,'rwork',ilog)
        call memory_monitor(sizeof(rwork),'rwork',.true.)

        allocate (rwork_next(7,nbzice), stat = ierr)
        rwork_next=0.0d0 
        call checkerr(ierr,'rwork_next',ilog)
        call memory_monitor(sizeof(rwork_next),'rwork_next',.true.)

!c  assign new boundary conditions for ice sheet model.
!c  definition of column of ice boundary condition, each boundary type has five parameters, 
!c  the first column is time, followed by 5 parameters for each boundary type
!c  e.g., 'gradient' ice boundary type
!c        time, temp_grad, thick_grad, temp_slope_grad, thick_slope_grad, rdummy
!c        'curve-fitting' ice boundary type
!c        time, ocean_temp, ocean_ice_thick, exponent, advance_coeff, retreat_coeff
!c        'first' ice boundary type
!c        time, bcond_temp, bcond_thick, rdummy, rdummy, rdummy
      
        if (b_first_update_bcice .and.                                 &
            time_io.ge.time_bcice_prev .and. time_io.le.time_bcice) then
          b_updt_next_only = b_first_update_bcice

          backspace(ibcice)

          read(ibcice,*,err=998,end=997) time_bcice_prev,              &
              (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)

          do while (time_io < time_bcice_prev)
            backspace(ibcice)
            backspace(ibcice)
            read(ibcice,*,err=998,end=997) time_bcice_prev,            &
                (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
          end do
          
          do while (time_io > time_bcice)
            read(ibcice,*,err=998,iostat=iflag) time_bcice_prev,       &
                (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
            !c end of file has reached
            if (iflag < 0) then
              time_bcice = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else            
              if (time_io < time_bcice_prev) then
                backspace(ibcice)
                backspace(ibcice)
                read(ibcice,*,err=998,end=997) time_bcice_prev,        &
                    (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
                exit
              end if
            end if
          end do
          read(ibcice,*,err=998,iostat=iflag) time_bcice,              &
              (rwork_next(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
          !c end of file has reached
          if (iflag < 0) then
            time_bcice = (tfinal+delt)/time_factor
            rwork_next = rwork
          end if  

        else  
          backspace(ibcice)
          read(ibcice,*,err=998,end=997) time_bcice_prev,              &
              (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)

          do while (time_io < time_bcice_prev)
            backspace(ibcice)
            backspace(ibcice)
            read(ibcice,*,err=998,end=997) time_bcice_prev,            &
                (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
          end do

          do while (time_io > time_bcice)
            read(ibcice,*,err=998,iostat=iflag) time_bcice_prev,       &
                (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
            !c end of file has reached
            if (iflag < 0) then
              time_bcice = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else
              if (time_io < time_bcice_prev) then
                backspace(ibcice)
                backspace(ibcice)
                read(ibcice,*,err=998,end=997) time_bcice_prev,        &
                    (rwork(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
                exit
              end if
            end if
          end do        
          
          if (b_interpolation_bcice) then
            read(ibcice,*,err=998,iostat=iflag) time_bcice,            &
                (rwork_next(1:ice_fitting_parms(ibz,1)%nparms,ibz),ibz=1,nbzice)
            !c end of file has reached
            if (iflag < 0) then
              time_bcice = (tfinal+delt)/time_factor
              rwork_next = rwork
            end if
            !c backspace, time_bcice will be read again later
            backspace(ibcice)
          end if
        end if

!c  if boundary type and zone is unchanged, just update the value
!c  without reading zone and type again, DSU 2019-10-28
!c  note: actually the boundary type and zone cannot be changed in the current version
        if (update_bcice_value_only) then

          do ibz = 1, nbzice
            if (.not. b_updt_next_only .or. b_restart_update_bcice) then
              btypezn = ice_fitting_parms(ibz,1)%btypezn
              if (btypezn.eq.'gradient')then
                ice_fitting_parms(ibz,1)%thick_grad = rwork(1,ibz)
                ice_fitting_parms(ibz,1)%thick_slope_grad = rwork(2,ibz)
              else if (btypezn.eq.'curve-fitting')then
                ice_fitting_parms(ibz,1)%sea_level = rwork(1,ibz)
                ice_fitting_parms(ibz,1)%sea_level_temp_coeff = rwork(2,ibz)
                ice_fitting_parms(ibz,1)%ice_thick_sea_level_coeff = rwork(3,ibz)
                ice_fitting_parms(ibz,1)%sea_level_threshold = rwork(4,ibz)
                ice_fitting_parms(ibz,1)%elevation_threshold = rwork(5,ibz)
              else if (btypezn.eq.'ellipsoid-fitting')then
                ice_fitting_parms(ibz,1)%ellip_x0 = rwork(1,ibz)
                ice_fitting_parms(ibz,1)%ellip_y0 = rwork(2,ibz)
                ice_fitting_parms(ibz,1)%ellip_z0 = rwork(3,ibz)
                ice_fitting_parms(ibz,1)%ellip_a = rwork(4,ibz)
                ice_fitting_parms(ibz,1)%ellip_b = rwork(5,ibz)
                ice_fitting_parms(ibz,1)%ellip_c = rwork(6,ibz)
                ice_fitting_parms(ibz,1)%ellip_alpha = rwork(7,ibz)
              else
                ice_fitting_parms(ibz,1)%ice_thickness = rwork(1,ibz)
              end if
            end if

            if (b_interpolation_bcice) then
              btypezn = ice_fitting_parms(ibz,2)%btypezn
              if (btypezn.eq.'gradient')then
                ice_fitting_parms(ibz,2)%thick_grad = rwork_next(1,ibz)
                ice_fitting_parms(ibz,2)%thick_slope_grad = rwork_next(2,ibz)
              else if (btypezn.eq.'curve-fitting')then
                ice_fitting_parms(ibz,2)%sea_level = rwork_next(1,ibz)
                ice_fitting_parms(ibz,2)%sea_level_temp_coeff = rwork_next(2,ibz)
                ice_fitting_parms(ibz,2)%ice_thick_sea_level_coeff = rwork_next(3,ibz)
                ice_fitting_parms(ibz,2)%sea_level_threshold = rwork_next(4,ibz)
                ice_fitting_parms(ibz,2)%elevation_threshold = rwork_next(5,ibz)
              else if (btypezn.eq.'ellipsoid-fitting')then
                ice_fitting_parms(ibz,2)%ellip_x0 = rwork_next(1,ibz)
                ice_fitting_parms(ibz,2)%ellip_y0 = rwork_next(2,ibz)
                ice_fitting_parms(ibz,2)%ellip_z0 = rwork_next(3,ibz)
                ice_fitting_parms(ibz,2)%ellip_a = rwork_next(4,ibz)
                ice_fitting_parms(ibz,2)%ellip_b = rwork_next(5,ibz)
                ice_fitting_parms(ibz,2)%ellip_c = rwork_next(6,ibz)
                ice_fitting_parms(ibz,2)%ellip_alpha = rwork_next(7,ibz)  
              else
                ice_fitting_parms(ibz,2)%ice_thickness = rwork_next(1,ibz)
              end if
            end if
          end do

          do ivol_sn = 1, num_nodes_sn
            ibz = node_idx_sn2bz(ivol_sn)

            if (ibz < 1) then
              cycle  
            end if

            !c update ice sheet thickness
            ice_thickness_old(ivol_sn) = ice_thickness_new(ivol_sn)

            if (b_interpolation_bcice) then
              call usg_ice_cal_thickness(ivol_sn,ice_fitting_parms(ibz,1),     &
                                         ice_thickness_new_prev(ivol_sn))
              call usg_ice_cal_thickness(ivol_sn,ice_fitting_parms(ibz,2),     &
                                         ice_thickness_new_next(ivol_sn))

              ice_thickness_new(ivol_sn) =                                     &
                  math_common_linear(time_bcice_prev, time_bcice,              &
                                     ice_thickness_new_prev(ivol_sn),          &
                                     ice_thickness_new_next(ivol_sn),          &
                                     time_io)
              if (b_restart_update_bcice) then
                ice_thickness_old(ivol_sn) =                                   &
                math_common_linear(time_bcice_prev, time_bcice,                &
                                   ice_thickness_new_prev(ivol_sn),            &
                                   ice_thickness_new_next(ivol_sn),            &
                                   time_io-delt_io)
              end if

              if (b_phw2ice) then
                call usg_ice_cal_thickness_phw2ice(ivol_sn)
              end if

            else
              call usg_ice_cal_thickness(ivol_sn)
              if (b_phw2ice) then
                call usg_ice_cal_thickness_phw2ice(ivol_sn)
              end if
            end if

          end do

          b_first_update_bcice = .false.

          goto 500
        end if

!c initialize array for ice boundary conditions    
        allocate (iabice(nngl), stat = ierr) 
        iabice=0 
        call checkerr(ierr,'iabice',ilog)
        call memory_monitor(sizeof(iabice),'iabice',.true.)      
        
  !c initialize parameters of curve fitting ice sheet model 
        if (allocated(ice_fitting_parms)) then
          if (size(ice_fitting_parms,1) /= nbzice) then
            call memory_monitor(-sizeof(ice_fitting_parms),            &
                                'ice_fitting_parms',.true.)
            deallocate (ice_fitting_parms, stat = ierr)
            call checkerr(ierr,'ice_fitting_parms',ilog)
          end if
        end if

        if (.not. allocated(ice_fitting_parms)) then
          allocate (ice_fitting_parms(nbzice,2), stat = ierr)
          call checkerr(ierr,'ice_fitting_parms',ilog)
          call memory_monitor(sizeof(ice_fitting_parms),               &
                              'ice_fitting_parms',.true.)
        end if

!c  initialize counter for boundary control volumes
        nbice=0
        iabice(1) = 1 

!c  read name of zone
!c  loop over number of zones 
        do ibz = 1, nbzice                                 !loop over number of zones
!c  temporary pointer for output         
          nbicep = nbice+1 
                                                                        
!c  find current zone in input file and write to temporary file          
                                                                                  
          subsection = 'number and name of zone' 
                                                                                  
          call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                                  
          if (found_subsection) then                                                                                 
            call readzone(itmp,icnv,ilog,zone_name,found_subsection)            
          else 
            if (rank == 0) then                                                              
              write(ilog,*) 'SIMULATION TERMINATED' 
              write(ilog,*) 'error in input file' 
              write(ilog,*) 'section "',section_header(:l_string),'"' 
              write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if  

!c  define length of zone name
          l_zone_name = index(zone_name,' ')-1 
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
            l_zone_name = 72 
          end if  

!c  define type and value of boundary condition                          
                                                                        
          subsection = 'boundary type' 
                                                                        
          call findstrg(subsection,icnv,found_subsection) 
                                                                          
          if (found_subsection) then
            ierrcd = 2
            read(icnv,'(a)',err=999,end=999) strbuffer
            strbuffer = adjustl(strbuffer)  
            if(index(strbuffer,'gradient') == 2) then
              if(index(strbuffer,'gradient-top') == 2) then
                ice_fitting_parms(ibz,1)%itype_grad = 2
              else if(index(strbuffer,'gradient-bottom') == 2) then
                ice_fitting_parms(ibz,1)%itype_grad = 1
              else
                ice_fitting_parms(ibz,1)%itype_grad = 0
              end if

              if (.not. b_use_layered_mesh) then
                ice_fitting_parms(ibz,1)%itype_grad = 0
              end if

              ice_fitting_parms(ibz,1)%btypezn = 'gradient'
              ierrcd = 3
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%dir_grad
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%thick_grad
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%thick_slope_grad

              if (ice_fitting_parms(ibz,1)%dir_grad /= 'x' .and. &
                  ice_fitting_parms(ibz,1)%dir_grad /= 'y' .and. &
                  ice_fitting_parms(ibz,1)%dir_grad /= 'z') then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'Error in gradient direction'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            else if(index(strbuffer,'curve fitting ice sheet model') == 2) then
              ice_fitting_parms(ibz,1)%btypezn = 'curve-fitting'
              ierrcd = 4
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%sea_level
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%sea_level_temp_coeff         
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ice_thick_sea_level_coeff
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%sea_level_threshold
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%elevation_threshold 
            else if(index(strbuffer,'ellipsoid fitting ice sheet model') == 2) then
              ice_fitting_parms(ibz,1)%btypezn = 'ellipsoid-fitting'
              ierrcd = 5
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_x0
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_y0
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_z0
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_a
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_b
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_c
              read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_alpha                     
            else
              ierrcd = 6
              read(strbuffer,*,err=999,end=999) ice_fitting_parms(ibz,1)%btypezn,      &
                                                ice_fitting_parms(ibz,1)%ice_thickness
            end if
                                                                          
          else 
            if (rank == 0) then                                                              
              write(ilog,*) 'SIMULATION TERMINATED' 
              write(ilog,*) 'error reading input file' 
              write(ilog,*) 'section "',trim(section_header),'"' 
              write(ilog,*) 'zone "', trim(zone_name),'"' 
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if 

!c  read coordiantes defining boundary zone,                             
                                                                        
          type_extent_zone = -1
          type_extent_zone_box = -1
  
          subsection = 'extent of zone'
          call findstrg(subsection,icnv,found_subsection)
  
          if (found_subsection) then  
            type_extent_zone = 0  
            ierrcd = 7
            read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,      &
                                         zbmin,zbmax  
          end if

          call read_zone_usg_input(icnv)
          if (type_extent_zone_box > 0) then
            ierrcd = 8
            read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,      &
                                         zbmin,zbmax
          end if

          !c check if x dimension is valid
          if (.not.btest(cell_projection,0)) then
            xbmin = -1.0d300
            xbmax = 1.0d300
          end if
        
          !c check if y dimension is valid
          if (.not.btest(cell_projection,1)) then
            ybmin = -1.0d300
            ybmax = 1.0d300
          end if
        
          !c check if z dimension is valid
          if (.not.btest(cell_projection,2)) then
            zbmin = -1.0d300
            zbmax = 1.0d300
          end if          
  
!c  write error information if 'extent of zone' is missing
          if (type_extent_zone < 0) then  
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',trim(section_header),'"'
              write(ilog,*) 'zone "', trim(zone_name),'"'
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop  
          end if  

!c  increment boundary coordinates                                       
                                                                        
          factiny=dabs(xbmax-xbmin)*tiny 
          if (factiny==r0) factiny=tiny 
          xbmin = xbmin-factiny 
          xbmax = xbmax+factiny 
          factiny=dabs(ybmax-ybmin)*tiny 
          if (factiny==r0) factiny=tiny 
          ybmin = ybmin-factiny 
          ybmax = ybmax+factiny 
          factiny=dabs(zbmax-zbmin)*tiny 
          if (factiny==r0) factiny=tiny 
          zbmin = zbmin-factiny 
          zbmax = zbmax+factiny 

!c  store type of boundary condition and boundary condition              
!c  for global system in compressed storage

          do ivol = 1,nngl
!c  skip internal nodes
            ivol_sn = node_idx_lg2sn(ivol)
            if (ivol_sn < 1) then
              cycle
            end if          

!c  check limits of boundary zone                                        
                                                                                    
            if (((type_extent_zone==0.or.type_extent_zone_box>0).and.  &
                (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.      &
                (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.      &
                (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.      &
                (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.   &
                ibits(type_extent_zone,0,1)==0)) then

              if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                if ((btest(type_extent_zone_box,1) .and.               &
                     .not. is_boundary_node(ivol)) .or.                &
                    (btest(type_extent_zone_box,2) .and.               &
                     is_boundary_node(ivol))) then
                  cycle
                end if
              end if

!  assign boundary type and boundary condition                          
                                                                        
              nbice = nbice+1
              iabice(nbice) = ivol

              node_idx_sn2bz(ivol_sn) = ibz
                                                                        
!  exit if nbice > nn                                                    
                                                                        
              if (nbice.gt.nngl) then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'nbice > nn ...'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if                                                                             

              !c update ice sheet thickness
              ice_thickness_old(ivol_sn) = ice_thickness_new(ivol_sn)
              call usg_ice_cal_thickness(ivol_sn)
                    
            end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                         !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                         !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
          end do         !loop over control volumes 

!c  disable output of updated boundary condition since
          if (.false.) then
!c  write header for boundary zone to generic output file                
            if (b_enable_output .and. b_enable_output_gen) then
              write(igen,'(/a,i0,a,1x,a)') 'zone ',ibz,':',zone_name 
              write(igen,'(72a)')('-',i=1,72)                                          

#ifdef PETSC   
              write(igen,'(4(a,3x)/)') 'local volume',                 &
                    'global volume', 'boundary type', 'thickness' 
#else
              write(igen,'(2x,a,3x,a,5x,a/)') 'volume',                &
                    'boundary type','thickness'
#endif
            end if          

!c  write boundary condition for zone to generic output file            
                                                                        
!c  first and gradient type   
            if (b_enable_output .and. b_enable_output_gen) then                                  
              do ibice=nbicep,nbice
                ivol = iabice(ibice)
                ivol_sn = node_idx_lg2sn(ivol)
#ifdef PETSC
                if(node_idx_lg2l(ivol) > 0) then
                  write(igen,'(i10,5x,i10,6x,a16,1pe15.6e3,1x)')       &
                        ivol,node_idx_lg2g(ivol),                      &
                        ice_fitting_parms(ibz,1)%btypezn,              &
                        ice_thickness_new(ivol_sn)
                end if
#else
                write(igen,'(i8,3x,a16,1pe15.6e3,1x)') ivol,           &
                      ice_fitting_parms(ibz,1)%btypezn,                &
                      ice_thickness_new(ivol_sn)
#endif
              end do
            end if
          end if
        end do

500     continue

!c  free space for array not required any more
!c  array iabice  
        if (allocated(iabice)) then    
          call memory_monitor(-sizeof(iabice),'iabice',.true.)
          deallocate (iabice, stat = ierr)
          call checkerr(ierr,'iabice',ilog)
        end if

!c  deallocate workarray for reading transient boundary conditions
        if (allocated(rwork)) then
          call memory_monitor(-sizeof(rwork),'rwork',.true.)
          deallocate (rwork, stat = ierr)
          call checkerr(ierr,'rwork',ilog)
        end if

        if (allocated(rwork_next)) then
          call memory_monitor(-sizeof(rwork_next),'rwork_next',.true.)
          deallocate (rwork_next, stat = ierr)
          call checkerr(ierr,'rwork_next',ilog)
        end if

!c  global ice thickness, used for pore stress calculation
#ifdef PETSC
        ice_thickness_gbl_old = ice_thickness_gbl_new

        ice_thickness_gbl_tmp = r0
        do ivol_sn = 1, num_nodes_sn
          ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
          ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_new(ivol_sn)
        end do        
  
        call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_gbl_new,  &
                           num_nodes_per_layer,MPI_REAL8,MPI_MAX,        &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        if (b_interpolation_bcice .and. b_restart_update_bcice) then
          ice_thickness_gbl_tmp = r0
          do ivol_sn = 1, num_nodes_sn
            ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
            ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_old(ivol_sn)
          end do        
    
          call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_gbl_old,  &
                             num_nodes_per_layer,MPI_REAL8,MPI_MAX,        &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
        end if

        !c positive water head as extra thickness when icesheet advances.
        ice_thickness_phw2ice_gbl_old = ice_thickness_phw2ice_gbl_new

        ice_thickness_gbl_tmp = r0
        do ivol_sn = 1, num_nodes_sn
          ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
          ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_phw2ice_new(ivol_sn)
        end do        
  
        call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_phw2ice_gbl_new,  &
                           num_nodes_per_layer,MPI_REAL8,MPI_MAX,                &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        if (b_interpolation_bcice .and. b_restart_update_bcice) then
          ice_thickness_gbl_tmp = r0
          do ivol_sn = 1, num_nodes_sn
            ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
            ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_phw2ice_old(ivol_sn)
          end do        
    
          call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_phw2ice_gbl_old,  &
                             num_nodes_per_layer,MPI_REAL8,MPI_MAX,                &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
        end if
#endif

!c  restore the reading position to previous record
        if (b_updt_next_only) then
          backspace(ibcice)
        end if

!c  assign next read time
        if (time_bcice < tfinal/time_factor) then
          read(ibcice,*,err=998,end=997) time_bcice
        end if

        return

!c  assign next read time greater than final solution time, if no more
!c  read times left and return
!cdsu replace 1.1*tfinal since tfinal can be negative

997     continue
        time_bcice = (tfinal+1.0d100)/time_factor
        return

998     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcice'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

999     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file, error code ', ierrcd
          write(ilog,*) 'section "',section_header(:l_string),'"'
          write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      else if (b_interpolation_bcice) then
        do ivol_sn = 1, num_nodes_sn
          ibz = node_idx_sn2bz(ivol_sn)

          if (ibz < 1) then
            cycle  
          end if

          !c update ice sheet thickness
          ice_thickness_old(ivol_sn) = ice_thickness_new(ivol_sn)
          ice_thickness_new(ivol_sn) =                                 &
                math_common_linear(time_bcice_prev, time_bcice,        &
                                   ice_thickness_new_prev(ivol_sn),    &
                                   ice_thickness_new_next(ivol_sn),    &
                                   time_io)

          if (b_restart_update_bcice) then
            ice_thickness_old(ivol_sn) =                               &
            math_common_linear(time_bcice_prev, time_bcice,            &
                               ice_thickness_new_prev(ivol_sn),        &
                               ice_thickness_new_next(ivol_sn),        &
                               time_io-delt_io)
          end if

          if (b_phw2ice) then
            call usg_ice_cal_thickness_phw2ice(ivol_sn)
          end if
                      
        end do
  
  !c  global ice thickness, used for pore stress calculation
#ifdef PETSC
        ice_thickness_gbl_old = ice_thickness_gbl_new

        ice_thickness_gbl_tmp = r0
        do ivol_sn = 1, num_nodes_sn
          ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
          ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_new(ivol_sn)
        end do        
  
        call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_gbl_new,&
                           num_nodes_per_layer,MPI_REAL8,MPI_MAX,      &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        if (b_restart_update_bcice) then
          ice_thickness_gbl_tmp = r0
          do ivol_sn = 1, num_nodes_sn
            ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
            ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_old(ivol_sn)
          end do        
    
          call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_gbl_old,  &
                             num_nodes_per_layer,MPI_REAL8,MPI_MAX,        &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
        end if

        !c positive water head as extra thickness when icesheet advances.
        ice_thickness_phw2ice_gbl_old = ice_thickness_phw2ice_gbl_new

        ice_thickness_gbl_tmp = r0
        do ivol_sn = 1, num_nodes_sn
          ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
          ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_phw2ice_new(ivol_sn)
        end do        
  
        call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_phw2ice_gbl_new,  &
                           num_nodes_per_layer,MPI_REAL8,MPI_MAX,                &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        if (b_restart_update_bcice) then
          ice_thickness_gbl_tmp = r0
          do ivol_sn = 1, num_nodes_sn
            ivol_ln = node_to_layer_node(node_idx_sn2lg(ivol_sn))
            ice_thickness_gbl_tmp(ivol_ln) = ice_thickness_phw2ice_old(ivol_sn)
          end do        
    
          call MPI_Allreduce(ice_thickness_gbl_tmp,ice_thickness_phw2ice_gbl_old,  &
                             num_nodes_per_layer,MPI_REAL8,MPI_MAX,                &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
        end if
#endif
      end if
      
#endif
      return

      end
