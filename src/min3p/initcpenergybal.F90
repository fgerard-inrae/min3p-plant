!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcpenergybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpenergybal
!c -------------------
!c
!c control parameters for energy balance
!c
!c written by:      Sergio Andres bea Jofre 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           deltol_vs          = solver update tolerance             * +
!c           dinc_vs            = increment for numerical             * +
!c                                differentiation
!c           perm_fac(nn)       = scaling factor for permeability     * +
!c                                as a function of porosity changes 
!c           restol_vs          = solver residual tolerance           * +
!c           srelfac_vs         = user specified underrelaxation      * +
!c                                factor
!c           sw_star            = anticipated change in saturation    * +
!c                                per time step
!c           tol_vs             = convergence tolerance               * +
!c                                (variably saturated flow)
!c           uvslim             = max. allowed update                 * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           idetail_vs         = solver information level            * +
!c           level_vs           = incomplete factorization level      * +
!c           maxit_vs           = max. number of newton iterations    * +
!c                                (variably saturated flow)
!c           msolvit_vs         = max. number of solver iterations    * +
!c           nn                 = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   * +
!c                                           factor
!c           hydraulic_head     = .true.  -> initial condition in     * +
!c                                           terms of hydraulic head
!c           mass_balance_vs    = .true.  -> compute mass balance     * +
!c                                           (variably_saturated
!c                                            flow)
!c           pressure_head      = .true.  -> initial condition in     * +
!c                                           terms of pressure head
!c           rcm_ordering_vs    = .true.  -> rcm ordering for         * +
!c                                           1d scalar matrix
!c           under_relax        = .true.  -> underrelaxation          * +
!c           upstream           = .true.  -> upstream weighting       * +
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c dens.f:
!c           real*8:
!c           -------
!c           courant_target     = target courant number               * +
!c           drho_dc            = density-TDS constant drho / dTDS    * +
!c
!c
!c           integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         + -
!c           inpl               = counter for napl components         * +
!c           iter_target        = target number of Picard iterations  + -
!c           maxit_sia          = maximum number of Picard iterations * +
!c           ndd                = number of components used for       * +  
!c                                fluid density calculation
!c           nnpl               = total number of napl components     * +
!c  
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density         * + 
!c                                           dependent flow
!c           fluid_pressure     = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c           fresh_head         = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of freshwater head 
!c           init_perm          = .true. -> initial media             * +
!c                                           properties in 
!c                                           permeability units
!c           init_cond          = .true. -> initial media             * +
!c                                           properties in hydraulic 
!c                                           conductivity units
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c local:    
!c           real*8:
!c           -------
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures       * +   
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpenergybal
 
      use parm
      use gen
      use dens
      use chem
#ifdef PETSC
      use solver_snes_common, only : stencil_width
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: ierr, l_string, ierrcd

      external findstrg, readbloc   

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0

      logical found_section, found_subsection
      character*72 subsection, subsubsection, name
 
!c  define or read control parameters for energy balance
      ierrcd = 0
      section_header = 'control parameters - energy balance'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  general control parameters

      tol_glob = 1.0d-6  
      maxit_glob = 100 
      update_viscosity_temp = .false. 
      drho_dt = -0.34d0   ! [M L-3 oC-1]
      dinc_heat = 1.0d-4 
      tempref_dens=20.0d0 
      nonlindens_heat=.false.
      b_check_div_vs = .false.
      b_check_div_heat = .false.
      
      tempcorr_min = -1.0d300
      tempcorr_max = 1.0d300

      tempcorr_maxit = 10
      
      level_glob = 0
      msolvit_glob = 100
      idetail_glob = 1
      restol_glob = 0.1d0 * tol_glob
      deltol_glob = 0.1d0 * tol_glob      

      tol_heat = 1.0d-6
      maxit_heat = 100 

      level_heat = 0
      msolvit_heat = 100
      idetail_heat = 1
      restol_heat = 0.1d0 * tol_heat
      deltol_heat = 0.1d0 * tol_heat      
      uheatlim_log = r1
      uheatant_log = r1

      iter_glob_ant = 0
      iter_heat_ant = 0

!c  !c  extimated fractorization coefficient for linear solver, default value is 3 before
      coeff_fac_conn_glob = 4
      coeff_fac_conn_heat = 4

!c density-dependent flow and picard iteration parameters

      subsection = 'energy balance parameters'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 1
        read(itmp,*,err=999,end=999) drho_dt
      end if

      subsection = 'update viscosity'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        update_viscosity_temp = .true.
        
        allocate (viscoold(nngl), stat = ierr)
        viscoold=1.0d-3
        call checkerr(ierr,'viscoold',ilog)
        call memory_monitor(sizeof(viscoold),'viscoold',.true.)
      end if
        
!cprovi----------------------------------------------------
!cprovi Read reference temperature for density 
!cprovi----------------------------------------------------
      subsection = 'reference temperature for density'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 2
        read(itmp,*,err=999,end=999) tempref_dens
      end if
        
!cdsu----------------------------------------------------
!cdsu Correction temperature for solution update
!cdsu----------------------------------------------------
      subsection = 'temperature correction for solution'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 3
        read(itmp,*,err=999,end=999) tempcorr_min, tempcorr_max
      end if

!cdsu----------------------------------------------------
!cdsu Maximum iterations of temperature correction for solution update
!cdsu----------------------------------------------------
      subsection = 'maximum iterations of temperature correction'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 4
        read(itmp,*,err=999,end=999) tempcorr_maxit
      end if        
        
!cprovi----------------------------------------------------        
!cprovi Read  
!cprovi----------------------------------------------------
      
      if (.not. av_dens_z) then
        subsection = 'average density in z'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          av_dens_z = .true. 
        end if   
      end if     
!cprovi----------------------------------------------------        
!cprovi Read  
!cprovi----------------------------------------------------
      subsection = 'upstream factor for heat equation'
      !cprovi--------------------------------------------
      !cprovi  
      !cprovi--------------------------------------------
      ups_heat=r1 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 5
        read(itmp,*,err=999,end=999) ups_heat
        if (ups_heat>r1.or.ups_heat<r0) ups_heat=r1         
      end if        
!cprovi----------------------------------------------------        
!cprovi Read reference tds
!cprovi----------------------------------------------------
      subsection = 'reference tds'
      !cprovi--------------------------------------------
      !cprovi Assign default reference mass fraction
      !cprovi--------------------------------------------
      ref_tds = 1.0d-20 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 6
        read(itmp,*,err=999,end=999) ref_tds         
      end if        
!cprovi----------------------------------------------------
!cprovi Mass flux for second boundary condition
!cprovi We assume that the second boundary condition for
!cprovi flow is in kg/s (for default is m3/s)
!cprovi----------------------------------------------------
      subsection = 'mass flux for second boundary condition'
      massflux_second=.false.
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        massflux_second=.true.
      end if                        
!cprovi----------------------------------------------------
!cprovi  
!cprovi----------------------------------------------------
      subsection = 'logarithm in unknowns'
      islogunk_energybal=.false.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        islogunk_energybal=.true.
      end if                                                             
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'non-linear density'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        nonlindens_heat=.true. 
      end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'non-advection'
      isadvective = .true.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (rank == 0 .and. b_enable_output) then 
          write(ilog,*) 'Non-advection in energy balance'
        end if
        isadvective = .false.
      end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'non-dispersion'
      isdispersive = .true.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (rank == 0 .and. b_enable_output) then  
          write(ilog,*) 'Non-dispersion in energy balance'
        end if
        isdispersive = .false.
      end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'non-conduction'
      isconductive = .true.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (rank == 0 .and. b_enable_output) then  
          write(ilog,*) 'Non-conduction in energy balance'
        end if
        isconductive = .false.
      end if     
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'non-storage term in flow equation'
      isstorflow = .true.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (rank == 0 .and. b_enable_output) then  
          write(ilog,*) 'Non-storage term is computed in flow equation'
        end if
        isstorflow = .false.
      end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'non-storage term in heat equation'
      isstorheat = .true.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (rank == 0 .and. b_enable_output) then  
          write(ilog,*) 'Non-storage term is computed in heat equation'
        end if
        isstorheat = .false.
      end if                              
!cprovi----------------------------------------------------
!cprovi Update Lambda thermal conductivity
!cprovi----------------------------------------------------
      subsection = 'update water thermal conductivity'
      update_heatcondw = .false. 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        update_heatcondw = .true. 
      end if

     
!cdsu----------------------------------------------------
!cdsu compute ice heat transport when water freezing/thawing is considered
!cdsu----------------------------------------------------
      b_icewater_heat = .false.

      if (b_water_freezing) then
        subsection = 'update energy balance parameters for ice'
        call findstrg(subsection,itmp,found_subsection)
  
        if (found_subsection) then
          b_icewater_heat = .true.
        end if  
      end if

!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
      subsection = 'assume boussinesq approximation'
      isboussinesq = .false.
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        isboussinesq=.true. 
      end if
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read if evaporation of water is computed
!cprovi----------------------------------------------------
!cdsu to be further checked
!cdsu use of evaporation is buggy in the code, here it is used for
!cdsu variably_saturated flow only, but in the code this keyword is
!cdsu used in full saturated flow as well.
      subsection = 'compute evaporation'
      evaporation = .false. 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (variably_saturated) then
           
          evaporation = .true.
          if (rank == 0 .and. b_enable_output) then
            write(ilog,*) 'Evaporation processes are computed'
          end if
        else
          if (rank == 0 .and. b_enable_output) then 
            write(ilog,*) 'Evaporation can not be computed'
            write(ilog,*) 'Please, set the problem to'
            write(ilog,*) 'variable saturated flow'
            write(*,*) 'Evaporation can not be computed'
            write(*,*) 'Please, set the problem to'
            write(*,*) 'variable saturated flow'
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if      
        
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read viscosity model for temperature
!cprovi----------------------------------------------------
      subsection = 'viscosity model'
      iviscomodel=2 ! diersch model
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 7
        read(itmp,*,err=999,end=999) name
        if (name=='sutra') then
          iviscomodel=1
        else if (name=='diersch') then
          iviscomodel=2
        else
          if (rank == 0) then
            write (*,*) 'Viscosity model not implemented'
            write (ilog,*) 'Viscosity model not implemented'
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
        end if
      end if  
    
!cdsu  ----------------------------------------------------
!cdsu  compute heat released from mineral oxidation, make it for general minerals
!cdsu  ----------------------------------------------------
      reaction_heat = .false. 
      subsection = 'compute reaction heat as sink source'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then              
        reaction_heat=.true.
      else 
        !c deprecated keyword 
        subsection = 'compute heat released from pyrite oxidation'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then              
          reaction_heat=.true.
        end if
      end if 
      if (rank == 0 .and. b_enable_output .and. reaction_heat) then
        write(ilog,'(a)') 'sink-source heat processes are computed'
      end if
        
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read if energy balance must be computed
!cprovi Default value => false
!cprovi----------------------------------------------------
      imheat=0
      imheat_first=0
      imheat_last=0
      culabsbalheat = r0
      culrelbalheat = r0

      subsection = 'energy balance'
      energy_balance=.false. 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        energy_balance=.true.
      end if         
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read thermal conductivity model
!cprovi----------------------------------------------------
      subsection = 'thermal conductivity model'
      heatcond_model = 'model 1'
      nheatcond = r1
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 8
        read(itmp,*,err=999,end=999) heatcond_model
        select case (heatcond_model)
        case ('model 1','model 2','model 3','model 4','model 5',   &
                'model 6')
          if (heatcond_model=='model 5') then
            ierrcd = 9
            read(itmp,*,err=999,end=999) nheatcond
          end if
        case default
          if (rank == 0) then 
            write (*,*) 'Thermal conductivity model not implemented'
            write (ilog,*) 'Thermal conductivity model not implemented'
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end select
      end if        
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read if entalphy change source is considered
!cprovi----------------------------------------------------
      entalphy_change=.false.
      if (reactive_transport) then          
        subsection = 'entalphy change'           
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          entalphy_change=.true.
        end if      
      end if
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read the gravity constant
!cprovi----------------------------------------------------
      subsection = 'gravity constant'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 10
        read(itmp,*,err=999,end=999) gacc           
      end if
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi  
!cprovi----------------------------------------------------
      subsection = 'spatial weighting'
      call findstrg(subsection,itmp,found_subsection)
      sp_weight_heat='upstream' 
      if (found_subsection) then
        ierrcd = 11
        read(itmp,*,err=999,end=999) sp_weight_heat     
       
        if (sp_weight_heat=='van leer') then
          sp_weight_heat='vanleer'
        elseif (sp_weight_heat=='van leer 2') then
          sp_weight_heat='vanleer2'
        elseif (sp_weight_heat=='centered 2') then   
          sp_weight_heat='centered2'
        end if
         
#ifdef PETSC
        if (sp_weight_heat=='vanleer' .or.       &
            sp_weight_heat=='vanleer2') then
          if (nprcs > 1 .and. stencil_width < 2) then
            if (rank == 0) then
              write(*,'(2a)') "Error van leer spatial weighting ",    &
                              "requires stencil width 2 or larger"
              write(ilog,'(2a)') "Error van leer spatial weighting ", &
                              "requires stencil width 2 or larger"
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop
          end if
        end if
#endif

        if (sp_weight_heat/='upstream'.and.      &
            sp_weight_heat/='centered'.and.      &
            sp_weight_heat/='centered2'.and.     &
            sp_weight_heat/='vanleer'.and.       &
            sp_weight_heat/='vanleer2') then
          if (rank == 0) then  
           write(ilog,'(a)')                     &
          'error reading subsection "spatial weighting" energy balance'
           write(*,'(a)')                        &
          'error reading subsection "spatial weighting" energy balance'
          end if 
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if      
      end if                                                   
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------

      subsection = 'user specified underrelaxation factor'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        under_relax_temp = .true.
        ierrcd = 12
        read(itmp,*,err=999,end=999) srelfac_temp
      end if

      if (under_relax_temp) then
        srelrange_temp_min = -1.0d100
        srelrange_temp_max = 1.0d100
        subsection = 'user specified underrelaxation range'
        call findstrg(subsection,itmp,found_subsection)  
        if (found_subsection) then
          under_relax_range_temp = .true.
          ierrcd = 13
          read(itmp,*,err=999,end=999) srelrange_temp_min,srelrange_temp_max
        end if
      end if        
        
      subsection = 'compute underrelaxation factor'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        under_relax_temp = .true.
        comp_relax_temp = .true.
        ierrcd = 14
        read(itmp,*,err=999,end=999) utemplim
      end if
        
!c  check divergence for newton iteration
      subsection = 'enable divergence check'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        if (decoupled_type_vs_heat <= 1) then
          b_check_div_vs = .true.
        else
          b_check_div_heat = .true.
        end if
      end if

!cdsu Run steady state flow in transient mode, here apply to heat transport.
!cdsu For some steady state flow, because of transient effect, the simulation
!cdsu may encounter convergence problem if using steady state flow directly.
!cdsu In this case, transient flow can be used until flow reaches steady state condition.
!cdsu To use this feature, please set flow to transient flow and add the following keywords
      rtol_tran_steady_heat = 1.0d-6
      atol_tran_steady_heat = 1.0d-6
      if (tran_steady_flow) then
        subsection = 'tolerance for steady state'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 15
          read(itmp,*,err=999,end=999) rtol_tran_steady_heat
          read(itmp,*,err=999,end=999) atol_tran_steady_heat
        end if
      end if

!cdsu  solver parameters

      subsection = 'newton iteration settings plus'

      call findstrg(subsection,itmp,found_subsection)
        
      if (found_subsection) then
        if (decoupled_type_vs_heat <= 1) then
          ierrcd = 16
          read(itmp,*,err=999,end=999) dinc_heat
          read(itmp,*,err=999,end=999) iter_glob_ant
          read(itmp,*,err=999,end=999) maxit_glob
          read(itmp,*,err=999,end=999) tol_glob
          read(itmp,*,err=999,end=999) uheatlim_log
        else
          ierrcd = 17
          read(itmp,*,err=999,end=999) dinc_heat
          read(itmp,*,err=999,end=999) iter_heat_ant
          read(itmp,*,err=999,end=999) maxit_heat
          read(itmp,*,err=999,end=999) tol_heat
          read(itmp,*,err=999,end=999) uheatlim_log 
          !optional parameter for anticipated temperature change                     
          read(itmp,*,err=997,end=997) uheatant_log
997       continue
        end if
      end if    
      
      subsection = 'anticipated number of newton iterations'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (decoupled_type_vs_heat <= 1) then
          ierrcd = 18
          read(itmp,*,err=999,end=999) iter_glob_ant
        else
          ierrcd = 19
          read(itmp,*,err=999,end=999) iter_heat_ant
        end if
      end if

      subsection = 'newton iteration settings'

      call findstrg(subsection,itmp,found_subsection)
        
      if (found_subsection) then
        if (decoupled_type_vs_heat <= 1) then
          ierrcd = 20
          read(itmp,*,err=999,end=999) dinc_heat
          read(itmp,*,err=999,end=999) maxit_glob
          read(itmp,*,err=999,end=999) tol_glob
          read(itmp,*,err=999,end=999) uheatlim_log
        else
          ierrcd = 21
          read(itmp,*,err=999,end=999) dinc_heat
          read(itmp,*,err=999,end=999) maxit_heat
          read(itmp,*,err=999,end=999) tol_heat
          read(itmp,*,err=999,end=999) uheatlim_log 
          !optional parameter for anticipated temperature change           
          read(itmp,*,err=998,end=998) uheatant_log
998       continue
        end if
      end if

      subsection = 'coefficient of factored connections'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 22
        read(itmp,*,err=999,end=999) coeff_fac_conn_glob 
      end if

!c  solver settings

      subsection = 'solver settings'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 22
        read(itmp,*,err=999,end=999) level_glob 
        read(itmp,*,err=999,end=999) msolvit_glob
        read(itmp,*,err=999,end=999) idetail_glob
        read(itmp,*,err=999,end=999) restol_glob
        read(itmp,*,err=999,end=999) deltol_glob  

        coeff_fac_conn_heat = coeff_fac_conn_glob
        level_heat = level_glob
        msolvit_heat = msolvit_glob
        idetail_heat = idetail_glob
        restol_heat = restol_glob
        deltol_heat = deltol_glob
      end if
        
 
      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
