!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initbcvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

! ----------------------------------------------------------------------
! subroutine initbcvs                                                   
! -------------------                                                   
!                                                                       
! boundary conditions (variably saturated flow)                         
!                                                                       
! first type boundary conditions:                                       
! -> define zone by delineating nodes located within zone               
!                                                                       
! second type boundary condition:                                       
! -> define area (only on surface of solution domain)                   
!                                                                       
! seepage face boundary condition:                                      
! -> define area (only on surface of solution domain)                   
!                                                                       
! written by:      Uli Mayer - May 17, 96                               
!                                                                       
! last modified:   Tom Henderson - March 24, 2003                       
!                  - added point source
!
!                  Danyang Su - Sept. 10, 2018
!                  Unstructured grid and HPC capabilities
!                                                                       
! definition of variables:                                              
!                                                                       
! I --> on input   * arbitrary  - initialized  + entries expected       
! O --> on output  * arbitrary  - unaltered    + altered                
!                                                                       
!                                                                    I O
! passed:   -                                                           
!                                                                       
! common:                                                               
! gen.f:    real*8:                                                     
!           -------                                                     
!           bcondvs(nbvs)      = boundary condition                  * +
!                                (pressure head or flux) or             
!                                identification of seepage face         
!                                boundary type                          
!           dimcv(3,nn)        = spatial dimensions of control       + -
!                                volumes                                
!           hhead(nn)          = hydraulic head                      + +
!           rwork(:,:)         = real*8 work array                   * *
!           time_bcvs          = next read time for flow boundary    * +
!                                conditions                             
!           uvsold(nn)         = solution vector (old time level)    + +
!           uvsnew(nn)         = solution vector (new time level)    + +
!           sec_per_days       = conversion factor from SI input     + -
!                                units for physico-chemical             
!                                parameters internal time units         
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibcvs              = unit number, transient boundary     * +
!                                             conditions, variably      
!                                             saturated flow            
!           idat               = unit number, run specific input     + -
!                                             file                      
!           igen               = unit number, generic output file    + -
!           ilog               = unit number, log book               + -
!           itmp               = unit number, temporary storage      + -
!           iabvs(nbvs)        = pointer to boundary control volumes * +
!                                for variably saturated flow            
!           iwork(:)           = integer work array                  * *
!           l_prfx             = length of prefix of I/O files       + -
!           l_zone_name        = length of zone name                 * +
!           nn                 = total number of control volumes     + -
!           nbvs               = number of specified boundary        * +
!                                control volumes                        
!                                (variably saturated flow)              
!           nseep_first        = number of seepage face nodes        * +
!                                                                       
!           logical:                                                    
!           --------                                                    
!           fully_saturated    = .true.  -> saturated conditions     + -
!           update_bcvs        = .true.  -> transient boundary       * +
!                                           condition for variably      
!                                           saturated flow              
!           variably_saturated = .true.  -> .not.fully_saturated,    + -
!                                        -> variably saturated          
!                                           conditions                  
!           hydraulic_head     = .true.  -> initial condition in     + -
!                                           terms of hydraulic head     
!           pressure_head      = .true.  -> initial condition in     + -
!                                           terms of pressure heada     
!           seepage_face       = .true.  -> seepage face boundary    * +
!                                           specified                   
!                                                                       
!           character:                                                  
!           ----------                                                  
!           prefix             = prefix name for all I/O files       + -
!           zone_name          = name of zone                        * +
!           btypevs(nbvs)      = boundary type array                 * +
!                                (variably saturated flow)              
!                                'first'   = Dirichlet                  
!                                'second'  = Neumann                    
!                                'seepage' = seepage face               
!           section_header     = section header                      * +
!                                                                       
! local:    real*8:                                                     
!           -------                                                     
!           r0                 = constant                               
!           r1                 = constant                               
!           tiny               = small increment                        
!           xbmin              = min. x-coordinate of boundary          
!                                zone                                   
!           xbmax              = max. x-coordinate of boundary          
!                                zone                                   
!           ybmin              = min. y-coordinate of boundary          
!                                zone                                   
!           ybmax              = max. y-coordinate of boundary          
!                                zone                                   
!           zbmin              = min. z-coordinate of boundary          
!                                zone                                   
!           zbmax              = max. z-coordinate of boundary          
!                                zone                                   
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibvs               = counter (boundary control volumes)     
!           ibz                = counter (zones)                        
!           ierr               = 0 -> memory allocation successful      
!           ivol               = counter (control volumes)              
!           istart             = pointer (control volume)               
!           iend               = pointer (control volume)               
!           l_string           = length of text string                  
!           nbvsp              = start of boundary zone                 
!                                (temporary)                            
!           nbzvs              = number of boundary zones
!                                                                       
!           logical:                                                    
!           --------                                                    
!           found              = logical variable to exit search        
!           found_section      = .true.  -> section header was          
!                                           found in input file         
!           found_subsection   = .true.  -> subsection header was       
!                                           found in input file         
!           xy_plane           = boundary zone parallel tp xy-plane     
!           xz_plane           = boundary zone parallel to xz-plane     
!           yz_plane           = boundary zone parallel to yz-plane
!           xyz_plane          = boundary zone is arbitrary
!                                                                       
!           character:                                                  
!           ----------                                                  
!           bcond              = btypevs = 'first'                      
!                                -> hydraulic head                      
!                                btypevs = 'second'                     
!                                -> specified flux                      
!                                btypevs = 'seepage'                    
!                                -> initial seepage face heigth         
!           btypezn            = boundary type of zone                  
!           subsection         = name of subsection in input file       
!                                                                       
! external: checkerr  = check for error during memory allocation        
!           findstrg  = find text string in file                        
!           findzone  = find zone in input section                      
!           readbloc  = read section of input file and write to         
!                       temporary file                                  
!           readzone  = read zone in section of input file and          
!                       write to temporary file                         
! ----------------------------------------------------------------------
                                                                        
      subroutine initbcvs 
                                                                        
      use parm 
      use gen 
      use file_unit, only : lun_get, lun_free
      use file_utility, only : rewind_first_record
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, num_nodes_per_cell,  &
                                node_cells, node_num_cells,            &
                                node_to_layer_node,                    &
                                layer_nodes_top, layer_nodes_bottom,   &
                                cell2halfid, CellFaceCenter, cells,    &
                                cal_cellface_index, cell_projection,   &
                                num_faces_per_cell, CellFaceScaledNorm,&
                                is_boundary_node, num_edge_dvols,      &
                                CellCvolFaceArea, get_cell_edge_cvol_id
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#endif
      implicit none
      
      integer :: i, ibz, ibvs, ivol, ierr, nbvsp, jtemp,               &
                 l_string, istart, iend, ierrcd
      integer :: itype_grad       !0: normal, 1: bottom, 2: top (layered mesh)

      real*8 :: areaf, bcond, xbmin, xbmax, ybmin, ybmax, zbmin, zbmax,&
                factiny, h0_grad, slope_grad, pos_grad, tol_pond_loc

      real*8 :: rx0, ry0, rz0     !center of gradient-radius type i.c. or b.c. condition          
                                                                        
      external checkerr, findstrg, findzone, readbloc, readzone
                                                                        
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, tiny = 1.0d-8 
                                                                        
      logical xy_plane,xz_plane,yz_plane,found,found_section,          &
              found_subsection
      character*1   :: dir_grad
      character*32  :: btypezn
      character*72  :: subsection 
      character*256 :: strbuffer
      character*16, allocatable :: cwork(:)

      logical, external :: freezing_adjacent_bd

      real*8, external :: pressure_melt_k

#ifdef USG
      real*8 :: ratio_flux
      integer :: icell, icell2, idvol, idvol_r, iedge_r, iface, cindex,&
                 jvol, jvol1, jvol2, jvol3, jvol4
      type(point) :: pts(4)
#endif

      ierrcd = 0
      areaf = r0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
                                                                        
!  define defaults                                                      
      if(rank == 0 .and. b_enable_output) then                                                                  
        write(*,*) 'boundary conditions - ',                           &
     &             'variably saturated flow'                              
        write(*,*) ('-',i=1,72) 
                                                                        
        write(ilog,'(2a)') 'boundary conditions - ',                   &
     &                     'variably saturated flow'                      
        write(ilog,'(72a/)')('-',i=1,72) 
      end if  
                                                                        
!  read section header for boundary conditions of variably saturated    
!  flow simulation                                                      
                                                                        
      section_header = 'boundary conditions - variably saturated flow' 
      call readbloc (idat,itmp,section_header,found_section,.true.) 

                                                                       
!  define length of section header                                      
                                                                        
      l_string = index(section_header,'  ')-1 
      if (l_string.eq.-1.or.l_string.gt.72) then 
         l_string=72 
      end if 
                                                                        
!  terminate program if section header not found                        
                                                                        
      if (.not.found_section) then 
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file' 
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop 
      end if 
                                                                        
!  write section header to generic output file                          
      if (b_enable_output .and. b_enable_output_gen) then                                                                  
        write(igen,'(/72a)')('-',i=1,72) 
        write(igen,'(a)') section_header(:l_string) 
        write(igen,'(72a/)')('-',i=1,72) 
      end if
                                                                        
!  initialize variables for seepage face iteration                      
                                                                        
      seepage_face = .false. 
      seep_iter = .false.
      nseep_first = 0 
                                                                        
!  preliminary allocation of memory for boundary conditions             
                                                                        
      allocate (bcondvs(nngl), stat = ierr) 
      bcondvs=0 
      call checkerr(ierr,'bcondvs',ilog) 
      call memory_monitor(sizeof(bcondvs),'bcondvs',.true.)
                                                                        
      allocate (iabvs(nngl), stat = ierr) 
      iabvs=0 
      call checkerr(ierr,'iabvs',ilog)
      call memory_monitor(sizeof(iabvs),'iabvs',.true.)
                                                                        
      allocate (btypevs(nngl), stat = ierr) 
      btypevs=' ' 
      call checkerr(ierr,'btypevs',ilog)
      call memory_monitor(sizeof(btypevs),'btypevs',.true.)
      
      allocate (ivol2bvs(nngl), stat = ierr)
      ivol2bvs=0 
      call checkerr(ierr,'ivol2bvs',ilog)
      call memory_monitor(sizeof(ivol2bvs),'ivol2bvs',.true.)

      allocate (ivol2bzvs(nngl), stat = ierr)
      ivol2bzvs=0
      call checkerr(ierr,'ivol2bzvs',ilog)
      call memory_monitor(sizeof(ivol2bvs),'ivol2bzvs',.true.)

      allocate (areaf_bvs(nngl), stat = ierr)
      areaf_bvs=0
      call checkerr(ierr,'areaf_bvs',ilog)
      call memory_monitor(sizeof(areaf_bvs),'areaf_bvs',.true.)

      allocate (gradf_bvs(nngl), stat = ierr)
      gradf_bvs=0
      call checkerr(ierr,'gradf_bvs',ilog)
      call memory_monitor(sizeof(gradf_bvs),'gradf_bvs',.true.)

      allocate (tol_freezing_pond(nngl), stat = ierr)
      tol_freezing_pond=1.0d300
      call checkerr(ierr,'tol_freezing_pond',ilog)
      call memory_monitor(sizeof(tol_freezing_pond),'tol_freezing_pond',.true.)

      allocate (seepage_bits(nngl), stat = ierr)
      seepage_bits=0
      call checkerr(ierr,'seepage_bits',ilog)
      call memory_monitor(sizeof(seepage_bits),'seepage_bits',.true.)

!  read number of boundary zones                                        
      ierrcd = 1
      read(itmp,*,err=999,end=999) nbzvs
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
     &  'number of boundary zones                        = ',nbzvs
      end if
                                                                        
!  initialize pointer array for storage of boundary conditions          
                                                                        
      nbvs = 0 
      iabvs(1) = 1 
      ivol2bvs(:) = 0

      tol_freezing_pond(:) = 1.0d300
      seepage_bits(:) = 0

!c  allocate variables for 'gradient' type boundary conditions
      allocate (bzvs_dir_grad(nbzvs), stat = ierr)
      bzvs_dir_grad=' '
      call checkerr(ierr,'bzvs_dir_grad',ilog)
      call memory_monitor(sizeof(bzvs_dir_grad),'bzvs_dir_grad',.true.)

      allocate (bzvs_itype_grad(nbzvs), stat = ierr)
      bzvs_itype_grad=0
      call checkerr(ierr,'bzvs_itype_grad',ilog)
      call memory_monitor(sizeof(bzvs_itype_grad),'bzvs_itype_grad',.true.)

      allocate (bzvs_nparms(nbzvs), stat = ierr)
      bzvs_nparms=1
      call checkerr(ierr,'bzvs_nparms',ilog)
      call memory_monitor(sizeof(bzvs_nparms),'bzvs_nparms',.true.)   
      
      allocate (bzvs_radius_center(nbzvs), stat = ierr)
      bzvs_radius_center%x = r0
      bzvs_radius_center%y = r0
      bzvs_radius_center%z = r0
      call checkerr(ierr,'bzvs_radius_center',ilog)
      call memory_monitor(sizeof(bzvs_radius_center),'bzvs_radius_center',.true.)      
                                                                        
!  read name of zone                                                    
                                                                        
                                  !loop over number of zones            
      do ibz=1,nbzvs
                                                                        
                                  !temporary pointer for output         
        nbvsp = nbvs+1 
                                                                        
!  find current zone in input file and write to temporary file          
                                                                        
        subsection = 'number and name of zone' 
                                                                        
        call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                        
        if (found_subsection) then 
                                                                        
          call readzone(itmp,icnv,ilog,zone_name,found_subsection) 
                                                                        
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error in input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define length of zone name                                           
                                                                        
        l_zone_name = index(zone_name,'  ')-1 
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
          l_zone_name = 72 
        end if 
               
!c  define if freezing ponding boundary is required
!c  the pressure head cannot exceed the specified tolerance

        subsection = 'pressure head tolerance of ponding boundary'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then
          ierrcd = 2
          read(icnv,*,err=999,end=999) tol_pond_loc
        else
          tol_pond_loc = 1.0d300
        end if  


                                                                        
!  define type and value of boundary condition                          
                                                                        
        subsection = 'boundary type' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 
                                                                        
        if (found_subsection) then 
          ierrcd = 3
          read(icnv,'(a)',err=999,end=999) strbuffer
          strbuffer = adjustl(strbuffer)

          if(index(strbuffer,'gradient') == 2) then
#ifdef USG
            if(index(strbuffer,'gradient-top') == 2) then
              itype_grad = 2
            else if(index(strbuffer,'gradient-bottom') == 2) then
              itype_grad = 1
            else
              itype_grad = 0
            end if

            if (.not. b_use_layered_mesh) then
              itype_grad = 0
            end if
#endif
            btypezn = 'gradient'

            if(index(strbuffer,'gradient-radius') == 2) then
              ierrcd = 4
              read(icnv,*,err=999,end=999) dir_grad, rx0, ry0, rz0
              read(icnv,*,err=999,end=999) h0_grad
              read(icnv,*,err=999,end=999) slope_grad

              bzvs_radius_center(ibz)%x = rx0
              bzvs_radius_center(ibz)%y = ry0
              bzvs_radius_center(ibz)%z = rz0

              !c reset dir_grad to 'r' for gradient-radius type
              if (dir_grad /= 'r') then
                dir_grad = 'r'
              end if

            else
              ierrcd = 5
              read(icnv,*,err=999,end=999) dir_grad
              read(icnv,*,err=999,end=999) h0_grad
              read(icnv,*,err=999,end=999) slope_grad
            end if


            if (dir_grad /= 'x'.and. dir_grad /= 'y' .and.             &
                dir_grad /= 'z' .and. dir_grad /= 'r') then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "',section_header(:l_string),'"'
                write(ilog,*) 'Error in gradient direction'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

            bzvs_dir_grad(ibz) = dir_grad
            bzvs_itype_grad(ibz) = itype_grad
            bzvs_nparms(ibz) = 2
                        
          else
            ierrcd = 6
            read(strbuffer,*,err=999,end=999) btypezn, bcond
          end if
                                                                        
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  read coordiantes defining boundary zone,                             
                                                                        
        type_extent_zone = -1
        type_extent_zone_box = -1

        subsection = 'extent of zone'
        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          type_extent_zone = 0
          ierrcd = 7
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax

        end if

#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 8
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xbmin = -1.0d300
          xbmax = 1.0d300
        end if

        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ybmin = -1.0d300
          ybmax = 1.0d300
        end if

        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zbmin = -1.0d300
          zbmax = 1.0d300
        end if

!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then

          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if
                                                                        
!  define boundary face to be considered (only needed for calculation   
!  of boundary face area for second type boundary conditions)           
                                                                        
        if (type_extent_zone == 0 .and. type_extent_zone_box <= 0 .and.&
           (btypezn.eq.'second' .or. btypezn.eq.'seepage-second' .or.  &
            btypezn.eq.'free-drainage')) then
                                                                        
          found = .false. 
          xy_plane = .false. 
          xz_plane = .false. 
          yz_plane = .false.
                                                  !xy_plane             
          if (dabs(zbmax-zbmin).lt.tiny) then 
            if ((dabs(xbmax-xbmin).lt.tiny).or.                         &
                (dabs(ybmax-ybmin).lt.tiny)) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED' 
                write(ilog,*) 'error in input file' 
                write(ilog,*) 'section "', section_header(:l_string),'"' 
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            else 
              xy_plane = .true. 
              found = .true. 
            end if 
          end if 
                                                                        
                                                   !xz_plane            
          if (.not.found) then 
            if (dabs(ybmax-ybmin).lt.tiny) then 
              if ((dabs(xbmax-xbmin).lt.tiny).or.                     &
                  (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "', section_header(:l_string),'"' 
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face' 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                xz_plane = .true. 
                if (xy_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                            &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
                                                   !yz_plane            
          if (.not.found) then 
            if (dabs(xbmax-xbmin).lt.tiny) then 
              if ((dabs(ybmax-ybmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then 
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "',section_header(:l_string),'"' 
                  write(ilog,*) 'zone "',zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                yz_plane = .true. 
                if (xy_plane.or.xz_plane) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                            &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 


!  exit if boundary face was not found                                  
!  for the structured grid, the boundary plane can only be xy_plane, yz_plane or xz_plane
!  for the unstructured grid in 3D, it can be in any direction
          if (.not.found) then
#ifdef USG
            if(cell_projection /= projection_xyz) then
#endif
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
#ifdef USG
            end if
#endif
          end if 

          !c define flux direction for unstructured grid
#ifdef USG
          if (discretization_type > 0 .and. type_flux_direction == 0) then
            if (xy_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,0.0d0,1.0d0)
            else if (yz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(1.0d0,0.0d0,0.0d0)
            else if (xz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,1.0d0,0.0d0)
            end if
          end if
#endif
                                  !(btypezn.eq.'second' .or. btypezn.eq.'free-drainage')
        end if 
                                                                        
!  increment boundary coordinates                                       
                                                                        
        factiny=dabs(xbmax-xbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        xbmin = xbmin-factiny 
        xbmax = xbmax+factiny 
        factiny=dabs(ybmax-ybmin)*tiny 
        if (factiny==r0) factiny=tiny 
        ybmin = ybmin-factiny 
        ybmax = ybmax+factiny 
        factiny=dabs(zbmax-zbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        zbmin = zbmin-factiny 
        zbmax = zbmax+factiny 
                                                                        
!  store type of boundary condition and boundary condition              
!  for global system in compressed storage

        do ivol = 1,nngl 

!  check limits of boundary zone                                        
                                                                        
          if (((type_extent_zone==0.or.type_extent_zone_box>0) .and.   &
              (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.        &
              (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.        &
              (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.        &
              (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
              ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
            if (discretization_type > 0 .and. type_extent_zone_box > 0) then
              if ((btest(type_extent_zone_box,1) .and.                 &
                   .not. is_boundary_node(ivol)) .or.                  &
                  (btest(type_extent_zone_box,2) .and.                 &
                   is_boundary_node(ivol))) then
                cycle
              end if
            end if
#endif
                                                                        
!  assign boundary type and boundary condition                          
                                                                        
            nbvs = nbvs+1
                                                                        
!  exit if nbvs > nn                                                    
                                                                        
            if (nbvs.gt.nngl) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'nbvs > nn ...'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if
                                                                        
!  assign pointer and                                                   
                                                                        
            iabvs(nbvs) = ivol
            btypevs(nbvs) = btypezn

            ivol2bvs(ivol) = nbvs
            ivol2bzvs(ivol) = ibz

            tol_freezing_pond(nbvs) = tol_pond_loc
                                                                        
!  first type boundary condition - constant pressure head               
                                                                        
            if (btypezn.eq.'first') then

              if (pressure_head) then
                hhead(ivol) = bcond + zg(ivol)
                bcondvs(nbvs) = bcond
              elseif (hydraulic_head) then
                hhead(ivol) = bcond
                bcondvs(nbvs) = bcond - zg(ivol)
              end if
                  
!#ifdef DEBUG
!              if(ivol == 14) then
!                  write(idbg,*) "-->initbcvs A hhead(ivol)", hhead(ivol)
!              end if
!#endif

              if (fully_saturated) then
                uvsnew(ivol) = hhead(ivol)
                uvsold(ivol) = hhead(ivol)
              elseif (variably_saturated) then
                uvsnew(ivol) = hhead(ivol)-zg(ivol)
                uvsold(ivol) = hhead(ivol)-zg(ivol)
              end if

!  tracer type boundary condition - mark the node only
            else if (btypezn.eq.'idle') then
              !c nothing is required here
              !c idle boundary is disigned for solute transport through 
              !c internal node where there is flow

!  gradient type condition - variable pressure head at different locations
            elseif (btypezn.eq.'gradient')then
#ifdef USG
              if (itype_grad == 1)then
                select case(dir_grad)
                case ('x')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                case ('y')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                case ('z')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                end select
              else if (itype_grad == 2)then
                select case(dir_grad)
                case ('x')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                case ('y')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                case ('z')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                end select
              else
#endif
                select case(dir_grad)
                case ('x')
                  pos_grad=xg(ivol)
                case ('y')
                  pos_grad=yg(ivol)
                case ('z')
                  pos_grad=zg(ivol)
                case ('r')
                  pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                  (yg(ivol) - ry0)**2 +  &
                                  (zg(ivol) - rz0)**2)
                end select
#ifdef USG
              end if
#endif

              bcond=h0_grad + slope_grad*pos_grad

              if (pressure_head) then
                hhead(ivol) = bcond + zg(ivol)
                bcondvs(nbvs) = bcond
              elseif (hydraulic_head) then
                hhead(ivol) = bcond
                bcondvs(nbvs) = bcond - zg(ivol)
              end if

              if (fully_saturated) then
                uvsnew(ivol) = hhead(ivol)
                uvsold(ivol) = hhead(ivol)
              elseif (variably_saturated) then
                uvsnew(ivol) = hhead(ivol)-zg(ivol)
                uvsold(ivol) = hhead(ivol)-zg(ivol)
              end if

              btypevs(nbvs) = 'first'
                                                                        
!  second type boundary condition - specified flux                      
                                                                        
            elseif (btypezn.eq.'second' .or. &
                    btypezn.eq.'seepage-second' .or. &
                    btypezn.eq.'free-drainage') then
                                                                        
!  calculate flux area

              if (discretization_type == 0) then
                if (xy_plane) then
                  areaf = dimcv(1,ivol) * dimcv(2,ivol)
                elseif (xz_plane) then
                  areaf = dimcv(1,ivol) * dimcv(3,ivol)
                elseif (yz_plane) then
                  areaf = dimcv(2,ivol) * dimcv(3,ivol)
                end if
#ifdef USG
              else
                if (cell_type == cell_type_tri .or.                    &
                    cell_type == cell_type_quad) then
                  !c connected boundary control volume
                  !c currently the boundary flow direction is considered perpendicular to the surface

                  if (is_boundary_node(ivol)) then
                    jvol1 = javs(iavs(ivol)+1)
                    jvol2 = javs(iavs(ivol+1)-1)

                    areaf = geometry_veclength(nodes(ivol)-            &
                            nodes(jvol1),flux_direction,               &
                            type_flux_direction)*0.5
                    areaf = areaf+geometry_veclength(nodes(ivol)-      &
                            nodes(jvol2),flux_direction,               &
                            type_flux_direction)*0.5

                  else
                    areaf = 0.0d0
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        if (icell2 > 0) then
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,&
                                     icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,  &
                                    iedge_r,icell2)
                          end do
                        end if
                      end do
                    end do
                  end if


                else if (cell_type == cell_type_tetra) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(               &
                                             CellFaceScaledNorm(iface,cindex),  &
                                             flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        if (icell2 > 0) then
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,&
                                     icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,  &
                                    iedge_r,icell2)
                          end do
                        end if
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_hexa) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_prism) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1, 2                              !number of faces, top and bottom faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                        end if
                      end do

                      do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_prism(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if
                else
                  if (rank == 0) then
                    write(ilog,'(2a,i2)') 'boundary surface area calculation ',  &
                          'does not support cell_type initbcvs',cell_type
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop

                end if
#endif
              end if
                                                                        
!  assign second type boundary condition                                
!  modify this part for unstructured grid if the direction of boundary condition is considered

              if (btypezn.eq.'second' .or. btypezn.eq.'seepage-second') then
                if (b_water_freezing) then
                  if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                    if (b_freezing_adjacent_bd) then
                      if (freezing_adjacent_bd(ivol)) then
                        bcondvs(nbvs) = r0
                      else
                        bcondvs(nbvs) = areaf*bcond
                      end if
                    else
                      bcondvs(nbvs) = areaf*bcond
                    end if
                  else
                    bcondvs(nbvs) = r0
                  end if
                else
                  bcondvs(nbvs) = areaf*bcond
                end if

                areaf_bvs(nbvs) = areaf

                if (btypezn.eq.'seepage-second') then
                  seepage_face = .true.
                  seepage_bits(nbvs) = 2
                end if
                
              else if (btypezn.eq.'free-drainage') then
                gradf_bvs(nbvs) = bcond
                areaf_bvs(nbvs) = areaf
              end if

            elseif (btypezn.eq.'point') then
              if (b_water_freezing) then
                if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                  if (b_freezing_adjacent_bd) then
                    if (freezing_adjacent_bd(ivol)) then
                      bcondvs(nbvs) = r0
                    else
                      bcondvs(nbvs) = bcond
                    end if
                  else
                    bcondvs(nbvs) = bcond
                  end if
                else
                  bcondvs(nbvs) = r0
                end if
              else
                bcondvs(nbvs) = bcond
              end if
                                                                        
!  seepage boundary condition - zero pressure or zero flux              
                                                                        
            elseif (btypezn.eq.'seepage') then

                                            !initialize seepage face
              seepage_face = .true.

                                            !assign first type b.c
              if (zg(ivol).lt.bcond) then
                uvsnew(ivol) = r0
                uvsold(ivol) = r0
                hhead(ivol) = r0 + zg(ivol)
                                              !identify zero pressure                            
                !bcondvs(nbvs) = -r1
                seepage_bits(nbvs) = 1
              else
                                              !identify zero-flux
                !bcondvs(nbvs) = r1
                seepage_bits(nbvs) = 2
              end if
                  
!#ifdef DEBUG
!              if(ivol == 14) then
!                  write(idbg,*) "-->initbcvs B hhead(ivol)", hhead(ivol)
!              end if
!#endif

                   !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.
            end if
                       ! btypezn.eq.'seepage')                          
          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes
                                                                        
!  write header for boundary zone to generic output file                
        if (b_enable_output .and. b_enable_output_gen) then   
            
        write(igen,'(/a,i0,a,1x,a)') 'zone ',ibz,':',zone_name 
        write(igen,'(72a)')('-',i=1,72)
                                      
#ifdef PETSC
        if (btypezn.eq.'first' .or. btypezn.eq.'gradient') then
          if (pressure_head) then 
            write(igen,'(3(a,3x),a/)') 'local volume',                 &
                  'global volume', 'boundary type','pressure head'
          else if (hydraulic_head) then
            write(igen,'(3(a,3x),a/)') 'local volume',                 &
                  'global volume', 'boundary type','hydraulic head'
          end if
        elseif (btypezn.eq.'second') then 
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','specified flux'
        elseif (btypezn.eq.'free-drainage') then
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','free-drainage'
        elseif (btypezn.eq.'idle') then
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','idle'
        elseif (btypezn.eq.'seepage') then 
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','initial guess'      
        elseif (btypezn.eq.'seepage-second') then 
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','specified seepage flux'                               
        end if 
#else
        if (btypezn.eq.'first' .or. btypezn.eq.'gradient') then
          if (pressure_head) then
            write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',  &
                                       'pressure head'
          else if (hydraulic_head) then
            write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',  &
                                       'hydraulic head'
          end if
        elseif (btypezn.eq.'second') then 
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                       'specified flux'
        elseif (btypezn.eq.'free-drainage') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                       'free-drainage'
        elseif (btypezn.eq.'idle') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                       'idle'
        elseif (btypezn.eq.'seepage') then 
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                       'initial guess'                  
        end if 
#endif
        end if
                                                                        
!  write boundary condition for zone to generic output file             
                                                                        
                                               !first and second type   
        if (btypezn.ne.'seepage') then
          if (b_enable_output .and. b_enable_output_gen) then       
            do ibvs=nbvsp,nbvs
              ivol = iabvs(ibvs)
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
                write(igen,'(i10,5x,i10,6x,a16,1pe15.6e3)') ivol,      &
                      node_idx_lg2g(ivol),btypevs(ibvs),bcondvs(ibvs)
              end if
#else
              write(igen,'(i8,3x,a16,1pe15.6e3)') ivol,btypevs(ibvs),  &
                                                     bcondvs(ibvs)
#endif
            end do
          end if
                                               !seepage face
        else 
          do ibvs=nbvsp,nbvs 
            ivol = iabvs(ibvs) 
            if (bcondvs(ibvs).lt.r0) then 
              if (b_enable_output .and. b_enable_output_gen) then  
#ifdef PETSC
                if(node_idx_lg2l(ivol) > 0) then
                  write(igen,'(i10,5x,i10,6x,a16,4x,a)') ivol,         &
                        node_idx_lg2g(ivol),btypevs(ibvs),'zero pressure'
                end if
#else
                write(igen,'(i8,3x,a16,4x,a)') ivol,btypevs(ibvs),     &
                                               'zero pressure'
#endif
              end if
              nseep_first = nseep_first + 1 
                                                                        
            else
              if (b_enable_output .and. b_enable_output_gen) then  
#ifdef PETSC
                if(node_idx_lg2l(ivol) > 0) then
                  write(igen,'(i10,5x,i10,6x,a16,4x,a)') ivol,         &
                        node_idx_lg2g(ivol),btypevs(ibvs),'zero flux'
                end if
#else
                write(igen,'(i8,3x,a16,4x,a)') ivol,btypevs(ibvs),     &
     &                                         'zero flux'
#endif
              end if  
            end if 
          end do 
        end if 
                                                                        
!  conversion of time units for computation in days                     
!  if second type boundary condition is specified                       
                                                                        
        if ((btypezn.eq.'second') .or. &
            (btypezn.eq.'seepage-second') .or. &
            (btypezn.eq.'point')) then                                     
          do ibvs=nbvsp,nbvs 
            if (b_water_freezing) then
              ivol = iabvs(ibvs)
              if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days
              else
                bcondvs(ibvs) = r0
              end if
            else
              bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days 
            end if
          end do 
        end if 
                                                                        
                        !end loop over zones                            
      end do 
                                                                        
!  define if boundary conditions are to updated
      update_bcvs = .false.

      subsection = 'transient boundary conditions'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then        
        update_bcvs = .true.
      else
        subsection = 'transient flow boundary conditions'
        call findstrg(subsection,itmp,found_subsection) 
        if (found_subsection) then        
          update_bcvs = .true.
        end if               
      end if

!cdsu only update the boundary condition values, with boundary type and zone unchanged.
      update_bcvs_value_only=.false.

      subsection = 'transient boundary conditions: values only'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        update_bcvs = .true.
        update_bcvs_value_only = .true.
      else
        subsection = 'transient flow boundary conditions: values only'
        call findstrg(subsection,itmp,found_subsection)   
        if (found_subsection) then
          update_bcvs = .true.
          update_bcvs_value_only = .true.
        end if             
      end if

!cdsu linear interpolation for boundary conditions, only if the 
!cdsu boundary condition type remains the same
      b_interpolation_bcvs = .false.
      b_first_update_bcvs = .false.

      if (update_bcvs_value_only) then
        subsection = 'linear interpolation of boundary conditions'
        call findstrg(subsection,itmp,found_subsection) 
        if (found_subsection) then
          b_interpolation_bcvs = .true.
          b_first_update_bcvs = .true.
        end if 
      end if   

!c  open file containing boundary conditions for variably saturated flow
!c  and read first read time

      if (update_bcvs) then

        !ibcvs = 15
        ibcvs = lun_get()
        open(ibcvs,file=prefix(:l_prfx)//'.bcvs',err=997, status='old')
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(ibcvs)
        read(ibcvs,*,err=998,end=998) time_bcvs
             
      end if
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
      update_ext_type_bcvs=.false. 
      subsection = 'update extension and type boundary conditions'
      call findstrg(subsection,itmp,found_subsection) 

      if (found_subsection) then
        update_ext_type_bcvs = .true.
      end if



      if (update_ext_type_bcvs) then
       
       !ibcvs1 = 17
       ibcvs1 = lun_get()

       open(ibcvs1,file=prefix(:l_prfx)//'.bcvs1',err=997, status='old')
             
      end if
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
       
!c  minimize memory requirement for boundary arrays

!c  array bcondvs

      allocate (rwork(nbvs,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcvs-rwork',.true.)

      do ibvs = 1,nbvs
        rwork(ibvs,1) = bcondvs(ibvs)
      end do

      call memory_monitor(-sizeof(bcondvs),'bcondvs',.true.)
      deallocate (bcondvs, stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)

      allocate (bcondvs(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)
      call memory_monitor(sizeof(bcondvs),'bcondvs',.true.)

      do ibvs = 1,nbvs
        bcondvs(ibvs) = rwork(ibvs,1)
      end do

!c  allocate array for linear interpolation of boundary conditions
      allocate (bcondvs_prev(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs_prev',ilog)
      call memory_monitor(sizeof(bcondvs_prev),'bcondvs_prev',.true.)
      bcondvs_prev = bcondvs

      allocate (bcondvs_next(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs_next',ilog)
      call memory_monitor(sizeof(bcondvs_next),'bcondvs_next',.true.)
      bcondvs_next = bcondvs     

!c  array tol_freezing_pond
      do ibvs = 1,nbvs
        rwork(ibvs,1) = tol_freezing_pond(ibvs)
      end do

      call memory_monitor(-sizeof(tol_freezing_pond),'tol_freezing_pond',.true.)
      deallocate (tol_freezing_pond, stat = ierr)
      call checkerr(ierr,'tol_freezing_pond',ilog)

      allocate (tol_freezing_pond(nbvs), stat = ierr)
      call checkerr(ierr,'tol_freezing_pond',ilog)
      call memory_monitor(sizeof(tol_freezing_pond),'tol_freezing_pond',.true.)

      do ibvs = 1,nbvs
        tol_freezing_pond(ibvs) = rwork(ibvs,1)
      end do

!c  array areaf_bvs

      do ibvs = 1,nbvs
        rwork(ibvs,1) = areaf_bvs(ibvs)
      end do

      call memory_monitor(-sizeof(areaf_bvs),'areaf_bvs',.true.)
      deallocate (areaf_bvs, stat = ierr)
      call checkerr(ierr,'areaf_bvs',ilog)

      allocate (areaf_bvs(nbvs), stat = ierr)
      call checkerr(ierr,'areaf_bvs',ilog)
      call memory_monitor(sizeof(areaf_bvs),'areaf_bvs',.true.)

      do ibvs = 1,nbvs
        areaf_bvs(ibvs) = rwork(ibvs,1)
      end do

!c  array gradf_bvs

      do ibvs = 1,nbvs
        rwork(ibvs,1) = gradf_bvs(ibvs)
      end do

      call memory_monitor(-sizeof(gradf_bvs),'gradf_bvs',.true.)
      deallocate (gradf_bvs, stat = ierr)
      call checkerr(ierr,'gradf_bvs',ilog)

      allocate (gradf_bvs(nbvs), stat = ierr)
      call checkerr(ierr,'gradf_bvs',ilog)
      call memory_monitor(sizeof(gradf_bvs),'gradf_bvs',.true.)

      do ibvs = 1,nbvs
        gradf_bvs(ibvs) = rwork(ibvs,1)
      end do

!c  array for interpolation of boundary conditions
      allocate (gradf_bvs_prev(nbvs), stat = ierr)
      call checkerr(ierr,'gradf_bvs_prev',ilog)
      call memory_monitor(sizeof(gradf_bvs_prev),'gradf_bvs_prev',.true.)
      gradf_bvs_prev = gradf_bvs

      allocate (gradf_bvs_next(nbvs), stat = ierr)
      call checkerr(ierr,'gradf_bvs_next',ilog)
      call memory_monitor(sizeof(gradf_bvs_next),'gradf_bvs_next',.true.)
      gradf_bvs_next = gradf_bvs

!c  release temporary array
      call memory_monitor(-sizeof(rwork),'initbcvs-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array seepage_bits
      allocate (iwork(nbvs), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initbcdd-iwork',.true.)

      do ibvs = 1,nbvs
        iwork(ibvs) = seepage_bits(ibvs)
      end do

      call memory_monitor(-sizeof(seepage_bits),'seepage_bits',.true.)
      deallocate (seepage_bits, stat = ierr)
      call checkerr(ierr,'seepage_bits',ilog)

      allocate (seepage_bits(nbvs), stat = ierr)
      call checkerr(ierr,'seepage_bits',ilog)
      call memory_monitor(sizeof(seepage_bits),'seepage_bits',.true.)

      do ibvs = 1,nbvs
        seepage_bits(ibvs) = iwork(ibvs)
      end do  

      call memory_monitor(-sizeof(iwork),'initbcdd-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

!c  array iabvs

      allocate (iwork(nbvs), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initbcvs-iwork',.true.)

      do ibvs = 1,nbvs
        iwork(ibvs) = iabvs(ibvs)
      end do

      call memory_monitor(-sizeof(iabvs),'iabvs',.true.)
      deallocate (iabvs, stat = ierr)
      call checkerr(ierr,'iabvs',ilog)

      allocate (iabvs(nbvs), stat = ierr)
      call checkerr(ierr,'iabvs',ilog)
      call memory_monitor(sizeof(iabvs),'iabvs',.true.)

      do ibvs = 1,nbvs
        iabvs(ibvs) = iwork(ibvs)
      end do

      do ibvs = 1,nbvs
        do i = nbvs, ibvs + 1, -1
          if (iabvs(i) == iabvs(ibvs)) then
            iabvs(ibvs) = -iabvs(ibvs)
            exit
          end if
        end do
      end do

      call memory_monitor(-sizeof(iwork),'initbcvs-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

!c  array btypevs
      allocate (cwork(nbvs), stat = ierr)
      call checkerr(ierr,'cwork',ilog)
      call memory_monitor(sizeof(cwork),'initbcvs-cwork',.true.)

      do ibvs = 1,nbvs
        cwork(ibvs) = btypevs(ibvs)
      end do

      call memory_monitor(-sizeof(btypevs),'btypevs',.true.)
      deallocate (btypevs, stat = ierr)
      call checkerr(ierr,'btypevs',ilog)

      allocate (btypevs(nbvs), stat = ierr)
      call checkerr(ierr,'btypevs',ilog)
      call memory_monitor(sizeof(btypevs),'btypevs',.true.)

      do ibvs = 1,nbvs
        btypevs(ibvs) = cwork(ibvs)
      end do

      call memory_monitor(-sizeof(cwork),'initbcvs-cwork',.true.)
      deallocate (cwork, stat = ierr)
      call checkerr(ierr,'cwork',ilog)            
      
      !Check if the boundary condition is valid
      !allocate(bvalid_iabvs(nbvs), stat = ierr)
      !call checkerr(ierr,'bvalid_iabvs',ilog)
      !bvalid_iabvs = .true.
      !do ibvs = 1,nbvs
      !    do ibvs2 = ibvs +1, nbvs
      !        if(iabvs(ibvs) == iabvs(ibvs2)) then
      !            bvalid_iabvs(ibvs) = .false.
      !            exit
      !        end if
      !    end do
      !end do

      goto 1000

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'file ', prefix(:l_prfx)//'.bcvs missing'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading input file, error code ',ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
