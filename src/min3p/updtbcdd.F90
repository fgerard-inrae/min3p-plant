!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updtbcdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updtbcdd
!c -------------------
!c
!c update boundary conditions (density dependent variably saturated flow) 
!c
!c first type boundary conditions: 
!c -> define zone by delineating nodes located within zone
!c
!c second type boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c seepage face boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c modified from Uli Mayer template 
!c
!c written by:      Tom Henderson - October 20, 2002
!c
!c last modified:   Tom Henderson - February 11, 2003
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  * +
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           dimcv(3,nn)        = spatial dimensions of control       + -
!c                                volumes
!c           rwork(:,:)         = real*8 work array                   * *
!c           time_bcvs          = next read time for flow boundary    * +
!c                                conditions
!c           uvsold(nn)         = solution vector (old time level)    + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           sec_per_days       = conversion factor from SI input     + -
!c                                units for physico-chemical 
!c                                parameters internal time units
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           time_io            = current solution time (I/O units)   + -
!c           tfinal             = final solution time                 + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           ibcvs              = unit number, transient boundary     * +
!c                                             conditions, variably
!c                                             saturated flow
!c           icnv               = unit number, data conversion        + -
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        * +
!c                                control volumes
!c                                (variably saturated flow)
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions 
!c           hydraulic_head     = .true.  -> initial condition in     + -
!c                                           terms of hydraulic head
!c           pressure_head      = .true.  -> initial condition in     + -
!c                                           terms of pressure heada
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           zone_name          = name of zone                        * +
!c           section_header     = section header                      * +
!c
!c local:    real*8:
!c           -------
!c           areaf              = interfacial area
!c           dummy              = dummy variable
!c           tiny               = small increment
!c           xbmin              = min. x-coordinate of boundary
!c                                zone
!c           xbmax              = max. x-coordinate of boundary
!c                                zone
!c           ybmin              = min. y-coordinate of boundary
!c                                zone
!c           ybmax              = max. y-coordinate of boundary
!c                                zone
!c           zbmin              = min. z-coordinate of boundary
!c                                zone
!c           zbmax              = max. z-coordinate of boundary
!c                                zone
!c
!c           integer*4:
!c           ----------
!c           ibvs               = counter (boundary control volumes)
!c           ibz                = counter (zones)
!c           ierr               = 0 -> memory allocation successful
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c           nbzvs              = number of boundary zones
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit search 
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           xy_plane           = boundary zone parallel tp xy-plane
!c           xz_plane           = boundary zone parallel to xz-plane
!c           yz_plane           = boundary zone parallel to yz-plane
!c
!c           character:
!c           ----------
!c           btypezn            = boundary type of zone        
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine updtbcdd
 
      use parm
      use gen
      use dens
      use math_common, only : math_common_linear
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, num_nodes_per_cell,  &
                                node_cells, node_num_cells,            &
                                cell2halfid, CellFaceCenter, cells,    &
                                cal_cellface_index, cell_projection,   &
                                num_faces_per_cell, CellFaceScaledNorm,&
                                is_boundary_node, num_edge_dvols,      &
                                node_to_layer_node, layer_nodes_top,   &
                                layer_nodes_bottom, CellCvolFaceArea,  &
                                get_cell_edge_cvol_id

      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#endif
      implicit none

      external checkerr, findstrg, findzone, readbloc, readzone

      real*8, parameter :: tiny = 1.d-5, r0=0.0d0, r1 = 1.0d0

      logical :: xy_plane,xz_plane,yz_plane,found,found_section,       &
                 found_subsection,b_updt_next_only,b_updtbc_back
      character*32 :: btypezn
      character*72 :: subsection
      character*1 :: dir_grad
      
      integer :: i, ibz, ibvs, ierr, ierrcd, ivol,  l_string,          &
                 istart, iend, jtemp, iflag, itype_grad

      real*8 :: timebcvsloc, dummy, xbmin, xbmax, ybmin, ybmax,        &
                zbmin, zbmax, areaf, pos_grad
      
      real*8 :: rx0, ry0, rz0     !center of gradient-radius type i.c. or b.c. condition

      logical, external :: freezing_adjacent_bd

      real*8, external :: pressure_melt_k      

#ifdef USG
      real*8 :: ratio_flux
      integer :: icell, icell2, idvol, idvol_r, iedge_r, iface, cindex,&
                 jvol, jvol1, jvol2, jvol3, jvol4
      type(point) :: pts(4)
#endif

      xy_plane = .false. 
      xz_plane = .false.
      yz_plane = .false.
      b_updt_next_only = .false.
      b_updtbc_back = .false.

      areaf = r0
      l_string = 0

      if ((.not. b_interpolation_bcvs .and.                            &
          time_io >= time_bcvs_prev .and. time_io < time_bcvs) .or.    &
          time_bcvs > tfinal/time_factor) then
        return
      end if

      if (.not. b_first_update_bcvs .and.                              &
         (time_io < time_bcvs_prev .or. time_io > time_bcvs)) then        
        b_updtbc_back = .true.
      end if
     
      if (time_io.ge.time_bcvs .or.                                    &
          b_restart_update_bcvs .or. b_first_update_bcvs .or.          &
          b_updtbc_recall .or. b_updtbc_back) then
          
        if(rank == 0 .and. b_enable_output)  then  
                                                                       
          write(*,*)                                                     
          write(*,*) 'update boundary conditions - ',                  &
                     'density dependent variably saturated flow'         
          write(*,*) ('-',i=1,72)                                        
          write(*,*)
                                                                       
          write(ilog,*)
          write(ilog,'(2a)') 'update boundary conditions - ',          &
                             'density dependent variably saturated flow'
          write(ilog,'(72a/)')('-',i=1,72)
          write(ilog,*)
        
        end if

!c  read section header for boundary conditions of variably saturated
!c  flow simulation
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------       
        bcondvs=r0
        if(update_ext_type_bcvs) then
          do 
            section_header = 'time for boundary condition' 
            call readbloc (ibcvs1,itmp,section_header,found_section,   &
     &                    .false.)
            if (found_section) then 
              ierrcd = 1
              read(itmp,*,err=999,end=999) timebcvsloc

              if (timebcvsloc==time_bcvs) then
                !cprovi  preliminary allocation of memory for boundary conditions
                ierrcd = 2
                read(itmp,*,err=999,end=999)
                exit 
              end if 
            else
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'time for boundary condition' 
                write(ilog,*) 'time not found:',time_bcvs 
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            end if 
          end do 
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------          
        else if (update_bcvs_value_only) then
          goto 100
        else
          section_header = 'boundary conditions - variably saturated flow'
          call readbloc (idat,itmp,section_header,found_section,.true.)
        end if
        
 
!c  define length of section header

        l_string = index(section_header,'  ')-1
        if (l_string.eq.-1.or.l_string.gt.72) then
           l_string=72
        end if

!c  read number of boundary zones
        ierrcd = 3
        read(itmp,*,err=999,end=999) nbzvs

!c  read values of new boundary conditions
100     continue

!c  allocate array for reading new boundary conditions
        allocate (rwork(2,nbzvs), stat = ierr)
        rwork=r0 
        call checkerr(ierr,'rwork',ilog)
        call memory_monitor(sizeof(rwork),'rwork',.true.)

        allocate (rwork_next(2,nbzvs), stat = ierr)
        rwork_next=r0 
        call checkerr(ierr,'rwork_next',ilog)
        call memory_monitor(sizeof(rwork_next),'rwork_next',.true.)

!c  assign new boundary conditions for variably-saturated flow
        if (b_first_update_bcvs .and.                                  &
            time_io.ge.time_bcvs_prev .and.                            &
            time_io.le.time_bcvs) then  
          b_updt_next_only = b_first_update_bcvs
          backspace(ibcvs)
          read(ibcvs,*,err=998,end=997) time_bcvs_prev,                &
              (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
          do while (time_io < time_bcvs_prev)
            backspace(ibcvs)
            backspace(ibcvs)
            read(ibcvs,*,err=998,end=997) time_bcvs_prev,              &
                (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
          end do
          
          do while (time_io > time_bcvs)
            read(ibcvs,*,err=998,iostat=iflag) time_bcvs_prev,         &
                (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
            !c end of file has reached
            if (iflag < 0) then
              time_bcvs = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else
              if (time_io < time_bcvs_prev) then
                backspace(ibcvs)
                backspace(ibcvs)
                read(ibcvs,*,err=998,end=997) time_bcvs_prev,          &
                    (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
                exit
              end if
            end if
          end do

          read(ibcvs,*,err=998,iostat=iflag) time_bcvs,                &
              (rwork_next(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
          !c end of file has reached
          if (iflag < 0) then
            time_bcvs = (tfinal+delt)/time_factor
            rwork_next = rwork
          end if  
        else
          backspace(ibcvs)
          read(ibcvs,*,err=998,end=997) time_bcvs_prev,                &
              (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)

          do while (time_io < time_bcvs_prev)
            backspace(ibcvs)
            backspace(ibcvs)
            read(ibcvs,*,err=998,end=997) time_bcvs_prev,              &
                (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
          end do
    
          do while (time_io > time_bcvs)
            read(ibcvs,*,err=998,iostat=iflag) time_bcvs_prev,         &
                (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
            !c end of file has reached
            if (iflag < 0) then
              time_bcvs = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else    
              if (time_io < time_bcvs_prev) then
                backspace(ibcvs)
                backspace(ibcvs)
                read(ibcvs,*,err=998,end=997) time_bcvs_prev,          &
                    (rwork(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
                exit
              end if
            end if
          end do

          if (b_interpolation_bcvs) then
            read(ibcvs,*,err=998,iostat=iflag) time_bcvs,              &
                (rwork_next(1:bzvs_nparms(ibz),ibz),ibz=1,nbzvs)
            !c end of file has reached
            if (iflag < 0) then
              time_bcvs = (tfinal+delt)/time_factor
              rwork_next = rwork
            end if
            !c backspace, time_bcvs will be read again later
            backspace(ibcvs)
          end if
        end if

!c  if boundary type and zone is unchanged, just update the value
!c  without reading zone and type again, DSU 2019-10-28
!c  note: actually the boundary type and zone cannot be changed in the current version
        if (update_bcvs_value_only) then

          if (nbvs > 0) then
            do ibvs = 1, nbvs
              ivol = iabvs(ibvs)

              if (ivol < 0) then
                cycle  
              end if

              btypezn = btypevs(ibvs)
              ibz = ivol2bzvs(ivol)
              dir_grad = bzvs_dir_grad(ibz)
              if (dir_grad == 'r') then
                rx0 = bzvs_radius_center(ibz)%x
                ry0 = bzvs_radius_center(ibz)%y
                rz0 = bzvs_radius_center(ibz)%z
              end if
              itype_grad = bzvs_itype_grad(ibz)

              if (btypezn .eq. 'first' .and. bzvs_nparms(ibz) .eq. 2) then
                btypezn = 'gradient'
              end if

              if (btypezn.eq.'initial') then

                  btypevs(ibvs) = 'first'
                  bcondvs(ibvs) = uvsnew(ivol)

!c  first type boundary condition - constant pressure head

              elseif (btypezn.eq.'first') then

                if (b_interpolation_bcvs) then
                  if (fluid_pressure) then
                    if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                      bcondvs_prev(ibvs) = rwork(1,ibz)
                    end if
                    bcondvs_next(ibvs) = rwork_next(1,ibz)
                  elseif (pressure_head) then
                    if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                      bcondvs_prev(ibvs) = rwork(1,ibz)*density(ivol)*gacc
                    end if
                    bcondvs_next(ibvs) = rwork_next(1,ibz)*density(ivol)*gacc
                  elseif (fresh_head) then
                    if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                      bcondvs_prev(ibvs) = (rwork(1,ibz) - zg(ivol)) * &
                                            gacc * ref_dens
                    end if
                    bcondvs_next(ibvs) = (rwork_next(1,ibz) - zg(ivol)) *   &
                                          gacc * ref_dens
                  elseif (hydraulic_head) then
                    if (.not. b_updt_next_only .or. b_restart_update_bcvs) then                    
                      bcondvs_prev(ibvs) = (rwork(1,ibz) - zg(ivol)) * &
                                            gacc * density(ivol)
                    end if
                    bcondvs_next(ibvs) = (rwork_next(1,ibz) - zg(ivol)) *   &
                                          gacc * density(ivol)
                  end if !fluid pressure
                  bcondvs(ibvs) = math_common_linear(                  &
                                       time_bcvs_prev, time_bcvs,      &
                                       bcondvs_prev(ibvs),             &
                                       bcondvs_next(ibvs),time_io)                  
                else
                  if (fluid_pressure) then
                    bcondvs(ibvs) = rwork(1,ibz)
                  elseif (pressure_head) then
                    bcondvs(ibvs) = rwork(1,ibz)*density(ivol)*gacc
                  elseif (fresh_head) then
                    bcondvs(ibvs) = (rwork(1,ibz) - zg(ivol)) *        &
                                     gacc * ref_dens
                  elseif (hydraulic_head) then
                    bcondvs(ibvs) = (rwork(1,ibz) - zg(ivol)) *        &
                                     gacc * density(ivol)
                  end if !fluid pressure
                end if

                if (.not. b_restart_update_bcvs) then
                  !uvsnew(ivol) = rwork(1,ibz)
                  !cdsu fixed bug here, uvsnew is fluid pressure for density dependent flow
                  uvsnew(ivol) = bcondvs(ibvs)
                end if
!  gradient type condition - variable pressure head at different locations
              elseif (btypezn.eq.'gradient')then
#ifdef USG
                if (itype_grad == 1)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                  end select
                else if (itype_grad == 2)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                  end select
                else
#endif
                  select case(dir_grad)
                  case ('x')
                    pos_grad=xg(ivol)
                  case ('y')
                    pos_grad=yg(ivol)
                  case ('z')
                    pos_grad=zg(ivol)
                  case ('r')
                    pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                    (yg(ivol) - ry0)**2 +  &
                                    (zg(ivol) - rz0)**2)
                  end select
#ifdef USG
                end if
#endif

                if (b_interpolation_bcvs) then
                  if (.not.b_updt_next_only .or. b_restart_update_bcvs) then
                    bcondvs_prev(ibvs) = rwork(1,ibz) + rwork(2,ibz)*pos_grad

                    if (pressure_head) then
                      bcondvs_prev(ibvs) = bcondvs_prev(ibvs)*density(ivol)*gacc
                    elseif (fresh_head) then
                      bcondvs_prev(ibvs) = (bcondvs_prev(ibvs) - zg(ivol)) *   &
                                            gacc * ref_dens
                    elseif (hydraulic_head) then
                      bcondvs_prev(ibvs) = (bcondvs_prev(ibvs) - zg(ivol)) *   &
                                            gacc * density(ivol)
                    end if !fluid pressure

                  end if

                  bcondvs_next(ibvs) = rwork_next(1,ibz) + rwork_next(2,ibz)*pos_grad
                  if (pressure_head) then
                    bcondvs_next(ibvs) = bcondvs_next(ibvs)*density(ivol)*gacc
                  elseif (fresh_head) then
                    bcondvs_next(ibvs) = (bcondvs_next(ibvs) - zg(ivol)) *   &
                                          gacc * ref_dens
                  elseif (hydraulic_head) then
                    bcondvs_next(ibvs) = (bcondvs_next(ibvs) - zg(ivol)) *   &
                                          gacc * density(ivol)
                  end if !fluid pressure
                  
                  bcondvs(ibvs) = math_common_linear(                  &
                                       time_bcvs_prev, time_bcvs,      &
                                       bcondvs_prev(ibvs),             &
                                       bcondvs_next(ibvs),time_io)
                else
                  bcondvs(ibvs)=rwork(1,ibz) + rwork(2,ibz)*pos_grad
                  
                  if (pressure_head) then
                    bcondvs(ibvs) = bcondvs(ibvs)*density(ivol)*gacc
                  elseif (fresh_head) then
                    bcondvs(ibvs) = (bcondvs(ibvs) - zg(ivol)) *       &
                                     gacc * ref_dens
                  elseif (hydraulic_head) then
                    bcondvs(ibvs) = (bcondvs(ibvs) - zg(ivol)) *       &
                                     gacc * density(ivol)
                  end if !fluid pressure
                end if

                if (.not. b_restart_update_bcvs) then
                  !uvsnew(ivol) = rwork(1,ibz)
                  !cdsu fixed bug here, uvsnew is fluid pressure for density dependent flow
                  uvsnew(ivol) = bcondvs(ibvs)
                end if

                !c btypevs(ibvs) = 'first'

!c  second type boundary condition - specified flux

              elseif (btypezn.eq.'second' .or. &
                      btypezn.eq.'seepage-second') then

!c  assign second type boundary condition and convert to internal
!c  time units
                if (b_interpolation_bcvs) then
                  if (b_water_freezing) then
                    if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                      if (b_freezing_adjacent_bd) then
                        if (freezing_adjacent_bd(ivol)) then
                          if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                            bcondvs_prev(ibvs) = r0
                          end if
                          bcondvs_next(ibvs) = r0
                        else
                          if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                            bcondvs_prev(ibvs) = areaf_bvs(ibvs)*rwork(1,ibz)*sec_per_days
                          end if
                          bcondvs_next(ibvs) = areaf_bvs(ibvs)*rwork_next(1,ibz)*sec_per_days
                        end if
                      else
                        if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                          bcondvs_prev(ibvs) = areaf_bvs(ibvs)*rwork(1,ibz)*sec_per_days
                        end if
                        bcondvs_next(ibvs) = areaf_bvs(ibvs)*rwork_next(1,ibz)*sec_per_days
                      end if
                    else
                      if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                        bcondvs_prev(ibvs) = r0
                      end if
                      bcondvs_next(ibvs) = r0
                    end if
                  else
                    if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                      bcondvs_prev(ibvs) = areaf_bvs(ibvs)*rwork(1,ibz)*sec_per_days
                    end if
                    bcondvs_next(ibvs) = areaf_bvs(ibvs)*rwork_next(1,ibz)*sec_per_days
                  end if
                  bcondvs(ibvs) = math_common_linear(time_bcvs_prev, time_bcvs,&
                                       bcondvs_prev(ibvs), bcondvs_next(ibvs), &
                                       time_io)
                else
                  if (b_water_freezing) then
                    if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                      if (b_freezing_adjacent_bd) then
                        if (freezing_adjacent_bd(ivol)) then
                          bcondvs(ibvs) = r0
                        else
                          bcondvs(ibvs) = areaf_bvs(ibvs)*rwork(1,ibz)*sec_per_days
                        end if
                      else
                        bcondvs(ibvs) = areaf_bvs(ibvs)*rwork(1,ibz)*sec_per_days
                      end if
                    else
                      bcondvs(ibvs) = r0
                    end if
                  else
                    bcondvs(ibvs) = areaf_bvs(ibvs)*rwork(1,ibz)*sec_per_days
                  end if
                end if

                !c revert 'seepage-second' to normal
                if (btypezn.eq.'seepage-second') then
                  seepage_bits(ibvs) = 2
                end if

              elseif (btypezn.eq.'point') then
                if (b_interpolation_bcvs) then
                  if (b_water_freezing) then
                    if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                      if (b_freezing_adjacent_bd) then
                        if (freezing_adjacent_bd(ivol)) then
                          if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                            bcondvs_prev(ibvs) = r0
                          end if
                          bcondvs_next(ibvs) = r0
                        else
                          if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                            bcondvs_prev(ibvs) = rwork(1,ibz)*sec_per_days
                          end if
                          bcondvs_next(ibvs) = rwork_next(1,ibz)*sec_per_days
                        end if
                      else
                        if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                          bcondvs_prev(ibvs) = rwork(1,ibz)*sec_per_days
                        end if
                        bcondvs_next(ibvs) = rwork_next(1,ibz)*sec_per_days
                      end if
                    else
                      if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                        bcondvs_prev(ibvs) = r0
                      end if
                      bcondvs_next(ibvs) = r0
                    end if
                  else
                    if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                      bcondvs_prev(ibvs) = rwork(1,ibz)*sec_per_days
                    end if
                    bcondvs_next(ibvs) = rwork_next(1,ibz)*sec_per_days
                  end if
                  bcondvs(ibvs) = math_common_linear(time_bcvs_prev, time_bcvs,&
                                       bcondvs_prev(ibvs), bcondvs_next(ibvs), &
                                       time_io)                  
                else
                  if (b_water_freezing) then
                    if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                      if (b_freezing_adjacent_bd) then
                        if (freezing_adjacent_bd(ivol)) then
                          bcondvs(ibvs) = r0
                        else
                          bcondvs(ibvs) = rwork(1,ibz)*sec_per_days
                        end if
                      else
                        bcondvs(ibvs) = rwork(1,ibz)*sec_per_days
                      end if
                    else
                      bcondvs(ibvs) = r0
                    end if
                  else
                    bcondvs(ibvs) = rwork(1,ibz)*sec_per_days
                  end if
                end if

              else if (btypezn.eq.'seepage') then
                if (zg(ivol).lt.rwork(1,ibz)) then
                  uvsnew(ivol) = r0
                  uvsold(ivol) = r0
                  hhead(ivol) = r0 + zg(ivol)
                                              !identify zero pressure
                  !bcondvs(ibvs) = -r1
                  seepage_bits(ibvs) = 1
                else
                                              !identify zero-flux
                  !bcondvs(ibvs) = r1
                  seepage_bits(ibvs) = 2
                end if

              else if (btypezn.eq.'free-drainage') then
                if (b_interpolation_bcvs) then
                  if (.not. b_updt_next_only .or. b_restart_update_bcvs) then
                    gradf_bvs_prev(ibvs) = rwork(1,ibz)
                  end if
                  gradf_bvs_next(ibvs) = rwork_next(1,ibz)

                  gradf_bvs(ibvs) = math_common_linear(time_bcvs_prev, time_bcvs,&
                                         bcondvs_prev(ibvs), bcondvs_next(ibvs), &
                                         time_io)
                else
                  gradf_bvs(ibvs) = rwork(1,ibz)
                end if
              end if   !(btypezn.eq.'first'.or.btypezn.eq.'second')
            end do
          end if
          b_first_update_bcvs = .false.
          goto 500
        end if

!c  initialize counter for boundary control volumes
 
        ibvs =0
        ivol2bvs(:) = 0
        ivol2bzvs(:) = 0
        
!c  read name of zone

        do ibz=1,nbzvs                !loop over number of zones

!c  find current zone in input file and write to temporary file

          subsection = 'number and name of zone'

          call findzone(subsection,itmp,found_subsection,ibz,zone_name)

          if (found_subsection) then

            call readzone(itmp,icnv,ilog,zone_name,found_subsection)

          end if

!c  define length of zone name

          l_zone_name = index(zone_name,'  ')-1
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
            l_zone_name = 72
          end if

!c  define type of boundary condition
      
          subsection = 'boundary type'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            ierrcd = 4
            read(icnv,*,err=999,end=999) btypezn

            if(index(btypezn,'gradient') == 2) then
              btypezn = 'gradient'
              itype_grad = bzvs_itype_grad(ibz)
              dir_grad = bzvs_dir_grad(ibz)
              if (dir_grad == 'r') then
                rx0 = bzvs_radius_center(ibz)%x
                ry0 = bzvs_radius_center(ibz)%y
                rz0 = bzvs_radius_center(ibz)%z
              end if
            end if

          end if

!c  read coordiantes defining boundary zone, 

          type_extent_zone = -1
          type_extent_zone_box = -1

          subsection = 'extent of zone'
          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            type_extent_zone = 0
            ierrcd = 5
            read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                         zbmin,zbmax
          end if

#ifdef USG
          call read_zone_usg_input(icnv)
          if (type_extent_zone_box > 0) then
            ierrcd = 6
            read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                         zbmin,zbmax
          end if
#endif

          !c check if x dimension is valid
          if (.not.btest(cell_projection,0)) then
            xbmin = -1.0d300
            xbmax = 1.0d300
          end if
        
          !c check if y dimension is valid
          if (.not.btest(cell_projection,1)) then
            ybmin = -1.0d300
            ybmax = 1.0d300
          end if
        
          !c check if z dimension is valid
          if (.not.btest(cell_projection,2)) then
            zbmin = -1.0d300
            zbmax = 1.0d300
          end if

!c  write error information if 'extent of zone' is missing
          if (type_extent_zone < 0) then

            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',trim(section_header),'"'
              write(ilog,*) 'zone "', trim(zone_name),'"'
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if


!c  define boundary face to be considered (only needed for calculation
!c  of boundary face area for second type boundary conditions) 

          if (type_extent_zone == 0 .and.                              &
              type_extent_zone_box <= 0 .and. (btypezn.eq.'second' .or.&
              btypezn.eq.'seepage-second')) then
   
            found = .false.
            xy_plane = .false.
            xz_plane = .false.
            yz_plane = .false.

            if (dabs(zbmax-zbmin).lt.tiny) then     !xy_plane
              if ((dabs(xbmax-xbmin).lt.tiny).or.                      &
                  (dabs(ybmax-ybmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "', section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                xy_plane = .true.
                found = .true.
              end if
            end if

            if (.not.found) then                     !xz_plane
              if (dabs(ybmax-ybmin).lt.tiny) then
                if ((dabs(xbmax-xbmin).lt.tiny).or.                   &
     &              (dabs(zbmax-zbmin).lt.tiny)) then
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                          &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                else
                  xz_plane = .true.
                  if (xy_plane) then 
                    if (rank == 0) then  
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'error in input file'
                      write(ilog,*) 'section "',                        &
     &                               section_header(:l_string),'"'
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                      write(ilog,*) 'unable to specify boundary face'
                      close(ilog)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if
                  found = .true.
                end if
              end if
            end if

            if (.not.found) then                     !yz_plane
              if (dabs(xbmax-xbmin).lt.tiny) then
                if ((dabs(ybmax-ybmin).lt.tiny).or.                    &
     &              (dabs(zbmax-zbmin).lt.tiny)) then
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                         &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "',zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                else
                  yz_plane = .true.
                  if (xy_plane.or.xz_plane) then 
                    if (rank == 0) then  
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'error in input file'
                      write(ilog,*) 'section "',                        &
     &                               section_header(:l_string),'"'
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                      write(ilog,*) 'unable to specify boundary face'
                      close(ilog)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                end if
                  found = .true.
                end if
              end if
            end if

!c  exit if boundary face was not found 

            if (.not.found) then
#ifdef USG
              if(cell_projection /= projection_xyz) then
#endif
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',                              &
     &                           section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
#ifdef USG
              end if
#endif
            end if

            !c define flux direction for unstructured grid
#ifdef USG
            if (discretization_type > 0 .and. type_flux_direction == 0) then
              if (xy_plane) then
                type_flux_direction = 2
                flux_direction = math_common_set_vector(0.0d0,0.0d0,1.0d0)
              else if (yz_plane) then
                type_flux_direction = 2
                flux_direction = math_common_set_vector(1.0d0,0.0d0,0.0d0)
              else if (xz_plane) then
                type_flux_direction = 2
                flux_direction = math_common_set_vector(0.0d0,1.0d0,0.0d0)
              end if
            end if
#endif

          end if                    !(btypezn.eq.'second')

!c  increment boundary coordinates

          xbmin = xbmin-tiny
          xbmax = xbmax+tiny
          ybmin = ybmin-tiny
          ybmax = ybmax+tiny
          zbmin = zbmin-tiny
          zbmax = zbmax+tiny

!c  store type of boundary condition and boundary condition
!c  for global system in compressed storage

          do ivol = 1,nngl

!c  check limits of boundary zone

            if (((type_extent_zone==0.or.type_extent_zone_box>0) .and. &
                (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.      &
                (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.      &
                (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.      &
                (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.   &
                ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
              if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                if ((btest(type_extent_zone_box,1) .and.               &
                     .not. is_boundary_node(ivol)) .or.                &
                    (btest(type_extent_zone_box,2) .and.               &
                     is_boundary_node(ivol))) then
                  cycle
                end if
              end if
#endif

!c  assign boundary condition

              ibvs = ibvs + 1

              if (ibvs.gt.nngl) then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'nbvs > nn ...'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if

!c  assign pointer and 
!c
              iabvs(ibvs) = ivol
              btypevs(ibvs) = btypezn

              ivol2bvs(ivol) = ibvs
              ivol2bzvs(ivol) = ibz

              if (btypezn.eq.'initial') then
                  
                  btypevs(ibvs) = 'first'
                  bcondvs(ibvs) = uvsnew(ivol)
                  
!c  first type boundary condition - constant pressure head

              elseif (btypezn.eq.'first') then

                if (fluid_pressure) then
                  bcondvs(ibvs) = rwork(1,ibz)
                elseif (pressure_head) then
                  bcondvs(ibvs) = rwork(1,ibz)*density(ivol)*gacc
                elseif (fresh_head) then
                  bcondvs(ibvs) = (rwork(1,ibz) - zg(ivol)) * gacc * ref_dens
                elseif (hydraulic_head) then
                  bcondvs(ibvs) = (rwork(1,ibz) - zg(ivol)) * gacc * density(ivol)
                end if !fluid pressure

                if (.not. b_restart_update_bcvs) then                  
                  !uvsnew(ivol)  = rwork(1,ibz)
                  !cdsu fixed bug here, uvsnew is fluid pressure for density dependent flow
                  uvsnew(ivol) = bcondvs(ibvs)
                end if

!  gradient type condition - variable pressure head at different locations
              elseif (btypezn.eq.'gradient')then
#ifdef USG
                if (itype_grad == 1)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                  end select
                else if (itype_grad == 2)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                  end select
                else
#endif
                  select case(dir_grad)
                  case ('x')
                    pos_grad=xg(ivol)
                  case ('y')
                    pos_grad=yg(ivol)
                  case ('z')
                    pos_grad=zg(ivol)
                  case ('r')
                    pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                    (yg(ivol) - ry0)**2 +  &
                                    (zg(ivol) - rz0)**2)
                  end select
#ifdef USG
                end if
#endif
                bcondvs(ibvs)=rwork(1,ibz) + rwork(2,ibz)*pos_grad
                  
                if (pressure_head) then
                  bcondvs(ibvs) = bcondvs(ibvs)*density(ivol)*gacc
                elseif (fresh_head) then
                  bcondvs(ibvs) = (bcondvs(ibvs) - zg(ivol)) *       &
                                   gacc * ref_dens
                elseif (hydraulic_head) then
                  bcondvs(ibvs) = (bcondvs(ibvs) - zg(ivol)) *       &
                                   gacc * density(ivol)
                end if !fluid pressure

                if (.not. b_restart_update_bcvs) then
                  !uvsnew(ivol) = rwork(1,ibz)
                  !cdsu fixed bug here, uvsnew is fluid pressure for density dependent flow
                  uvsnew(ivol) = bcondvs(ibvs)
                end if    
                
                btypevs(ibvs) = 'first'

!c  second type boundary condition - specified flux

              elseif (btypezn.eq.'second' .or. btypezn.eq.'seepage-second') then

!c  calculate flux area

                if (discretization_type == 0) then
                  if (xy_plane) then
                    areaf = dimcv(1,ivol) * dimcv(2,ivol)
                  elseif (xz_plane) then
                    areaf = dimcv(1,ivol) * dimcv(3,ivol)
                  elseif (yz_plane) then
                    areaf = dimcv(2,ivol) * dimcv(3,ivol)
                  end if
#ifdef USG
                else
                  if (cell_type == cell_type_tri .or.                  &
                      cell_type == cell_type_quad) then
                    !c connected control volume
                    if (is_boundary_node(ivol)) then
                      jvol1 = javs(iavs(ivol)+1)
                      jvol2 = javs(iavs(ivol+1)-1)
                      areaf = geometry_veclength(nodes(ivol)-          &
                              nodes(jvol1),flux_direction,             &
                              type_flux_direction)*0.5
                      areaf = areaf+geometry_veclength(nodes(ivol)-    &
                              nodes(jvol2),flux_direction,             &
                              type_flux_direction)*0.5
                    else
                      areaf = 0.0d0
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          if (icell2 > 0) then
                            do idvol = 1, num_edge_dvols
                              call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                              areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                            end do
                          end if
                        end do
                      end do
                    end if

                  else if (cell_type == cell_type_tetra) then
                    areaf = 0.0d0
                    if (is_boundary_node(ivol)) then
                      do icell = 1, node_num_cells(ivol)
                        cindex = node_cells(icell,ivol)
                        do iface = 1,  num_faces_per_cell           !number of faces
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)

                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if

                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
                          end if
                        end do
                      end do
                    else
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end do
                      end do
                    end if

                  else if (cell_type == cell_type_hexa) then
                    areaf = 0.0d0
                    if (is_boundary_node(ivol)) then
                      do icell = 1, node_num_cells(ivol)
                        cindex = node_cells(icell,ivol)
                        do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                            jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)

                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if

                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol4 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(2) = nodes(jvol4)
                              pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
                          end if
                        end do
                      end do
                    else
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end do
                      end do
                    end if

                  else if (cell_type == cell_type_prism) then
                    areaf = 0.0d0
                    if (is_boundary_node(ivol)) then
                      do icell = 1, node_num_cells(ivol)
                        cindex = node_cells(icell,ivol)
                        do iface = 1, 2                              !number of faces, top and bottom faces of prism
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_prism(3,iface),cindex)

                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if

                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if

                          end if
                        end do

                        do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                            jvol4 = cells(face_node_mapping_prism(4,iface),cindex)

                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if

                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol4 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(2) = nodes(jvol4)
                              pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
                          end if
                        end do
                      end do
                    else
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end do
                      end do
                    end if
                  else
                    if (rank == 0) then
                      write(ilog,'(2a,i2)') 'boundary surface area calculation ',&
                            'does not support cell_type updtbcdd',cell_type
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if
#endif
                end if

!c  assign second type boundary condition and convert to internal 
!c  time units
                if (b_water_freezing) then
                  if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                    if (b_freezing_adjacent_bd) then
                      if (freezing_adjacent_bd(ivol)) then
                        bcondvs(ibvs) = r0
                      else
                        bcondvs(ibvs) = areaf*rwork(1,ibz)*sec_per_days
                      end if
                    else
                      bcondvs(ibvs) = areaf*rwork(1,ibz)*sec_per_days
                    end if
                  else
                    bcondvs(ibvs) = r0
                  end if
                else
                  bcondvs(ibvs) = areaf*rwork(1,ibz)*sec_per_days
                end if

                !c revert 'seepage-second' to normal
                if (btypezn.eq.'seepage-second') then
                  seepage_bits(ibvs) = 2
                end if

              elseif (btypezn.eq.'point') then
                if (b_water_freezing) then
                  if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                    if (b_freezing_adjacent_bd) then
                      if (freezing_adjacent_bd(ivol)) then
                        bcondvs(ibvs) = r0
                      else
                        bcondvs(ibvs) = rwork(1,ibz)*sec_per_days
                      end if
                    else
                      bcondvs(ibvs) = rwork(1,ibz)*sec_per_days
                    end if
                  else
                    bcondvs(ibvs) = r0
                  end if
                else
                  bcondvs(ibvs) = rwork(1,ibz)*sec_per_days
                end if

              else if (btypezn.eq.'seepage') then
                if (zg(ivol).lt.rwork(1,ibz)) then
                  uvsnew(ivol) = r0
                  uvsold(ivol) = r0
                  hhead(ivol) = r0 + zg(ivol)
                                              !identify zero pressure
                  !bcondvs(ibvs) = -r1
                  seepage_bits(ibvs) = 1
                else
                                              !identify zero-flux
                  !bcondvs(ibvs) = r1
                  seepage_bits(ibvs) = 2
                end if
                
              else if (btypezn.eq.'free-drainage') then
                gradf_bvs(ibvs) = rwork(1,ibz)
              end if   !(btypezn.eq.'first'.or.btypezn.eq.'second')
            end if     !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
          end do       !loop over control volumes
        end do         !end loop over zones
        
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------        
       if (nbvs.ne.ibvs .and. b_enable_output) then
         write(*,*)'Warning, different number of assigned cells for ',&
     &             ' boundary  conditions'
         write(*,*)'Previous:',nbvs,'cells'
         write(*,*)'Now:',ibvs,'cells'
       end if 
       nbvs=ibvs

500     continue

!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!c  deallocate workarray for reading transient boundary conditions
        call memory_monitor(-sizeof(rwork),'rwork',.true.)
        deallocate (rwork, stat = ierr)
        call checkerr(ierr,'rwork',ilog)

        call memory_monitor(-sizeof(rwork_next),'rwork_next',.true.)
        deallocate (rwork_next, stat = ierr)
        call checkerr(ierr,'rwork_next',ilog)
        
!c  array iabvs

        allocate (iwork(nbvs), stat = ierr)
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'iwork',.true.)
        
        do ibvs = 1,nbvs
          iwork(ibvs) = iabvs(ibvs)
        end do
        
        call memory_monitor(-sizeof(iabvs),'iabvs',.true.)
        deallocate (iabvs, stat = ierr)
        call checkerr(ierr,'iabvs',ilog)
        
        allocate (iabvs(nbvs), stat = ierr)
        call checkerr(ierr,'iabvs',ilog)
        call memory_monitor(sizeof(iabvs),'iabvs',.true.)
        
        do ibvs = 1,nbvs
          iabvs(ibvs) = iwork(ibvs)
        end do

        do ibvs = 1, nbvs
          do i = nbvs, ibvs + 1, -1
            if (iabvs(i) == iabvs(ibvs)) then
              iabvs(ibvs) = -iabvs(ibvs)
              exit
            end if
          end do
        end do
        
        call memory_monitor(-sizeof(iwork),'iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)

!c  save the updated boundary condition when ice loading is considered
        if (compute_ice_sheet_loading) then 
          bcondvs0 = bcondvs
        end if

!c  restore the reading position to previous record 
        if (b_updt_next_only) then
          backspace(ibcvs)
        end if

!c  assign next read time    
        if (time_bcvs < tfinal/time_factor) then
          read(ibcvs,*,err=998,end=997) time_bcvs
        end if

        return

!c  assign next read time greater than final solution time, if no more
!c  read times left and return
!cdsu replace 1.1*tfinal since tfinal can be negative

997     time_bcvs = (tfinal+1.0d100)/time_factor

        return

998     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

999     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file, error code ', ierrcd
          write(ilog,*) 'section "',section_header(:l_string),'"'
          write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      else if (b_interpolation_bcvs) then  
        if (nbvs > 0) then
          do ibvs = 1, nbvs
            ivol = iabvs(ibvs)
  
            if (ivol < 0) then
              cycle  
            end if
  
            btypezn = btypevs(ibvs)
  
            bcondvs(ibvs) = math_common_linear(time_bcvs_prev, time_bcvs,&
                                 bcondvs_prev(ibvs), bcondvs_next(ibvs), &
                                 time_io)
  
            if (btypezn .eq. 'free-drainage') then
              gradf_bvs(ibvs) = math_common_linear(time_bcvs_prev, time_bcvs,&
                                     bcondvs_prev(ibvs), bcondvs_next(ibvs), &
                                     time_io)            
            end if
  
            if (btypezn .eq. 'first') then
              uvsnew(ivol) = bcondvs(ibvs)
            end if
          end do
  
          if (compute_ice_sheet_loading) then 
            bcondvs0 = bcondvs
          end if  
        end if
      end if

      return

      end
