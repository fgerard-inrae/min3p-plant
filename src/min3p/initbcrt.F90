!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initbcrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initbcrt  
!c ------------------- 
!c
!c boundary conditions (reactive transport)
!c
!c modified with addition of point source boundary and calculation of
!c density of multcomponent source boundary
!c
!c written by:      Uli Mayer - August 21, 96
!c
!c last modified:   Tom Henderson - September 3, 2003
!c                  Sergi Molins - May 2, 2006 
!c                  added 'pn2', 'pch4', pco2', 'pco2x', 'par'
!c                  module phys added for permx, permy, permz, 
!c                  permbrt
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   
!c
!c common:
!c parm.f:   -
!c
!c gen.f:    real*8:
!c           -------
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  * +
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third type b.c. -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  * +
!c                                volumes (gaseous phase)
!c                                third type b.c. -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for * +
!c                                diffusive mass fluxes across 
!c                                boundary
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           dimcv(3,nn)        = dimension of control volumes        + -
!c           gbrt(ng,nbrt)      = gas concentrations in boundary      * +
!c                                control volumes
!c           rwork(:,:)         = real*8 work array                   * *
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           tsrc(nbrt)         = read times - transient source       * +
!c                                chemistry
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           iwork(:)           = integer work array                  * *
!c           iabrt(nbzrt+1)     = pointer array - boundary conditions * +
!c                                (reactive transport)
!c           jabrt(nbrt)        = pointer array - boundary conditions * +
!c                                (reactive transport)
!c           icnv               = unit number, data conversion and    + -
!c                                             temporary storage
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging information  + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           itsrc              = pointer to current target read
!c                                time for updating boundary 
!c                                conditions 
!c                                (reactive transport) 
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           nn                 = total number of control volumes     + -
!c           nbrt               = number of specified boundary        * +
!c                                control volumes
!c           nbzrt              = number of boundary zones            * +
!c                                (reactive transport)
!c           ntsrc              = number of read times for            * +
!c                                transient source chemistry
!c
!c           logical:
!c           --------
!c           explicit_surface   = .true.  -> include surface sites    + -
!c                                           in equilibrium
!c                                           calculations
!c           explicit_surface_ion  = .true.  -> include surface sites + -
!c                                           in equilibrium 
!c                                           calculations
!c                                           of ion-exchange
!c           explicit_surface_surf = .true.  -> include surface sites + -
!c                                           in equilibrium 
!c                                           calculations
!c                                           of surface-complex
!c           implicit_surface   = .true.  -> equilibrate surface      + -
!c                                           sites with fixed
!c                                           solution composition
!c           implicit_surface_ion  = .true.  -> equilibrate surface   + -
!c                                           sites with fixed 
!c                                           solution composition
!c                                           of ion-exchange
!c           implicit_surface_surf = .true.  -> equilibrate surface   + -
!c                                           sites with fixed 
!c                                           solution composition
!c                                           of surface-complex
!c           redox_equil_rt     = .true.  -> equilibrium redox        + -
!c                                           reactions
!c           spec_conc          = .true.  -> source concentrations    * +
!c                                           specified
!c                                .false. -> background
!c                                           concentrations as
!c                                           boundary condition
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_source   = .true.  -> transient source         * +
!c                                           chemistry
!c                                .false. -> constant source
!c                                           chemistry
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    * +
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (specified dispersive flux, 
!c                                            free mass outflux for aqueous
!c                                            phase, free exit)
!c                                'third'  = Cauchy
!c                                           (specified dispersive and advective flux, 
!c                                            for aqueous phase)
!c                                'third-evap'
!c                                         = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase, for outflux,
!c                                            use closed boundary for transport,
!c                                            like evaporation)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase
!c                            'mixed-evap' = mixed-evap
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and gaseous phase,
!c                                            for outflux, use closed boundary
!c                                            for transport for aqueous phase,
!c                                            like evaporation)
!c           prefix             = prefix name for all I/O files       + -
!c           section_header     = section header                      * +
!c           zone_name          = name of zone                        * +
!c           
!c
!c chem.f:   real*8:
!c           -------
!c           actv(nc)           = activities of free species          * +
!c                                - new time level
!c           ccnew(nc)          = concentrations of free species      + +
!c                                - new time level [moles/l water]
!c           ccold(nc)          = concentrations of free species      + +
!c                                - old time level [moles/l water]
!c           cgc(ng)            = gas concentrations                  * +
!c                                - new time level [moles/l air]
!c           cxc(nx)            = concentrations of secondary         * +
!c                                aqueous species
!c                                - new time level [moles/l water]
!c           delt_lc(nthreads)  = time step for local chemistry       * +
!c                                computations
!c           gamma_l(nc+nx)     = activity coefficients for aqueous   * *
!c                                species
!c           gfwc(nc)           = gram formula weight of components   + -
!c           phguess            = guess for pH                        * +
!c           tempk              = temperature [deg K]                 + -
!c           totcn(n,nthreads)  = total aqueous component             * +
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totco(n,nthreads)  = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgn(n,nthreads)  = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c
!c           integer*4:
!c           ----------
!c           l_namec(nc)        = length of component names           + -
!c           nc                 = number of components including h2o  + -
!c           ncorder(nc)        = ordering array for components       + -
!c                                ncorder(old order) = new order
!c           ng                 = number of gases                     + -
!c           nr                 = number of redox couples             + -
!c
!c           logical:
!c           --------
!c           reactive_minerals  = .true.  -> consider mineral         * +
!c                                           dissolution-
!c                                           precipitation reactions
!c           redox_equil_lc     = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       * +
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           ctype(nc-1)        = 'charge' = correct total aqueous    * +
!c                                           component concentration
!c                                           for specified component 
!c                                           to satisfy charge balance
!c                                'fixed'  = compute total aqueous
!c                                           component concentrations
!c                                           based on fixed activities
!c                                           of components as species
!c                                           in solution
!c                                'free'   = compute concentrations
!c                                           of components as species
!c                                           in solution based on 
!c                                           specified total aqueous
!c                                           component concentrations
!c                                'ph'    =  pH specified for 'h+1'
!c           input_units        = 'mol/l'                             + -
!c                                'mmol/l'
!c                                'mg/l'
!c                                'g/l'
!c           namec(nc)          = component names                     + -
!c
!c
!c dens.f:   real*8:
!c           -------
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density 
!c                                           dependent flow
!c
!c local:    real*8:
!c           -------
!c           porc               = porosity for local chemistry
!c                                calculations
!c           r1                 = constant
!c           r2                 = constant
!c           r1000              = constant
!c           sgc                = gaseous phase saturation for local
!c                                chemistry calculations
!c           sac                = aqueous phase saturation for local
!c                                chemistry saturations
!c           tiny               = small increment
!c           xbmax              = max. x-coordinate of boundary zone
!c           xbmin              = min. x-coordinate of boundary zone
!c           ybmax              = max. y-coordinate of boundary zone
!c           ybmin              = min. y-coordinate of boundary zone
!c           zbmax              = max. z-coordinate of boundary zone
!c           zbmin              = min. z-coordinate of boundary zone
!c
!c           integer*4:
!c           ----------
!c           ibrt               = counter (boundary control volumes)
!c           ibrt_start         = start of current boundary zone
!c           ibrt_stop          = end of current boundary zone
!c           ibz                = counter (boundary zones)
!c           ierr               = 0 -> memory allocation successful
!c           ic                 = counter (components)
!c           icount             = counter
!c           ig                 = counter (gases)
!c           itemp              = pointer
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit search
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           xy_plane           = boundary zone parallel tp xy-plane
!c           xz_plane           = boundary zone parallel to xz-plane
!c           yz_plane           = boundary zone parallel to yz-plane
!c
!c           character:
!c           ----------
!c           btypezn            = boundary type of zone
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           gcreact   = geochemical reactions for batch system
!c           guess     = guess for concentrations of
!c                       free species
!c           icbcrt    = assign initial or boundary condition
!c                       to global system (reactive transport)
!c           minmaxwd  = determine minimum total aqueous component
!c                       concentrations and maximum secondary aqueous
!c                       species concentration in solution domain
!c           outputlc  = write results of local chemistry
!c                       computations to generic output file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c           rtrvpprm  = retrieve physical parameters
!c           setsize   = define number of primary unknowns
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c ----------------------------------------------------------------------
 
      subroutine initbcrt
 
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use chem
      use dens
      use phys
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize, petsc_mpi_barrier
#endif

#ifdef USG
      use geometry
      use usg_ice_sheet
      use usg_mesh_data, only : nodes, cell_type, num_nodes_per_cell,  &
                                node_cells, node_num_cells,            &
                                cell2halfid, CellFaceCenter, cells,    &
                                cal_cellface_index, cell_projection,   &
                                num_faces_per_cell, CellFaceScaledNorm,&
                                is_boundary_node, num_edge_dvols,      &
                                CellCvolFaceUnitNorm,                  &
                                CellCvolFaceArea, get_cell_edge_cvol_id
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#endif
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: tid, i, iaq, ic, ix, icount, itemp, ierr, ibz, ibrt,  &
                 ibrt_start, ibrt_stop, ig, itid, ivol, l_string,      &
                 ibz_ice, istart, iend, jtemp, jtemp1, jtemp2,         &
                 nbrt_usg, ierrcd
      
      real*8 :: sac, sgc, porc, xbmin, xbmax, ybmin, ybmax,            &
                zbmin, zbmax, rtemp_scaling, areaf
      real*8, external :: boundary_func

      external checkerr, comptotc, findstrg, findzone,  guess,         &
               icbcrt, outputlc, minmaxwd, readbloc, readzone,         &
               rtrvpprm, setsize, totconc, totconcg,                   &
               minmaxwd_mpi, gcreact
      
      logical :: flag_nan, flag_invalid, flag_stop, flag_istotbc
      logical xy_plane,xz_plane,yz_plane,found,found_section,          &
              found_subsection
      character*32 btypezn, bctypefunc
      character*72 subsection
#ifdef USG
      real*8 :: ratio_flux
      integer :: icell, icell2, iface, cindex, idvol, idvol_r,         &
                 iedge_r, jvol, jvol1, jvol2, jvol3, jvol4, jvol5,     &
                 jvol6, jvol7, jvol8
      type(point) :: pts(4)
      integer (type_i4), allocatable :: ia_permbrt_usg(:)
#endif

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif
      
      logical iserror      
     
      integer, parameter :: iscreen=6
      
      character(len=100) :: msg 

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,         &
                 r1000 = 1.0d+3, small = 1.0d-7, tiny = 1.d-10
      
      logical :: b_fluxd_bcond_zn      
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
      ierrcd = 0

      xy_plane = .false. 
      xz_plane = .false.
      yz_plane = .false.
      
      dens_h2o = 1.0d+3
      
      msg=' ' 

!c  read section header for boundary conditions (reactive transport)
 
      section_header = 'boundary conditions - reactive transport'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to generic output file
      if(b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a)')('-',i=1,72)
      end if

      if(rank == 0 .and. b_enable_output) then
        write(*,'(/1x,a)') section_header(:l_string)
        write(*,'(1x,72a)')('-',i=1,72)
     
        write(ilog,'(a)') section_header(:l_string)
        write(ilog,'(72a/)')('-',i=1,72)
      end if

!c  control parameters for processing initial condition for minerals
!c  only equilibrium for source chemistry

      reactive_minerals = .false.
      delt_lc(:) = r1
      !implicit_surface = .false.
      !explicit_surface = .false.
      implicit_surface_ion = .false.
      explicit_surface_ion = .false.
      implicit_surface_surf = .false.
      explicit_surface_surf = .false.
      
      b_fluxd_bcond_zn = .false.

!c  read number of boundary zones

      ierrcd = 1
      read(itmp,*,err=999,end=999) nbzrt
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/a,i10)')  &
     &  'number of boundary zones                        = ',nbzrt
      end if

!c  preliminary allocation of memory for boundary conditions
 
      allocate (bcondrt_a(nc,nngl), stat = ierr)
      bcondrt_a=0.0d0 
      call checkerr(ierr,'bcondrt_a',ilog)
      call memory_monitor(sizeof(bcondrt_a),'bcondrt_a',.true.)


      allocate (bcondrt_g(nc,nngl), stat = ierr)
      bcondrt_g=0.0d0 
      call checkerr(ierr,'bcondrt_g',ilog)
      call memory_monitor(sizeof(bcondrt_g),'bcondrt_g',.true.)


      allocate (bdycrt_d(nngl), stat = ierr)
      bdycrt_d=0.0d0 
      call checkerr(ierr,'bdycrt_d',ilog)
      call memory_monitor(sizeof(bdycrt_d),'bdycrt_d',.true.)


      allocate (zgbrt(nngl), stat = ierr)
      zgbrt=0.0d0 
      call checkerr(ierr,'zgbrt',ilog)
      call memory_monitor(sizeof(zgbrt),'zgbrt',.true.)


      allocate (gbrt(ng,nngl), stat = ierr)
      gbrt=0.0d0 
      call checkerr(ierr,'gbrt',ilog)
      call memory_monitor(sizeof(gbrt),'gbrt',.true.)


      allocate (iabrt(nbzrt+1), stat = ierr)
      iabrt=0 
      call checkerr(ierr,'iabrt',ilog)
      call memory_monitor(sizeof(iabrt),'iabrt',.true.)


      allocate (jabrt(nngl), stat = ierr)
      jabrt=0 
      call checkerr(ierr,'jabrt',ilog)
      call memory_monitor(sizeof(jabrt),'jabrt',.true.)


      allocate (btypert(nngl), stat = ierr)
      btypert='undefined'
      call checkerr(ierr,'btypert',ilog)
      call memory_monitor(sizeof(btypert),'btypert',.true.)
      

      allocate (b_fluxd_bcond(nngl), stat = ierr)
      b_fluxd_bcond=.false.
      call checkerr(ierr,'b_fluxd_bcond',ilog)
      call memory_monitor(sizeof(b_fluxd_bcond),'b_fluxd_bcond',.true.)


      allocate (dijbrt(nngl), stat = ierr)
      dijbrt=0.0d0 
      call checkerr(ierr,'dijbrt',ilog)
      call memory_monitor(sizeof(dijbrt),'dijbrt',.true.)



#ifdef USG
      if (discretization_type > 0) then
        allocate (permbrt_usg(njavs), stat = ierr)
        permbrt_usg=0.0d0
        call checkerr(ierr,'permbrt_usg',ilog)
        call memory_monitor(sizeof(permbrt_usg),'permbrt_usg',.true.)

        allocate(ia_permbrt_usg(nngl+1))
        ia_permbrt_usg = 0
        call checkerr(ierr,'ia_permbrt_usg',ilog)
        call memory_monitor(sizeof(ia_permbrt_usg),'ia_permbrt_usg',.true.)
      end if
#endif
      allocate (permbrt(nngl), stat = ierr)
      permbrt=0.0d0
      call checkerr(ierr,'permbrt',ilog)
      call memory_monitor(sizeof(permbrt),'permbrt',.true.)


      allocate (cinfvs_gbrt(nngl), stat = ierr)
      cinfvs_gbrt=0.0d0 
      call checkerr(ierr,'cinfvs_gbrt',ilog)
      call memory_monitor(sizeof(cinfvs_gbrt),'cinfvs_gbrt',.true.)
      

      !transient boundary condition function
      allocate (totco_func(6,nc-1,nbzrt), stat = ierr)
      totco_func=0.0d0
      totco_func(2,:,:) = 1.0d0
      call checkerr(ierr,'totco_func',ilog)
      call memory_monitor(sizeof(totco_func),'totco_func',.true.)
      
      allocate (scalfac_aq_func(6,naq,nbzrt), stat = ierr)
      scalfac_aq_func=0.0d0
      scalfac_aq_func(2,:,:)=1.0d0
      call checkerr(ierr,'scalfac_aq_func',ilog)
      call memory_monitor(sizeof(scalfac_aq_func),'scalfac_aq_func',.true.)
      
      allocate (phguess_func(6,nbzrt), stat = ierr)
      phguess_func=0.0d0
      phguess_func(2,:) = 1.0d0
      call checkerr(ierr,'phguess_func',ilog) 
      call memory_monitor(sizeof(phguess_func),'phguess_func',.true.)
      
      allocate (b_update_zone_func(nbzrt), stat = ierr)
      b_update_zone_func=.false.
      call checkerr(ierr,'b_update_zone_func',ilog)
      call memory_monitor(sizeof(b_update_zone_func),'b_update_zone_func',.true.)
        
      !transient boundary condition for linear interpolation     
      allocate (scalfac_aq_init(naq,nbzrt), stat = ierr)
      scalfac_aq_init=0.0d0
      call checkerr(ierr,'scalfac_aq_init',ilog)
      call memory_monitor(sizeof(scalfac_aq_init),'scalfac_aq_init',.true.)
      
      allocate (phguess_init(nbzrt), stat = ierr)
      phguess_init=0.0d0
      call checkerr(ierr,'phguess_init',ilog)
      call memory_monitor(sizeof(phguess_init),'phguess_init',.true.)
      
      allocate (ctype_bzrt_init(nc-1,nbzrt), stat = ierr)
      ctype_bzrt_init=' ' 
      call checkerr(ierr,'ctype_bzrt_init',ilog)
      call memory_monitor(sizeof(ctype_bzrt_init),'ctype_bzrt_init',.true.)
!c  set default value for ssdens vector

      if (density_dependence) then
        do ivol = 1, nngl
          ssdens(ivol) = ref_dens
        end do
      end if

      transient_source_function = .false. 

!c  initialize counter for boundary control volumes

      iabrt(1) = 1
      
#ifdef USG
      if (discretization_type > 0) then
        nbrt_usg = 0
      end if
#endif

!c  read number of boundary zones 

      do ibz=1,nbzrt                      !loop over number of zones

        ibrt = iabrt(ibz)-1               !set counter for current zone

!c  find current zone in input file and write to temporary file

        subsection = 'number and name of zone'

        call findzone(subsection,itmp,found_subsection,ibz,zone_name)

        if (found_subsection) then

          call readzone(itmp,icnv,ilog,zone_name,found_subsection)

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error in input file'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define length of zone name

        l_zone_name = index(zone_name,'  ')-1
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
          l_zone_name = 72
        end if

!c  write header for boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/a,i0,a,1x,a)') 'zone ',ibz,':', &
     &                                 zone_name(:l_zone_name)
          write(igen,'(72a)')('-',i=1,72)
        end if
        
        subsection = 'use function for transient boundary input'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then
          b_update_zone_func(ibz) = .true.  
          transient_source_function = .true.
          if (b_enable_output .and. b_enable_output_gen) then
              write(igen,'(/2a,i0)') trim(subsection), "for zone ",ibz
          end if
        end if
        
      
!c  determine interpolation spatial weighting for transient source chemistry is to be used

!c  define type of boundary condition

        subsection = 'boundary type'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then
          ierrcd = 2
          read(icnv,*,err=999,end=999) btypezn

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define, if background concentrations are to be used as boundary 
!c  condition

        if (btypezn.eq.'first') then

          subsection = 'use background chemistry for boundary zone'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            spec_conc = .false.
          else
            spec_conc = .true.
          end if

        end if

!c  concentration input for current zone
!c  Note: the tracer here is placed inside the domain, not at the boundaries.
!c  Only the components names as 'tracer-xxx' is tracked while other components are ignored.
!c  The input format is same as normal component input.
!c  If the tracer is placed at the boundaries, use normal boundary condition setting.
 
        if ((btypezn.eq.'first' .and. spec_conc).or.  &
            (btypezn.eq.'third').or.                  &
            (btypezn.eq.'third-evap').or.             &
            (btypezn.eq.'mixed') .or.                 &
            (btypezn.eq.'mixed-evap') .or.            &
            (btypezn.eq.'point')) then

          if (rank == 0 .and. b_enable_output) then  
            write(ilog,'(a/72a)') zone_name,('-',i=1,72)
          end if

          subsection = 'concentration input'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            do ic=1,nc-1

              itemp = ncorder(ic)                      !internal order
              if (component_type(itemp).eq.'aqueous'.or.               &
                  component_type(itemp).eq.'biomass') then

                if (b_update_zone_func(ibz)) then
                  ierrcd = 3
                  read(icnv,*,err=999,end=999) bctypefunc,             &
                       totco_func(3:6,itemp,ibz),ctype(itemp) 
                  
                  if (trim(bctypefunc)=='polynomial') then
                    totco_func(1,itemp,ibz) = 2.0d0  
                  else if (trim(bctypefunc)=='sine') then
                    totco_func(1,itemp,ibz) = 4.0d0  
                  else
                    if (rank == 0) then
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'error reading input file'
                      write(ilog,*) 'section "',section_header(:l_string),'"'
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                      write(ilog,*) 'unknow boundary function type ',trim(bctypefunc)
                      close(ilog)
                    end if
#ifdef PETSC        
                    call petsc_mpi_finalize
#endif              
                    stop
                  end if
                  
                else
                  ierrcd = 4
                  read(icnv,*,err=999,end=999) totco(itemp,tid),       &
                       ctype(itemp)
                end if  

!c  -> convert input units to internal units [moles/l]

                rtemp_scaling = 1.0d0

                if (ctype(itemp).ne.'ph'.and.     &
                    ctype(itemp).ne.'eh'.and.     &
                    ctype(itemp).ne.'pe'.and.     &
                    ctype(itemp).ne.'po2'.and.    &
                    ctype(itemp).ne.'pn2'.and.    &
                    ctype(itemp).ne.'pch4'.and.   &
                    ctype(itemp).ne.'ph2'.and.    &
                    ctype(itemp).ne.'pco2x'.and.  &
                    ctype(itemp).ne.'par'.and.    &
                    ctype(itemp).ne.'pco2') then
                  if (input_units.eq.'mmol/l') then
                    rtemp_scaling = rtemp_scaling / r1000
                  elseif (input_units.eq.'mg/l') then
                    rtemp_scaling = rtemp_scaling / r1000 / gfwc(itemp)
                  elseif (input_units.eq.'g/l') then
                    rtemp_scaling = rtemp_scaling / gfwc(itemp)
                  end if
                end if
     
                if (b_update_zone_func(ibz)) then
                  totco_func(2,itemp,ibz) = rtemp_scaling
                  totco(itemp,tid) =                                   &
                        boundary_func(6,totco_func(1:6,itemp,ibz),time)
                end if
                
                totco(itemp,:) = totco(itemp,tid)*rtemp_scaling
                
              end if     

            end do

          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',trim(section_header),'"'
              write(ilog,*) 'zone "', trim(zone_name),'"'
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if
          
          ctype_bzrt_init(1:nc-1,ibz) = ctype(1:nc-1)
         
!c  define if diffusive flux is applied for third or mixed boundary condition
!c  for mixed boundary condition, diffusive flux is a default
          if (btypezn.eq.'mixed' .or. btypezn.eq.'mixed-evap') then
            b_fluxd_bcond_zn = .true.
          end if

          subsection = 'include diffusive flux for third/mixed boundary condition'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            b_fluxd_bcond_zn = .true.
          end if

          subsection = 'exclude diffusive flux for third/mixed boundary condition'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            b_fluxd_bcond_zn = .false.
          end if

          !c the following keywords are deprecated
          subsection = 'include diffusive flux for mixed boundary condition'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            b_fluxd_bcond_zn = .true.
          end if

          subsection = 'include diffusive flux from mixed boundary condition'
          call findstrg(subsection,icnv,found_subsection) 
          if (found_subsection) then
            b_fluxd_bcond_zn = .true.
          end if

          subsection = 'exclude diffusive flux for mixed boundary condition'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            b_fluxd_bcond_zn = .false.
          end if

          subsection = 'exclude diffusive flux from mixed boundary condition'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            b_fluxd_bcond_zn = .false.
          end if
          
!c  define guess for pH

          subsection = 'guess for ph'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            if (b_update_zone_func(ibz)) then
              ierrcd = 5
              read(icnv,*,err=999,end=999) bctypefunc,phguess_func(3:6,ibz)
              if (trim(bctypefunc)=='polynomial') then
                phguess_func(1,ibz) = 2.0d0  
              else if (trim(bctypefunc)=='sine') then
                phguess_func(1,ibz) = 4.0d0  
              else
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error reading input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unknow boundary function type ',trim(bctypefunc)
                  close(ilog)
                end if
#ifdef PETSC    
                call petsc_mpi_finalize
#endif          
                stop
              end if
              phguess = boundary_func(6,phguess_func(1:6,ibz),time)
            else
              ierrcd = 6
              read(icnv,*,err=999,end=999) phguess
            end if
          else
            if (b_update_zone_func(ibz)) then
              phguess_func(3:5,ibz) = 0.0d0
              phguess_func(6,ibz) = 7.0d0
            end if
            phguess = 7.0d0
          end if
          
          phguess_init(ibz) = phguess
         
!c_bubbles - spatial dependent intra-aqueous scaling factors

          subsection = 'scaling for intra-aqueous kinetic reactions'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            if (b_update_zone_func(ibz)) then
              do iaq = 1,naq
                ierrcd = 7
                read(icnv,*,err=999,end=999) bctypefunc,               &
                     scalfac_aq_func(3:6,iaq,ibz)
                
                if (trim(bctypefunc)=='polynomial') then
                  scalfac_aq_func(1,iaq,ibz) = 2.0d0  
                else if (trim(bctypefunc)=='sine') then
                  scalfac_aq_func(1,iaq,ibz) = 4.0d0  
                else
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error reading input file'
                    write(ilog,*) 'section "',section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unknow boundary function type ',trim(bctypefunc)
                    close(ilog)
                  end if
#ifdef PETSC      
                  call petsc_mpi_finalize
#endif            
                  stop
                end if                
                scalfac_aq(iaq) = boundary_func(6,scalfac_aq_func(1:6,iaq,ibz),time)                
              end do
            else
              do iaq = 1,naq
                ierrcd = 8
                read(icnv,*,err=999,end=999) scalfac_aq(iaq)
              end do
            end if
            
          else
            if (b_update_zone_func(ibz)) then
              do iaq = 1,naq
                scalfac_aq_func(3:5,iaq,ibz) = 0.0d0
                scalfac_aq_func(6,iaq,ibz) = r1
              end do
            end if
            do iaq = 1,naq
              scalfac_aq(iaq) = r1
            end do

          end if
          
          if (naq > 0) then
            scalfac_aq_init(1:naq,ibz) = scalfac_aq(1:naq)
          end if
  
!c  guess for concentrations of free species

          call guess(ccnew,ccold,tempk,ilog,tid)

!c  write input parameters for current zone to generic output file
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(/2a)') 'control parameters: ',zone_name
            write(igen,'(72a/)') ('-',i=1,72)
            
            write(igen,'(a/)') 'equilibration of aqueous species'
            
            write(igen,'(/2a)') 'input parameters: ',zone_name
            write(igen,'(72a)')('-',i=1,72)
            
            write(igen,'(/a)')'total aqueous component concentrations:'
            write(igen,'(a)')'---------------------------------------'
            write(igen,'(a)')'component             conc.'
            write(igen,'(a)')'---------------------------'
            do ic=1,nc-1
              if (component_type(ic).eq.'aqueous'.and.      &
     &            ctype(ic).eq.'free') then
                  write(igen,'(a12,1x,1pe15.6e3)') namec(ic),totco(ic,tid)
              end if
            end do
            
            icount = 0
            do ic=1,nc-1
              if (ctype(ic).eq.'fixed') then
                icount = icount+1
                if (icount.eq.1) then
                  write(igen,'(/a)')'fixed activities:'
                  write(igen,'(a)')'------------------'
                  write(igen,'(a)')'species               actv.'
                  write(igen,'(a)')'---------------------------'
                end if
                write(igen,'(a12,1x,1pe15.6e3)') namec(ic),actv(ic)
              end if
            end do
            
            do ic=1,nc-1
              if (ctype(ic).eq.'charge') then
                write(igen,'(/3a)')'total aqueous component ',      &
     &                             'concentrations of component ',  &
     &                              namec(ic)(:l_namec(ic))
                write(igen,'(a)')'to be determined by charge balance'
              end if
            end do          
          end if
          
!c  biomass concentrations

          if (nbio.gt.0) then
            if (b_enable_output .and. b_enable_output_gen) then
              write(igen,'(/a)')'biomass concentrations:'
              write(igen,'(a)')'-----------------------'
              write(igen,'(a)')'component             conc.'
              write(igen,'(a)')'---------------------------'
              do ic=1,nc-1
                if (component_type(ic).eq.'biomass'.and.                &
     &              ctype(ic).eq.'free') then
                    write(igen,'(a12,1x,1pe15.6e3)') namec(ic),         &
                          totco(ic,tid)
                end if
              end do
            end if
          end if

!c  guess for pH
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(/a,f8.4)')                                 &
     &      'guess for pH of solution:          pH =', phguess
          end if

!c  set number of primary unknowns for current batch problem

          call setsize(redox_equil_lc)

!c  retrieve physical parameters for scaling

          call rtrvpprm(sac,sgc,porc,r1,section_header)

!c  temperature correction
          if (temp_corr.or.heat_transport) then
            do itid = 1, nthreads
              call tcorr(tempk,0,itid)
            end do
          end if

!c  compute concentration distribution at boundary
          call gcreact(ccnew,ccold,cxc,gamma_l(1),gamma_l(nc+1),      &
     &                 cgc,sac,sgc,porc,igen,ilog,tid,idbg,tec_header,&
     &                 prefix,l_prfx,zone_name,l_zone_name,           &
     &                 mtime,i_append_sim,mtime_append)

!c  determine minimum total aqueous component concentrations and maximum
!c  secondary aqueous species concentration in solution domain

          call minmaxwd(cxc,totcn(:,tid))

#ifdef PETSC
          call minmaxwd_mpi
#endif

!c  write results to generic output file
          if(b_enable_output .and. b_enable_output_gen)  then
            call outputlc(ccnew,cxc,gamma_l(1),gamma_l(nc+1),          &
     &                    cgc,igen,ilog,tid,section_header)
          end if

!c  check if the concentration of solution is physically and numerically reasonable 
          flag_nan = .false.
          do ic = 1, nc-1
            if (isnan(ccnew(ic))) then
              flag_nan = .true.
              exit
            end if
          end do

          do ix = 1, nx
            if (isnan(cxc(ix))) then
              flag_nan = .true.
              exit
            end if
          end do

          flag_stop = flag_nan

#ifdef PETSC        
          call MPI_Allreduce(flag_nan, flag_stop, 1, MPI_LOGICAL,      &
                             MPI_LOR,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
#endif
    
          if(flag_stop) then
            if(rank == 0) then
              write(*,'(2a,/,7x,2a)') "Error: Concentration is not physically or ",    &
                    "numerically reasonable. ", "Please check initial conditions",     &
                    " or try other solvers."
              write(ilog,'(2a,/,7x,2a)') "Error: Concentration is not physically or ", &
                    "numerically reasonable. ", "Please check initial conditions",     &
                    " or try other solvers."
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

        end if


!c  assign boundary condition to control volumes located in boundary zone

!c  read coordiantes defining boundary zone

        type_extent_zone = -1
        type_extent_zone_box = -1

        subsection = 'extent of zone'
        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          type_extent_zone = 0
          ierrcd = 9
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax

        end if

#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 10
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xbmin = -1.0d300
          xbmax = 1.0d300
        end if

        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ybmin = -1.0d300
          ybmax = 1.0d300
        end if

        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zbmin = -1.0d300
          zbmax = 1.0d300
        end if

!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then

          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define boundary face to be considered (only needed for calculation
!c  of boundary face area for second type boundary conditions)

        if (type_extent_zone == 0 .and. type_extent_zone_box <= 0 .and.&
            (btypezn.eq.'mixed' .or. btypezn.eq.'mixed-evap' .or.      &
            (btypezn.eq.'third'.and.b_fluxd_bcond_zn) .or.             &
            (btypezn.eq.'third-evap'.and.b_fluxd_bcond_zn))) then

          found = .false.
          xy_plane = .false.
          xz_plane = .false.
          yz_plane = .false.

          if (dabs(zbmax-zbmin).lt.tiny) then     !xy_plane
            if ((dabs(xbmax-xbmin).lt.tiny).or.                       &
     &          (dabs(ybmax-ybmin).lt.tiny)) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            else
              xy_plane = .true.
              found = .true.
            end if
          end if

          if (.not.found) then                     !xz_plane
            if (dabs(ybmax-ybmin).lt.tiny) then
              if ((dabs(xbmax-xbmin).lt.tiny).or.                     &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                xz_plane = .true.
                if (xy_plane) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                          &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

          if (.not.found) then                     !yz_plane
            if (dabs(xbmax-xbmin).lt.tiny) then
              if ((dabs(ybmax-ybmin).lt.tiny).or.                     &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                yz_plane = .true.
                if (xy_plane.or.xz_plane) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                          &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

!c  exit if boundary face was not found

          if (.not.found) then
#ifdef USG
            if(cell_projection /= projection_xyz) then
#endif
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "',section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
#ifdef USG
            end if
#endif
          end if

          !c define flux direction for unstructured grid
#ifdef USG
          if (discretization_type > 0 .and. type_flux_direction == 0) then
            if (xy_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,0.0d0,1.0d0)
            else if (yz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(1.0d0,0.0d0,0.0d0)
            else if (xz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,1.0d0,0.0d0)
            end if
          end if
#endif

        end if                    !(btypezn.eq.'mixed' .or. btypezn.eq.'mixed-evap')

!c  increment boundary coordinates
        flag_invalid = .false.
        xbmin = xbmin-tiny
        xbmax = xbmax+tiny
        ybmin = ybmin-tiny
        ybmax = ybmax+tiny
        zbmin = zbmin-tiny
        zbmax = zbmax+tiny

        do ivol = 1,nngl         !loop over control volumes

!c  check limits of boundary zone

          if (((type_extent_zone==0.or.type_extent_zone_box>0) .and.   &
              (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.        &
              (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.        &
              (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.        &
              (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
              ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
            if (discretization_type > 0 .and. type_extent_zone_box > 0) then
              if ((btest(type_extent_zone_box,1) .and.                 &
                   .not. is_boundary_node(ivol)) .or.                  &
                  (btest(type_extent_zone_box,2) .and.                 &
                   is_boundary_node(ivol))) then
                cycle
              end if
            end if
#endif

            ibrt = ibrt+1

            if(ibrt > nngl) then   
              flag_invalid = .true.           
              write(*,*) 'Error in setting boundary conditions'
              write(*,*) 'Check duplicated boundary volumes.'
            end if

!c  assign pointer arrays and and boundary type

            jabrt(ibrt) = ivol

#ifdef USG
            if (discretization_type > 0) then
              ia_permbrt_usg(ibrt) = nbrt_usg+1
            end if
#endif

            btypert(ivol) = btypezn

            b_fluxd_bcond(ivol) = b_fluxd_bcond_zn

            if (btypert(ivol).eq.'mixed' .or.                          &
                btypert(ivol).eq.'mixed-evap' .or.                     &
                (btypezn.eq.'third'.and.b_fluxd_bcond_zn) .or.         &
                (btypezn.eq.'third-evap'.and.b_fluxd_bcond_zn)) then

!c  calculate boundary influence coefficient for diffusive mass
!c  fluxes across boundary

              if (discretization_type == 0) then

                if (xy_plane) then
                  bdycrt_d(ibrt) = r2 * dimcv(1,ivol)               &
                                 * dimcv(2,ivol) / dimcv(3,ivol)
                  permbrt(ibrt)     = permz(ivol)
                  cinfvs_gbrt(ibrt) = permbrt(ibrt)                 &
                                    * dimcv(1,ivol) * dimcv(2,ivol) &
                                    / dimcv(3,ivol) ! * r2

                  dijbrt(ibrt)      = dimcv(3,ivol) ! / r2 

                  diff_brt_dim(ibrt) = 3
                elseif (xz_plane) then
                  bdycrt_d(ibrt) = r2 * dimcv(1,ivol)               &
                                 * dimcv(3,ivol) / dimcv(2,ivol)
                  permbrt(ibrt)     = permy(ivol)
                  cinfvs_gbrt(ibrt) = permbrt(ibrt)                 &
                                    * dimcv(1,ivol) * dimcv(3,ivol) &
                                    / dimcv(2,ivol) ! * r2

                  dijbrt(ibrt)      = dimcv(2,ivol) ! / r2

                  diff_brt_dim(ibrt) = 2
                elseif (yz_plane) then
                  bdycrt_d(ibrt) = r2 * dimcv(2,ivol)               &
                                 * dimcv(3,ivol) / dimcv(1,ivol)
                  permbrt(ibrt)     = permx(ivol)
                  cinfvs_gbrt(ibrt) = permbrt(ibrt)                 &
                                    * dimcv(2,ivol) * dimcv(3,ivol) &
                                    / dimcv(1,ivol) ! * r2

                  dijbrt(ibrt)      = dimcv(1,ivol) ! / r2

                  diff_brt_dim(ibrt) = 1
                end if

                if (abs(zg(ivol)-zbmax).lt.small) then
                  zgbrt(ibrt) = zg(ivol) + dimcv(3,ivol) ! / r2
                else
                  zgbrt(ibrt) = zg(ivol) - dimcv(3,ivol) ! / r2
                endif
#ifdef USG
              else

                if (cell_type == cell_type_tri .or.                    &
                    cell_type == cell_type_quad) then
                  !c connected boundary control volume
                  !c currently the boundary flow direction is considered perpendicular to the surface
                  if (is_boundary_node(ivol)) then

                    jtemp1 = iavs(ivol)+1
                    jtemp2 = iavs(ivol+1)-1
                    jvol1 = javs(jtemp1)
                    jvol2 = javs(jtemp2)

                    areaf = geometry_veclength(nodes(ivol)-            &
                            nodes(jvol1),flux_direction,               &
                            type_flux_direction)*0.5
                    areaf = areaf+geometry_veclength(nodes(ivol)-      &
                            nodes(jvol2),flux_direction,               &
                            type_flux_direction)*0.5

                    if (is_cell_based_perm_cond) then
                      do icell = 1, janumcell(jtemp1)
                        if (jacell(icell,jtemp1) > 0) then
                          icell2 = jacell(icell,jtemp1)
                          nbrt_usg = nbrt_usg + 1
                          permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                            permx(icell2),permy(icell2),permz(icell2))) .dot.  &
                            (geometry_normal(nodes(ivol),nodes(jvol1),         &
                             cell_projection,.true.)))
                        end if
                      end do

                      do icell = 1, janumcell(jtemp2)
                        if (jacell(icell,jtemp2) > 0) then
                          icell2 = jacell(icell,jtemp2)
                          nbrt_usg = nbrt_usg + 1
                          permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                            permx(icell2),permy(icell2),permz(icell2))) .dot.  &
                            (geometry_normal(nodes(ivol),nodes(jvol1),         &
                             cell_projection,.true.)))
                        end if
                      end do
                      ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                    else
                      nbrt_usg = nbrt_usg + 1
                      permbrt_usg(nbrt_usg) = abs((math_common_set_vector(      &
                                   (permx(ivol)+permx(jvol1))*0.5d0,            &
                                   (permy(ivol)+permy(jvol1))*0.5d0,            &
                                   (permz(ivol)+permz(jvol1))*0.5d0)) .dot.     &
                                   (geometry_normal(nodes(ivol),nodes(jvol1),   &
                                    cell_projection,.true.)))

                      nbrt_usg = nbrt_usg + 1
                      permbrt_usg(nbrt_usg) = abs((math_common_set_vector(      &
                                   (permx(ivol)+permx(jvol2))*0.5d0,            &
                                   (permy(ivol)+permy(jvol2))*0.5d0,            &
                                   (permz(ivol)+permz(jvol2))*0.5d0)) .dot.     &
                                   (geometry_normal(nodes(ivol),nodes(jvol2),   &
                                    cell_projection,.true.)))

                      ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                    end if

                  else
                    areaf = 0.0d0
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        if (icell2 > 0) then
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)

                            if (is_cell_based_perm_cond) then
                              nbrt_usg = nbrt_usg + 1
                              permbrt_usg(nbrt_usg) = abs((math_common_set_vector(  &
                                 permx(icell2),permy(icell2),permz(icell2))) .dot.  &
                                 (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                              ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                            else
                              nbrt_usg = nbrt_usg + 1
                              permbrt_usg(nbrt_usg) = abs((math_common_set_vector(  &
                                      (permx(ivol)+permx(jvol))*0.5d0,              &
                                      (permy(ivol)+permy(jvol))*0.5d0,              &
                                      (permz(ivol)+permz(jvol))*0.5d0)) .dot.       &
                                      (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                              ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                            end if
                          end do
                        end if
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_tetra) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(     &
                               permx(cindex),permy(cindex),permz(cindex))) .dot.     &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(       &
                               (permx(jvol1)+permx(jvol2)+permx(jvol3))/3.0d0,         &
                               (permy(jvol1)+permy(jvol2)+permy(jvol3))/3.0d0,         &
                               (permz(jvol1)+permz(jvol2)+permz(jvol3))/3.0d0)) .dot.  &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if

                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                               permx(icell2),permy(icell2),permz(icell2))) .dot. &
                               (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            jvol1 = cells(1,cindex)
                            jvol2 = cells(2,cindex)
                            jvol3 = cells(3,cindex)
                            jvol4 = cells(4,cindex)

                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                               (permx(jvol1)+permx(jvol2)+                       &
                                permx(jvol3)+permx(jvol4))/4.0d0,                &
                               (permy(jvol1)+permy(jvol2)+                       &
                                permy(jvol3)+permy(jvol4))/4.0d0,                &
                               (permz(jvol1)+permz(jvol2)+                       &
                                permz(jvol3)+permz(jvol4))/4.0d0)) .dot.         &
                               (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_hexa) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                               permx(cindex),permy(cindex),permz(cindex))) .dot. &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                               (permx(jvol1)+permx(jvol2)+                       &
                                permx(jvol3)+permx(jvol4))/4.0d0,                &
                               (permy(jvol1)+permy(jvol2)+                       &
                                permy(jvol3)+permy(jvol4))/4.0d0,                &
                               (permz(jvol1)+permz(jvol2)+                       &
                                permz(jvol3)+permz(jvol4))/4.0d0)) .dot.         &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if

                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(  &
                               permx(icell2),permy(icell2),permz(icell2))) .dot.  &
                               (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            jvol1 = cells(1,cindex)
                            jvol2 = cells(2,cindex)
                            jvol3 = cells(3,cindex)
                            jvol4 = cells(4,cindex)
                            jvol5 = cells(5,cindex)
                            jvol6 = cells(6,cindex)
                            jvol7 = cells(7,cindex)
                            jvol8 = cells(8,cindex)

                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                               (permx(jvol1)+permx(jvol2)+                       &
                                permx(jvol3)+permx(jvol4)+                       &
                                permx(jvol5)+permx(jvol6)+                       &
                                permx(jvol7)+permx(jvol8))/8.0d0,                &
                               (permy(jvol1)+permy(jvol2)+                       &
                                permy(jvol3)+permy(jvol4)+                       &
                                permy(jvol5)+permy(jvol6)+                       &
                                permy(jvol7)+permy(jvol8))/8.0d0,                &
                               (permz(jvol1)+permz(jvol2)+                       &
                                permz(jvol3)+permz(jvol4)+                       &
                                permz(jvol5)+permz(jvol6)+                       &
                                permz(jvol7)+permz(jvol8))/8.0d0)) .dot.         &
                               (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_prism) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1, 2                              !number of faces, top and bottom faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(     &
                               permx(cindex),permy(cindex),permz(cindex))) .dot.     &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(     &
                               (permx(jvol1)+permx(jvol2)+permx(jvol3))/3.0d0,       &
                               (permy(jvol1)+permy(jvol2)+permy(jvol3))/3.0d0,       &
                               (permz(jvol1)+permz(jvol2)+permz(jvol3))/3.0d0)) .dot.&
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if

                        end if
                      end do

                      do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_prism(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(  &
                               permx(cindex),permy(cindex),permz(cindex))) .dot.  &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(  &
                               (permx(jvol1)+permx(jvol2)+                        &
                                permx(jvol3)+permx(jvol4))/4.0d0,                 &
                               (permy(jvol1)+permy(jvol2)+                        &
                                permy(jvol3)+permy(jvol4))/4.0d0,                 &
                               (permz(jvol1)+permz(jvol2)+                        &
                                permz(jvol3)+permz(jvol4))/4.0d0)) .dot.          &
                               (math_common_vector_unit(CellFaceScaledNorm(iface,cindex))))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if

                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)

                          if (is_cell_based_perm_cond) then
                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector(  &
                               permx(icell2),permy(icell2),permz(icell2))) .dot.  &
                               (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          else
                            jvol1 = cells(1,cindex)
                            jvol2 = cells(2,cindex)
                            jvol3 = cells(3,cindex)
                            jvol4 = cells(4,cindex)
                            jvol5 = cells(5,cindex)
                            jvol6 = cells(6,cindex)

                            nbrt_usg = nbrt_usg + 1
                            permbrt_usg(nbrt_usg) = abs((math_common_set_vector( &
                               (permx(jvol1)+permx(jvol2)+                       &
                                permx(jvol3)+permx(jvol4)+                       &
                                permx(jvol5)+permx(jvol6))/6.0d0,                &
                               (permy(jvol1)+permy(jvol2)+                       &
                                permy(jvol3)+permy(jvol4)+                       &
                                permy(jvol5)+permy(jvol6))/6.0d0,                &
                               (permz(jvol1)+permz(jvol2)+                       &
                                permz(jvol3)+permz(jvol4)+                       &
                                permz(jvol5)+permz(jvol6))/6.0d0)) .dot.         &
                               (CellCvolFaceUnitNorm(idvol_r,iedge_r,icell2)))
                            ia_permbrt_usg(ibrt+1) = nbrt_usg+1
                          end if

                        end do
                      end do
                    end do
                  end if

                else
                  flag_invalid = .true.
                  write(*,'(2a,i2)') 'boundary surface area calculation ',  &
                        'does not support cell_type initbcvs',cell_type
                end if

                istart = ia_permbrt_usg(ibrt)
                iend = ia_permbrt_usg(ibrt+1)-1
                permbrt(ibrt) = sum(permbrt_usg(istart:iend))/(iend-istart+1)

                bdycrt_d(ibrt) = r2*areaf
                cinfvs_gbrt(ibrt) = permbrt(ibrt)*areaf
                dijbrt(ibrt) = r1 ! / r2

                ! why???? DSU, 2017-05-17
                !if (abs(zg(ivol)-zbmax).lt.small) then
                !  zgbrt(ibrt) = zg(ivol) + dimcv(3,ivol) ! / r2
                !else
                !  zgbrt(ibrt) = zg(ivol) - dimcv(3,ivol) ! / r2
                !endif
                zgbrt(ibrt) = zg(ivol) + small
#endif
              end if

            end if

          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes

        flag_stop = flag_invalid

#ifdef PETSC        
        call MPI_Allreduce(flag_invalid, flag_stop, 1, MPI_LOGICAL,      &
                           MPI_LOR,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
#endif

        if(flag_stop) then
          if(rank == 0) then
            write(*,'(a)') "Error: boundary conditions cannot be specified "
            write(ilog,'(a)') "Error: boundary conditions cannot be specified "
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if

!c  define pointer to next boundary zone

        iabrt(ibz+1) = ibrt+1

!c  write extent and type of boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/2a)') 'extent of ',zone_name(:l_zone_name)
          write(igen,'(72a/)')('-',i=1,72)
          write(igen,'(2x,a,3x,a/)') 'volume','boundary type'
        end if

        ibrt_start = iabrt(ibz)
        ibrt_stop = iabrt(ibz+1)-1

        if (b_enable_output .and. b_enable_output_gen) then
          do ibrt = ibrt_start,ibrt_stop
            ivol = jabrt(ibrt)
#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
#endif
              write(igen,'(i8,3x,a16)') ivol,btypert(ivol)
#ifdef PETSC
            end if
#endif
          end do
        end if

!c  assign boundary conditions to global system

        do ibrt = ibrt_start,ibrt_stop              !boundary zone

          ivol = jabrt(ibrt)    

!c  first type boundary condition (specified source concentrations 
!c  in terms of free species concentrations)

          if (btypert(ivol).eq.'first'.and.spec_conc) then

            do ic=1,nc
              bcondrt_a(ic,ibrt) = ccnew(ic)
            end do
            call icbcrt(ivol,1,tid,.true.)

            if (density_dependence) then
              tot_tds = r0
              do ic=1,nc-1
                itemp = ncorder(ic)                 !internal order
                tds_ic = bcondrt_a(ic,ibrt) * gfwc(itemp) ! M/L --> g/L = Kg/M^3
                tot_tds = tot_tds + tds_ic
              end do
                !cprovi------------------------------------------------       
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
              if (ispitzerdens) then
               !cprovi------------------------------------------------
               !cprovi Allocate local pointers
               !cprovi------------------------------------------------
               !cprovi------------------------------------------------
               !cprovi Copy the molalities in the local vector
               !cprovi------------------------------------------------
                 cpz_loc(1:nc)=ccnew(1:nc)
                 cpz_loc(nc+1:nc+nx)=cxc(1:nx)
                 call compute_density_ (phase,0.0d0,0.0d0,cpz_loc,       &
                                        ssdens(ivol),.false.,iserror)
                 if (iserror) then
                   msg='Error when call compute_density_ in the phase object'
                   goto 10
                 end if
               else
                 ssdens(ivol) = ref_dens + drho_dc * tot_tds
               end if
            
              continue
            end if

!c  first type boundary condition (background concentrations in terms
!c  of free species concentrations)

          elseif (btypert(ivol).eq.'first'.and.(.not.spec_conc)) then

            do ic = 1,nc
              bcondrt_a(ic,ibrt) = cnew(ic,ivol)
            end do

!c  assign boundary condition for density dependent flow
            if (density_dependence) then
              tot_tds = r0
              do ic=1,nc-1
              itemp = ncorder(ic)                 !internal order
              tds_ic = bcondrt_a(ic,ibrt) * gfwc(itemp) ! M/L --> g/L = Kg/M^3
                tot_tds = tot_tds + tds_ic
              end do
                !cprovi------------------------------------------------       
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
               if (ispitzerdens) then                   
                !cprovi------------------------------------------------
                !cprovi Copy the molalities in the local vector 
                !cprovi------------------------------------------------
                   cpz_loc(1:nc)=cnew(1:nc,ivol)
                   cpz_loc(nc+1:nc+nx)=cx(1:nx,ivol)  
                 call compute_density_ (phase,0.0d0,0.0d0,cpz_loc,      &
                                      ssdens(ivol),.false.,iserror)
                 if (iserror) then 
                 msg='Error when call compute_density_ in the phase object'
                 goto 10 
                 end if
              else
                 ssdens(ivol) = ref_dens + drho_dc * tot_tds
              end if
            
           end if

!c  third type boundary condition (specified source concentrations 
!c  in terms of total aqueous component concentrations)

          elseif ((btypert(ivol).eq.'third') .or.     &
     &      (btypert(ivol).eq.'third-evap') .or.      &
     &      (btypezn.eq.'point')) then

!c  compute total aqueous component concentrations

            call totconc(ccnew,cxc,totcn(:,tid))

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil_rt.and.nr.gt.0) then
              call comptotc(totcn(:,tid))
            end if

!c  assign boundary condition for density dependent flow
            if (density_dependence) then
              tot_tds = r0
              do ic=1,nc-1
                bcondrt_a(ic,ibrt) = totcn(ic,tid)   !total aqueous component
                itemp = ncorder(ic)                 !internal order
                tds_ic = bcondrt_a(ic,ibrt) * gfwc(itemp) ! M/L --> g/L = Kg/M^3
                tot_tds = tot_tds + tds_ic
              end do
                !cprovi------------------------------------------------       
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
              if (ispitzerdens) then
                !cprovi------------------------------------------------
                !cprovi Copy the molalities in the local vector 
                !cprovi------------------------------------------------
                cpz_loc(1:nc)=ccnew(1:nc)
                cpz_loc(nc+1:nc+nx)=cxc(1:nx)
                call compute_density_ (phase,0.0d0,0.0d0,cpz_loc,        &
                                        ssdens(ivol),.false.,iserror) 
                if (iserror) then
                  msg='Error when call compute_density_ in the phase object'
                  goto 10
                end if
              else
                ssdens(ivol) = ref_dens + drho_dc * tot_tds
              end if 
            
            else
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi I was added by Sergio Andres Bea Jofre
!cprovi----------------------------------------------------------------               
              do ic=1,nc-1
                bcondrt_a(ic,ibrt) = totcn(ic,tid)   !total aqueous component
              end do
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------            
            end if
           
!cdsu------------------------------------------------------------------
!cdsu  Sync data for other slave threads
!cdsu------------------------------------------------------------------
            do itid = 1, nthreads
              totcn(:,itid) = totcn(:,tid)
            end do

!c  mixed type boundary condition (specified source concentrations 
!c  in terms of total aqueous component concentrations and total
!c  gaseous component concentrations, also assign gas concentrations
!c  for mass balance calculations)

          elseif (btypert(ivol).eq.'mixed' .or. btypert(ivol).eq.'mixed-evap') then

!c  compute total aqueous component concentrations

            call totconc(ccnew,cxc,totcn(:,tid))

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil_rt.and.nr.gt.0) then
              call comptotc(totcn(:,tid))
            end if

!c  assign boundary condition

            do ic=1,nc-1
              bcondrt_a(ic,ibrt) = totcn(ic,tid)   !total aqueous component
            end do                             !concentrations

            if (ng.gt.0) then

!cprovi-----------------------------------------------------------------
!cprovi If the boundary condition is type 'mixed', it is possible 
!cprovi to read the gas pressures
!cprovi Note that not necessary this partial pressure should be 
!cprovi in equilibrium with the boundary solution 
!cprovi-----------------------------------------------------------------
              subsection = 'partial gas pressure'
              call findstrg(subsection,icnv,found_subsection)
              if (found_subsection) then
                do ig=1,ng
                  ierrcd = 11
                  read(icnv,*,err=999,end=999) cgc(ig)
                  cgc(ig)=cgc(ig)/(rgasatm*tempks)
                end do
              else
                subsection = 'partial gas pressure (pa)'
                call findstrg(subsection,icnv,found_subsection)
                if (found_subsection) then
                  do ig=1,ng
                    ierrcd = 12
                    read(icnv,*,err=999,end=999) cgc(ig)
                    cgc(ig)=cgc(ig)/(rgasjoule*tempks)
                  end do
                end if 
              end if
!c  compute total gaseous component concentrations

              call totconcg(cgc,totgn(:,tid))

!c  compress total gaseous component concentration vector in case
!c  of redox equilibrium reactions

              if (redox_equil_rt.and.nr.gt.0) then
                call comptotc(totgn(:,tid))
              end if

!c  assign boundary condition

              do ic=1,nc-1
                bcondrt_g(ic,ibrt) = totgn(ic,tid) !total gaseous component
              end do                               !concentrations
              do ig = 1,ng
                gbrt(ig,ibrt) = cgc(ig)        !gas concentrations
              end do
            end if
            
!cdsu------------------------------------------------------------------
!cdsu  Sync data for other slave threads
!cdsu------------------------------------------------------------------
           do itid = 1, nthreads
             totcn(:,itid) = totcn(:,tid)
             totgn(:,itid) = totgn(:,tid)
           end do

          end if                               !boundary type

        end do                                 !boundary zone

      end do                                   !number of zones
      
!---------------------------------------------------------------------------------     
!---------------------------------------------------------------------------------      
!---------------------------------------------------------------------------------      
      if (compute_ice_sheet_loading) then

        if (ice_sheet_type == 0) then
          nbzice = 1
        end if

        do ibz_ice = 1, nbzice

          if (ice_sheet_type == 0) then
            flag_istotbc = ice_sheet%istotbc
          else if (ice_sheet_type == 1) then
#ifdef USG        
            flag_istotbc = ice_istotbc(ibz_ice)
#endif
          end if


          !c do not move this line together with the previous line, if ice loading is not enabled, ice_sheet is a null object
          !c code compiled in release version probably crashes due to this null object reference. DSU, 2018-09-10.
          if (flag_istotbc) then
            if (ice_sheet_type == 0) then
              call get_components_(ice_sheet,totco(:,tid),ctype,nc-1,iserror)
              if (iserror) then
                msg='Error when call get_components_ => ice_sheet'  
                goto 10
              end if
            else if (ice_sheet_type == 1) then
#ifdef USG
              call usg_ice_get_components(ibz_ice,nc-1,totco(:,tid),ctype,iserror)
#endif
            end if
            do ic=1,nc-1  
              itemp = ncorder(ic)
              if (ctype(itemp).ne.'ph'.and.     &
                  ctype(itemp).ne.'eh'.and.     &
                  ctype(itemp).ne.'pe'.and.     &
                  ctype(itemp).ne.'po2'.and.    &
                  ctype(itemp).ne.'pn2'.and.    &
                  ctype(itemp).ne.'pch4'.and.   &
                  ctype(itemp).ne.'ph2'.and.    &
                  ctype(itemp).ne.'pco2x'.and.  &
                  ctype(itemp).ne.'par'.and.    &
                  ctype(itemp).ne.'pco2') then
                if (input_units.eq.'mmol/l') then
                  totco(itemp,tid) = totco(itemp,tid) / r1000
                elseif (input_units.eq.'mg/l') then
                  totco(itemp,tid) = totco(itemp,tid) / r1000 / gfwc(itemp)
                elseif (input_units.eq.'g/l') then
                  totco(itemp,tid) = totco(itemp,tid) / gfwc(itemp)
                end if
          
!cdsu------------------------------------------------------------------
!cdsu  Sync data for other slave threads
!cdsu------------------------------------------------------------------
                do itid = 1, nthreads
                  totco(itemp,itid) = totco(itemp,tid)
                end do
          
              end if
            end do
            
            phguess=7.0d0
            call guess(ccnew,ccold,tempk,ilog,tid)
            call setsize(redox_equil_lc)

!c  retrieve physical parameters for scaling
            call rtrvpprm(sac,sgc,porc,r1,section_header)

!c  temperature correction
            if (temp_corr.or.heat_transport) then
              do itid = 1, nthreads
                call tcorr(tempk,0,itid)
              end do
            end if

!c  compute concentration distribution at boundary
            call gcreact(ccnew,ccold,cxc,gamma_l(1),gamma_l(nc+1),         &
                         cgc,sac,sgc,porc,igen,ilog,tid,idbg,tec_header,   &
                         prefix,l_prfx,zone_name,l_zone_name,              &
                         mtime,i_append_sim,mtime_append)
            call minmaxwd(cxc,totcn(:,tid))
            ctype='free' 

!c  compute total aqueous component concentrations
            call totconc(ccnew,cxc,totcn(:,tid))  
          
!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions
            if (redox_equil_rt.and.nr.gt.0) then
              call comptotc(totcn(:,tid))
            end if

            if (ice_sheet_type == 0) then
              call set_components_ (ice_sheet,totcn(:,tid),ctype,nc-1,iserror)
              if (iserror) then
                msg='Error when call set_components_ => ice_sheet'  
                goto 10
              end if
            else if (ice_sheet_type == 1) then
#ifdef USG
              call usg_ice_set_components(ibz_ice,nc-1,totcn(:,tid),ctype,iserror)
#endif
            end if
          
            section_header='ice sheet chemical composition'
            if(b_enable_output .and. b_enable_output_gen)  then
              write(igen,*)'-----------------------------------------------'
              write(igen,*) section_header
              write(igen,*)'-----------------------------------------------'
              call outputlc(ccnew,cxc,gamma_l(1),gamma_l(nc+1),            &
                            cgc,igen,ilog,tid,section_header)
              write(igen,*)'-----------------------------------------------'
            end if
          end if
        end do
      end if

!c  define absolute number of boundary control volumes

      nbrt = iabrt(nbzrt+1)-1

!c  minimize memory requirement for boundary arrays

!c  array bcondrt_a

      allocate (rwork(nc,nbrt), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcrt-rwork',.true.)

      do ibrt = 1,nbrt
        do ic = 1,nc
          rwork(ic,ibrt) = bcondrt_a(ic,ibrt)
        end do
      end do

      call memory_monitor(-sizeof(bcondrt_a),'bcondrt_a',.true.)
      deallocate (bcondrt_a, stat = ierr)
      call checkerr(ierr,'bcondrt_a',ilog)

      allocate (bcondrt_a(nc,nbrt), stat = ierr)
      call checkerr(ierr,'bcondrt_a',ilog)
      call memory_monitor(sizeof(bcondrt_a),'bcondrt_a',.true.)

      do ibrt = 1,nbrt
        do ic = 1,nc
          bcondrt_a(ic,ibrt) = rwork(ic,ibrt)
        end do
      end do

      call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array bcondrt_g

      allocate (rwork(nc,nbrt), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcrt-rwork',.true.)

      do ibrt = 1,nbrt
        do ic = 1,nc
          rwork(ic,ibrt) = bcondrt_g(ic,ibrt)
        end do
      end do

      call memory_monitor(-sizeof(bcondrt_g),'bcondrt_g',.true.)
      deallocate (bcondrt_g, stat = ierr)
      call checkerr(ierr,'bcondrt_g',ilog)

      allocate (bcondrt_g(nc,nbrt), stat = ierr)
      call checkerr(ierr,'bcondrt_g',ilog)
      call memory_monitor(sizeof(bcondrt_g),'bcondrt_g',.true.)

      do ibrt = 1,nbrt
        do ic = 1,nc
          bcondrt_g(ic,ibrt) = rwork(ic,ibrt)
        end do
      end do

      call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array gbrt

      allocate (rwork(ng,nbrt), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcrt-rwork',.true.)

      do ibrt = 1,nbrt
        do ig = 1,ng
          rwork(ig,ibrt) = gbrt(ig,ibrt)
        end do
      end do

      call memory_monitor(-sizeof(gbrt),'gbrt',.true.)
      deallocate (gbrt, stat = ierr)
      call checkerr(ierr,'gbrt',ilog)

      allocate (gbrt(ng,nbrt), stat = ierr)
      call checkerr(ierr,'gbrt',ilog)
      call memory_monitor(sizeof(gbrt),'gbrt',.true.)

      do ibrt = 1,nbrt
        do ig = 1,ng
          gbrt(ig,ibrt) = rwork(ig,ibrt)
        end do
      end do

      call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array bdycrt_d

      allocate (rwork(nbrt,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcrt-rwork',.true.)

      do ibrt = 1,nbrt
        rwork(ibrt,1) = bdycrt_d(ibrt)
      end do

      call memory_monitor(-sizeof(bdycrt_d),'bdycrt_d',.true.)
      deallocate (bdycrt_d, stat = ierr)
      call checkerr(ierr,'bdycrt_d',ilog)

      allocate (bdycrt_d(nbrt), stat = ierr)
      call checkerr(ierr,'bdycrt_d',ilog)
      call memory_monitor(sizeof(bdycrt_d),'bdycrt_d',.true.)

      do ibrt = 1,nbrt
        bdycrt_d(ibrt) = rwork(ibrt,1)
      end do

      call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array jabrt

      allocate (iwork(nbrt), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initbcrt-iwork',.true.)

      do ibrt = 1,nbrt
        iwork(ibrt) = jabrt(ibrt)
      end do

      call memory_monitor(-sizeof(jabrt),'jabrt',.true.)
      deallocate (jabrt, stat = ierr)
      call checkerr(ierr,'jabrt',ilog)

      allocate (jabrt(nbrt), stat = ierr)
      call checkerr(ierr,'jabrt',ilog)
      call memory_monitor(sizeof(jabrt),'jabrt',.true.)

      do ibrt = 1,nbrt
        jabrt(ibrt) = iwork(ibrt)
      end do

      !c check if the boundary condition is duplicated, reserve the last one only as
      !c the previous ones are overwritten
      do ibrt = 1,nbrt
        do i = nbrt, ibrt + 1, -1
          if (jabrt(i) == jabrt(ibrt)) then
            jabrt(ibrt) = -jabrt(ibrt)
            exit
          end if
        end do
      end do

!c  array diff_brt_dim
      do ibrt = 1,nbrt
        iwork(ibrt) = diff_brt_dim(ibrt)
      end do

      call memory_monitor(-sizeof(diff_brt_dim),'diff_brt_dim',.true.)
      deallocate (diff_brt_dim, stat = ierr)
      call checkerr(ierr,'diff_brt_dim',ilog)

      allocate (diff_brt_dim(nbrt), stat = ierr)
      call checkerr(ierr,'diff_brt_dim',ilog)
      call memory_monitor(sizeof(diff_brt_dim),'diff_brt_dim',.true.)

      do ibrt = 1,nbrt
        diff_brt_dim(ibrt) = iwork(ibrt)
      end do

      call memory_monitor(-sizeof(iwork),'initbcrt-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      
!c  array permbrt

      allocate (rwork(nbrt,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcrt-rwork',.true.)

      do ibrt = 1,nbrt
        rwork(ibrt,1) = permbrt(ibrt)
      end do

      call memory_monitor(-sizeof(permbrt),'permbrt',.true.)
      deallocate (permbrt, stat = ierr)
      call checkerr(ierr,'permbrt',ilog)

      allocate (permbrt(nbrt), stat = ierr)
      call checkerr(ierr,'permbrt',ilog)
      call memory_monitor(sizeof(permbrt),'permbrt',.true.)

      do ibrt = 1,nbrt
        permbrt(ibrt) = rwork(ibrt,1)
      end do

!c  array dijbrt
      do ibrt = 1,nbrt
        rwork(ibrt,1) = dijbrt(ibrt)
      end do

      call memory_monitor(-sizeof(dijbrt),'dijbrt',.true.)
      deallocate (dijbrt, stat = ierr)
      call checkerr(ierr,'dijbrt',ilog)

      allocate (dijbrt(nbrt), stat = ierr)
      call checkerr(ierr,'dijbrt',ilog)
      call memory_monitor(sizeof(dijbrt),'dijbrt',.true.)

      do ibrt = 1,nbrt
        dijbrt(ibrt) = rwork(ibrt,1)
      end do

      call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c array permbrt_usg
#ifdef USG
      if (discretization_type > 0) then

        if (nbrt_usg > 0) then
          allocate (rwork(nbrt_usg,1), stat = ierr)
          call checkerr(ierr,'rwork',ilog)
          call memory_monitor(sizeof(rwork),'initbcrt-rwork',.false.)
          
          do ibrt = 1,nbrt_usg
            rwork(ibrt,1) = permbrt_usg(ibrt)
          end do
          
          call memory_monitor(-sizeof(permbrt_usg),'permbrt_usg',.false.)
          deallocate (permbrt_usg, stat = ierr)
          call checkerr(ierr,'permbrt_usg',ilog)
          
          allocate (permbrt_usg(nbrt_usg), stat = ierr)
          call checkerr(ierr,'permbrt_usg',ilog)
          call memory_monitor(sizeof(permbrt_usg),'permbrt_usg',.false.)
          
          do ibrt = 1,nbrt_usg
            permbrt_usg(ibrt) = rwork(ibrt,1)
          end do
          
          call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.false.)
          deallocate (rwork, stat = ierr)
          call checkerr(ierr,'rwork',ilog)
        end if

!c  array ia_permbrt_usg

        allocate (iwork(nbrt+1), stat = ierr)
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'initbcrt-iwork',.true.)

        do ibrt = 1,nbrt+1
          iwork(ibrt) = ia_permbrt_usg(ibrt)
        end do

        call memory_monitor(-sizeof(ia_permbrt_usg),'ia_permbrt_usg',.true.)
        deallocate (ia_permbrt_usg, stat = ierr)
        call checkerr(ierr,'ia_permbrt_usg',ilog)

        allocate (ia_permbrt_usg(nbrt+1), stat = ierr)
        call checkerr(ierr,'ia_permbrt_usg',ilog)
        call memory_monitor(sizeof(ia_permbrt_usg),'ia_permbrt_usg',.true.)

        do ibrt = 1,nbrt+1
          ia_permbrt_usg(ibrt) = iwork(ibrt)
        end do

        call memory_monitor(-sizeof(iwork),'initbcrt-iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)

      end if
#endif

!c  array cinfvs_gbrt

      allocate (rwork(nbrt,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcrt-rwork',.true.)

      do ibrt = 1,nbrt
        rwork(ibrt,1) = cinfvs_gbrt(ibrt)
      end do

      call memory_monitor(-sizeof(cinfvs_gbrt),'cinfvs_gbrt',.true.)
      deallocate (cinfvs_gbrt, stat = ierr)
      call checkerr(ierr,'cinfvs_gbrt',ilog)

      allocate (cinfvs_gbrt(nbrt), stat = ierr)
      call checkerr(ierr,'cinfvs_gbrt',ilog)
      call memory_monitor(sizeof(cinfvs_gbrt),'cinfvs_gbrt',.true.)

      do ibrt = 1,nbrt
        cinfvs_gbrt(ibrt) = rwork(ibrt,1)
      end do

      call memory_monitor(-sizeof(rwork),'initbcrt-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      
!c  array iupsgbrt
      
      allocate (iupsgbrt(nbrt), stat = ierr)
      call checkerr(ierr,'iupsgbrt',ilog)
      call memory_monitor(sizeof(iupsgbrt),'iupsgbrt',.true.)

      do ibrt=1,nbrt
        iupsgbrt(ibrt)='a'
      enddo

!c  clear array ctype for transport calculations

      do ic = 1,nc-1
        ctype(ic) = 'free'
      end do

!c  determine if transient source chemistry is to be used

      subsection = 'update boundary conditions'

      call findstrg(subsection,itmp,found_subsection)

!c  read number of target times, target times and convert 
!c  time units of target times to internal time units [days]

      if (found_subsection) then

        transient_source = .true.
        ierrcd = 13
        read(itmp,*,err=999,end=999) ntsrc

        allocate (tsrc(ntsrc+1), stat = ierr)
        tsrc=0.0d0
        call checkerr(ierr,'tsrc',ilog)
        call memory_monitor(sizeof(tsrc),'tsrc',.true.)

        do itsrc = 1,ntsrc
          ierrcd = 14
          read(itmp,*,err=999,end=999) tsrc(itsrc)
          tsrc(itsrc) = time_factor * tsrc(itsrc)
        end do
        tsrc(ntsrc+1) = tfinal+tinytime_global

!c  define pointer to first target time for reading source chemistry

        itsrc = 1

      else

        transient_source = .false.

      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
10    continue 
      if (rank == 0) then
        write (ilog,*) msg
        write (iscreen,*) msg
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
      end
