!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcpgs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpgs
!c -------------------
!c
!c control parameters for global system
!c modified for optional density dependent flow simulation
!c
!c written by:      Uli Mayer - May 9, 96
!c
!c last modified:   Tom Henderson - August 21, 2002
!c
!c            Celine Blitz Frayret (CBF) for Frederic Gerard, December 14, 2018 
!c            Added root_uptake global control parameter      
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           l_time_unit        = length of time_unit for output      * +
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     * +
!c           geo_chemistry      = .true.  -> local or background and  * +
!c                                           source chemistry
!c           reactive_transport = .true.  -> perform reactive         * +
!c                                           transport simulation
!c           steady_flow        = .true.  -> steady state flow        * +
!c           transient_flow     = .true.  -> .not.steady_flow,        * +
!c                                        -> transient flow
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c           varsat_flow        = .true.  -> perform flow simulation  * +
!c         root_uptake        = .true.  -> calculate root water
!c                                           uptake  CBF
!c
!c           character:
!c           ----------
!c           problem_title      = problem title                       * +
!c           section_header     = section header                      * +
!c           drive              = drive of program installation       * +
!c           time_unit          = time unit for output -> 'years'     * +
!c                                                        'days'
!c                                                        'hours'
!c                                                'seconds'
!c dens.f:   logical:
!c           --------
!c           density_dependence = .true.  -> density-dependant flow 
!c
!c local:    integer*4:
!c           ----------
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c
!c external: readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpgs
 
      use parm
      use gen
      use dens
      use mip_bubble, only : mip_mt_enable
      use file_utility, only : replacecharacter
      use biol, only : pure_evap
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: i, l_string, ierrcd

      external readbloc
 
      real*8 :: mem_input
      logical found_section, found_subsection,iserror
      character*72 subsection, subkeyword

!c     set defaults
      ierrcd = 0
      drive = 'u'
      density_dependence = .false.

!c  read numerical data and write to temporary file   
   
      section_header = 'global control parameters'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to current output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  read global control parameters 

      root_uptake = .false.                           !DSU - This is an optional parameter, initialize with false if the value is not provided
      ierrcd = 1
      read(itmp,*,err=999,end=999) problem_title
      read(itmp,*,err=999,end=999) varsat_flow
      read(itmp,*,err=999,end=999) steady_flow
      read(itmp,*,err=999,end=999) fully_saturated
      read(itmp,*,err=999,end=999) reactive_transport
      read(itmp,*,err=998,end=999) root_uptake        !CBF - FG 07-2017 - fast trick to enable reading of trunk benchmarks
998   continue

      pure_evap = .false.
#ifdef ARCHISIMPLE
      if (.not. root_uptake) then
        subsection = 'pure evaporation'      
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          pure_evap = .true.
        end if
      end if
#endif
      
!c  chemical water
      subsection = 'chemical water'
      
      call findstrg(subsection,itmp,found_subsection)

      chemical_water = .false.
     
      if (found_subsection) then
        chemical_water = .true.
        if (steady_flow) then
          if (rank == 0) then  
            write(ilog,*) 'chemical water and steady flow: not compatible'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        endif
        
      end if
      
!c  number of time steps to skip for writing log file (and on screen)
      skip_time = 0   !initially none
      subsection = 'skipped time steps in log file'
         
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 2
        read(itmp,*,err=999,end=999) skip_time
      
        if (rank == 0 .and. b_enable_output) then
          write(*,*) 'skipped time steps in log file: ', skip_time
          write(ilog,*) 'skipped time steps in log file: ', skip_time
        end if

      end if                 !(found_section)

!c  type of redox reactions

      subsection = 'specify drive of program installation'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 3
        read(itmp,*,err=999,end=999) drive
      end if
      
!c  write version information to tecplot data file or not

      subsection = 'write version to tecplot data file'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
          b_writeversion_tecplot = .true.
      else
          b_writeversion_tecplot = .false.
      end if

!c  convert external data file to binary format.
!c  for large dataset, reading binary format is much faster 
!c  than ascii format line by line.
!c      export_ascii_binary = .false.
!c      subsection = 'export external data to binary format'
!c      call findstrg(subsection,itmp,found_subsection)
!c      if (found_subsection) then
!c        export_ascii_binary = .true.
!c      end if
      
!cprovi---------------------------------------------------
!cprovi Restart process
!cprovi Based on Richard Amos implementation 
!cprovi and Sergi Molins implementation 
!cprovi---------------------------------------------------
      restart_sim = .false.

      subsection = 'restart'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        restart_sim = .true.
        b_check_restart_time = .true.
        b_restart_update_bcvs = .true.
        b_restart_update_bcheat = .true.
        b_restart_update_bcice = .true. 
        b_restart_update_ice_scalfac = .true.
      else
        b_check_restart_time = .false.
        b_restart_update_bcvs = .false.
        b_restart_update_bcheat = .false.
        b_restart_update_bcice = .false.
        b_restart_update_ice_scalfac = .false.        
      end if
      
      !c Append results when simulation is restarted.
      !c This only works for ascii output. DSU - 2019-01-23
      !c set mtime_append to the maximum value of integer*4
      !c this is also the maximum record allowed in the existing transient output
      mtime_append = 2147483647
      i_append_sim = 0
      if (restart_sim) then
        subsection = 'append results'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          i_append_sim = 1
        end if

        subsection = 'append results in legacy mode'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          i_append_sim = 2
        end if

        subsection = 'append results after specified time steps'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          i_append_sim = 2
          ierrcd = 4
          read(itmp,*,err=999,end=999) mtime_append
          if (mtime_append < 1) then
            mtime_append = 1
          end if
        end if
      end if

     
#ifdef PETSC
      subsection = 'use distributed restart files to read'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        b_distributed_restart_read = .true.
      else
        b_distributed_restart_read = .false.
      end if
#else
      b_distributed_restart_read = .false.
#endif
      
#ifdef PETSC
      subsection = 'use distributed restart files to write'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        b_distributed_restart_write = .true.
      else
        b_distributed_restart_write = .false.
      end if
#else
      b_distributed_restart_write = .false.
#endif
      
      subsection = 'use binary restart file to read'
      call findstrg(subsection,itmp,found_subsection)
#ifdef PETSC
      if (found_subsection) then
        b_binary_restart_read = .true.
      else
#endif
        if (found_subsection) then
          if (rank == 0) then
            write(ilog,'(a)') 'Binary restart file reading is only available when built with MPI'
          end if
        end if
        b_binary_restart_read = .false.
#ifdef PETSC
      end if
#endif
      
      subsection = 'use binary restart file to write'
      call findstrg(subsection,itmp,found_subsection)
#ifdef PETSC
      if (found_subsection) then
        b_binary_restart_write = .true.
      else
#endif
        if (found_subsection) then
          if (rank == 0) then
            write(ilog,'(a)') 'Binary restart file writing is only available when built with MPI'
          end if
        end if
        b_binary_restart_write = .false.
#ifdef PETSC
      end if
#endif

!c  parallel reading method for initial condition, material properties and etc.
      subsection = 'read spatial data using master processor'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        read_spatial_master_proc = .true.
      else
        read_spatial_master_proc = .false.
      end if

      subsection = 'ignore restart time'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ignore_restart_time = .true.
      else
        ignore_restart_time = .false.
      end if

      subsection = 'backup frequency'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 5
        read(itmp,*,err=999,end=999) backup_frequency
      else
        backup_frequency = 100
      end if

!c  ascii output data format
      subsection = 'use double precision'  
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        ascii_fmt = '(1000(1pe25.17e3))'
        ascii_fmt_iir = '(2(i10,1x),1000(1pe25.17e3))'
      else
        ascii_fmt = '(1000(1pe15.6e3))'
        ascii_fmt_iir = '(2(i10,1x),1000(1pe15.6e3))'
      end if

!c  maximum memory avaiable for master node per CPU
      subsection = 'memory limitation per processor'  
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        ierrcd = 6
        read(itmp,*,err=999,end=999) mem_input, mem_unit
        if (mem_unit == 'MB') then
          !c default, do nothing
        else if (mem_unit == 'GB') then
          mem_input = mem_input*1.0d3
        else if (mem_unit == 'TB') then
          mem_input = mem_input*1.0d6
        else if (mem_unit == 'PB') then
          mem_input = mem_input*1.0d9
        else
          if (rank == 0) then
            write(*,*) 'Error in reading memory limitation per processor'
            write(ilog,*) 'Error in reading memory limitation per processor'
          end if
          ierrcd = 7
          goto 999
        end if
        mem_limit = int(mem_input)
      else
        mem_limit = 2**30    !maximum value of interger*4 is 2**31-1
      end if

 
!c  assign related global control parameters
 
      if ((varsat_flow).and.(reactive_transport)) then
        geo_chemistry = .true.
      elseif ((varsat_flow).and.(.not.reactive_transport)) then
        geo_chemistry = .false.
      elseif ((.not.varsat_flow).and.(reactive_transport)) then
        geo_chemistry = .true.
      elseif ((.not.varsat_flow).and.(.not.reactive_transport)) then
        geo_chemistry = .true.
      end if

      transient_flow = .not.steady_flow
      variably_saturated = .not.fully_saturated

      if (steady_flow.and.(.not.reactive_transport)) then
        time_unit = '-'
        l_time_unit = 1
      end if

! prc --------------------------------------------------------
! prc --------------------------------------------------------
! prc Multicomponenet Diffusion: finding the keyword in the 
! prc subsection and intializing the logical variable
! prc --------------------------------------------------------
! prc --------------------------------------------------------
      multi_diff = .false.
      hmulti_diff = .false.
      

      subsection = 'multicomponent diffusion'
      
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        multi_diff = .true.        
      else
        subsection = 'hybrid multicomponent diffusion'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          multi_diff = .true.
          hmulti_diff = .true.
        end if
      end if

!c  density dependant flow

      subsection = 'density dependent flow'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        density_dependence = .true.
      end if
    
    
!cprovi--------------------------------------------------------
!cprovi  Energy balance block 
!cprovi--------------------------------------------------------
      subsection = 'energy balance'
      heat_transport = .false. 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        if (density_dependence) then
          heat_transport = .true.
        else
          if (rank == 0 .and. b_enable_output) then
            write(ilog,'(a)') 'Warning: heat transport requires ',     &
                  'density dependent flow'
          end if
        end if
      end if
    
!cdsu  ----------------------------------------------------
!cdsu  coupling between flow and heat equations
!cdsu  here decouple means loosely coupling between flow
!cdsu  and heat equations, df(Pa)/dT = 0, df(T)/dPa = 0
!cdsu  ----------------------------------------------------
      decoupled_type_vs_heat = 0

      if (heat_transport) then
        !c old keywords
        subsection = 'semi-coupled flow and heat equations'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          decoupled_type_vs_heat = 1
        end if

        subsection = 'decoupled flow and heat equations'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          decoupled_type_vs_heat = 2
        end if

        !c new keywords
        subsection = 'type of coupling for flow and heat equations'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 8
          read(itmp,*,err=999,end=999) subkeyword
          if (trim(subkeyword) == 'coupled') then
            decoupled_type_vs_heat = 0
          else if (trim(subkeyword) == 'semi-coupled') then
            decoupled_type_vs_heat = 1
          else if (trim(subkeyword) == 'decoupled') then
            decoupled_type_vs_heat = 2
          end if
        end if   
      end if 
    
!cprovi---------------------------------------------------
!cprovi---------------------------------------------------
!cprovi---------------------------------------------------    
!cprovi---------------------------------------------------
!cprovi Compute Ice Sheet loading  
!cprovi---------------------------------------------------
      compute_ice_sheet_loading = .false.
      subsection = 'compute ice sheet loading/unloading'

      call findstrg(subsection,itmp,found_section)

      if (found_section) then
        if (density_dependence) then
          compute_ice_sheet_loading = .true.
        else
          if (rank == 0 .and. b_enable_output) then
            write(ilog,'(a)') 'Warning: ice sheet model requires ',    &
                  'density dependent flow'
          end if
        end if
      end if

!cdsu--------------------------------------------------------  
!cdsu   Macroscopic invasion percolation (MIP) bubble flow model
!cdsu--------------------------------------------------------
      mip_mt_enable = .false.
      subsection = 'mip bubble model'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        mip_mt_enable = .true.
      else
        subsection = 'invasion percolation bubble flow'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          mip_mt_enable = .true.
        end if
      end if
!cdsu--------------------------------------------------------  
!cdsu   Parallel solver configuration file
!cdsu--------------------------------------------------------
      if (.not. b_solver_cfg_arg) then
        subsection = 'parallel solver configuration file'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 9
          read(itmp,*,err=999,end=999) str_solvercfg
          !replace '\' with '/'
          call replacecharacter(str_solvercfg,achar(92),achar(47))
        else
          str_solvercfg = ""
        end if
      end if
        
!cdsu--------------------------------------------------------  
!cdsu   Output or not
!cdsu   If true, all the output will be disabled. 
!cdsu   Only the final output "normal exit" is kept.
!cdsu   This section has been moved to opngfls subroutine
!cdsu--------------------------------------------------------         
        !b_enable_output = .true.
        !subsection = 'disable output'        
        !call findstrg(subsection,itmp,found_subsection)
        !
        !if (found_subsection) then
        !  b_enable_output  = .false. 
        !end if 

    
!cdsu--------------------------------------------------------  
!cdsu   Output runtime statistics
!cdsu   This is only for test
!cdsu-------------------------------------------------------- 
      if (.not. b_prtfile) then
        subsection = 'output runtime statistics analysis'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_prtfile  = .true.
        end if
      end if
        
!cdsu--------------------------------------------------------  
!cdsu   Output sparse matrix data and right hand side
!cdsu   This is only for test
!cdsu-------------------------------------------------------- 
      if (.not. (b_output_matrix .or. b_output_matrix_petsc) .and.   &
          itimestep_output_matrix<0) then
        subsection = 'output sparse matrix data set and rhs'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_output_matrix = .true.
          itype_matrix_format = 1
        end if

        subsection = 'output sparse matrix data set and rhs using petsc'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_output_matrix_petsc = .true.
          itype_matrix_format = 1
        end if

        subsection = 'output sparse matrix data set and rhs at timestep'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 10
          read(itmp,*,err=999,end=999) itimestep_output_matrix
          itype_matrix_format = 1
        else
          itimestep_output_matrix = -1
        end if


      end if
        
!cdsu--------------------------------------------------------  
!cdsu   Output condition number
!cdsu   This is only for test
!cdsu--------------------------------------------------------
      if (.not. b_output_condition_number) then
        subsection = 'output condition number'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          if(b_enable_output)  then
            b_output_condition_number  = .true.
          else
            b_output_condition_number  = .false.
          end if
        end if
      end if
!cprovi--------------------------------------------------------
!cprovi--------------------------------------------------------
!cprovi--------------------------------------------------------    

!c  write run specific information to generic output file
!c  type of simulation

!c  disable the following output if b_enable_output is .false.
      if (b_enable_output .and. b_enable_output_gen) then

!c  New block for density dependent flow

        write(igen,'(a/)') problem_title

        if (.not.density_dependence) then

          if ((varsat_flow).and.(reactive_transport)) then

            if (steady_flow) then

              if (fully_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'steady state saturated flow ',            &
                     'and reactive transport'
              elseif (variably_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'steady state variably saturated flow ',   &
                     'and reactive transport'
              end if                !(fully_saturated/variably_saturated)

            elseif (transient_flow) then

              if (fully_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'transient saturated flow ',               &
                     'and reactive transport'
              elseif (variably_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'transient variably saturated flow ',      &
                     'and reactive transport'
              end if                !(fully_saturated/variably_saturated)

            end if                  !(steady_flow/transient_flow)

          elseif ((varsat_flow).and.(.not.reactive_transport)) then

            if (steady_flow) then

              if (fully_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'steady state saturated flow '
              elseif (variably_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'steady state variably saturated flow '
              end if                !(fully_saturated/variably_saturated)

            elseif (transient_flow) then

              if (fully_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'transient saturated flow '
              elseif (variably_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'transient variably saturated flow '
              end if                !(fully_saturated/variably_saturated)

            end if                  !(steady_flow/transient_flow)

          elseif ((.not.varsat_flow).and.(reactive_transport)) then

            write(igen,'(a/a)')                                 &
                  'simulation of:',                             &
                  'reactive transport with constant velocity field '

          elseif ((.not.varsat_flow).and.(.not.reactive_transport)) then

            write(igen,'(a/a)')                                 &
                  'simulation of:',                             &
                  'batch test with kinetically controlled dissolution-',&
                  'precipitation reactions'

          end if
        end if !.not density-dependence

!c  density dependent flow

        if (density_dependence) then

          if ((varsat_flow).and.(reactive_transport)) then

            if (steady_flow) then

              if (fully_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'density dependent steady state ',         &
                     'saturated flow and reactive transport'
              elseif (variably_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'density dependent steady state',          &
                     'variably saturated flow and reactive transport'
              end if                !(fully_saturated/variably_saturated)

            elseif (transient_flow) then

              if (fully_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'density dependent transient ',            &
                     'saturated flow and reactive transport'
              elseif (variably_saturated) then
                write(igen,'(2(a/),a)')                         &
                     'simulation of:',                          &
                     'density dependent transient',             &
                     'variably saturated flow and reactive transport'
              end if                !(fully_saturated/variably_saturated)

            end if                  !(steady_flow/transient_flow)

          elseif ((varsat_flow).and.(.not.reactive_transport)) then

            if (steady_flow) then

              if (fully_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'density dependent steady state saturated flow '
              elseif (variably_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'density dependent steady state',          &
                     'variably saturated flow '
              end if                !(fully_saturated/variably_saturated)

            elseif (transient_flow) then

              if (fully_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'density dependent transient saturated flow '
              elseif (variably_saturated) then
                write(igen,'(a/a)')                             &
                     'simulation of:',                          &
                     'density dependent transient',             &
                     'variably saturated flow '
              end if                !(fully_saturated/variably_saturated)

            end if                  !(steady_flow/transient_flow)

          elseif ((.not.varsat_flow).and.(reactive_transport)) then

            write(igen,'(a/a)')                                 &
                  'simulation of:',                             &
                  'reactive transport with constant velocity field '

          elseif ((.not.varsat_flow).and.(.not.reactive_transport)) then

            write(igen,'(a/a)')                                 &
                  'simulation of:',                             &
                  'batch test with kinetically controlled dissolution-',&
                  'precipitation reactions'

          end if
        end if ! density-dependence


!C     Multicomponent diffusion function warning

        if (multi_diff) then
              write(igen,'(2(a/),a)')            &
                   '',                    &
                   '!!!!!!!!!! WARNING !!!!!!!!!!',    &
                   'Multicomponent diffusion is ON',    &
                   'Make sure initial solution is charge balanced.'
        end if ! (multi_diff)
      
      end if

!c  file information file
      if (rank == 0 .and. b_enable_output) then
        if (i_append_sim > 0) then
          open(ifls,file=prefix(:l_prfx)//'_o'//'.fls',                &
               status='unknown',form='formatted',position='append')

          if (i_append_sim == 1) then
            write(ifls,'(/72a/a/72a/)')                                &
                 ('+',i=1,72),                                         &
                  'output of appended results',                        &
                 ('+',i=1,72)
          else if (i_append_sim == 2) then
            write(ifls,'(/72a/a/72a/)')                                &
                  ('+',i=1,72),                                        &
                   'output of appended results in legacy mode',        &
                  ('+',i=1,72)
          end if
        else
          open(ifls,file=prefix(:l_prfx)//'_o'//'.fls',                &
               status='unknown',form='formatted')
        end if
      end if


!c  write file names and numbers to file information file

      if (rank == 0 .and. b_enable_output) then

        write(ifls,'(72a/a/72a)')('*',i=1,72),                         &
                                  'MIN3P file information',            &
                                 ('*',i=1,72)
        write(ifls,'(//72a/a/72a/)')                                   &
             ('*',i=1,72),                                             &
             'problem specific input files',                           &
             ('*',i=1,72)
        write(ifls,'(a,8x,a)') prefix(:l_prfx)//'.dat',                &
                              'problem specific input'

!c  o   tput files

        write(ifls,'(//72a/a/72a/)')                                   &
             ('*',i=1,72),                                             &
             'general output files',                                   &
             ('*',i=1,72)
        write(ifls,'(a,6x,a)') prefix(:l_prfx)//'_o'//                 &
                   trim(adjustl(str_rank))//'.gen',                    &
                              'generic output'
        write(ifls,'(a,6x,a)') prefix(:l_prfx)//'_o'//                 &
                   trim(adjustl(str_rank))//'.dbg',                    &
                              'debugging information'
        if (log_file) then
          write(ifls,'(a,8x,a)') prefix(:l_prfx)//                     &
                   trim(adjustl(str_rank))//'.log',                    &
                                'log file'
        end if
        write(ifls,'(a,7x,a)') prefix(:l_prfx)//'_o'//                 &
                   trim(adjustl(str_rank))//'.dt',                     &
                              'time step data'
        write(ifls,'(a,8x,2a)') prefix(:l_prfx)//                      &
                   trim(adjustl(str_rank))//'.hyc',                    &
                               'initial hydraulic conductivity ',      &
                               'distribution'

#ifdef MEMORY_MONITOR
        if (b_output_mem_detail) then

          write(*,'(2a,/,9x,a)')                                       &
               "Warning: output of detailed memory usage affects ",    &
               "performance,","use this for debug purpose only"
          write(ilog,'(2a,/,9x,a)')                                    &
               "Warning: output of detailed memory usage affects ",    &
               "performance,","use this for debug purpose only"

          open(ifile_mem,file=prefix(:l_prfx)//'_o.mem',               &
               status='unknown',form='formatted')
          write(ifile_mem,'(2a)') 'MIN3P-HPC detailed memory usage ',  &
                                  'based on dynamic arrays'



          if (nprcs > 1) then
            write(ifile_mem,'(146a,/)') ('-',i=1,146)
            write(ifile_mem,'(a,28a,a,2(26a,a),2(24a,a),/)')           &
                  '|',('*',i=1,28),'|',('*',i=1,26),'MIN3P-HPC',       &
                  ('*',i=1,26),'|',                                    &
                  ('*',i=1,24), 'PETSc',('*',i=1,24),'|'
            write(ifile_mem,'(3a,/,3a,/)')                             &
              ' +/-             Array name     Size   ',               &
              '    Current     Maximum   Total current Total maximum', &
              '    Current     Maximum   Total current Total maximum', &
              '                               (bytes) ',               &
              '      (MB)        (MB)        (MB)          (MB)     ', &
              '      (MB)        (MB)        (MB)          (MB)'
          else
            write(ifile_mem,'(90a,/)') ('-',i=1,90)
            write(ifile_mem,'(a,28a,a,2(26a,a),/)') '|',('*',i=1,28),  &
                  '|',('*',i=1,26),'MIN3P-HPC',('*',i=1,26),'|'
            write(ifile_mem,'(2a,/,2a,/)')                             &
              ' +/-             Array name     Size   ',               &
              '    Current     Maximum   Total current Total maximum', &
              '                               (bytes) ',               &
              '      (MB)        (MB)        (MB)          (MB)     '
          end if

          write(ifls,'(a,13x,a)') prefix(:l_prfx)//'_o.mem',            &
                'detailed memory usage of dynamic arrays'
        end if
#endif
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
