!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updateheat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updateheat
!c -------------------
!c
!c update temperature for decoupled heat transport problem
!c
!c modified from Sergio Andres Bea Jofre
!c
!c written by:      Danyang Su    - May. 31, 2020
!c
!c last modified:   Danyang Su    - May. 31, 2020
!c
!c                  Unstructured grid and HPC capabilities
!c
!c ----------------------------------------------------------------------

    subroutine updateheat 

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use dens
      use phys
      use chem

#ifdef OPENMP
      use omp_lib
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      real*8 :: utempmax_gbl
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer*4 :: nexvol_gbl, mpireduce_irank
      PetscErrorCode :: ierrcode
#endif
      
      real*8, parameter :: rhalf = 0.5d0, &
                           r0 = 0.0d0, &
                           r1 = 1.0d0, &
                           r3 = 3.0d0, &
                           r10=10.0d0, &
                           enat = 2.71828182845904509d0
      integer, parameter :: iscreen=6
      
      integer :: ivol, izn, tid, i1, ioutunit
      integer :: nexvoltemp, maxvoltemp, nexvoltemp2, tempcorr_it
      real*8 :: actw, dummy1, dummy2, dummy3, uabs, aentry_loc,        &
                utempmax, uheatlim_ln, sfac, relfactemp, sfactemp,     &
                ufactemp, temp_updt_max, temp_updt_delta,              &
                uheatlim_ln_temp
      logical :: bflag_goto

      real*8, external :: rhonew, visconew
      
#ifdef STANDARD_FORTRAN
      !By definition, NAN is not equal to anything, even itself.
      if (rnorm /= rnorm .or. over_flow_heat) then
#else
      !isnan is not fortran standard, this is gnu extension.
      if (isnan(rnorm) .or. over_flow_heat) then
#endif
         if(rank == 0 .and. b_enable_output)  then 
           write(ilog,*) 'NAN or over_flow obtained in updateheat'
           write(*,*) 'NAN or over_flow obtained in updateheat'
         end if
         reduce_timestep=.true.
         return
      end if

#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      if (islogunk_energybal) then
        uheatlim_ln = uheatlim_log * dlog(r10)             
      else
        uheatlim_ln = enat**(uheatlim_log * dlog(r10))
      end if
      
      utempmax = r0   
      relfactemp = r0
      tempcorr_it = 0
      
      if (under_relax_temp) then          !underrelaxation

        if (comp_relax_temp .or. under_relax_range_temp) then
!c  find maximum update to calculate relaxation factor
!c  according to Cooley's method (1983)

#ifdef OPENMP
         maxval_omp = utempmax
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, tid)                                              
    !$omp do schedule(static)
#endif   

#ifdef OPENMP   
          do ivol = 1,nngl
            tid = omp_get_thread_num()+1  
            if (dabs(uheat(ivol)).gt.dabs(maxval_omp(tid))) then
              maxval_omp(tid) = uheat(ivol)
            end if
          end do
#else
          do ivol = 1,nngl
            if (dabs(uheat(ivol)).gt.dabs(utempmax)) then
              utempmax = uheat(ivol)
            end if
          end do
#endif

#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
          i1 = maxloc(abs(maxval_omp), 1)
          utempmax = maxval_omp(i1)         
#endif

#ifdef PETSC          
          call MPI_Allreduce(utempmax,utempmax_gbl,1,MPI_REAL8,MPI_MAX,&
                             Petsc_Comm_World,ierrcode) 
          CHKERRQ(ierrcode)
          utempmax = utempmax_gbl
#endif
        end if

        if (comp_relax_temp) then         !compute underelaxation factor

!c  compute underrelaxation factor
          if (iter_heat==1) then                 !first iteration
            relfactemp = r1
          else                                   !following iterations
            sfactemp = utempmax/(utempmaxold*relfactempold)            !step 1
            if (sfactemp<-r1) then                          !step 2
              relfactemp = rhalf/dabs(sfactemp)
            else
              relfactemp = (r3 + sfactemp)/(r3 + dabs(sfactemp))
            endif
          end if

!c  limit to maximum allowed update          
          ufactemp = relfactemp*dabs(utempmax)/utemplim                !step 3
          if (ufactemp>r1) then
            relfactemp = relfactemp/ufactemp
          end if

!c  assign old max. update and relaxation factor for next time step          
          utempmaxold = utempmax
          relfactempold = relfactemp

        else                      !user specified underelaxtion factor

          if (under_relax_range_temp) then
            if (utempmax >= srelrange_temp_min .and.                   &
                utempmax <= srelrange_temp_max) then
              relfactemp = srelfac_temp
            else
              relfactemp = r1
            end if
          else
            relfactemp = srelfac_temp
          end if

        end if       !comp_relax
        
      end if         !under_relax

      
!dsu start of maximum log cycles control
1000  continue  

!c  check size of updates (relaxed/un-relaxed) to determine convergence

    
      nexvoltemp=0
      nexvoltemp2=0
      utempmax=r0
      maxvoltemp=1
#ifdef OPENMP
      bflag_omp1 = .false.
      bflag_omp2 = .false.
      bflag_omp3 = .false.  
      maxval_omp = utempmax
      maxvol_omp = maxvoltemp
#endif 

      bflag_goto = .false.  

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, izn, i1, tid, actw, dummy3, dummy1, dummy2,  &
    !$omp uabs, uheatlim_ln_temp, aentry_loc)                         &
    !$omp reduction(+:nexvoltemp,nexvoltemp2)
    !$omp do schedule(static)
#endif 
      do ivol = 1,nngl  
!#ifdef PETSC
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#endif
          
#ifdef OPENMP    
        tid = omp_get_thread_num()+1
#else
        tid = 1
#endif         

#ifdef OPENMP
        if (bflag_omp1(tid).or.bflag_omp2(tid).or.bflag_omp3(tid)) then
          cycle
        end if
#endif        
       
        if (under_relax_temp) then                    !underrelaxation
          uheat(ivol) = relfactemp*uheat(ivol)
        end if

        ! Stablish the thershold for maximum update        
        if (uheat(ivol)>uheatlim_ln) then
          uheat(ivol) = uheatlim_ln
        elseif (uheat(ivol)<-uheatlim_ln) then
          uheat(ivol) = -uheatlim_ln
        end if
        
        if (islogunk_energybal) then      
          tempnew(ivol) = dlog(tempnew(ivol)) + uheat(ivol)
          tempnew(ivol) = enat**tempnew(ivol)
          uabs  = dabs(uheat(ivol)/dlog(r10))              
        else  
            tempnew(ivol) = tempnew(ivol) + uheat(ivol) 
            uabs  = dabs(uheat(ivol))        
        end if

        if (tempnew(ivol) < tempcorr_min .or. tempnew(ivol) > tempcorr_max) then

          if (islogunk_energybal) then
            uheatlim_ln_temp = uheatlim_ln*0.5 
          else  
            uheatlim_ln_temp = sqrt(uheatlim_ln)
          end if
          
          if(uheatlim_ln_temp < 1.0d-8) then
#ifdef OPENMP
            bflag_omp1(tid) = .true.
#else
            not_converged = .true.
#endif              
            if (tempnew(ivol) < tempcorr_min) then
              if (rank == 0 .and. b_enable_output) then  
                write(*,*) "reduce timestep: temperature is below correction range, ivol", ivol  
                write(ilog,*) "reduce timestep: temperature is below correction range, ivol", ivol
              end if
            else
              if (rank == 0 .and. b_enable_output) then 
                write(*,*) "reduce timestep: temperature is above correction range, ivol", ivol  
                write(ilog,*) "reduce timestep: temperature is above correction range, ivol", ivol 
              end if   
            end if
            
            if(iter_heat >= maxit_heat) then

#ifdef OPENMP
             bflag_omp2(tid) = .true.
#else
             reduce_timestep=.true. 
#ifndef PETSC
             return
#endif
#endif
            end if
           
          else
#ifdef OPENMP
            bflag_omp3(tid) = .true.
#else
            bflag_goto = .true.
#endif
          end if
        end if
       
#ifdef OPENMP
        if (uabs>maxval_omp(tid)) then
          maxval_omp(tid) = uabs                  !max solution update
          maxvol_omp(tid) = ivol                 !location of max update
        endif
#else        
        if (uabs>utempmax) then
          utempmax = uabs                         !max solution update
          maxvoltemp = ivol                       !location of max update
        endif
#endif     
        if (uabs>tol_heat) then                    !number of volumes
#ifdef PETSC
          if(node_idx_lg2l(ivol) > 0) then
            nexvoltemp = nexvoltemp + 1
          end if
#else
          nexvoltemp = nexvoltemp + 1             !exceeding convergence
#endif
        end if

        if (tran_steady_flow) then
          temp_updt_max = max(abs(tempnew(ivol)),abs(tempold(ivol)))
          if (temp_updt_max > r0) then
            temp_updt_delta = abs(tempnew(ivol)-tempold(ivol))/delt
            if (temp_updt_delta > atol_tran_steady_heat .and.          &
                temp_updt_delta/temp_updt_max > rtol_tran_steady_heat) then
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
                nexvoltemp2 = nexvoltemp2 + 1
              end if
#else
              nexvoltemp2 = nexvoltemp2 + 1         !exceeding convergence
#endif
            end if
          end if
        end if

!cprovi----------------------------------------------------------------------------------
!cprovi Update the density according to linear expression or based on Pitzer equations
!cprovi----------------------------------------------------------------------------------        
        if (ispitzerdens) then 
          density(ivol) = rhonew(ref_dens,density_pitzer(ivol),ref_dens,       &
                                 tempnew(ivol),tempref_dens,r1,drho_dt,        &
                                 nonlindens_heat,cdens1,cdens2,cdens3,cdens4)
        else
          density(ivol) = rhonew(ref_dens,tds_new(ivol),ref_tds,tempnew(ivol), &
                                 tempref_dens,drho_dc,drho_dt,nonlindens_heat, &
                                 cdens1,cdens2,cdens3,cdens4)
        end if
        
        if (update_viscosity_temp.or.update_viscosity) then
           viscosity(ivol) = visconew(density(ivol),tds_new(ivol),             &
                                      tempnew(ivol),update_viscosity,          &
                                      update_viscosity_temp,cvisco1,cvisco2,   &
                                      cvisco3,cvisco4,cvisco5,tempref_dens,    &
                                      iviscomodel,ref_visco,ref_tds,ref_dens) 
        end if  

!cprovi----------------------------------------------------------------------------------
!cprovi Update the soil properties as a function of water pressure
!cprovi Only of variable saturated medium 
!cprovi----------------------------------------------------------------------------------        
        if (variably_saturated) then
          !cprovi--------------------------------------------------------------------------
          !cprovi Compute the saturated vapour density 
          !cprovi (see Saito et al. (2006) and RETRASO manual
          !cprovi--------------------------------------------------------------------------
          if (evaporation) then             
            if (reactive_transport) then   
              actw = gamma(nc,ivol) 
            else
              actw = r1
            end if  
  
            if (soilhydrfunc_field) then
              aentry_loc = aentry_vol(ivol)
            else
              izn = mpropvs(ivol)
              aentry_loc = aentry(izn)
            end if
  
            call vapor_prop(densvnew(ivol),dummy1,dummy2,dummy3,      &
                            latvapnew(ivol),tempnew(ivol),aentry_loc, &
                            uvsnew(ivol),actw,density(ivol),ivol)  
          end if 
        end if      
      end do        !loop over control volumes     
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
      if (any(bflag_omp1,1) .eqv. .true.) then
        not_converged = .true.
        if (any(bflag_omp2,1) .eqv. .true.) then
          reduce_timestep = .true.  
        end if
      end if
#endif

#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(not_converged, b_mpi_process_flag, 1,         &
              MPI_LOGICAL, MPI_LOR, Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      not_converged = b_mpi_process_flag
      
      b_mpi_process_flag = .false.
      call MPI_Allreduce(reduce_timestep, b_mpi_process_flag, 1,       &
              MPI_LOGICAL, MPI_LOR, Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      reduce_timestep = b_mpi_process_flag
#endif

      if (reduce_timestep) then
        if (rank == 0 .and. b_enable_output) then
          write(*,'(a,1x,2(a,1x,i6,1x))')                                  &
                "reduce timestep: temperature correction is out of range", &
                "current iteration",iter_heat,"max iteration",maxit_heat
          write(ilog,'(a,1x,2(a,1x,i6,1x))')                               &
                "reduce timestep: temperature correction is out of range", &
                "current iteration",iter_heat,"max iteration",maxit_heat
        end if
        return
      end if

#ifdef OPENMP 
      if (any(bflag_omp3,1) .eqv. .true.) then
        bflag_goto = .true.
      end if
#endif


#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(bflag_goto, b_mpi_process_flag,1,             &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      bflag_goto = b_mpi_process_flag    
#endif

      if (bflag_goto) then        
        if (islogunk_energybal) then
          uheatlim_ln = uheatlim_ln*0.5 
        else  
          uheatlim_ln = sqrt(uheatlim_ln)
        end if      

        tempcorr_it = tempcorr_it + 1
        if (tempcorr_it <= tempcorr_maxit) then
          goto 1000
        else
          if (rank == 0 .and. b_enable_output) then
            write(*,'(a,1x,2(a,1x,i6,1x))')                                  &
                  "reduce timestep: temperature correction is out of range", &
                  "current correction",tempcorr_it,                          &
                  "max correction",tempcorr_maxit
            write(ilog,'(a,1x,2(a,1x,i6,1x))')                               &
                  "reduce timestep: temperature correction is out of range", &
                  "current correction",tempcorr_it,                          &
                  "max correction",tempcorr_maxit
          end if

          reduce_timestep = .true.
          return
        end if
      end if

!dsu end of maximum log cycles control

#ifdef OPENMP   
      i1 = maxloc(maxval_omp, 1)
      utempmax = maxval_omp(i1)
      maxvoltemp = maxvol_omp(i1)    
#endif

#ifdef PETSC     
      
      mpireduce_in(1) = utempmax    !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      utempmax = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvoltemp, 1, MPI_INTEGER4, mpireduce_irank,     &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)

      call MPI_Allreduce(nexvoltemp, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,&
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvoltemp = nexvol_gbl

      call MPI_Allreduce(nexvoltemp2, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,&
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvoltemp2 = nexvol_gbl
#endif

      if (nexvoltemp2 == 0) then
        tran_steady_heat_converged = .true.
        !c DO NOT add tran_steady_flow_converged = .true. here 
      else
        tran_steady_heat_converged = .false.
        tran_steady_flow_converged = .false.
      end if

!cprovi----------------------------------------------------------------------------------
!cprovi If evaporation is solved, update the atmospheric parameters for flow and 
!cprovi energy transport equations 
!cprovi---------------------------------------------------------------------------------- 
!cdsu   confusion here, jacbevap sounds like doing nothing that is necessary,
!cdsu   comment by DSU, 2018-01-28
 

!cprovi----------------------------------------------------------------------------------
!cprovi Write convergence history to screen or log file
!cprovi----------------------------------------------------------------------------------
      
      if (idetail_heat>0) then       
        if(rank == 0 .and. b_enable_output .and. .not.                 &
           ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
            
          ioutunit = iscreen
            
2000      continue  
       
          if (iter_heat==1 .or. idetail_heat==2) then
            write(ioutunit,*)'------------------------------------------------'
            write(ioutunit,'(a)') ' Newton Iteration Convergence Summary For Heat Transport:'
            write(ioutunit,*)'------------------------------------------------'

            write(ioutunit,'(2a)')                                           &
                  ' Newton      maximum       maximum    ',' solver'
            if (tran_steady_flow) then
              write(ioutunit,'(2a)')                                         &
                    ' iteration   updateTemp    residual   ',                &
                    ' iterations  maxvoltemp   nexvoltemp  nexvoltemp2'
            else
              write(ioutunit,'(3a)')                                         &
                    ' iteration   updateTemp    residual   ',                &
                    ' iterations  maxvoltemp   nexvoltemp'
            end if
             
          end if
          
          if (tran_steady_flow) then
            write(ioutunit,'(i6,6x,1pe11.4,2x,1e11.4,i9,5x,i9,2(3x,i9))')    &
                  iter_heat,utempmax,rnorm,itsolv,maxvoltemp,                &
                  nexvoltemp,nexvoltemp2
          else
            write(ioutunit,'(i6,6x,1pe11.4,2x,1e11.4,i9,5x,i9,3x,i9)')       &
                  iter_heat,utempmax,rnorm,itsolv,maxvoltemp,nexvoltemp
          end if
          
          if(ioutunit == iscreen .and. ioutunit /= ilog) then
            ioutunit = ilog
            goto 2000
          end if
      
        end if
        
      end if

!cdsu  ------------------------------------------------------------------------
!cdsu  save maximum update value in newton iteration to check if iteration is diverged
!cdsu  ------------------------------------------------------------------------
      if (b_check_div_heat) then
        i1 = mod(iter_heat,5)
        if (i1 == 0) then
          i1 = 5
        end if
        div_heat(i1) = abs(utempmax)
      end if

!cprovi-----------------------------------------------------------------------------------
!cprovi Final convergence check
!cprovi-----------------------------------------------------------------------------------
      if (utempmax<tol_heat) then
        not_converged = .false.
      end if

      return
    end subroutine updateheat
