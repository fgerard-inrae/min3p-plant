!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updtdisprt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updtdisprt
!c -------------------
!c
!c update dispersivity for reactive transport
!c
!c
!c
!c written by:      Danyang Su - Jul 11, 2020
!c
!c last modified:   
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c ----------------------------------------------------------------------
 
      subroutine updtdisprt
      
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif 
      use gen
      use phys
      use math_common      
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none

#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: i, izn, ierr, l_string, iflag
 
      logical :: b_updt_next_only, b_updtbc_back

      b_updt_next_only = .false.
      b_updtbc_back = .false.

      if ((.not. b_interpolation_disprt .and.                          &
          time_io >= time_disprt_prev .and. time_io < time_disprt) .or.&
          time_disprt > tfinal/time_factor) then
        return
      end if

      !c check if the current timestep right after boundary condition update is failed
      if (.not. b_first_update_disprt .and. &
        (time_io < time_disprt_prev .or. time_io > time_disprt)) then        
        b_updtbc_back = .true.
      end if
         
      if (time_io.gt.time_disprt .or.                                  &
          b_restart_update_disprt .or. b_first_update_disprt .or.      &
          b_updtbc_recall .or. b_updtbc_back) then
          
        if(rank == 0 .and. b_enable_output)  then   
                                                                       
          write(*,*)
          write(*,*) 'update dispersivity for reactive transport'
          write(*,*) ('-',i=1,72)
          write(*,*)

          write(ilog,*)
          write(ilog,'(a)') 'update dispersivity for reactive transport'
          write(ilog,'(72a)')('-',i=1,72)
          write(ilog,*)
        
        end if

!c  allocate array for reading new dispersivity for reactive transport. 

        allocate (rwork(3,nzn), stat = ierr)
        rwork=0.0d0 
        call checkerr(ierr,'rwork',ilog)
        call memory_monitor(sizeof(rwork),'rwork',.true.)

        allocate (rwork_next(3,nzn), stat = ierr)
        rwork_next=0.0d0 
        call checkerr(ierr,'rwork_next',ilog)
        call memory_monitor(sizeof(rwork_next),'rwork_next',.true.)

!c  assign new dispersivity for reactive tranpsort.
      
        if (b_first_update_disprt .and.                                &
            time_io.ge.time_disprt_prev .and.                          &
            time_io.le.time_disprt) then
          b_updt_next_only = b_first_update_disprt
          backspace(idisprt)
          read(idisprt,*,err=998,end=997) time_disprt_prev,            &
              (rwork(1:3,izn),izn=1,nzn)
          do while (time_io < time_disprt_prev)
            backspace(idisprt)
            backspace(idisprt)
            read(idisprt,*,err=998,end=997) time_disprt_prev,          &
                (rwork(1:3,izn),izn=1,nzn)
          end do

          do while (time_io > time_disprt)
            read(idisprt,*,err=998,iostat=iflag) time_disprt_prev,     &
                (rwork(1:3,izn),izn=1,nzn)
            !c end of file has reached
            if (iflag < 0) then
              time_disprt = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else            
              if (time_io < time_disprt_prev) then
                backspace(idisprt)
                backspace(idisprt)
                read(idisprt,*,err=998,end=997) time_disprt_prev,      &
                    (rwork(1:3,izn),izn=1,nzn)
                exit
              end if
            end if
          end do

          read(idisprt,*,err=998,iostat=iflag) time_disprt,            &
              (rwork_next(1:3,izn),izn=1,nzn)
          !c end of file has reached
          if (iflag < 0) then
            time_disprt = (tfinal+delt)/time_factor
            rwork_next = rwork
          end if 

        else  
          backspace(idisprt)
          read(idisprt,*,err=998,end=997) time_disprt_prev,            &
              (rwork(1:3,izn),izn=1,nzn)

          do while (time_io < time_disprt_prev)
            backspace(idisprt)
            backspace(idisprt)
            read(idisprt,*,err=998,end=997) time_disprt_prev,          &
                (rwork(1:3,izn),izn=1,nzn)
          end do

          do while (time_io > time_disprt)
            read(idisprt,*,err=998,iostat=iflag) time_disprt_prev,     &
                (rwork(1:3,izn),izn=1,nzn)
            !c end of file has reached
            if (iflag < 0) then
              time_disprt = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else            
              if (time_io < time_disprt_prev) then
                backspace(idisprt)
                backspace(idisprt)
                read(idisprt,*,err=998,end=997) time_disprt_prev,      &
                    (rwork(1:3,izn),izn=1,nzn)
                exit
              end if
            end if
          end do
          
          if (b_interpolation_disprt) then
            read(idisprt,*,err=998,iostat=iflag) time_disprt,          &
                (rwork_next(1:3,izn),izn=1,nzn)
            !c end of file has reached
            if (iflag < 0) then
              time_disprt = (tfinal+delt)/time_factor
              rwork_next = rwork
            end if
            !c backspace, time_disprt will be read again later
            backspace(idisprt)
          end if
        end if

!c  if boundary type and zone is unchanged, just update the value
!c  without reading zone and type again, DSU 2019-10-28
!c  note: actually the boundary type and zone cannot be changed in the current version
        if (update_disprt_value_only) then

          do izn = 1, nzn
            if (.not. b_updt_next_only .or. b_restart_update_disprt) then
              disx_prev(izn) = rwork(1,izn)
              disy_prev(izn) = rwork(2,izn)
              disz_prev(izn) = rwork(3,izn)
            end if

            if (b_interpolation_disprt) then
              disx_next(izn) = rwork_next(1,izn)
              disy_next(izn) = rwork_next(2,izn)
              disz_next(izn) = rwork_next(3,izn)
              
              disx(izn) = math_common_linear(                          &
                                      time_disprt_prev, time_disprt,   &
                                      disx_prev(izn),disx_next(izn),   &
                                      time_io)
              disy(izn) = math_common_linear(                          &
                                      time_disprt_prev, time_disprt,   &
                                      disy_prev(izn),disy_next(izn),   &
                                      time_io)  
              disz(izn) = math_common_linear(                          &
                                      time_disprt_prev, time_disprt,   &
                                      disz_prev(izn),disz_next(izn),   &
                                      time_io)
            else
              disx(izn) = disx_prev(izn)
              disy(izn) = disy_prev(izn)
              disz(izn) = disz_prev(izn)
            end if
          end do

          b_first_update_disprt = .false.

        end if

!c  free space for array not required any more

!c  deallocate workarray for reading transient boundary conditions
        if (allocated(rwork)) then
          call memory_monitor(-sizeof(rwork),'rwork',.true.)
          deallocate (rwork, stat = ierr)
          call checkerr(ierr,'rwork',ilog)
        end if

        if (allocated(rwork_next)) then
          call memory_monitor(-sizeof(rwork_next),'rwork_next',.true.)
          deallocate (rwork_next, stat = ierr)
          call checkerr(ierr,'rwork_next',ilog)
        end if

!c  restore the reading position to previous record
        if (b_updt_next_only) then
          backspace(idisprt)
        end if

!c  assign next read time
        if (time_disprt < tfinal/time_factor) then
          read(idisprt,*,err=998,end=997) time_disprt
        end if

        return

!c  assign next read time greater than final solution time, if no more
!c  read times left and return
!cdsu replace 1.1*tfinal since tfinal can be negative

997     continue
        time_disprt = (tfinal+1.0d100)/time_factor
        return

998     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.disprt'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

      else if (b_interpolation_disprt) then
        do izn = 1, nzn
          disx(izn) = math_common_linear(                    &
                            time_disprt_prev, time_disprt,   &
                            disx_prev(izn),disx_next(izn),   &
                            time_io)
          disy(izn) = math_common_linear(                    &
                            time_disprt_prev, time_disprt,   &
                            disy_prev(izn),disy_next(izn),   &
                            time_io)  
          disz(izn) = math_common_linear(                    &
                            time_disprt_prev, time_disprt,   &
                            disz_prev(izn),disz_next(izn),   &
                            time_io)
        end do

      end if
      
      return

    end subroutine
