!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/heattran.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine heattran
!c -----------------
!c
!c driver subroutine for decoupled heat transport 
!c
!c written by:      Danyang Su    - May. 29, 2020
!c
!c last modified:   Danyang Su    - May. 29, 2020
!c
!c                  Unstructured grid and HPC capabilities
!c
!c
!c ----------------------------------------------------------------------

      subroutine heattran

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use phys
      use dens
      use chem 
      use file_unit, only : lun_get, lun_set, lun_free
      use solver_results, only : solver_results_check_output
      
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef PARDISO
      use solver_pardiso, only : pardiso_symbolicfactorization,      &
                                 pardiso_numfactorization,           &
                                 pardiso_substitution, ptheat,       &
                                 iparm_heat
#endif  

      
#ifdef PETSC
      use solver_dd, only : solver_dd_snes_solve_flow_heat
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use usg_mesh_data, only : num_cells, num_nodes_per_cell, cells
#endif

#ifdef LIS
      use solver_lis, only : solver_lis_solve_heat
#endif

      use matrix_utility, only : export_arrays1d, export_mmformat,     &
                                 export_mmformat_gbl                      !for test, dsu
      
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: i, ierr, ilist, ivol, iter_div
      real*8 :: cputime
      integer :: ifile, idummy, iskip, nskip, maxvol
      character*256 :: strdummy, strfile

      external checkerr, incompletefactorization, ws209, updateheat,   &
               tstepheat, jacheat, jacbheat

      logical over_flow, b_redo_symbfac
      
      real*8, parameter :: r0=0.0d0, r1=1.0d0
      
      integer, parameter :: i0=0 

      not_converged = .true.

      if (.not. allocated(aheat)) then
        allocate (aheat(njaheat), stat = ierr)
        aheat = 0.0d0
        call checkerr(ierr,'aheat',ilog)
        call memory_monitor(sizeof(aheat),'aheat',.true.)
      end if
    
      if (i_solver_type_heat == 0) then
        if (.not. allocated(afheat)) then
          allocate (afheat(njafheat), stat = ierr)
          afheat = 0.0d0
          call checkerr(ierr,'afheat',ilog)
          call memory_monitor(sizeof(afheat),'afheat',.true.)
        end if
      end if

      iter_heat = 0
      not_converged = .true.

      do while (not_converged)          !newton iteration loop
            
        prt_heat_tot = cputime()

!cdsu --------------------------------------------
!cdsu Decoupled Energy balance 
!cdsu--------------------------------------------
        iter_heat = iter_heat + 1         !iteration counter (current)
        ittot_heat = ittot_heat + 1       !iteration counter (total)
                                          !to report number of iterations to log file 
        if (idetail_heat.eq.2 .and. rank == 0 .and. b_enable_output) then
          write(ilog,'(/a,i3,a)') 'Newton iteration ',iter_heat,':'
          write(ilog,'(a)') '---------------------'
        end if

!cprovi---------------------------------------------------------------------
!cprovi Initialice arrays
!cprovi--------------------------------------------------------------------
        aheat = r0
        bheat = r0
        uheat = r0    

        if (i_solver_type_heat == 0) then
          afheat = r0
        end if

        prt_heat_jac = cputime()    
           
!cdsu--------------------------------------------------------------------
!cdsu assemble matrix and rhs-vector for decoupled heat transport equation  
!cdsu Parallelized, OpenMP, DSU
!cdsu--------------------------------------------------------------------

        call jacheat
!cprovi--------------------------------------------------------------------
!cprovi adjust matrix and rhs vector for boundary conditions for decoupled 
!cprovi heat transport equation
!cprovi Parallelized, OpenMP, DSU
!cprovi--------------------------------------------------------------------
        call jacbheat

        !Export sparse matrix dataset and right hand side. For test only, dsu. 
        if((b_output_matrix.or.itimestep_output_matrix == mtime.or.&
          (itimestep_output_matrix > 0 .and. mtime == 0)).and.     &
          b_enable_output) then
          if(itype_matrix_format == 0) then
            call export_arrays1d(nngl, njaheat, iaheat, jaheat,    &
                 aheat, bheat, uheat, .true., .true., .false.,     &
                 "heat", ittot_heat)
          else if(itype_matrix_format == 1) then
            call export_mmformat(nngl, njaheat, iaheat, jaheat,    &
                 aheat, bheat, uheat, .true., .true., .false.,     &
                 "heat", ittot_heat)
#ifdef PETSC
            call export_mmformat_gbl(nn,nngl,njaheat,iaheat,       &
                 jaheat,aheat,bheat,uheat,.true.,.true.,.false.,   &
                 "heat",nngl,nngbl,.false.,ittot_heat)
#endif
          end if
        end if
      
           
!cprovi--------------------------------------------------------------------
!cprovi Estimate condition number for the current matrix. 
!cprovi This is used for testing when newton iteration failed.
!cprovi--------------------------------------------------------------------
#ifdef CONDITION_NUMBER
        if(b_output_condition_number) then
          call cond_num_cal(nngl, njaheat, iaheat, jaheat, aheat,  &
                            condition_number, condition_number_info)  
          if (rank == 0 .and. b_enable_output) then
          
          if (condition_number_info(1) .ge. 0) then
            write(*,"(2(a, 1pe15.6e3, 1x))")                       &
                  " classical cond. num. ", condition_number(1),   &
                  " skeel cond. num. ", condition_number(2)
            write(ilog,"(2(a, 1pe15.6e3, 1x))")                    &
                  " classical cond. num. ", condition_number(1),   &
                  " skeel cond. num. ", condition_number(2)
          else
            write(*,*)                                             &
                ' error in estimating condition number, info(1) ', &
                condition_number_info(1)
            write(ilog,*)                                          &
                ' error in estimating condition number, info(1) ', &
                condition_number_info(1)
          endif
              
          if(i_solver_type_heat == 1) then
            if(condition_number(1) > 1.0e10 .and.                  &
                    condition_number(2) > 1.0e10) then
                write(*,"(a)")                                     &
                      " Warning: matrix is ill-conditioned."
                write(ilog,"(a)")                                  &
                      " Warning: matrix is ill-conditioned."
            end if
          end if
          
          end if
        end if
#endif         
        prt_heat_jac = cputime() - prt_heat_jac
           
        prt_heat_solver = 0.0d0  

        !! use ws209 solver
        if (i_solver_type_heat == 0) then
#ifdef PARDISO
          if (b_solver_test_pardiso) then
    !$omp parallel                                                    &
    !$omp if (njaheat > numofloops_thred_global)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            do i = 1, njaheat
              aheat_std(i) = aheat(imapheat_std(i))
            end do
    !$omp end do
    !$omp end parallel
           
            b_redo_symbfac = .true.
100         prt_heat_symbfac_comp = cputime()
            if(bsymbolicfactor_heat  .or.                          &
               i_symfactor_type_heat == 1) then
              call pardiso_symbolicfactorization(iparm_heat,       &
                   ptheat, nngl, njaheat, iaheat, jaheat_std,      &
                   aheat_std)
              bsymbolicfactor_heat = .false.
            end if 
            prt_heat_symbfac_comp=cputime()-prt_heat_symbfac_comp

            prt_heat_fac_comp = cputime()
            call pardiso_numfactorization(iparm_heat,              &
                 ptheat, nngl, njaheat, iaheat, jaheat_std,        &
                 aheat_std)
            prt_heat_fac_comp=cputime()-prt_heat_fac_comp

            prt_heat_sub_comp = cputime()  
            call pardiso_substitution(ilog, msolvit_heat,          &
                 itsolv, idetail_heat, res_heat,                   &
                 restol_heat, deltol_heat, over_flow, rnorm,       &
                 rmupdate, iparm_heat, ptheat, nngl, njaheat,      &
                 iaheat, jaheat_std, aheat_std, bheat, uheat_std)
            prt_heat_sub_comp = cputime() - prt_heat_sub_comp
                
            if (b_redo_symbfac .and.                               &
                (itsolv > n_max_iteration_heat .or.                &
                rnorm > r_max_residual_heat .or. over_flow)) then
              bsymbolicfactor_heat = .true.  
              b_redo_symbfac = .false.
              goto 100
            end if            
          end if
#endif       

#ifdef PETSC
          if(b_solver_test_petsc) then

            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_flow_heat(ilog,.false.,      &
                      idetail_heat,aheat,bheat,uheat_std,          &
                      iaheat,jaheat,nngl,itsolv,                   &
                      over_flow,rnorm,row_idx_l2pg_heat,           &
                      col_idx_l2pg_heat,.false.)
            over_flow_heat = over_flow

#ifdef DEBUG
            if(rank == 0) then
              write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')     &
              "heattran-A: rank, iteration, over_flow, rnorm ",    &
              rank, itsolv, over_flow, rnorm 
            end if
#endif
          end if
#endif

#ifdef LIS     
          if(b_solver_test_lis) then
            !only solver the local part, update the ghost value
            call solver_lis_solve_heat(ilog,idetail_heat,          &
                      aheat,bheat,uheat_std,iaheat,jaheat,         &
                      nngl,nn,1,itsolv,over_flow,rnorm,            &
                      row_idx_l2pg_heat,col_idx_l2pg_heat,.false.)
            over_flow_heat = over_flow

#ifdef DEBUG
            if(rank == 0 .and. b_enable_output) then
              write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')     &
                "heattran-A2: rank, iteration, over_flow, rnorm ", &
                rank, itsolv, over_flow, rnorm  
            end if
#endif
          end if
#endif


!cprovi--------------------------------------------------------------------
!cprovi Scale [avs] and {bvs} to produce unit diagonal
!cprovi Generate re-ordered preconditioner [af]
!cprovi--------------------------------------------------------------------
          ilist = 1
          prt_heat_fac = cputime()
              
          call incompletefactorization(nngl,njaheat,njafheat,bheat,      &
                                       aheat,afheat,rwork_max,iaheat,    &
                                       jaheat,iafheat,iafdheat,          &
                                       jafheat,iwork_max(ilist),         &
                                       lorderheat,invordheat,            &
                                       numofthreads_ws209)

          prt_heat_fac = cputime() - prt_heat_fac
 
!c  solve [avs] * {uvs} = {bvs}
          prt_heat_sub = cputime()  

          call ws209(ilog,nngl,msolvit_heat,itsolv,                      &
               idetail_heat,iaheat,jaheat,iafheat,iafdheat,jafheat,      &
               lorderheat,aheat,afheat,uheat,bheat,res_heat,rwork_max,   &
               restol_heat,deltol_heat,njaheat,njafheat,over_flow,rnorm, &
               rmupdate,numofthreads_ws209,rank,b_enable_output) 

          prt_heat_sub = cputime() - prt_heat_sub
           
#ifdef PARDISO
          if (b_solver_test_pardiso) then
            call solver_results_check_output(ittot_heat, nngl,     &
                 uheat, uheat_std, "heat") 
          end if 
#endif

#ifdef PETSC
          if (b_solver_test_petsc) then        
            call solver_results_check_output(ittot_heat, nngl,     &
                 uheat, uheat_std, "heat_petsc") 
          end if
#endif

#ifdef LIS
          if (b_solver_test_lis) then        
            call solver_results_check_output(ittot_heat, nngl,     &
                 uheat, uheat_std, "heat_lis") 
          end if
#endif
          prt_heat_solver = prt_heat_symbfac + prt_heat_fac + prt_heat_sub
        !! use pardiso solver
        else if (i_solver_type_heat == 1) then
#ifdef PARDISO 
    !$omp parallel                                                     &
    !$omp if (njaheat > numofloops_thred_global)                       &
    !$omp num_threads(numofthreads_global)                             &
    !$omp default(shared)                                              &
    !$omp private (i)  
    !$omp do schedule(static)
          do i = 1, njaheat
            aheat_std(i) = aheat(imapheat_std(i))
          end do
    !$omp end do
    !$omp end parallel
           
          b_redo_symbfac = .true.
200       prt_heat_symbfac = cputime() 
          if(bsymbolicfactor_heat  .or. i_symfactor_type_heat == 1) then
            call pardiso_symbolicfactorization(iparm_heat, ptheat, &
                 nngl, njaheat, iaheat, jaheat_std, aheat_std)
            bsymbolicfactor_heat = .false.
          end if 
          prt_heat_symbfac = cputime() - prt_heat_symbfac
            
          prt_heat_fac = cputime()
          call pardiso_numfactorization(iparm_heat, ptheat, nngl,  &
               njaheat, iaheat, jaheat_std, aheat_std)
          prt_heat_fac = cputime() - prt_heat_fac
              
          prt_heat_sub = cputime() 
          call pardiso_substitution(ilog, msolvit_heat,            &
               itsolv, idetail_heat, res_heat, restol_heat,        &
               deltol_heat, over_flow, rnorm, rmupdate, iparm_heat,&
               ptheat, nngl, njaheat, iaheat, jaheat_std,          &
               aheat_std, bheat, uheat) 
          prt_heat_sub = cputime() - prt_heat_sub
              
          if (b_redo_symbfac .and.                                 &
                (itsolv > n_max_iteration_heat .or.                &
                rnorm > r_max_residual_heat .or. over_flow)) then
              bsymbolicfactor_heat = .true.    
              b_redo_symbfac = .false.
              goto 200
          end if
#endif 
          prt_heat_solver=prt_heat_symbfac+prt_heat_fac+prt_heat_sub
          !! use PETSc solver
        else if (i_solver_type_heat == 2) then
#ifdef PETSC     
          prt_heat_solver = cputime()

          !only solver the local part, update the ghost value
          call solver_dd_snes_solve_flow_heat(ilog,.false.,        &
                    idetail_heat,aheat,bheat,uheat,                &
                    iaheat,jaheat,nngl,itsolv,over_flow,rnorm,     &
                    row_idx_l2pg_heat,col_idx_l2pg_heat,.false.)
          over_flow_heat = over_flow
          prt_heat_solver = cputime() - prt_heat_solver

#ifdef DEBUG
          if(rank == 0 .and. b_enable_output) then
            write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')       &
              "heattran-B: rank, iteration, over_flow, rnorm ",    &
              rank, itsolv, over_flow, rnorm  
          end if
#endif
#endif        
        !! use LIS solver
        else if (i_solver_type_heat == 3) then
#ifdef LIS     
          prt_heat_solver = cputime()
          !only solver the local part, update the ghost value
          call solver_lis_solve_heat(ilog,idetail_heat,           &
                      aheat,bheat,uheat,iaheat,jaheat,nngl,nn,1,  &
                      itsolv,over_flow,rnorm,row_idx_l2pg_heat,   &
                      col_idx_l2pg_heat,.false.)
          over_flow_heat = over_flow
          prt_heat_solver = cputime() - prt_heat_solver
#ifdef DEBUG
          if(rank == 0 .and. b_enable_output) then
            write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')       &
                "heattran-B2: rank, iteration, over_flow, rnorm ", &
                rank, itsolv, over_flow, rnorm  
          end if
#endif
#endif        
        end if
        
        !Export sparse matrix dataset and right hand side. For test only, dsu.
        if((b_output_matrix.or.itimestep_output_matrix == mtime.or.&
            (itimestep_output_matrix > 0 .and. mtime == 0)).and.   &
            b_enable_output) then
          if(itype_matrix_format == 0) then
            call export_arrays1d(nngl, njaheat, iaheat, jaheat,    &
            aheat, bheat, uheat, .false., .false., .true.,         &
            "heat", ittot_heat)
          else if(itype_matrix_format == 1) then
            call export_mmformat(nngl, njaheat, iaheat, jaheat,    &
            aheat, bheat, uheat, .false., .false., .true.,         &
            "heat", ittot_heat)
#ifdef PETSC
            call export_mmformat_gbl(nn,nngl,njaheat,iaheat,       &
                 jaheat,aheat,bheat,uheat,.false.,.false.,         &
                 .true.,"heat",nngl,nngbl,.false.,ittot_heat)
#endif
          end if
        end if
         
        if (.not.transient_flow.and.itsolv.eq.msolvit_heat) then
          if(rank == 0) then        !if MPI rank 0 
            write(*,'(a/a)')                                       &
              'maximum number of inner iterations exceeded',       &
              'steady state flow solution non-convergent'
            write(ilog,'(a/a)')                                    &
              'maximum number of inner iterations exceeded',       &
              'steady state flow solution non-convergent'
          end if                     !end if MPI rank 0

#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if

!cdsu  debug part, use external solution (written in sequential order) to test
!        if (mtime >= 1 .and. mtime <= 30) then
!          call export_mmformat_gbl(nn,nngl,njaheat,iaheat,         &
!               jaheat,aheat,bheat,uheat,.true.,.true.,.true.,      &
!               "heat_check",nngl,nngbl,.false.,ittot_heat)
!        end if
!
!        if (mtime >= 1 .and. mtime <= 3) then
!          if (rank == 0) then
!            write(*,*) "-->read temperature change from external"
!          end if
!          
!          ifile = lun_get()
!          write(strfile, *) ittot_heat
!          strfile = "x_heat_"//trim(adjustl(strfile))//"_natgbl.txt"
!          open(ifile,file=trim(strfile),status='old',form='formatted')
!          read(ifile,*) strdummy
!
!          !c read hydraulic head (pressure) data
!          uheat(1:nngl) = 0.0d0
!          nskip = 0
!          do ivol = 1, nngl
!#ifdef  PETSC
!            do iskip = 1, node_idx_lg2g(ivol) - nskip -1
!              read(ifile,*) idummy
!            end do
!            nskip = node_idx_lg2g(ivol)
!#endif   
!            read(ifile,*) idummy,uheat(ivol)
!          end do
!
!          close(ifile)
!          call lun_free(ifile)
!        end if
!cdsu  debug part, use external solution (written in sequential order) to test, end        

!cprovi---------------------------------------------------------------------------------------------------
!cprovi End build jacobian and residual 
!cprovi---------------------------------------------------------------------------------------------------      
!c  total number of solver iterations

        itsolvtot_heat = itsolvtot_heat + itsolv
      
        if (.not.over_flow) then
!cprovi---------------------------------------------------------------------------------------------------
!cprovi Update the solution 
!cprovi Parallelized, OpenMP, DSU
!cprovi---------------------------------------------------------------------------------------------------           

          call updateheat

!cdsu ---------------------------------------------------------------------------------------------------
!cdsu check if newton iteration is diverged based on the saved maximum update value in newton iteration
!cdsu ---------------------------------------------------------------------------------------------------
          if (b_check_div_heat .and. iter_heat >= 5) then
            iter_div = mod(iter_heat,5)             
            if (iter_div == 0) then
              if (div_heat(5) > div_heat(4)*1.1d0 .and.              &
                  div_heat(4) > div_heat(3)*1.1d0 .and.              &
                  div_heat(3) > div_heat(2)*1.1d0 .and.              &
                  div_heat(2) > div_heat(1)*1.1d0) then
                if (steady_flow) then
                  not_converged = .true.
                else
                  reduce_timestep = .true.
                end if
              end if
            else if (iter_div == 1) then
              if (div_heat(1) > div_heat(5)*1.1d0 .and.              &
                  div_heat(5) > div_heat(4)*1.1d0 .and.              &
                  div_heat(4) > div_heat(3)*1.1d0 .and.              &
                  div_heat(3) > div_heat(2)*1.1d0) then
                if (steady_flow) then
                  not_converged = .true.
                else
                  reduce_timestep = .true.
                end if
              end if
            else if (iter_div == 2) then
              if (div_heat(2) > div_heat(1)*1.1d0 .and.              &
                  div_heat(1) > div_heat(5)*1.1d0 .and.              &
                  div_heat(5) > div_heat(4)*1.1d0 .and.              &
                  div_heat(4) > div_heat(3)*1.1d0) then
                if (steady_flow) then
                  not_converged = .true.
                else
                  reduce_timestep = .true.
                end if
              end if
            else if (iter_div == 3) then
              if (div_heat(3) > div_heat(2)*1.1d0 .and.              &
                  div_heat(2) > div_heat(1)*1.1d0 .and.              &
                  div_heat(1) > div_heat(5)*1.1d0 .and.              &
                  div_heat(5) > div_heat(4)*1.1d0) then
                reduce_timestep = .true.
              end if
            else if (iter_div == 4) then
              if (div_heat(4) > div_heat(3)*1.1d0 .and.              &
                  div_heat(3) > div_heat(2)*1.1d0 .and.              &
                  div_heat(2) > div_heat(1)*1.1d0 .and.              &
                  div_heat(1) > div_heat(5)*1.1d0) then
                if (steady_flow) then
                  not_converged = .true.
                else
                  reduce_timestep = .true.
                end if
              end if
            end if
  
            if (reduce_timestep) then
              if (steady_flow) then
                if (rank == 0) then
                  write(*,*)                                         &
                  '-------------------------------------------'
                  write(*,*)                                         &
                  '   terminated in routine heattran          '
                  write(*,*)                                         &
                  '   newton solver diverges                  '
                  write(*,*)                                         &
                  '   bye now ...                             '
                  write(*,*)                                         &
                  '-------------------------------------------'

                  write(ilog,*)                                      &
                  '-------------------------------------------'
                  write(ilog,*)                                      &
                  '   terminated in routine heattran          '
                  write(ilog,*)                                      &
                  '   newton solver diverges                  '
                  write(ilog,*)                                      &
                  '   bye now ...                             '
                  write(ilog,*)                                      &
                  '-------------------------------------------'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                if (rank == 0 .and. b_enable_output .and. idetail_heat.gt.0) then
                  write(*,*) 'reduce time step: newton iteration diverged'
                  write(ilog,*) 'reduce time step: newton iteration diverged'
                end if
              end if
            end if
          end if

!cprovi---------------------------------------------------------------------------------------------------           
!cprovi---------------------------------------------------------------------------------------------------                 
!cprovi---------------------------------------------------------------------------------------------------            
                        
!c  max. number of iterations is exceeded and convergence tolerance
!c  not satisfied
!c  steady state problem -> terminate execution

          if ((iter_heat==maxit_heat).and.(not_converged)) then
            if (steady_flow) then
              if (rank == 0 .and. b_enable_output) then
                write(*,*)                                        &
                '-------------------------------------------'
                write(*,*)                                        &
                '   terminated in routine heattran            '
                write(*,*)                                        &
                '   maximum number of iterations exceeded   '
                write(*,*)                                        &
                '   bye now ...                             '
                write(*,*)                                        &
                '-------------------------------------------'

                write(ilog,*)                                     &
                '-------------------------------------------'
                write(ilog,*)                                     &
                '   terminated in routine heattran            '
                write(ilog,*)                                     &
                '   maximum number of iterations exceeded   '
                write(ilog,*)                                     &
                '   bye now ...                             '
                write(ilog,*)                                     &
                '-------------------------------------------'
                
                if (b_enable_output_gen) then
                  write(igen,*)                                   &
                  '-------------------------------------------'
                  write(igen,*)                                   &
                  '   terminated in routine heattran            '
                  write(igen,*)                                   &
                  '   maximum number of iterations exceeded   '
                  write(igen,*)                                   &
                  '   bye now ...                             '
                  write(igen,*)                                   &
                  '-------------------------------------------'
                end if
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop

!c  transient problem -> reduce time step

            elseif (transient_flow) then
              if(rank == 0 .and. b_enable_output)  then
                write(ilog,*)                                   & 
                '-------------------------------------------'
                write(ilog,*)                                   & 
                '   maximum number of iterations exceeded   '
                write(ilog,*)                                   &
                '             reducing time step            '
                write(ilog,*)                                   & 
                '-------------------------------------------'                
              end if
              reduce_timestep = .true.
            end if
          end if

!c  overflow occurred
!c  steady state problem -> terminate execution

        elseif (over_flow) then
          if (steady_flow) then
            if (rank == 0 .and. b_enable_output) then
              write(*,*)'-------------------------------------------'
              write(*,*)'   failure in solver - overflow occurred in heattran'
              write(*,*)'   bye now ...                             '
              write(*,*)'-------------------------------------------'

              write(ilog,*)'-------------------------------------------'
              write(ilog,*)'   failure in solver - overflow occurred in heattran'
              write(ilog,*)'   bye now ...                             '
              write(ilog,*)'-------------------------------------------'
                  
              if (b_enable_output_gen) then
                write(igen,*)'-------------------------------------------'
                write(igen,*)'   failure in solver - overflow occurred in heattran'
                write(igen,*)'   bye now ...                             '
                write(igen,*)'-------------------------------------------'
              end if
                  
            end if

            reduce_timestep = .true.

!c  transient problem -> reduce time step

          elseif (transient_flow) then
                
            if(rank == 0 .and. b_enable_output)  then  

              write(*,*)'-------------------------------------------'
              write(*,*)'   failure in solver - overflow occurred in heattran'
              write(*,*)'             reducing time step            '
              write(*,*)'-------------------------------------------'

              write(ilog,*)'-------------------------------------------'
              write(ilog,*)'   failure in solver - overflow occurred in heattran'
              write(ilog,*)'             reducing time step            '
              write(ilog,*)'-------------------------------------------'

            end if

            reduce_timestep = .true.
          end if
        end if                      !(over_flow)
          
        prt_heat_tot = cputime() - prt_heat_tot
          
!c  write runtime to file
        if(rank == 0 .and. b_prtfile) then
          write(iprt_heat, "(i8,1x,3(i3, 1x),i8,1x,7(1pe15.6e3,2x))")&
                mtime, iter_sia, iter_seep, iter_heat, ittot_heat,   &
                prt_heat_jac, prt_heat_symbfac, prt_heat_fac,        &
                prt_heat_sub, prt_heat_solver,                       &
                (prt_heat_tot - prt_heat_jac - prt_heat_solver),     &
                prt_heat_tot
            
          if(b_solver_test_pardiso) then
            write(iprt_heat_comp,                                    &
                  "(i8,1x,3(i3, 1x),i8,1x,5(1pe15.6e3,2x))")         &
                  mtime, iter_sia, iter_seep, iter_heat,             &
                  ittot_heat, prt_heat_fac, prt_heat_sub,            &
                  prt_heat_symbfac_comp, prt_heat_fac_comp,          &
                  prt_heat_sub_comp
          end if        
        end if

        if (reduce_timestep) then
          exit            
        end if
 
      end do          !newton iteration loop        
       
!c  reset primary and secondary unknowns for reduced time step
      if (reduce_timestep) then
        tempnew = tempold
        if (update_viscosity_temp) then 
          viscosity = viscoold
        end if 
        if (ispitzerdens) then
          density_pitzer = densold2_pitzer
          densold_pitzer = densold2_pitzer
        end if
        if (variably_saturated) then
          sgnew = sgold
          if (evaporation) then
            densvnew = densvold
            latvapnew = latvapold
          end if  
        end if
      end if      

!c  estimate time step size for next time level
!c  Parallelized, OpenMP, DSU
      if (transient_flow .and. .not.reduce_timestep) then
        call tstepheat
      end if 
      
!cprov-------------------------------------------------------------------------      
!cprov Deallocate local variables
!cprov-------------------------------------------------------------------------
      
      if (b_dynamic_memory) then
        call memory_monitor(-sizeof(aheat),'aheat',.true.)
        deallocate (aheat)
        call checkerr(ierr,'aheat',ilog)
        
        if (i_solver_type_heat == 0) then
            call memory_monitor(-sizeof(afheat),'afheat',.true.)
            deallocate (afheat)
            call checkerr(ierr,'afheat',ilog)     
        end if
      end if

      return
    end subroutine heattran