!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 786 $
!> $Author: dsu $
!> $Date: 2021-01-06 21:41:32 -0800 (Wed, 06 Jan 2021) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/iajavs_energybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine iajavs_energybal
!c --------------------
!c
!c set up ia-ja data-structure for variably saturated flow - 
!c secondary porosity, by duplicationg existing ia-ja structure 
!c      
!c                z
!c                     y
!c                7  
!c                |  5                  local connection list 
!c                | /                   for ja pointer array
!c                |/                    
!c       2--------1----------3  x     
!c               /|
!c              / |
!c             4  |
!c                6
!c
!c nonexistent connections (1D-2D-boundary effects) are skipped:
!c
!c      z
!c            
!c      4                     e.g.
!c      |                     x-z plane - on boundary x=0
!c      |                     
!c      |                     
!c      1----------2  x     
!c      |
!c      |
!c      |
!c      3
!c
!c written by:      Uli Mayer - July 7, 02 
!c
!c last modified:   -
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c
!c gen.f:    integer*4:
!c           ---------- 
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook                + -
!c           nn                 = total number of control volumes     + -
!c           iavs(nn+1)         = row pointer array for avs           * +
!c           javs(njavs)        = connectivity list                   * +
!c           isymvs(njavs)      = symmetry pointer array              * +
!c           njavs              = number of global connections        * +
!c
!c local:    idebug             = key for activation of debug output  
!c           irow               = counter (rows)
!c           i1                 = counter (column entries in row)
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine iajavs_energybal
 
      use parm
      use gen
#ifdef OPENMP
      use omp_lib 
#endif 

      implicit none
      
      integer :: i, ivol, iterm, istart, iend, isym, jvol, ierr
      
      integer, parameter :: i0=0

      external :: checkerr
     
      if (decoupled_type_vs_heat > 1) then

        !cdsu this part can be simplified to use data structure directly from flow

        njaheat = njavs
        
        allocate (iaheat(nngl+1), stat = ierr)
        call checkerr(ierr,'iaheat',ilog)
        call memory_monitor(sizeof(iaheat),'iaheat',.true.)
        iaheat = iavs

#ifdef PETSC
        allocate (row_idx_l2pg_heat(nngl+1), stat = ierr)        
        call checkerr(ierr,'row_idx_l2pg_heat',ilog)
        call memory_monitor(sizeof(row_idx_l2pg_heat),'row_idx_l2pg_heat',.true.)
        row_idx_l2pg_heat = row_idx_l2pg_vs
#endif  

        allocate (jaheat(njaheat), stat = ierr)        
        call checkerr(ierr,'jaheat',ilog)
        call memory_monitor(sizeof(jaheat),'jaheat',.true.)
        jaheat = javs

#ifdef PETSC 
        allocate (col_idx_l2pg_heat(njaheat), stat = ierr)
        call checkerr(ierr,'col_idx_l2pg_heat',ilog)
        call memory_monitor(sizeof(col_idx_l2pg_heat),'col_idx_l2pg_heat',.true.)
        col_idx_l2pg_heat = col_idx_l2pg_vs
#endif

        allocate (isymheat(njaheat), stat = ierr)
        call checkerr(ierr,'isymheat',ilog)
        call memory_monitor(sizeof(isymheat),'isymheat',.true.)
        isymheat = isymvs

      else
        njaglob = njavs*4 
      
        allocate (iaglob(2*nngl+1), stat = ierr)
        iaglob = i0
        call checkerr(ierr,'iaglob',ilog)
        call memory_monitor(sizeof(iaglob),'iaglob',.true.)

#ifdef PETSC
        allocate (row_idx_l2pg_glob(2*nngl+1), stat = ierr)
        row_idx_l2pg_glob = i0
        call checkerr(ierr,'row_idx_l2pg_glob',ilog)
        call memory_monitor(sizeof(row_idx_l2pg_glob),'row_idx_l2pg_glob',.true.)
#endif      
 
        allocate (jaglob(njaglob), stat = ierr)
        jaglob = i0
        call checkerr(ierr,'jaglob',ilog)
        call memory_monitor(sizeof(jaglob),'jaglob',.true.)

#ifdef PETSC 
        allocate (col_idx_l2pg_glob(njaglob), stat = ierr)
        col_idx_l2pg_glob = i0
        call checkerr(ierr,'col_idx_l2pg_glob',ilog)
        call memory_monitor(sizeof(col_idx_l2pg_glob),'col_idx_l2pg_glob',.true.)
#endif
 
        allocate (isymglob1(njavs), stat = ierr)
        isymglob1 = i0
        call checkerr(ierr,'isymglob1',ilog)
        call memory_monitor(sizeof(isymglob1),'isymglob1',.true.)

        allocate (isymglob2(njavs), stat = ierr)
        isymglob2 = i0
        call checkerr(ierr,'isymglob2',ilog)
        call memory_monitor(sizeof(isymglob2),'isymglob2',.true.)

        allocate (isymglob3(njavs), stat = ierr)
        isymglob3 = i0
        call checkerr(ierr,'isymglob3',ilog)
        call memory_monitor(sizeof(isymglob3),'isymglob3',.true.)

        allocate (isymglob4(njavs), stat = ierr)
        isymglob4 = i0 
        call checkerr(ierr,'isymglob4',ilog)
        call memory_monitor(sizeof(isymglob4),'isymglob4',.true.)

        iterm=i0 
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_iajavs_ener_1)                  &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i, iend, istart, iterm, ivol, jvol, isym)
#endif

#ifdef OPENMP
    !$omp do schedule(static)
#endif      
        do ivol = 1,nngl

          istart=iavs(ivol)
          iend=iavs(ivol+1)-1

#ifdef OPENMP
          iterm = 2*(iavs(ivol)-1)
#endif

          if (ivol==1) then
            iaglob(ivol)=1
            iaglob(nngl+ivol)=2*njavs+ivol
   !         else if (ivol==nngl+1) then
   !         iaglob(nngl+ivol)=iavs(ivol)+3*njavs
          else 
            iaglob(ivol)=2*iavs(ivol)-1
            iaglob(nngl+ivol)=2*iavs(ivol)-1 + 2*njavs 
          end if  
       
#ifdef PETSC
          row_idx_l2pg_glob(ivol) = 2*(node_idx_lg2pg(ivol))-1       
          row_idx_l2pg_glob(nngl+ivol) = row_idx_l2pg_glob(ivol) + 1
!#ifdef DEBUG
!       write(idbg,'(2(a,1x,i,1x))') "ivol",ivol,"row_idx_l2pg_glob",row_idx_l2pg_glob(ivol)
!#endif       
          if(node_idx_lg2l(ivol) < 0) then
            row_idx_l2pg_glob(ivol) = - row_idx_l2pg_glob(ivol)
            row_idx_l2pg_glob(nngl+ivol) = - row_idx_l2pg_glob(nngl+ivol)
          end if
#endif
     
      ! for the first cuadrant
        do i=istart,iend
          iterm = iterm + 1     
          jvol = javs(i)
          jaglob(iterm) = jvol
          isym = isymvs(i)
          isymglob1(isym)=iterm
          
#ifdef PETSC
          col_idx_l2pg_glob(iterm) = 2*(node_idx_lg2pg(jvol))-1
#endif         
        end do
        ! for the second cuadrant 
        do i=istart,iend
          iterm=iterm+1
          jvol = javs(i)
          jaglob(iterm)=jvol+nngl
          isym = isymvs(i)
          isymglob2(isym)=iterm
          
#ifdef PETSC
          col_idx_l2pg_glob(iterm) = 2*(node_idx_lg2pg(jvol))
#endif         
        end do 
        
      end do 
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
    
#ifdef OPENMP
    !$omp single
#endif
      iaglob(2*nngl+1)=iavs(nngl+1)+3*njavs
#ifdef OPENMP
    !$omp end single
#endif      
     
#ifdef OPENMP
    !$omp do schedule(static)
#endif 
      do ivol=1,nngl
        
        istart=iavs(ivol)
        iend=iavs(ivol+1)-1
        
#ifdef OPENMP
       iterm = 2*(iavs(nngl+1) + iavs(ivol) - 2)
#endif

        ! for the third cuadrant
        do i=istart,iend
          iterm=iterm+1
          jvol = javs(i)
          jaglob(iterm)=jvol+nngl
          isym = isymvs(i)
          isymglob3(isym)=iterm  
          
#ifdef PETSC
          col_idx_l2pg_glob(iterm) = 2*(node_idx_lg2pg(jvol))
#endif         
        end do
        ! for the forth cuadrant 
        do i=istart,iend
          iterm=iterm+1
          jvol = javs(i)
          jaglob(iterm)=jvol
          isym = isymvs(i)
          isymglob4(isym)=iterm 
          
#ifdef PETSC
          col_idx_l2pg_glob(iterm) = 2*(node_idx_lg2pg(jvol))-1
#endif
        end do
      
      end do    
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif
    
#ifdef OPENMP
    !$omp end parallel
#endif      
      end if

      return
      end
