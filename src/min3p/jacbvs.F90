!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacbvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacbvs
!c -----------------
!c
!c incorporate dirichlet and neumann type boundary condition in 
!c jacobian matrix and rhs vector for variably saturated flow 
!c
!c written by:      Uli Mayer - May 6, 96
!c
!c last modified:   Tom Henderson - March 20, 2003
!c                  added point source
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = Jacobian matrix                     + +
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           bvs(nn)            = rhs vector                          + +
!c           
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           njavs              = number of global connections        + -
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c dens.f:   real*8:
!c           -------
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density 
!c                                           dependent flow
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           ibvs               = counter (boundary control volumes)
!c           istart             = pointer (start of row) 
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal entry)
!c           i1                 = counter (row entries)
!c           info_debug         = debugging information level
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine jacbvs
 
      use parm
      use gen
      use dens
      use phys
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use usg_mesh_data, only : node_cells, node_num_cells
#endif
 
      implicit none
      
      integer :: i1, ibvs, idiag, istart, iend, ivol, info_debug,      &
                 ivol_gbl, ivol_track
#ifdef USG
      integer :: icell, ncell, cindex
#endif

      real*8 :: condz_free, relp_loc

      real*8, external :: fluxvs_free_drainage

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0

    
!c  debug toggle
 
      info_debug = 0

      if(ittot_vs.eq.1) then
        info_debug = 0
        ivol_track = -1
      else
        info_debug = 0
        ivol_track = -1
      end if

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, ncell, cindex,                                       &
#endif
    !$omp i1, ibvs, idiag, iend, istart, ivol, ivol_gbl,              &
    !$omp condz_free, relp_loc)
    
!c  loop over boundary control volumes
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 

#endif  
      do ibvs = 1,nbvs
          
        ivol = iabvs(ibvs)
        if (ivol < 0) then
          cycle  
        end if

        if (compute_ice_sheet_loading) then
          if (.not. b_iabvs_ice(ibvs)) then
            cycle
          end if
        end if

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif
          
!c  modify for second type flow boundary condition and
!c  point source boundary
!c  calculate mass flux
 
        if ((btypevs(ibvs).eq.'second') .or.                           &
            (btypevs(ibvs).eq.'seepage-second' .and.                   &
            ibits(seepage_bits(ibvs),1,1).eq.1) .or.                   &
            (btypevs(ibvs).eq.'free-drainage') .or.                    &
            (btypevs(ibvs).eq.'point')) then

          if (btypevs(ibvs).eq.'free-drainage') then

            if (permeability_field) then
#ifdef USG
              if (discretization_type > 0 .and. is_cell_based_perm_cond) then
                ncell = node_num_cells(ivol)
                condz_free = r0
                do icell = 1, ncell
                  cindex = node_cells(icell,ivol)
                  condz_free = condz_free + permz(cindex)
                end do
                condz_free = condz_free / ncell
              else
#endif
                condz_free = permz(ivol)
#ifdef USG
              end if
#endif
            else
              condz_free = condzz(mpropvs(ivol))*k_depth_ratio(ivol)
            end if

#ifdef USG
            if (discretization_type > 0 .and. is_cell_based_relp) then
              ncell = node_num_cells(ivol)
              relp_loc = r0
              do icell = 1, ncell
                cindex = node_cells(icell,ivol)
                relp_loc = relp_loc + relperm(cindex)
              end do
              relp_loc = relp_loc / ncell
            else
#endif
              relp_loc = relperm(ivol)
#ifdef USG
            end if
#endif

            if (density_dependence) then
              !c for density dependent flow, permeability is stored in permz and condzz
              condz_free = condz_free*density(ivol)*gacc/viscosity(ivol)
            end if

            bcondvs(ibvs) =  - fluxvs_free_drainage(relp_loc,          &
                                      condz_free,perm_fac(ivol),       &
                                      gradf_bvs(ibvs),areaf_bvs(ibvs))
          end if

          if ((density_dependence).and.(.not.flow_verification)) then
            bvs(ivol) = bvs(ivol) + bcondvs(ibvs)*ssdens(ivol)
          else
            bvs(ivol) = bvs(ivol) + bcondvs(ibvs)
          end if

#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              write(idbg,'(a,1x,i6,1x,3(a,1x,1pe15.6e3,1x))')          &
                    "-->jacbvs A ivol",ivol,"bcondvs",bcondvs(ibvs),   &
                    "ssdens",ssdens(ivol),"bvs(ivol)",bvs(ivol)
            end if
          end if
#endif

          continue
!c  modify for first type boundary and zero pressure seepage face
!c  boundary conditions
 
        elseif ((btypevs(ibvs).eq.'first').or.           &
                (btypevs(ibvs).eq.'seepage' .or.         &
                 btypevs(ibvs).eq.'seepage-second').and. &
                 ibits(seepage_bits(ibvs),0,1).eq.1) then

          istart = iavs(ivol)          !pointer - start of row
          iend = iavs(ivol+1)-1        !pointer - end of row
          idiag = iavs(ivol)           !pointer - diagonal

          do i1=istart,iend            !modify matrix and rhs
            avs(i1) = r0
          end do
          avs(idiag) = r1
          bvs(ivol) = r0 
 
        end if                        !(btypevs(ibvs).eq......)

      end do                          !loop - boundary control volumes 
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif      

      continue 
!cdbg
#ifdef DEBUG
      if (info_debug.gt.100) then
        write(idbg,'(/a/)') 'flow jacobian' 
        do ivol=1,nngl
          istart = iavs(ivol)
          iend = iavs(ivol+1)-1
          write(idbg,'(8es16.8)')(avs(i1),i1=istart,iend),bvs(ivol) 
        end do
      end if
#endif
      if (info_debug.gt.100) then
        if (mtime .eq. 10) then 
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if 
!cdbg

      return
      end
