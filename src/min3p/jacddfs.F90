!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacddfs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacddfs
!c ----------------
!c
!c pressure formulation
!c accounts for presence of DNAPL phase
!c 
!c
!c construct Jacobian matrix and rhs-vector (density-dependent flow)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - August 16, 2002
!c
!c last modified:   Tom Henderson - December 16, 2003
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     - +
!c           bvs(nn)            = rhs vector                          - +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation
!c           pornew(nn)         = porosity (new time level)           + -
!c           relperm(nn)        = relative permeability               * +
!c           relpinc(nn)        = relative permeability (incremented) * *
!c           sainc(nn)          = aqueous phase saturation            * *
!c                                - incremented
!c           sanew(nn)          = aqueous phase saturation            * +
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           uvsinc(nn)         = solution vector (incremented)       * *
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c
!c dens.f:   real*8:
!c           -------
!c           del_p(ncon-1)      = difference in total                 + -       
!c                                pressure potential
!c           del_z(ncon-1)      = difference in                       + -                   
!c                                elevation potential
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + -  
!c           viscosity(nn)      = fluid viscosity                     + -
!c           dcoef(ncon-1)      = coefficient including density       + -
!c                                and viscosity 
!c           rho_av             = average density between ivol        + -
!c                                and jvol
!c
!c           integer*4
!c           ---------
!c           iter_sia           = iteration counter -Picard iteration * - 
!c
!c local:    real*8:
!c           -------
!c           dqroot             = derivative of root water uptake
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsstor            = derivative of storage term
!c           dvsflux            = derivative of flux term
!c           hhinc              = hydraulic head (incremented)
!c           qroot              = root water uptake for current
!c                                control volume
!c           qrootinc           = root water uptake for current 
!c                                control volume (incremented)
!c           totvsflux          = total flux into current control 
!c                                volume
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           r0                 = constant
!c           r1                 = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ivol               = counter (control volumes)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           isym               = symmetry pointer
!c           jvol               = row-column pointer
!c
!c external: rhsvs     = assembly of rhs vector
!c           storddfs  = storage function for fully saturated 
!c                       density dependent flow 
!c           fluxdd    = flux function for fully saturated 
!c                       density dependent flow
!c           soilparm  = soil hydraulic parameters
!c ----------------------------------------------------------------------
 
      subroutine jacddfs
 
      use parm
      use gen
      use phys
      use dens
#ifdef OPENMP
      use omp_lib 
#endif 
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif 

#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols,num_nodes_per_cell,     &
                                num_edge_maxcells,cells, num_cells
      use gradient_usg, only : gradient_cross_diff_dd,                 &
                               gradient_cross_diff_dd_inc
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxdd_usg, only : fluxdd_usg
#endif

      implicit none
      
      integer :: i1, icon, idiag, istart, iend, isym, ivol, izn, jvol, &
                 info_debug, itemp, ivol_track, ivol_gbl
      
      real*8 :: delt_loc, totvsflux, densnew_ivol, densold_ivol,       &
                sanew_ivol, saold_ivol, relperm_av, visco_av, vsstor,  &
                dinc_vs_loc, porinc_ivol, dtotvsflux, del_pinc,        &
                vsfluxinc, dvsflux, vsstorinc, dvsstor, ph_ivol,       &
                stor_ivol, permx_ivol, permz_ivol,                     &
                densnewc_ivol, densoldc_ivol, tdsnew_ivol, tdsold_ivol
      real*8, external :: relpfsat, storddfs, fluxdd, porosity_flow
     
      integer :: chunk

      external :: rhsvs, zero_r8

      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1 = 1.0d0,      &
                           r2 = 2.0d0, r3 = 3.0d0, r4 = 4.0d0,         &
                           r86400 = 86400.0d0
      logical                :: updatepor
      
#ifdef USG
      integer :: i2, icell, idvol, kvol, ncell, ndvol, nrelp
      real*8 :: sanew_loc
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells),  &
                flux_ddflow_inc_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_locs(num_crossdifficv_max)
      type(point) :: grad_ddflow_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_ddflow_inc_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif

      if(iter_vs.eq.1) then
        info_debug = -1
        ivol_track = -1
      else
        info_debug = -1
        ivol_track = -1
      end if

      vsstorinc = r0
      
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
            if(mod(chunk, i_chunksize_factor_flow) > 0) then
                chunk = chunk/i_chunksize_factor_flow + 1
            else
                chunk = chunk/i_chunksize_factor_flow
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif
      
!c  debug toggle

      if (iter_sia==1) then
        delt_loc=delt_tds
      else
        delt_loc=delt
      end if

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp i2, icell, idvol, kvol, nrelp, ndvol, relps_loc, sanew_loc, &
    !$omp grad_ddflow_mids, grad_ddflow_inc_mids, grad_locs,          &
    !$omp flux_ddflow_hls_corr, flux_ddflow_inc_hls_corr,             &
    !$omp grad_weights, grad_ddflow_hls_loc,                         &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc,                       &
#endif
    !$omp i1, icon, idiag, iend, istart, isym, ivol, izn,             &
    !$omp jvol, dcoef, del_p, del_pinc, del_z, dinc_vs_loc,           &
    !$omp densnew_ivol, densold_ivol, densnewc_ivol, densoldc_ivol,   &
    !$omp dtotvsflux, dvsflux, dvsstor, porinc_ivol, relperm_av,      &
    !$omp rho_av, sanew_ivol, saold_ivol, totvsflux, visco_av,        &
    !$omp vsflux, vsfluxinc, vsstor, vsstorinc,                       &
    !$omp tdsnew_ivol, tdsold_ivol)
#endif

!c calculate relative permeability to account for the presence
!c of a napl phase

      if (napl_permeability) then
#ifdef USG
        if (discretization_type > 0 .and. is_cell_based_relp) then
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
          do icell = 1,num_cells             !loop over cells
            izn = mpropvs_cell(icell)

            sanew_loc = 0.0d0
            do i2 = 1, num_nodes_per_cell
              sanew_loc = sanew_loc + sanew(cells(i2,icell))
            end do
            sanew_loc = sanew_loc / num_nodes_per_cell

            if (napl_kfunction .eq. 'vangenuchten') then
              relperm(icell) = relpfsat(sanew_loc,swr(izn),expn(izn),spgamma(izn))
            else if (napl_kfunction .eq. 'corey') then
              relperm(icell) = ((sanew_loc - swr(izn))/(r1 - swr(izn)))**r4
            end if
          end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
        else
#endif

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
          do ivol = 1,nngl             !loop over control volumes
            izn = mpropvs(ivol)
            if (napl_kfunction .eq. 'vangenuchten') then

              relperm(ivol) = relpfsat(sanew(ivol),swr(izn),expn(izn),spgamma(izn))

            else if (napl_kfunction .eq. 'corey') then

              relperm(ivol) = ((sanew(ivol) - swr(izn))/(r1 - swr(izn)))**r4

            end if
          end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef USG
        end if
#endif

      end if

!c  build jacobian matrix
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
      do ivol = 1,nngl             !loop over control volumes

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        idiag = iavs(ivol)       !pointer - diagonal
        istart = iavs(ivol)+1    !pointer - start (off-diagonal entries)
        iend = iavs(ivol+1)-1    !pointer - end (off-diagonal entries)

!c  calculate storage and flux terms for current control volume

        totvsflux = r0           !initialize total influx
        icon = 0                 !counter (connections)
        
        !cdsu convergence problem if using formula below
        !cdsu need further check, DSU 2020-01-07
        !if (iter_sia==1) then
        !  densnew_ivol = densold(ivol)
        !  densold_ivol = densold2(ivol)
        !  sanew_ivol = saold(ivol)
        !  saold_ivol = saold2(ivol)
        !  tdsold_ivol = tds_old2(ivol)
        !  tdsnew_ivol = tds_old(ivol)
        !else
        !  densnew_ivol = density(ivol)
        !  densold_ivol = densold(ivol)
        !  sanew_ivol = sanew(ivol)
        !  saold_ivol = saold(ivol)
        !  tdsold_ivol = tds_old(ivol)
        !  tdsnew_ivol = tds_new(ivol)
        !end if

        sanew_ivol = sanew(ivol)
        saold_ivol = saold(ivol)
        densnew_ivol = density(ivol)
        densold_ivol = densold(ivol)
        tdsold_ivol = tds_old(ivol)
        tdsnew_ivol = tds_new(ivol)

        if (ispitzerdens) then
          if (heat_transport) then
            densoldc_ivol = densold_pitzer(ivol)
            densnewc_ivol = density_pitzer(ivol)
          else
            !c density_pitzer is not avaialbe without heat transport
            !c use the following formula which is same as non-pitzer density
            densoldc_ivol = drho_dc*tdsold_ivol
            densnewc_ivol = drho_dc*tdsnew_ivol
          end if
        else
          densoldc_ivol = r0
          densnewc_ivol = r0
        end if
        

        do i1=istart,iend        !loop over connected control volumes

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          jvol = javs(i1)        !column pointer

!c  compute difference in total presure potential between  
!c  current and adjacent control volumes Pjvol - Pivol
          icon = icon+1          !counter (row entries)hen

          del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
          del_z(icon) = zg(jvol) - zg(ivol)

          if (del_z(icon)/=r0) then
            rho_av = rhalf * (density(ivol) + density(jvol))

            if (av_dens_z) then
              del_p(icon) = rho_av*(uvsnew(jvol)/density(jvol)-        &
                                    uvsnew(ivol)/density(ivol))
            end if

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
            del_z(icon) = del_z(icon) * rho_av * gacc
            del_p(icon) = del_p(icon) + del_z(icon)
          end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
          if (is_cell_based_relp) then
            if (del_p(icon) > r0) then
              visco_av = ups_flow*viscosity(jvol)+(r1-ups_flow)*viscosity(ivol)
              rho_av = ups_flow*density(jvol)+(r1-ups_flow)*density(ivol)
            else
              visco_av = ups_flow*viscosity(ivol)+(r1-ups_flow)*viscosity(jvol)
              rho_av = ups_flow*density(ivol)+(r1-ups_flow)*density(jvol)
            end if
            dcoef(icon) = rho_av / visco_av
          else
            if (del_p(icon) > r0) then
              relperm_av = ups_flow*relperm(jvol)+(r1-ups_flow)*relperm(ivol)
              visco_av = ups_flow*viscosity(jvol)+(r1-ups_flow)*viscosity(ivol)
              rho_av = ups_flow*density(jvol)+(r1-ups_flow)*density(ivol)
            else
              relperm_av = ups_flow*relperm(ivol)+(r1-ups_flow)*relperm(jvol)
              visco_av = ups_flow*viscosity(ivol)+(r1-ups_flow)*viscosity(jvol)
              rho_av = ups_flow*density(ivol)+(r1-ups_flow)*density(jvol)
            end if
            dcoef(icon) = relperm_av * rho_av / visco_av
          end if

    
!c  compute fluxes between current control volume and adjacent 
!c  control volumes
          if (b_use_fixed_flow_vel) then
              
            if (b_use_zero_flow_vel) then
              vsflux(icon) = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
            if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_ddflow_mids = vector_zero
              flux_ddflow_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_dd(i1,ivol,jvol,              &
                     grad_locs,grad_ddflow_mids,grad_weights,          &
                     flux_ddflow_hls_corr,grad_ddflow_hls_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = 1.0d0
              end if

              vsflux(icon) = -fluxdd_usg(del_p(icon),num_edge_dvols,ncell,       &
                                grad_ddflow_mids(1:num_edge_dvols,1:ncell),      &
                                flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell),  &
                                cinfvs_usg_loc(1:num_edge_dvols,1:ncell),        &
                                cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell),  &
                                is_cell_based_relp,nrelp,                        &
                                relps_loc(1:nrelp)*dcoef(icon))
            else
#endif
              vsflux(icon) = - fluxdd(del_p(icon),cinfvs_a(i1),dcoef(icon))
#ifdef USG
            end if
#endif
          end if

!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no fluid flux between them
!cdsu fix bug
          !if (pore_clogging) then
          !  if (pornew(ivol) <= por_thresh_min .or.                    &
          !      pornew(jvol) <= por_thresh_min)  then
          !     vsflux(icon) = r0
          !  end if        
          !end if  
            
          totvsflux = totvsflux + vsflux(icon)

        end do                   !loop over connected control volumes

!c for the first picard iteration, TDS and saturations used for storage
!c calculations are taken from time levels N and N-1.  Saturations are a function
!c of computed NAPL saturations

        if (transient_flow) then
            vsstor = cvol(ivol)* storddfs(delt,delt_loc,              &
                                 pornew(ivol),porold(ivol),           &
                                 sanew_ivol,saold_ivol,               &
                                 densnew_ivol,densold_ivol,           &
                                 densnewc_ivol,densoldc_ivol,         &
                                 tdsnew_ivol,tdsold_ivol,             &
                                 r0,r0,drho_dc,r0,                    &
                                 uvsnew(ivol),uvsold(ivol),stor(ivol),&
                                 new_stor_deri,coupled_porpress,      &
                                 .false.,ispitzerdens,.false.,        &
                                 r0,r0,r0,r0)
        else
            vsstor = 0.0d0
        end if                   !(transient_flow)

!c  assembly of storage and flux terms in rhs vector
!c Anna Harrison added qh2o term Jan 24 2014
        if(water_removal) then
          totvsflux = totvsflux+qh2o(ivol)/delt  
        end if

        call rhsvs(vsstor,totvsflux,bvs(ivol))

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
           write(idbg,'(3(a,1x,1pe15.6e3,1x),2(a,1x,i6,1x))')          &
                 "-->jacddfs->rhsvs vsstor", vsstor, "totvsflux",      &
                 totvsflux, "bvs", bvs(ivol),"ivol",ivol
#ifdef PETSC     
           do itemp = iavs(ivol), iavs(ivol+1)-1
             write(idbg,"(3(a,1x,i6,1x))") "rank",rank,                &
                   "ivol",node_idx_lg2g(ivol),                         &
                   "jvol",node_idx_lg2g(javs(itemp))
           end do
#endif
        end if
#endif

!cprovi--------------------------------------------------------------------
!cprovi increment primary unknown (fluid pressure)
!cprovi If the process is iterative, the increment is a factor of the 
!cprovi fluid pressure 
!cprovi--------------------------------------------------------------------
        !c old code
        !if (iterative_solver_flow.and.uvsnew(ivol)/=r0) then
        !  dinc_vs_loc = uvsnew(ivol)*dinc_vs
        !else
        !  dinc_vs_loc = dinc_vs
        !end if 
!cdsu  --------------------------------------------------------------------
!cdsu  The above part is buggy. When uvsnew is very small or very large, 
!cdsu  this gives very small or large increment, causing zero diagonal entry 
!cdsu  in the matrix or numerical unstable.
!cdsu  By Danyang Su, 2020-06-04.
!cdsu  --------------------------------------------------------------------

        !c new code
        dinc_vs_loc = dinc_vs

        uvsinc(ivol) = uvsnew(ivol) + dinc_vs_loc
        
        
        if (modify_por(ivol)) then
            porinc_ivol = porosity_flow(porold(ivol),uvsinc(ivol), & 
                          uvsold(ivol),stor(ivol), &
                          por_stress_dt(ivol),por_init(ivol),facpormin)
        else
            porinc_ivol = pornew(ivol)               
        end if
        
        

!c  calculate derivatives of storage and flux terms for current 
!c  control volume (assembly columnwise)

        dtotvsflux = r0          !initialize derivative of total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          jvol = javs(i1)        !column pointer
          isym = isymvs(i1)      !symmetry pointer

          icon = icon+1

          del_pinc = uvsnew(jvol) - uvsinc(ivol)
          del_pinc = del_pinc + del_z(icon)

!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions
!c  flux with incremented variables and derivative of flux
          if (b_use_fixed_flow_vel) then
              
            if (b_use_zero_flow_vel) then
              vsfluxinc = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
!c calculate gradient for ivol
            if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_ddflow_inc_mids = vector_zero
              flux_ddflow_inc_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_dd_inc(i1,ivol,jvol,          &
                     dinc_vs_loc,r0,grad_locs,                         &
                     grad_ddflow_inc_mids,grad_weights,                &
                     flux_ddflow_inc_hls_corr,grad_ddflow_hls_loc)                
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = 1.0d0
              end if

              vsfluxinc = -fluxdd_usg(del_pinc,num_edge_dvols,ncell,             &
                             grad_ddflow_inc_mids(1:num_edge_dvols,1:ncell),     &
                             flux_ddflow_inc_hls_corr(1:num_edge_dvols,1:ncell), &
                             cinfvs_usg_loc(1:num_edge_dvols,1:ncell),           &
                             cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell),     &
                             is_cell_based_relp,nrelp,                           &
                             relps_loc(1:nrelp)*dcoef(icon))

#ifdef DEBUG
              if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.     &
                  ivol_track == 0)) then
                if (vsfluxinc /= vsfluxinc) then
                  write(*,'(a,1x,i6,1x,a,1x,1pe15.6e3,1x)')              &
                        "NaN found from in vsfluxinc rank",rank,         &
                        "del_pinc",del_pinc
  
                  do icell = 1, ncell
                    do idvol = 1, num_edge_dvols
                      write(idbg,'(a,1x,i6,1x,a,1x,1pe15.6e3)')          &
                            "icell",icell,"idvol",idvol,"cinfvs_usg",    &
                            cinfvs_usg_loc(idvol,icell)
  
                      write(idbg,'(2(a,1x,3(1pe15.6e3,1x)))')            &
                            "grad_ddflow_inc_mids",                      &
                            grad_ddflow_inc_mids(idvol,icell)%x,         &
                            grad_ddflow_inc_mids(idvol,icell)%y,         &
                            grad_ddflow_inc_mids(idvol,icell)%z,         &
                            "cinfvs_usg_cross",                          &
                            cinfvs_usg_cross_loc(idvol,icell)%x,         &
                            cinfvs_usg_cross_loc(idvol,icell)%y,         &
                            cinfvs_usg_cross_loc(idvol,icell)%z
                    end do
                  end do
  
                end if
              end if
#endif

            else
#endif
              vsfluxinc = - fluxdd(del_pinc,cinfvs_a(i1),dcoef(icon))
#ifdef USG
            end if
#endif
          end if

          dvsflux = (vsfluxinc - vsflux(icon))/dinc_vs_loc
          
!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no fluid flux between them
!cdsu fix bug, comment to avoid setting matrix diag entry to zero
          !if (pore_clogging) then
          !  if (pornew(ivol) <= por_thresh_min   .or.                  &
          !      pornew(jvol) <= por_thresh_min)  then
          !    dvsflux = r0
          !    vsfluxinc = r0
          !  end if        
          !end if  
          
          dtotvsflux = dtotvsflux + vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
 
          avs(isym) = avs(isym) - dvsflux    !off-diagonal entries

#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            if (dvsflux /= dvsflux) then
              write(idbg,'(a,1x,i6,1x,3(a,1x,1pe15.6e3,1x))')          &
                    "NaN found from in dvsflux rank",rank,             &
                    "vsfluxinc",vsfluxinc,"vsflux(icon)",vsflux(icon), &
                    "dinc_vs_loc",dinc_vs_loc
            end if
          end if
#endif

        end do                  !loop over connected control volumes

!c  compute storage term with incremented variables (lumped)
!c  for current control volume, only for transient conditions
        if (transient_flow) then
          vsstorinc = cvol(ivol)* storddfs(delt,delt_loc,          &
                                  porinc_ivol,porold(ivol),        &
                                  sanew_ivol,saold_ivol,           &
                                  densnew_ivol,densold_ivol,       &
                                  densnewc_ivol,densoldc_ivol,     &
                                  tdsnew_ivol,tdsold_ivol,         &
                                  r0,r0,drho_dc,r0,                &
                                  uvsinc(ivol),uvsold(ivol),       &
                                  stor(ivol),new_stor_deri,        &
                                  coupled_porpress,                &
                                  .false.,ispitzerdens,.false.,    &
                                  r0,r0,r0,r0)
        else
          vsstorinc = 0.0d0
        end if                   !(transient_flow)
       
!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs_loc             
        
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs_loc

        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  

#ifdef DEBUG
    if (info_debug.eq.1) then
        write(idbg,'(5(g12.4,2x))') ivol,                             &
     &                              idiag,                            &
     &                              avs(idiag),                       &
     &                              dvsstor,                          &
     &                              dtotvsflux
    end if
    
    if (info_debug==2.and.uvsnew(ivol)<r0) then
        write(idbg,*) '----------------------------------------------'
        write(idbg,*) '             NEGATIVE PRESSURES               '
        write(idbg,*) '----------------------------------------------'
        write(idbg,*) '    ivol        Paivol         dens         '//&
                      '    por           kzz        x      y      z'
        write(idbg,'(i8,7(1pe15.6e3))')                               &
              ivol,uvsnew(ivol),density(ivol),pornew(ivol),           &
              permz(ivol),xg(ivol),yg(ivol),zg(ivol)
        icon=0    
        write(idbg,*) '----------------------------------------------'
        do i1=istart,iend 
           icon=icon+1
           jvol=javs(i1)
           write(idbg,*) 'connection with:',jvol
           write(idbg,*) 'x jvol:', xg(jvol)
           write(idbg,*) 'y jvol:', yg(jvol)
           write(idbg,*) 'z jvol:', zg(jvol)
           write(idbg,*) 'Pa jvol:', uvsnew(jvol)
           write(idbg,*) 'Dens jvol:', density(jvol)
           write(idbg,*) 'Por jvol:', pornew(jvol)
           write(idbg,*) 'Kzz jvol:', permz(jvol)
           write(idbg,*) '-------------------------------------------'
           write(idbg,*) '         vel            dPa            dz'//&
     &                   '         (A/D)kzz'
           write(idbg,*) '-------------------------------------------'
           write(idbg,'(4(1pe15.6e3))') vsflux(icon), del_p(icon),    &
     &                            del_z(icon),cinfvs_a(i1)
        end do
        write(idbg,*) '----------------------------------------------'
        write(idbg,*) '----------------------------------------------'
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop 
      elseif (info_debug==3.and.uvsnew(ivol)<r0) then 
          ph_ivol=uvsnew(ivol)/(density(ivol)*gacc)    
          stor_ivol=stor(ivol)*(ref_dens*gacc)
          permx_ivol=permx(ivol)/r86400
          permz_ivol=permz(ivol)/r86400
          write(*,'(a27,i8)') 'Negative pressure in ivol:',ivol
          write(*,'(a9,1pe15.6e3)') 'x(ivol):',xg(ivol)
          write(*,'(a9,1pe15.6e3)') 'y(ivol):',yg(ivol)
          write(*,'(a9,1pe15.6e3)') 'z(ivol):',zg(ivol)
          write(*,'(a9,1pe15.6e3)') 'Pa [m]:',ph_ivol
          write(*,'(a16,1pe15.6e3)') 'por(ivol) [-]:',pornew(ivol)
          write(*,'(a21,1pe15.6e3)') 'dens(ivol) [kg m-3]:',density(ivol)
          write(*,'(a26,1pe15.6e3)') 'visco(ivol) [kg m-1 s-1]:',         &
     &                            viscosity(ivol)
          write(*,'(a18,1pe15.6e3)') 'stor(ivol) [m-1]:',stor_ivol
          write(*,'(a18,1pe15.6e3)') 'kxx(ivol) [m2]:',permx_ivol
          write(*,'(a18,1pe15.6e3)') 'kzz(ivol) [m2]:',permz_ivol
      end if
#endif

      end do                          !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

!cdbg
#ifdef DEBUG
    if (info_debug.eq.1) then
        write(idbg,'(4x,5a12)') 'ivol        ',                       &
     &                          'idiag       ',                       &
     &                          'avs(idiag)  ',                       &
     &                          'dvsstor     ',                       &
     &                          'dtotvsflux  '
      end if
#endif      
       
      
      
!   10 continue   
  

      return
      end
