!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/tstepheat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine tstepheat
!c ------------------
!c
!c estimate magnitude of next time step (decoupled heat transport)
!c based on the method of Sammon and Forsyth, J. of Computational 
!c Physics, Vol.62, 265-281, 1986
!c
!c written by:      Danyang Su - May 31, 2020
!c
!c last modified:   Danyang Su - May 31, 2020
!c
!c                  HPC capabilities
!c
!c
!c ----------------------------------------------------------------------

      subroutine tstepheat

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use dens
#ifdef OPENMP
      use omp_lib 
#endif 

      implicit none
     
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: ivol
      real*8 :: delta_heat
      real*8 :: delt_heat_iter
      
#ifdef PETSC
      real*8 :: delta_heat_gbl
      PetscErrorCode :: ierrcode
#endif

      real*8, parameter :: enat = 2.71828182845904509d0,               &
                           r0=0.0d0,rhalf=0.5d0,r5=5.0d0,rsmall=1.0d-10       

!c  calculate maximum saturation change 

      delta_heat = r0
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)                                              &
    !$omp reduction(max:delta_heat)
    !$omp do schedule(static)
#endif  
      do ivol=1,nngl
!#ifdef PETSC 
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#endif
        delta_heat = dmax1(delta_heat,dabs(tempnew(ivol)-tempold(ivol)))
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(delta_heat, delta_heat_gbl,1,MPI_REAL8,       & 
                 MPI_MAX, Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      delta_heat = delta_heat_gbl
#endif

!c  calculate average newton iteration numbers in each timestep.
      if (iter_heat_ant > 0) then
        if (iter_sia <= 1) then
          iter_heat_ave = max(real(iter_heat),1.0d0)
        else
          iter_heat_ave = (iter_heat_ave*(iter_sia-1) + iter_heat)/iter_sia
        end if
!c  compute factor based on anticipated number of Newton iterations
!c  assume linear relationship for now        
        delt_heat_iter = iter_heat_ant/iter_heat_ave
!c  use more aggressive strategy to push the upper limit of
!c  iter_heat_ant, time step increase must be larger than time
!c  step decrease, if iter_heat = iter_heat_ant+1
        if (iter_heat_ave <= iter_heat_ant) then
          delt_heat_iter = real(iter_heat_ant+2)/real(iter_heat_ant)*  &
                         delt_heat_iter
        end if
!c  take square root of factor for smoother changes
        delt_heat_iter = sqrt(delt_heat_iter)                
      else
        delt_heat_iter = r5
      end if

!c  new time step estimate for decoupled heat transport

      delt_heat = (enat**uheatant_log)/(delta_heat+rsmall)*delt  !first estimate
      delt_heat = dmin1(delt_heat, delt_heat_iter*delt)          !upper bound - max. increase
      delt_heat = dmin1(delt_heat, deltmax)                      !upper bound - max. time step
      delt_heat = dmax1(delt_heat, rhalf*delt)                   !lower bound - max. decrease
      delt_heat = dmax1(delt_heat, deltmin)                      !lower bound - min. time step

      return
      end
