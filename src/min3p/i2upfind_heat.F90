!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/i2upfind_heat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine i2upfind
!c -------------------
!c
!c assign pointers to second upstream point for flux limiter
!c
!c written by:      Uli Mayer - February 10, 98
!c
!c last modified:   -
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           cinfrt_va(njavs)   = influence coefficients              + -
!c                                (advection - aqueous phase)
!c
!c           integer*4:
!c           ----------
!c           i2up(nn)           = pointer array to second upstream    * +
!c                                point
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           idbg               = unit number - debugging file        + -
!c           javs(njavs)        = connectivity list                   + -
!c           nn                 = total number of control volumes     + -
!c     
!c
!c local:    real*8:
!c           -------
!c           cinvrt_va_max      = max. inflow in control volume ivol
!c                                (Note: signs are negative)
!c           r0                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (entries in ja, a arrays 
!c                                         for 1d-scalar matrix)
!c           icon               = pointer (off-diagonal connections)
!c           istart             = pointer (first off diagonal entry 
!c                                         in row for 1d-scalar 
!c                                         matrix)
!c           istop              = pointer (last off-diagonal entry 
!c                                         in row for 1d-scalar 
!c                                         matrix)
!c           ivol               = counter (control volumes)
!c           jvol               = pointer (column in 1d-scalar 
!c                                         matrix)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine i2upfind_heat
 
      use parm
      use gen
      use dens
      use phys, only : is_cell_based_relp
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols,num_edge_maxcells
      use gradient_usg, only : gradient_cross_diff_dd
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxdd_usg, only : fluxdd_usg
#endif

      implicit none
      
      integer :: i1, i2, ivol, istart, istop, icon, jvol
      
      real(type_r8) :: rho_av_loc
      real(type_r8) :: dcoef_loc

      real*8 :: vflux_max, delp, delzloc, rho_z, relperm_av, visco_av, &
                vflux
      real*8, external :: fluxdd
      real*8, parameter :: r0 = 0.0d0, r1= 1.0d0, r2 = 2.0d0,          &
                           r3 = 3.0d0, rhalf = 0.5d0

#ifdef USG
      integer :: icell, idvol, kvol, ncell, ndvol, nrelp
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_ddflow_locs(num_crossdifficv_max),           &
                     grad_ddflow_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif

      rho_z = r0

!c  find second upstream point i2up based on the maximum advective flux
!c  into control volume ivol
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_i2upfind_heat_1)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, idvol, kvol, ndvol, ncell, nrelp, relps_loc,         &
    !$omp grad_ddflow_locs, grad_weights,                             &
    !$omp grad_ddflow_mids, flux_ddflow_hls_corr,                     &
    !$omp grad_ddflow_hls_loc, cinfvs_usg_loc, cinfvs_usg_cross_loc, &
#endif
    !$omp i1, i2, icon, istart, istop, ivol, jvol,                    &
    !$omp dcoef_loc, delp, delzloc, relperm_av, rho_av_loc, vflux,    &
    !$omp vflux_max, visco_av)
    !$omp do schedule(static)
#endif
      do ivol=1,nngl             !loop over control volumes

!c  initialize pointer to second upstream point

        i2up(ivol) = 0

!c  get row pointers

        istart = iavs(ivol)+1        !start - off-diagonal connections
        istop = iavs(ivol+1)-1       !end   - off-diagonal connections

!c  compute fluxes between current control volume and adjacent
!c  control volumes and total flux into current control volume

        icon = 0                     !initialize connection counter
        vflux_max = r0               !initialize max. influx

        do i1 = istart,istop         !off-diagonal connections

          icon = icon+1              !current connection
          jvol = javs(i1)            !column pointer

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          delp = uvsnew(jvol) - uvsnew(ivol)
          delzloc = zg(jvol) - zg(ivol)

          if (delzloc/=r0) then

              rho_av_loc = rhalf * (density(ivol) + density(jvol))
              if (av_dens_z) then
                 delp=rho_av_loc* &
               (uvsnew(jvol)/density(jvol)-uvsnew(ivol)/density(ivol))
              end if
!cprovi---------------------------------------------------------------  
!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
!cprovi---------------------------------------------------------------

!cdsu-----------------------------------------------------------------
!c  bug: rho_z is never initialized before, use zero instead
!cdsu-----------------------------------------------------------------   
              delzloc = delzloc * rho_z * gacc
              delp = delp + delzloc
          end if

!cprovi---------------------------------------------------------------  
!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
!cprovi---------------------------------------------------------------


          if (is_cell_based_relp) then
            if (delp > r0) then
              visco_av = ups_flow*viscosity(jvol)+(r1-ups_flow)*viscosity(ivol)
            else
              visco_av = ups_flow*viscosity(ivol)+(r1-ups_flow)*viscosity(jvol)
            end if
            dcoef_loc = 1.0d0 / visco_av
          else
            if (delp > r0) then
              relperm_av = ups_flow*relperm(jvol)+(r1-ups_flow)*relperm(ivol)
              visco_av = ups_flow*viscosity(jvol)+(r1-ups_flow)*viscosity(ivol)
            else
              relperm_av = ups_flow*relperm(ivol)+ (r1-ups_flow)*relperm(jvol)
              visco_av = ups_flow*viscosity(ivol)+(r1-ups_flow)*viscosity(jvol)
            end if
            dcoef_loc = relperm_av / visco_av
          end if
           
          if (b_use_fixed_flow_vel) then
              
            if (b_use_zero_flow_vel) then
              vflux = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
            if (discretization_type > 0) then
              grad_ddflow_mids = vector_zero
              flux_ddflow_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_dd(i1,ivol,jvol,              &
                              grad_ddflow_locs,grad_ddflow_mids,       &
                              grad_weights,flux_ddflow_hls_corr,       &
                              grad_ddflow_hls_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,    &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = 1.0d0
              end if

              vflux = -fluxdd_usg(delp,num_edge_dvols,ncell,               &
                          grad_ddflow_mids(1:num_edge_dvols,1:ncell),      &
                          flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell),         &
                          cinfvs_usg_loc(1:num_edge_dvols,1:ncell),        &
                          cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell),  &
                          is_cell_based_relp,nrelp,                        &
                          relps_loc(1:nrelp)*dcoef_loc)
            else
#endif
              vflux = - fluxdd(delp,cinfvs_a(i1),dcoef_loc)
#ifdef USG
            end if
#endif
          end if

!c  define second upstream point
!c  max. influx has here a negative sign

          if (vflux<vflux_max) then
            vflux_max = vflux
            i2up(ivol) = jvol
          endif

        end do                   !off-diagonal connections

      end do                  !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

      return
      end
