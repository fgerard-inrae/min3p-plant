!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/datstr_n.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine datstr_n
!c -------------------
!c
!c set up data-structure, generate ordering vectors
!c and perform symbolic factorization for nd-scalar matrix
!c
!c written by:      Uli Mayer - Aug 6, 96
!c
!c last modified:   Uli Mayer - Jan 7, 2000
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed: -
!c
!c common:   
!c parm.f:   integer*4:
!c           ----------
!c           mnjafrt            = max. number of factored connections + -
!c
!c gen.f:    integer*4:
!c           ----------  
!c           ilog               = unit number, log file               + -
!c           nn                 = total number of control volumes     + -
!c           n                  = number of primary unknowns          + -
!c           njart              = number of global connections        * +
!c           njafrt             = number of factored connections      * +
!c           iart(nn*n+1)       = row pointer array for art           * +
!c           jart(njart)        = connectivity list                   * +
!c           iafrt(nn*n+1)      = row pointer array for afrt          * +
!c           jafrt(njafrt)      = column pointer array for afrt       * +
!c           iafdrt(nn*n)       = diagonal pointer array for afrt     * +
!c           lorderrt(nn*n)     = array containing ordering           * +
!c           invordrt(nn*n)     = array containing inverse ordering   * +
!c           iwork(*)           = integer work array                  * +
!c           idbg               = unit number, debugging file         + -
!c           level_rt           = incomplete factoriztaion level      + -
!c
!c           logical:
!c           --------
!c           lwork(*)           = logical work array                  * +
!c           redox_equil_rt     = .true.  -> equilibrium redox        + -
!c                                           reactions
!c           rcm_ordering_rt    = .true.  -> rcm ordering for         * +
!c                                           n-d scalar matrix
!c
!c local:    integer*4:
!c           ----------
!c           i1                 = pointer
!c           ierr               = 0 -> memory allocation successful
!c           ilist              = pointer for work array list
!c           irow               = pointer for work array irow
!c           ilevptr            = pointer for work array levptr
!c         
!c external: checkerr  = check for error during memory allocation 
!c           iajabl    = set up ia-ja data-structure for diagonal 
!c                       and off-diagonal block matrices for 
!c                       reactive transport problem
!c           iajart    = set up ia-ja data-structure for
!c                       nd-scalar matrix
!c           mem_njart = allocate memory for one-dimensional arrays
!c                       of size njart
!c           naturalorderin = assigngs ordering vectors for natural
!c                             ordering
!c           rcmordering =  assigns ordering vectors for reverse
!c                          Cuthill-McKee ordering
!c           setsize   = set number of primary unknowns
!c           symbolicfactorization = incomplete symbolic lower/
!c                                   upper factorization
!c                                   - brute force factor
!c ----------------------------------------------------------------------
 
      subroutine datstr_n
 
      use parm
      use gen
      use matrix_utility, only : remap_matrix_ja
#ifdef PARDISO
      use solver_pardiso, only : ptrt
#endif   
#ifdef METIS
      use metis_iface, only : metis_fill_reducing_ordering
#endif
      implicit none
      
      integer :: i1, ierr, ilist, irow, ilevptr

      external checkerr, iajabl, iajart, mem_njart,   &
              rcmordering, naturalordering, setsize,  &
              symbolicfactorization
#ifdef USG
      external iajart_usg
#endif

!c  set number of primary unknowns for reaction-transport problem

      call setsize(redox_equil_rt)

!c  data structure (diagonal and off-diagonal block matrices)

      call iajabl

!c  preliminary memory allocation for pointer arrays jart and kart
!c  use njabl instead of n*n when sparse block matrices are used
!c  use njavs instead of mnjavs since the actual connection is already known
      mnjart = njavs*njabl

      allocate(jart(mnjart), stat = ierr)
      jart=0
      call checkerr(ierr,'jart',ilog)
      call memory_monitor(sizeof(jart),'jart',.true.)
      
#ifdef PETSC
      allocate(col_idx_l2pg_rt(mnjart), stat = ierr)
      col_idx_l2pg_rt=0
      call checkerr(ierr,'col_idx_l2pg_rt',ilog)
      call memory_monitor(sizeof(col_idx_l2pg_rt),'col_idx_l2pg_rt',.true.)
#endif

      allocate(kart(mnjart), stat = ierr)
      kart=0 
      call checkerr(ierr,'kart',ilog)
      call memory_monitor(sizeof(kart),'kart',.true.)

!c  data structure (n-d scalar matrix)
      if(discretization_type == 0) then
        call iajart
#ifdef USG
      else
        call iajart_usg
#endif
      end if

!c  final memory allocation for one-dimensional arrays of size njart
!c  only reallocate the memory when the size of the array is changed
      if (mnjart > njart) then
        call mem_njart
      end if

    ! use ws209 solver
      if (i_solver_type_react == 0) then
        
        mnjafrt = coeff_fac_conn_rt*(level_rt+1)*njart

!c  allocate memory for temporary work-arrays
        allocate (lwork(nngl*n), stat = ierr)
        lwork=.false.
        call checkerr(ierr,'lwork',ilog)
        call memory_monitor(sizeof(lwork),'lwork',.true.)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
        allocate (jafrt(mnjafrt), stat = ierr)
        jafrt=0
        call checkerr(ierr,'jafrt',ilog)
        call memory_monitor(sizeof(jafrt),'jafrt',.true.)
      
        allocate (iwork(2*nngl*n+mnjafrt), stat = ierr)
        iwork=0
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'iwork',.true.)

!c  ordering vectors

        if (rcm_ordering_rt) then    !rcm ordering

          call rcmordering (nngl*n,njart,iart,jart,lorderrt,invordrt,  &
                           lwork,iwork)
#ifdef METIS
        else if (metis_ordering_rt) then

          call metis_fill_reducing_ordering(nngl*n,njart,iart,jart,    &
                     lorderrt,invordrt)
#endif
        else                         !natural ordering

          call naturalordering (nngl*n,lorderrt,invordrt)

        endif

!c  write memory-requirements to log file
        if(rank == 0 .and. b_enable_output)  then
        
           write(ilog,'(/a/)')                                         &
              'memory requirements for reactive transport simulation:'
           write(ilog,'(2(a,i10/),a,i10)')                             &
              'estimated number of connections:          ',mnjart,     &
              'actual number of connections:             ',njart,      &
              'estimated number of factored connections: ',mnjafrt

        end if
 
!c  symbolic factorization

        njafrt = 0
        ilist = 1                  !pointer for work array list
        irow = n*nngl+1              !pointer for work array irow
        ilevptr = 2*(n*nngl)+1       !pointer for work array levptr

        call symbolicfactorization(ilog,n*nngl,njart,njafrt,mnjafrt,   &
                                  level_rt,iwork(ilist),iart,jart,     &
                                  iwork(irow),iwork(ilevptr),iafrt,    &
                                  iafdrt,jafrt,lorderrt,invordrt,      &
                                  rank,b_enable_output)

!c  write actual number of factored connections to log file
        if(rank == 0 .and. b_enable_output)  then
        
          write(ilog,'(a,i10/)') &
         'actual number of factored connections:    ',njafrt

        end if
 
!c  deallocate memory from work arrays
        call memory_monitor(-sizeof(iwork),'iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)

        call memory_monitor(-sizeof(lwork),'lwork',.true.)
        deallocate (lwork, stat = ierr)
        call checkerr(ierr,'lwork',ilog)

!c  minimize memory requirements for array jafrt

        allocate (iwork(njafrt), stat = ierr)
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'iwork',.true.)

        do i1 = 1,njafrt
          iwork(i1) = jafrt(i1)
        end do

        call memory_monitor(-sizeof(jafrt),'jafrt',.true.)
        deallocate (jafrt, stat = ierr)
        call checkerr(ierr,'jafrt',ilog)

        allocate (jafrt(njafrt), stat = ierr)
        call checkerr(ierr,'jafrt',ilog)
        call memory_monitor(sizeof(jafrt),'jafrt',.true.)

        do i1 = 1,njafrt
          jafrt(i1) = iwork(i1)
        end do

        call memory_monitor(-sizeof(iwork),'iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)
    
      end if
    
    ! use pardiso solver
#ifdef PARDISO
      if (i_solver_type_react == 1 .or. (i_solver_type_react == 0 .and. &
          b_solver_test_pardiso .eqv. .true.)) then

        if (allocated(jart_std)) then
            call memory_monitor(-sizeof(jart_std),'jart_std',.true.)
            deallocate(jart_std, stat = ierr)
            call checkerr(ierr,'jart_std',ilog) 
        end if

        allocate(jart_std(njart), stat = ierr)
        jart_std = 0
        call checkerr(ierr,'jart_std',ilog)
        call memory_monitor(sizeof(jart_std),'jart_std',.true.)

        if (allocated(imaprt_std)) then
            call memory_monitor(-sizeof(imaprt_std),'imaprt_std',.true.)
            deallocate(imaprt_std, stat = ierr)
            call checkerr(ierr,'imaprt_std',ilog) 
        end if

        allocate(imaprt_std(njart), stat = ierr)
        imaprt_std = 0
        call checkerr(ierr,'imaprt_std',ilog)
        call memory_monitor(sizeof(imaprt_std),'imaprt_std',.true.)

        if (allocated(art_std)) then
            call memory_monitor(-sizeof(art_std),'art_std',.true.)
            deallocate(art_std, stat = ierr)
            call checkerr(ierr,'art_std',ilog) 
        end if

        allocate(art_std(njart), stat = ierr)
        art_std = 0.0d0
        call checkerr(ierr,'art_std',ilog)
        call memory_monitor(sizeof(art_std),'art_std',.true.)

        if (b_solver_test_pardiso) then
            if (allocated(urt_std)) then
                call memory_monitor(-sizeof(urt_std),'urt_std',.true.)
                deallocate(urt_std, stat = ierr)
                call checkerr(ierr,'urt_std',ilog) 
            end if

            allocate(urt_std(nngl*n), stat = ierr)
            urt_std = 0.0d0
            call checkerr(ierr,'urt_std',ilog)
            call memory_monitor(sizeof(urt_std),'urt_std',.true.)
        end if

        !map ja array to standard sparse matrix structure, increasing column number for each row
        jart_std = jart
        do i1 = 1, njart
            imaprt_std (i1) = i1
        end do
        call remap_matrix_ja(nngl*n, iart, njart, jart_std, imaprt_std) 
               
      end if
#endif
     
    ! use PETSC solver
#ifdef PETSC
#ifdef CYGWIN
      if(b_enable_output)  then
        write(*,'(2(a,1x,i4,1x),a,1x,l1)') "rank",rank,                &
              "solver_type_react",i_solver_type_react,                 &
              "b_solver_test_petsc",b_solver_test_petsc
      end if
#endif
      if (i_solver_type_react == 0 .and. b_solver_test_petsc .eqv. .true.) then

        if (allocated(urt_std)) then
            call memory_monitor(-sizeof(urt_std),'urt_std',.true.)
            deallocate(urt_std, stat = ierr)
            call checkerr(ierr,'urt_std',ilog) 
        end if

        allocate(urt_std(nngl*n), stat = ierr)
        urt_std = 0.0d0
        call checkerr(ierr,'urt_std',ilog)
        call memory_monitor(sizeof(urt_std),'urt_std',.true.)
      end if
#endif



!cdbg
!c
!c  ia-ja pointers
!c
!c     do irow=1,nn*n+1
!c       write(igen,*) 'ia(',irow,') = ',iart(irow)
!c     end do
!c     do irow=1,nn*n
!c       istart = iart(irow)
!c       iend = iart(irow+1)-1
!c       write(igen,*) ('ja(',i1,') = ',jart(i1),i1=istart,iend)
!c     end do
!c
!c  ordering vectors
!c
!c     do irow=1,nn*n
!c       write(igen,'(a,1x,i6,1x,a,1x,i6)')
!c    &        'lorderrt(',irow,') = ',lorderrt(irow)
!c     end do
!c     write(igen,*)
!c     do irow=1,nn*n
!c       write(igen,'(a,1x,i6,1x,a,1x,i6)')
!c    &        'invordrt(',irow,') = ',invordrt(irow)
!c     end do
!c
!c  iaf-jaf pointers
!c
!c     do irow=1,nn*n+1
!c       write(igen,*) 'iaf(',irow,') = ',iafrt(irow)
!c     end do
!c     do irow=1,nn*n
!c       write(igen,*) 'iafd(',irow,') = ',iafdrt(irow)
!c     end do
!c     do irow=1,nn*n
!c       istart = iafrt(irow)
!c       iend = iafrt(irow+1)-1
!c       write(igen,*) ('jaf(',i1,') = ',jafrt(i1),i1=istart,iend)
!c     end do
!c     stop
!cdbg

      return
      end
