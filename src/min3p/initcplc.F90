!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcplc.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcplc
!c -------------------
!c
!c control parameters for local chemistry
!c
!c written by:      Uli Mayer - May 13, 96
!c
!c last modified:   Uli Mayer - November 21, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           n                  = number of primary unknowns          + -
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c chem.f:   real*8:
!c           -------
!c           acth2omin          = min. activity for h2o               * +
!c           dinc_lc            = factor to compute increment for     * +
!c                                numerical differentiation
!c           sionmax            = max. ionic strength of solution     * +
!c           time_factor        = conversion factor from I/O time     * +
!c                                units to internal time units
!c           tinyrate           = set reaction rates to zero,         * +
!c                                if smaller than tinyrate
!c           tol_lc             = convergence tolerance               * +
!c                                (local chemistry)
!c 
!c           integer*4:
!c           ----------
!c           nm                 = number of minerals                  + -
!c           nopu               = number of primary unknowns          + -
!c           nr                 = number of redox couples             + -
!c
!c           logical:
!c           --------
!c           finite_minerals    = .true.  -> finite minerals          * +
!c           redox_equil_lc     = .true.  -> equilibrium redox        * +
!c                                           reactions
!c
!c           character:
!c           ----------
!c           time_unit_lc       = time unit for output -> 'years'     * +
!c                                                        'days'
!c           update_activity_lc = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (local chemistry)
!c
!c local:    real*8:
!c           -------
!c           r1                 = constant
!c           r24                = constant
!c           r365               = constant
!c           r86400             = constant
!c
!c           integer*4:
!c           ----------
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to 
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcplc
 
      use parm
      use gen
      use chem
      use file_utility, only : readnextline
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
 
      implicit none
      
      integer :: i, l_string, ierrcd

      external findstrg, readbloc

      logical found_section, found_subsection
      character*72 subsection
      character*72 strbuffer

      real*8, parameter :: r1 = 1.0d0, r24 = 24.0d0, r365 = 365.0d0,   &
                           r1440 = 1440.d0, r86400 = 8.64d4

!c  read control parameters for local chemistry and write to temporary 
!c  file
      ierrcd = 0

!cdsu concentration limitation
      conc_corr_min = 1.0d-300
      conc_corr_max = 1.0d300

!c  by default, underrelaxation for local geochemistry is disabled
      under_relax_lc = .false.      
      srelfac_lc = 1.0d0

!c  linear solver type of local chemistry, 0 - Gaussian (default), 1 - QR, 2 - SVD
      linear_solver_lc = 0

!c  default linear solver setting
      maxit_lc = 2000
      idetail_lc = 1

      section_header = 'control parameters - local geochemistry'
      call readbloc (idat,itmp,section_header,found_section,.true.)
 
!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for control parameters for local chemistry

!c  general control parameters

      if (nr.gt.0) then
        redox_equil_lc = .true.
      end if
      if (nm.gt.0.and..not.reactive_transport) then
        finite_minerals = .true.
      end if
      sionmax = 2.0d0
      acth2omin = 0.5d0
      
      !tinyrate = 1.0d-300
      tinyrate = 0.0d0          !tinyrate is an optional parameter in the input file, if tinyrate is set to 0, there will be
                                !bug in some cases that causes ratemp(ireac) to NaN (in modrate.F90) due to zero divider.
                                !So, this value should be set to a tiny positive value, e.g, 1.0E-300. DSU, 2013-2-8
                                !Revised on May 22, 2017. Use another method in modrate.F90 to avoid NaN.

!c  Newton iteration

      dinc_lc = 1.0d-4
      tol_lc = 1.0d-6

!c  output time unit

      time_unit_lc = 'days'

!c  read control parameters for local chemistry

      if (found_section) then

        subsection = 'redox reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nr.gt.0) then
            ierrcd = 1
            read(itmp,*,err=999,end=999) redox_equil_lc
            redox_equil_lc = .true.       !currently hardwired
          end if
        end if

!c  define if mineral concentrations are updated

        subsection = 'finite minerals'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            ierrcd = 2
            read(itmp,*,err=999,end=999) finite_minerals
          end if
        end if

!c  type of activity update

        subsection = 'activity update settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 3
          read(itmp,*,err=999,end=999) update_activity_lc
        end if

!c  read minimum activity for h2o

        subsection = 'minimum activity for h2o'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 4
          read(itmp,*,err=999,end=999) acth2omin 
        end if

!c  read maximum ionic strength

        subsection = 'maximum ionic strength'
        call findstrg(subsection,itmp,found_subsection)
   
        if (found_subsection) then
          ierrcd = 5
          read(itmp,*,err=999,end=999) sionmax
        end if

!c  read minimum reaction rate

        subsection = 'define minimum reaction rate'
        call findstrg(subsection,itmp,found_subsection)
  
        if (found_subsection) then
          ierrcd = 6
          read(itmp,*,err=999,end=999) tinyrate
        end if

!cdsu  concentration limiter for very small concentration
!cdsu  Important: It can make a difference, esp. in the context of redox chemistry.
!cdsu  Redox couples are related to each other via an equilibrium constant. 
!cdsu  C1/C2 = K, or C1 = K x C2, if a concentration of a redox couple is changes, 
!cdsu  it might cause problems. Less an issue for all other reactions.
!cdsu  DSU, 2020-12-17
        subsection = 'minimum component concentration'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 7
          read(itmp,*,err=999,end=999) conc_corr_min       
        end if 

        subsection = 'maximum component concentration'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 7
          read(itmp,*,err=999,end=999) conc_corr_max       
        end if 

!c  read setting for Newton iteration

        subsection = 'newton iteration settings'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 8
          read(itmp,*,err=999,end=999) dinc_lc
          read(itmp,*,err=999,end=999) tol_lc
        end if

!c  read setting for linear solver

        subsection = 'solver settings'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 9
          read(itmp,*,err=999,end=999) maxit_lc
          read(itmp,*,err=999,end=999) idetail_lc
        end if

!c  read type of linear solver

        subsection = 'linear solver type'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 10
          if(readnextline(itmp, strbuffer, withquote=.true., lowercase=.true.)) then
            if (trim(strbuffer) == 'gaussian') then
              linear_solver_lc = 0
            else if (trim(strbuffer) == 'qr') then
              linear_solver_lc = 1
            else if (trim(strbuffer) == 'svd') then
              linear_solver_lc = 2
            end if

#ifndef GPL
            if (linear_solver_lc > 0) then
              if (rank == 0) then
                write(*,*) 'Error: GPL licensed library is required for QR or SVD solver'
                write(ilog,*) 'Error: GPL licensed library is required for QR or SVD solver'
              end if
              goto 999
            end if
#endif

          end if
        end if

!c  read time unit for output

        subsection = 'output time unit'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 11
          read(itmp,*,err=999,end=999) time_unit_lc
        end if

!c  underrelaxation for local geochemistry
        subsection = 'user specified underrelaxation factor' 
        call findstrg(subsection,itmp,found_subsection)
  
        if (found_subsection) then
          ierrcd = 12
          under_relax_lc = .true.       
          read(itmp,*,err=999,end=999) srelfac_lc
        end if

      end if                      !(found_section)
 
!c  compute time factor for conversion from I/O to internal time
!c  units

      if (time_unit_lc.eq.'years') then
        time_factor_lc = r365
      elseif (time_unit_lc.eq.'days') then
        time_factor_lc = r1
      elseif (time_unit_lc.eq.'hours') then
        time_factor_lc = r1/r24
      elseif (time_unit_lc.eq.'minutes') then
        time_factor_lc = r1/r1440
      elseif (time_unit_lc.eq.'seconds') then
        time_factor_lc = r1/r86400
      end if
      
      if (b_enable_output .and. b_enable_output_gen) then

!c  write control parameters for local chemistry to generic output file
 
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

      if (nr.gt.0) then
        if (redox_equil_lc) then
          write(igen,'(a)') 'equilibrium controlled redox reactions'
        else
          write(igen,'(a)') 'kinetically controlled redox reactions'
        end if
      end if

      if (nm.gt.0) then
        if (finite_minerals) then
          write(igen,'(a)') 'finite mineral masses'
        end if
      end if

      write(igen,'(a,1pe15.6e3)')       &
     &'factor for numerical differentiation            = ', dinc_lc
      write(igen,'(a,1pe15.6e3)')       &
     &'convergence tolerance                           = ', tol_lc
      write(igen,'(a,1pe15.6e3)')       &
     &'max. ionic strength                             = ', sionmax
      write(igen,'(a,1pe15.6e3)')       &
     &'min. activity for h2o                           = ', acth2omin
      write(igen,'(a,1pe15.6e3)')       &
     &'minimum reaction rate considered                = ', tinyrate
      
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
