!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updtrootdensity.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updtrootdensity
!c -------------------
!c
!c Update root length densities
!c
!c written by: Fred Gerard (FG), Celine Blitz Frayret (CBF) and Laurent Labatut (LLab) - December 14, 2018
!c 
!c
!c last modified:  Danayng Su - Bug fix, transient root update, 2019
!c
!c      
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c
!c gen.F90:  real*8:
!c           -------
!c           time_io            = current solution time (I/O units)   + -
!c           xg(nn)             = spatial coordinates in x-direction
!c           yg(nn)             = spatial coordinates in y-direction
!c           zg(nn)             = spatial coordinates in z-direction
!c           xmax(nxx)          = max. coordinate of discretization 
!c                                interval in x-direction
!c           ymax(nyy)          = max. coordinate of discretization 
!c                                interval in y-direction
!c           zmax(nzz)          = max. coordinate of discretization
!c                                interval in z-direction
!c
!c         integer:
!c         --------
!c           nn                 = total number of control volumes without ghost nodes
!c           nxx                = number of intervals in x-direction  
!c           nyy                = number of intervals in y-direction 
!c           nzz                = number of intervals in z-direction
!c           nvx                = number of control volumes in x-direction             
!c           nvy                = number of control volumes in y-direction       
!c           nvz                = number of control volumes in z-direction
!c                                
!c
!c biol.F90: real*8:
!c           -------
!c           time_rld           = time at which RLD are updated 
!c          time_io_prec    = previous time step
!c         arld        = value of one of the rld model parameters
!c         brld        = value of one of the rld model parameters
!c         crld        = value of one of the rld model parameters
!c         drld        = value of one of the rld model parameters
!c         rld(nn+1)          = root length density used to compute qroot
!c
!c         logical:
!c         --------
!c           coupled_as         = .true. -> update root length density by coupling with ArchiSimple
!c           coupled_rt         = .true. -> update root length density by coupling with RootTyp
!c         inside_rld            = .true. -> update root length density by a law inside updtrootdensity
!c         rootdensitynill        = .true. -> when root density length equal to zero
!c
!c root_modu.F90: 
!c         real:
!c         -----
!c         x_g(nn)        = same as xg, but declared to be passed for coupling
!c         y_g(nn)        = same as yg, but declared to be passed for coupling
!c         z_g(nn)        = same as zg, but declared to be passed for coupling
!c         RSD_coupled(nn+1)    = RLD array passed during coupling and assigned to rld(nn+1)
!c
!c         subroutine for coupling interface:
!c         ----------------------------------
!c         COMP_AS        = ArchiSimple root architecture program computation
!c         COMP_RT        = Root Typ root architecture program computation
!c      
!c local:    double precision: (real*8 = f77)
!c           ----------------
!c           tiny               = small increment
!c            
!c           integer*4:
!c           -------
!c           ivol               = counter for control volumes
!c         flag        = flag to detect if the domain is 1D or 2D, based on the value of nvx
!c         tmax        = integer part of the final solution time to be passed by coupling and used in C arrays allocations
!c
!c         real:
!c         -----
!c         delt_MIN3P        = length of the time step to be passed for coupling
!c         sumrld         = check the occurence of root densities
!c
!c external: -
!c ---------------------------------------------------------------------
    subroutine updtrootdensity
 
#ifdef ARCHISIMPLE
      use, intrinsic :: ISO_C_BINDING
      use root_modu
#endif
      use gen
      use biol 
#ifdef OPENMP
      use omp_lib 
#endif 

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_initialize
#endif
         
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif      

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif

      integer ::ivol, flag, tmax, ierr !FGG norme f95 pour integer*4 en f77
      real*8 :: delt_MIN3P !CBF time step to be transferred in Compute Archi   
      real*8 :: sumrld, sumrld_gbl !FG Feb 2015 to check if no root developped yet
      
      character (len=90) :: file_name
      real*8, parameter :: r0 = 0.0d0, tiny = 1.d-10, verytiny = 1.0d-300

      external :: checkerr


      if(inside_rld) then
          
        if (time_io.gt.time_rld) then  !LLab 30, Dec 2013---- update root each day
          if (b_enable_output .and. rank == 0) then
            write(*,*) ' '
            write(*,*) 'RLD IN 1D UPDATED BY EXPONENTIAL MODEL WITH FOLLOWING PARAMETERS :'
            write(*,*) ' a =', arld, ' b = ', brld, ' c = ', crld, ' d = ', drld
            write(*,*) ' '
          end if
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl
            rld(ivol)=exp(arld+brld*sqrt(zg(ivol))+crld*time_io+drld*sqrt(zg(ivol))*time_io)
          enddo
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

          time_rld=time_rld+1.0d0
        endif
      endif       

#ifdef ARCHISIMPLE
      if((coupled_as).or.(coupled_rt)) then ! CBF RLD
         
        if (time_io.gt.time_rld) then !FGG, janv 2014 ! CBF every day

          delt_MIN3P=time_io-time_io_prec ! CBF compute the time step length to transfer to COMPUTE

          allocate(x_g(nngl), stat = ierr)
          call checkerr(ierr,'x_g',ilog)
          call memory_monitor(sizeof(x_g),'x_g',.true.)

          allocate(y_g(nngl), stat = ierr)
          call checkerr(ierr,'y_g',ilog)
          call memory_monitor(sizeof(y_g),'y_g',.true.)

          allocate(z_g(nngl), stat = ierr)
          call checkerr(ierr,'z_g',ilog)
          call memory_monitor(sizeof(z_g),'z_g',.true.)
                
          !DSU - Is x_g/y_g/z_g changed after calling ArchiSimple code?
          !DSU - If not changed, just pass xg, yg and zg.
          do ivol=1,nngl
            x_g(ivol)=xg(ivol)
            y_g(ivol)=yg(ivol)
            z_g(ivol)=zg(ivol)
          enddo



          if(nvx.gt.1)then
            flag=2 ! if 1< control volume in x -> 2D
          else
            flag=1 ! if 1 control volume in x -> 1D
          endif
                
          tmax=int(tfinal)

          if(flag.eq.1)then ! 1D
            if (b_enable_output .and. rank == 0) then
              write(*,*) ' '
              write(*,*) 'RLD IN 1D UPDATED BY COUPLING TO ARCHISIMPLE'
              write(*,*) ' '
            end if

            call COMP_AS(flag, time_io, real(delt_MIN3P,4),            &
                         nvxgbl, nvygbl, nvzgbl, nvx, nvy, nvz,        &
                         C_LOC(x_g), C_LOC(y_g), C_LOC(z_g),           &
                         C_LOC(RSD_coupled),                           &
                         xlmaxgbl-xlmingbl, ylmaxgbl-ylmingbl,         &
                         zlmaxgbl-zlmingbl, tmax)            
                         !DSU - add ymax and nvy parameters, not used at present
                         ! CB : zmax=depth domain in meters
                         !arguments necessaires en 1D : (flag, time_io, delt_MIN3P, z_max, nv_z, x_max, nv_x,
                         !C_LOC(RSD_coupled),tfinal) meme si on en n'a pas besoin, on passe quand meme x_g, y_g,z_g
                         !pour ne pas avoir a creer une autre fonction COMPUTE specialement pour le 1D
                         !DSU: question here, why 1D vertical problem (z direction) still use xlmaxgbl as input parameter

            do ivol=1,nngl
              rld(nngl-ivol+1)=RSD_coupled(ivol)
            enddo

                
          else ! if flag=2 (2D)

            if(coupled_as)then
              if (b_enable_output .and. rank == 0) then
                write(*,*) ' '
                write(*,*) 'RLD IN 2D UPDATED BY COUPLING TO ARCHISIMPLE'
                write(*,*) ' '
              end if
              call COMP_AS(flag, time_io, real(delt_MIN3P,4),          &
                           nvxgbl, nvygbl, nvzgbl, nvx, nvy, nvz,      &
                           C_LOC(x_g), C_LOC(y_g), C_LOC(z_g),         &
                           C_LOC(RSD_coupled),                         &
                           xlmaxgbl-xlmingbl, ylmaxgbl-ylmingbl,       &
                           zlmaxgbl-zlmingbl, tmax)          !DSU - add ymax and nvy parameters, not used at present
                           ! CB : zmax=depth domain in meters
                           !DSU: question here, why 1D vertical problem (z direction) still use xlmaxgbl as input parameter
            endif

            if(coupled_rt)then
              if (b_enable_output .and. rank == 0) then
                write(*,*) ' '
                write(*,*) 'RLD IN 2D UPDATED BY COUPLING TO ROOT TYP'
                write(*,*) ' '
              end if

              call COMP_RT(time_io, real(delt_MIN3P,4),                &
                           nvxgbl, nvygbl, nvzgbl, nvx, nvy, nvz,      &
                           C_LOC(x_g), C_LOC(y_g), C_LOC(z_g),         &
                           C_LOC(RSD_coupled),                         &
                           xlmaxgbl-xlmingbl, ylmaxgbl-ylmingbl,       &
                           zlmaxgbl-zlmingbl)
            endif

            do ivol=1,nngl ! CB : callage du debut zero en C et 1 en fortran
              rld(ivol)=RSD_coupled(ivol)
              !write(*,*) 'updtrootdensity : RSD(',ivol,')=', RSD_coupled(ivol)
            enddo
            
            !c DSU: to be checked later, why put rld(nngl)=0 here? 
            !c rld(nngl)=0 ! Au coin du domaine on met RSD = 0 sinon on a une valeur garbage de 1
          endif  ! flag 1D/2D
                    
          call memory_monitor(-sizeof(x_g),'x_g',.true.)
          call memory_monitor(-sizeof(y_g),'y_g',.true.)
          call memory_monitor(-sizeof(z_g),'z_g',.true.)
          deallocate(x_g)
          deallocate(y_g)
          deallocate(z_g)

          time_io_prec=time_io ! CB pour calcul pas de temps delt_MIN3P a mettre ds Compute_archi
             
          time_rld=time_rld+1.0d0 ! incrementation time rld
           
        endif ! if (time_io.gt.time_rld)
          
      endif ! if coupled_as or coupled_rt
#endif     
         
      ! FG Feb 2015 check if no root developed yet :

      sumrld=0.0d0

      do ivol=1,nngl
!c  skip ghost nodes
#ifdef PETSC
        if (node_idx_lg2l(ivol) < 0) then
          cycle
        end if 
#endif
        sumrld=sumrld+rld(ivol)
      enddo

#ifdef PETSC
      call MPI_Allreduce(sumrld, sumrld_gbl,1,MPI_REAL8,               & 
                 MPI_SUM, Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      sumrld = sumrld_gbl
#endif      

      !FG : operator set to true is no root, and set to false if root (it first appears in initplant.f
      !to check if initially no root, here it is in case of update) :

      if (sumrld <= verytiny) then
        rootdensitynill = .true.
      else
        rootdensitynill = .false.
      endif

      goto 1000
 
998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' ! write in log file
        write(ilog,*) 'error reading root density from rldin file'
        write(*,*) 'SIMULATION TERMINATED' !write on screen
        write(*,*) 'error reading root density from rldin file'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop     

1000  return

      end

!cdsu
!cdsu update root length density from external file
!cdsu
      subroutine updtrootdensity_ext

        use biol, only : irld, rld
        use gen, only : ilog, rank, nngbl, nngl, discretization_type,  &
                        node_idx_g2lg, node_idx_lg2g,                  &
                        usg_mesh_ordering, node_idx_g2g_invord
        use file_utility, only : makelowercase

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
        use petscsys
#endif
#endif

#ifdef PETSC
        use petsc_mpi_common, only : petsc_mpi_finalize
#endif
        implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

        integer :: ivol, ivolgbl, iskip, nskip
        real :: rdummy
        character(72) :: strbuffer

        !c locate the root length density data in tecplot data format
        !c please note data sharing of coordinates is used in the rld file
        !c to save memory in the file
        !c example of data format
        !
        ! title = "dataset transp-updrld"
        ! variables = "x", "y", "z", "rld"
        ! zone t = "Initial root length density" i =   30, j =   30, k =    1,  f=point
        ! 0.000000E+00 0.000000E+00 0.000000E+00 1.000000E-01
        ! 3.448276E-02 0.000000E+00 0.000000E+00 1.000000E-01
        ! 6.896552E-02 0.000000E+00 0.000000E+00 1.000000E-01
        ! ...
        ! zone t = "root length density on day 3" i =   30, j =   30, k =    1,  f=point, varsharelist=([1,2,3]=1)
        ! 1.000000E-01
        ! 1.000000E-01
        ! ...
        ! zone t = "root length density on day 6" i =   30, j =   30, k =    1,  f=point, varsharelist=([1,2,3]=1)
        ! 1.000000E-01
        ! 1.000000E-01
        ! ...
        !

        do while (.true.)
          read(irld,*,err=998,end=998) strbuffer
          call makelowercase(strbuffer)
          if (index(strbuffer,'zone') > 0) then
            exit
          end if
        end do

#ifdef USG
        if (discretization_type > 0) then
          do ivolgbl = 1,nngbl
#ifdef PETSC
            if (ibits(usg_mesh_ordering,0,2) == 3) then
              ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
            else
              ivol = node_idx_g2lg(ivolgbl)
            end if
#else
            if (ibits(usg_mesh_ordering,0,2) == 3) then
              ivol = node_idx_g2g_invord(ivolgbl)
            else
              ivol = ivolgbl
            end if
#endif
            if (ivol > 0) then
              read(irld,*,err=998,end=998) rld(ivol)
            else
              read(irld,*,err=998,end=998) rdummy
            end if
          end do
        end if
#endif
        if (discretization_type == 0) then
          nskip = 0
          do ivol = 1,nngl
#ifdef PETSC
            do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                read(irld,*,end=998,err=998) rdummy
            end do
            nskip = node_idx_lg2g(ivol)
#endif
            read(irld,*,err=998,end=998) rld(ivol)
          end do
        end if

        goto 1000

998     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error updating root length density from file'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

1000    return

      end subroutine updtrootdensity_ext
