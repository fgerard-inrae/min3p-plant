!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcpice.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpgs
!c -------------------
!c
!c control parameters for ice loading/unloading
!c ported from Sergio Bea's code by Danyang Su
!c
!c written by:      Danyang Su - Oct 22, 17
!c
!c last modified:   
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           l_time_unit        = length of time_unit for output      * +
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     * +
!c           geo_chemistry      = .true.  -> local or background and  * +
!c                                           source chemistry
!c           reactive_transport = .true.  -> perform reactive         * +
!c                                           transport simulation
!c           steady_flow        = .true.  -> steady state flow        * +
!c           transient_flow     = .true.  -> .not.steady_flow,        * +
!c                                        -> transient flow
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c           varsat_flow        = .true.  -> perform flow simulation  * +
!c
!c           character:
!c           ----------
!c           problem_title      = problem title                       * +
!c           section_header     = section header                      * +
!c           drive              = drive of program installation       * +
!c           time_unit          = time unit for output -> 'years'     * +
!c                                                        'days'
!c                                                        'hours'
!c                                                'seconds'
!c dens.f:   logical:
!c           --------
!c           density_dependence = .true.  -> density-dependant flow 
!c
!c local:    integer*4:
!c           ----------
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c
!c external: readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpice
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use dens
      use chem, only : nc, ncorder, component_type, namec
      use file_unit, only : lun_get
      use file_utility, only : rewind_first_record
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use usg_mesh_data, only : num_nodes_per_layer
      use usg_ice_sheet
      use geometry
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      
      integer :: i, ic, itemp, l_string, ierr, ierrcd

      character*72 :: subsection

      character*256 :: strbuffer

      external readbloc, checkerr
 
      logical found_section, found_subsection, iserror

      real*8, parameter :: r0 = 0.0d0, tiny = 1.0d-8 

      ierrcd = 0

!c  initialization of ice sheet parameters
      ice_sheet_type = -1
!c  read numerical data and write to temporary file   

      section_header = 'ice sheet loading/unloading' 
      call readbloc (idat,itmp,section_header,found_section,.true.)
      if (found_section) then
        ice_sheet_type = 0
      end if

!c  new ice sheet control parameter for general structured and unstructured mesh
#ifdef USG      
      section_header = 'control parameters - ice sheet loading/unloading' 
      call readbloc (idat,itmp,section_header,found_section,.true.)
      if (found_section) then
        ice_sheet_type = 1

!c  define length of section header
        l_string = index(section_header,'  ')-1 
        if (l_string.eq.-1.or.l_string.gt.72) then 
          l_string=72 
        end if
  
!c  write section header to generic output file                          
        if (b_enable_output .and. b_enable_output_gen) then                                                                  
          write(igen,'(/72a)')('-',i=1,72) 
          write(igen,'(a)') section_header(:l_string) 
          write(igen,'(72a/)')('-',i=1,72) 
        end if

!c  check if layered mesh is used
!c         if (.not. b_use_layered_mesh) then
!c           if (rank == 0) then
!c             write(*,*) 'SIMULATION TERMINATED'
!c             write(*,*) 'Error: layered mesh is requried for ice sheet'
!c             write(ilog,*) 'SIMULATION TERMINATED'
!c             write(ilog,*) 'Error: layered mesh is requried for ice sheet'
!c             close(ilog)
!c           end if
!c #ifdef PETSC
!c           call petsc_mpi_finalize
!c #endif
!c           stop
!c         end if

      end if

#endif

      if (ice_sheet_type < 0) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section ice sheet loading/unloading is missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
  
      if (ice_sheet_type == 1) then                      !new format ice sheet type
#ifdef USG
!c  initialization of parameters for new format ice sheet type
        ice_density = 920.0d0

        subsection = 'density of ice'
        call findstrg(subsection,itmp,found_subsection)  
        if (found_subsection) then
          ierrcd = 1
          read(itmp,*,end=999,err=999) ice_density
        end if
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(a,1pe15.6e3)')                                  &
                'density of ice [kg/m^3]                         = ',  &
                ice_density
        end if

        b_phw2ice = .false.
        subsection = 'transform surface water to ice'
        call findstrg(subsection,itmp,found_subsection)  
        if (found_subsection) then
          b_phw2ice = .true.
        end if

        update_ice_scalfac = .false.
        subsection = 'transient ice sheet factors'
        call findstrg(subsection,itmp,found_subsection)  
        if (found_subsection) then
          update_ice_scalfac = .true.
        end if

        if (update_ice_scalfac) then
          ierrcd = 2
          file_ice_scalfac = lun_get()
          open(file_ice_scalfac,file=prefix(:l_prfx)//'.bcisf',err=998, status='old')
          call rewind_first_record(file_ice_scalfac)
          read(file_ice_scalfac,*,err=998,end=998) time_ice_scalfac
        end if

        b_linear_ice_scalfac = .false.
        b_first_update_ice_scalfac = .false.

        subsection = 'linear interpolation of ice sheet factors'
        call findstrg(subsection,itmp,found_subsection)  
        if (found_subsection) then
          b_linear_ice_scalfac = .true.
          b_first_update_ice_scalfac = .true.
        end if

        ice_scalfac_pw_grow = 0.0d0
        ice_scalfac_pice_grow = 1.0d0
        ice_scalfac_pw_decay = 0.95d0
        ice_scalfac_pice_decay = 1.0d0
        ice_scalfac_pp_grow = 0.0d0
        ice_scalfac_pp_decay = 0.0d0

        subsection = 'scaling factor of pressure head and pore stress'
        call findstrg(subsection,itmp,found_subsection)       
        if (found_subsection) then
          ierrcd = 3
          read(itmp,*,end=999,err=999) ice_scalfac_pw_grow
          read(itmp,*,end=999,err=999) ice_scalfac_pice_grow
          read(itmp,*,end=999,err=999) ice_scalfac_pw_decay
          read(itmp,*,end=999,err=999) ice_scalfac_pice_decay
        end if

        subsection = 'scaling factor of boundary pore pressure'
        call findstrg(subsection,itmp,found_subsection)       
        if (found_subsection) then
          ierrcd = 4
          read(itmp,*,end=999,err=999) ice_scalfac_pp_grow
          read(itmp,*,end=999,err=999) ice_scalfac_pp_decay
        end if        

        ice_basal_temperature_type = 0

        ice_basal_temperature_grow = 0.0d0
        ice_basal_temperature_decay = 0.0d0
        subsection = 'ice sheet basal temperature'
        call findstrg(subsection,itmp,found_subsection)
        if (.not.found_subsection) then
          subsection = 'basal temperature of ice'
          call findstrg(subsection,itmp,found_subsection)
        end if
        if (found_subsection) then
          ierrcd = 5
          read(itmp,*,end=999,err=999) ice_basal_temperature_grow
          read(itmp,*,end=999,err=999) ice_basal_temperature_decay
          ice_basal_temperature_type = 1
        end if

        heatcond_upper_layer = 0.0d0
        heatcond_lower_layer = 0.0d0
        delta_temp_per_meter = 0.0d0
        if (num_nodes_per_layer > 0) then
          subsection = 'double layer basal temperature model'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 6
            read(itmp,*,end=999,err=999) heatcond_upper_layer
            read(itmp,*,end=999,err=999) heatcond_lower_layer
            read(itmp,*,end=999,err=999) delta_temp_per_meter
            ice_basal_temperature_type = 2

            !c allocate temperature at the bottom of layered simualtion domain
            allocate(layer_nodes_bottom_temp(num_nodes_per_layer), stat = ierr)
            call checkerr(ierr,'layer_nodes_bottom_temp',ilog)
            call memory_monitor(sizeof(layer_nodes_bottom_temp),       &
                                'layer_nodes_bottom_temp',.false.)

            allocate(layer_nodes_bottom_temp_gbl(num_nodes_per_layer), stat = ierr)
            call checkerr(ierr,'layer_nodes_bottom_temp_gbl',ilog)
            call memory_monitor(sizeof(layer_nodes_bottom_temp_gbl),   &
                                'layer_nodes_bottom_temp_gbl',.false.)
          end if
        end if

        ice_thickness_scalfac = 1.0d0
        subsection = 'scaling factor of ice thickness'
        call findstrg(subsection,itmp,found_subsection)       
        if (found_subsection) then
          ierrcd = 7
          read(itmp,*,end=999,err=999) ice_thickness_scalfac
        end if

        b_ice_transformation = .false.
        ice_transformation_a = 0.0d0
        ice_transformation_b = 0.0d0
        ice_transformation_c = 0.0d0
        subsection = 'transformation parameters of ice thickness'
        call findstrg(subsection,itmp,found_subsection)       
        if (found_subsection) then
          ierrcd = 8
          read(itmp,*,end=999,err=999) ice_transformation_a,           &
                                       ice_transformation_b,           &
                                       ice_transformation_c
          b_ice_transformation = .true.
        end if

#endif
      else if (ice_sheet_type == 0) then                 !old format ice sheet type
      
  !cprovi---------------------------------------------------
  !cprovi---------------------------------------------------
  !cprovi---------------------------------------------------    
  !cprovi---------------------------------------------------
  !cprovi Compute Ice Sheet loading  
  !cprovi---------------------------------------------------
        compute_permafrost = .false. 
  
        icestage = -1
        nicestages = -1
  
        allocate (ice_sheet)
        call create_ (ice_sheet)
        call read_ice_sheet_block_ (ice_sheet, itmp,                     &
                                    nc, ncorder, component_type,         &
                                    heat_transport, icetimeline, iserror)
        if (iserror) then
          if (rank == 0) then 
            write(*,*) 'Error when call service read_ice_sheet_block_'
            write(ilog,*) 'Error when call service read_ice_sheet_block_'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
        end if
          
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,*) 'Ice Sheet loading/unloading is computed'
          write(igen,'(72a/)') ('-',i=1,72)
          if (ice_sheet%istotbc) then
            write(igen,'(a/)') "Concentration input: Yes"
            write(igen,'(a)')'component           concentration      type'
            write(igen,'(72a/)') ('-',i=1,72)
            do ic = 1, nc-1
              if (component_type(ic).eq.'aqueous'.or. &
                  component_type(ic).eq.'biomass') then
                write(igen,'(a12,6x,1pe15.6e3,6x,a12)') namec(ic),       &
                      ice_sheet%totbc(ic),ice_sheet%typetotbc(ic)
              end if
            end do
          else
            write(igen,'(a)') "Concentration input: No"
          end if
        end if
          
        subsection = 'compute permafrost'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          if (b_enable_output .and. b_enable_output_gen) then  
            write(igen,*) 'Permafrost is considered'
          end if
          compute_permafrost=.true.          
        end if 
        if (b_enable_output .and. b_enable_output_gen) then
          call write_ (ice_sheet,igen,iserror)
        end if
        if (iserror) then
          if (rank == 0) then  
            write(*,*) 'Error when call service write_'
            write(ilog,*) 'Error when call service write_'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
        end if

      end if                  !ice_sheet_type

      goto 1000

998   continue
      if (rank == 0) then
        write(*,*) 'error reading ice sheet scaling factor file, error code ', ierrcd
        write(*,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'error reading ice sheet scaling factor file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(*,*) 'error reading input file, error code ', ierrcd
        write(*,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
