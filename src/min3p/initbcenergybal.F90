!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initbcenergybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

! ----------------------------------------------------------------------
! subroutine initbcenergybal                                            
! -------------------                                                   
!                                                                       
! boundary conditions (variably saturated flow)                         
!                                                                       
! first type boundary conditions:                                       
! -> define zone by delineating nodes located within zone               
!                                                                       
! second type boundary condition:                                       
! -> define area (only on surface of solution domain)                   
!                                                                       
! seepage face boundary condition:                                      
! -> define area (only on surface of solution domain)                   
!                                                                       
! written by:                               I O
!
!c last modified:   -
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
! passed:   -                                                           
!                                                                       
! common:                                                               
! gen.f:    real*8:                                                     
!           -------                                                     
!           bcondvs(nbvs)      = boundary condition                  * +
!                                (pressure head or flux) or             
!                                identification of seepage face         
!                                boundary type                          
!           dimcv(3,nn)        = spatial dimensions of control       + -
!                                volumes                                
!           hhead(nn)          = hydraulic head                      + +
!           rwork(:,:)         = real*8 work array                   * *
!           time_bcvs          = next read time for flow boundary    * +
!                                conditions                             
!           uvsold(nn)         = solution vector (old time level)    + +
!           uvsnew(nn)         = solution vector (new time level)    + +
!           sec_per_days       = conversion factor from SI input     + -
!                                units for physico-chemical             
!                                parameters internal time units         
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibcvs              = unit number, transient boundary     * +
!                                             conditions, variably      
!                                             saturated flow            
!           idat               = unit number, run specific input     + -
!                                             file                      
!           igen               = unit number, generic output file    + -
!           ilog               = unit number, log book               + -
!           itmp               = unit number, temporary storage      + -
!           iabvs(nbvs)        = pointer to boundary control volumes * +
!                                for variably saturated flow            
!           iwork(:)           = integer work array                  * *
!           l_prfx             = length of prefix of I/O files       + -
!           l_zone_name        = length of zone name                 * +
!           nn                 = total number of control volumes     + -
!           nbvs               = number of specified boundary        * +
!                                control volumes                        
!                                (variably saturated flow)              
!           nseep_first        = number of seepage face nodes        * +
!                                                                       
!           logical:                                                    
!           --------                                                    
!           fully_saturated    = .true.  -> saturated conditions     + -
!           update_bcvs        = .true.  -> transient boundary       * +
!                                           condition for variably      
!                                           saturated flow              
!           variably_saturated = .true.  -> .not.fully_saturated,    + -
!                                        -> variably saturated          
!                                           conditions                  
!           hydraulic_head     = .true.  -> initial condition in     + -
!                                           terms of hydraulic head     
!           pressure_head      = .true.  -> initial condition in     + -
!                                           terms of pressure heada     
!           seepage_face       = .true.  -> seepage face boundary    * +
!                                           specified                   
!                                                                       
!           character:                                                  
!           ----------                                                  
!           prefix             = prefix name for all I/O files       + -
!           zone_name          = name of zone                        * +
!           btypevs(nbvs)      = boundary type array                 * +
!                                (variably saturated flow)              
!                                'first'   = Dirichlet                  
!                                'second'  = Neumann                    
!                                'seepage' = seepage face               
!           section_header     = section header                      * +
!                                                                       
! local:    real*8:                                                     
!           -------                                                     
!           r0                 = constant                               
!           r1                 = constant                               
!           tiny               = small increment                        
!           xbmin              = min. x-coordinate of boundary          
!                                zone                                   
!           xbmax              = max. x-coordinate of boundary          
!                                zone                                   
!           ybmin              = min. y-coordinate of boundary          
!                                zone                                   
!           ybmax              = max. y-coordinate of boundary          
!                                zone                                   
!           zbmin              = min. z-coordinate of boundary          
!                                zone                                   
!           zbmax              = max. z-coordinate of boundary          
!                                zone                                   
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibvs               = counter (boundary control volumes)     
!           ibz                = counter (zones)                        
!           ierr               = 0 -> memory allocation successful      
!           ivol               = counter (control volumes)              
!           istart             = pointer (control volume)               
!           iend               = pointer (control volume)               
!           l_string           = length of text string                  
!           nbvsp              = start of boundary zone                 
!                                (temporary)                            
!           nbzheat            = number of boundary zones
!                                                                       
!           logical:                                                    
!           --------                                                    
!           found              = logical variable to exit search        
!           found_section      = .true.  -> section header was          
!                                           found in input file         
!           found_subsection   = .true.  -> subsection header was       
!                                           found in input file         
!           xy_plane           = boundary zone parallel tp xy-plane     
!           xz_plane           = boundary zone parallel to xz-plane     
!           yz_plane           = boundary zone parallel to yz-plane     
!                                                                       
!           character:                                                  
!           ----------                                                  
!           bcond              = btypevs = 'first'                      
!                                -> hydraulic head                      
!                                btypevs = 'second'                     
!                                -> specified flux                      
!                                btypevs = 'seepage'                    
!                                -> initial seepage face heigth         
!           btypezn            = boundary type of zone                  
!           subsection         = name of subsection in input file       
!                                                                       
! external: checkerr  = check for error during memory allocation        
!           findstrg  = find text string in file                        
!           findzone  = find zone in input section                      
!           readbloc  = read section of input file and write to         
!                       temporary file                                  
!           readzone  = read zone in section of input file and          
!                       write to temporary file                         
! ----------------------------------------------------------------------
                                                                        
      subroutine initbcenergybal 
                                                                        
      use parm 
      use gen 
      use dens 
      use m_heat_transport
      use file_unit, only : lun_get, lun_free
      use file_utility, only : rewind_first_record
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, num_nodes_per_cell,  &
                                node_cells, node_num_cells,            &
                                node_to_layer_node,                    &
                                layer_nodes_top, layer_nodes_bottom,   &
                                cell2halfid, CellFaceCenter, cells,    &
                                cal_cellface_index, cell_projection,   &
                                num_faces_per_cell, CellFaceScaledNorm,&
                                is_boundary_node, num_edge_dvols,      &
                                CellCvolFaceArea, get_cell_edge_cvol_id
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#endif
      implicit none
                                                                        
      external checkerr, findstrg, findzone, readbloc, readzone
      
      real*8 :: r0, r1, tiny, r86400, r1000
      real*8 :: ddens_temp, ddens_c, areaf, temp0_grad, slope_grad,    &
                bcond, xbmin, xbmax, ybmin, ybmax, zbmin, zbmax,       &
                pos_grad
      real*8 :: rx0, ry0, rz0     !center of gradient-radius type i.c. or b.c. condition
      integer :: i, ibheat, ibz, ibvs, ivolvs, ierr, ivol, jvol,       &
                 jvol1, jvol2, l_string, nbheatp, istart, iend, jtemp, &
                 ierrcd
      integer :: itype_grad       !0: normal, 1: bottom, 2: top (layered mesh)
                                                                        
      parameter (r0=0.0d0,r1=1.0d0,tiny=1.0d-8,r86400=86400.0d0,       &
                 r1000=1000.0d0)
                                                                        
      logical :: xy_plane,xz_plane,yz_plane,found,found_section,       &
                 found_subsection
      character*1  :: dir_grad
      character*32 :: btypezn
      character*72 :: subsection
      character*256 :: strbuffer
      character*16, allocatable :: cwork(:)
      real*8  factiny
#ifdef USG
      real*8 :: ratio_flux
      integer :: icell, icell2, iface, cindex, idvol, idvol_r, iedge_r,&
                 jvol3, jvol4
      type(point) :: pts(4)
#endif
                                                                        
      ierrcd = 0
      nbzheat=0
!cprovi-----------------------------------------------------------------
!cprovi Set initial values for themal gradient                          
!cprovi-----------------------------------------------------------------
      temp0_grad=r0 
      slope_grad=r1 
      dir_grad='z' 
      
      areaf = r0
      pos_grad = r0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
                                                                        
!  define defaults                                                      
          
      if(rank == 0 .and. b_enable_output) then
        write(*,*) 'boundary conditions - ',                           &
     &             'energy balance'                                       
        write(*,*) ('-',i=1,72) 
                                                                        
        write(ilog,'(2a)') 'boundary conditions - ',                     &
     &                     'energy balance'                               
        write(ilog,'(72a/)')('-',i=1,72) 
      end if  
                                                                        
!  read section header for boundary conditions of variably saturated    
!  flow simulation                                                      
                                                                        
      section_header = 'boundary conditions - energy balance' 
      call readbloc (idat,itmp,section_header,found_section,.true.) 
                                                                        
!  define length of section header                                      
                                                                        
      l_string = index(section_header,'  ')-1 
      if (l_string.eq.-1.or.l_string.gt.72) then 
         l_string=72 
      end if 
                                                                        
!  terminate program if section header not found                        
                                                                        
      if (.not.found_section) then 
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file' 
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop 
      end if 
                                                                        
!  write section header to generic output file                          
      if (b_enable_output .and. b_enable_output_gen) then                                                          
        write(igen,'(/72a)')('-',i=1,72) 
        write(igen,'(a)') section_header(:l_string) 
        write(igen,'(72a/)')('-',i=1,72) 
      end if
                                                                        
!c  initialize variables for seepage face iteration                      
!c  bug here, seepage_face should not be initialized false here
!c  otherwise, it always turn off seepage_face when heat transport
!c  is used. DSU, 2020-03-09
      !seepage_face = .false. 
      !nseep_first = 0 
                                                                        
!  preliminary allocation of memory for boundary conditions
      allocate (bcondheat(nngl), stat = ierr) 
      bcondheat=r0 
      call checkerr(ierr,'bcondheat',ilog)
      call memory_monitor(sizeof(bcondheat),'bcondheat',.true.)

                                                                          
      allocate (bcondheat0(nngl), stat = ierr) 
      bcondheat0=r0 
      call checkerr(ierr,'bcondheat0',ilog)
      call memory_monitor(sizeof(bcondheat0),'bcondheat0',.true.)

                                                                    
      allocate (iabheat(nngl), stat = ierr) 
      iabheat=0 
      call checkerr(ierr,'iabheat',ilog)
      call memory_monitor(sizeof(iabheat),'iabheat',.true.)

                                                                   
      allocate (iabheat0(nngl), stat = ierr) 
      iabheat0=0 
      call checkerr(ierr,'iabheat0',ilog) 
      call memory_monitor(sizeof(iabheat0),'iabheat0',.true.)

                                                                   
      allocate (btypeheat(nngl), stat = ierr) 
      btypeheat=' ' 
      call checkerr(ierr,'btypeheat',ilog) 
      call memory_monitor(sizeof(btypeheat),'btypeheat',.true.)

                                                                   
      allocate (ivol2bheat(nngl), stat = ierr)
      ivol2bheat=0
      call checkerr(ierr,'ivol2bheat',ilog)
      call memory_monitor(sizeof(ivol2bheat),'ivol2bheat',.true.)   

                                                                   
      allocate (ivol2bzheat(nngl), stat = ierr)
      ivol2bzheat=0
      call checkerr(ierr,'ivol2bzheat',ilog)
      call memory_monitor(sizeof(ivol2bzheat),'ivol2bzheat',.true.)   

                                                                   
      allocate (areaf_bheat(nngl), stat = ierr)
      areaf_bheat=0
      call checkerr(ierr,'areaf_bheat',ilog)
      call memory_monitor(sizeof(areaf_bheat),'areaf_bheat',.true.)   

!  read number of boundary zones                                        

      ierrcd = 1
      read(itmp,*,err=999,end=999) nbzheat
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
     &  'number of boundary zones                        = ',nbzheat
      end if
                                                                        
!  initialize pointer array for storage of boundary conditions          
                                                                        
      nbheat = 0 
      iabheat(1) = 1 

!c  allocate variables for 'gradient' type boundary conditions
      allocate (bzheat_dir_grad(nbzheat), stat = ierr)
      bzheat_dir_grad=' '
      call checkerr(ierr,'bzheat_dir_grad',ilog)
      call memory_monitor(sizeof(bzheat_dir_grad),'bzheat_dir_grad',.true.)

      allocate (bzheat_itype_grad(nbzheat), stat = ierr)
      bzheat_itype_grad=0
      call checkerr(ierr,'bzheat_itype_grad',ilog)
      call memory_monitor(sizeof(bzheat_itype_grad),'bzheat_itype_grad',.true.)

      allocate (bzheat_nparms(nbzheat), stat = ierr)
      bzheat_nparms=1
      call checkerr(ierr,'bzheat_nparms',ilog)
      call memory_monitor(sizeof(bzheat_nparms),'bzheat_nparms',.true.)   
      
      allocate (bzheat_radius_center(nbzheat), stat = ierr)
      bzheat_radius_center%x = r0
      bzheat_radius_center%y = r0
      bzheat_radius_center%z = r0
      call checkerr(ierr,'bzheat_radius_center',ilog)
      call memory_monitor(sizeof(bzheat_radius_center),'bzheat_radius_center',.true.)

!  read name of zone                                                    
                                                                        
                                  !loop over number of zones            
      do ibz=1,nbzheat
                                                                        
                                      !temporary pointer for output     
        nbheatp = nbheat+1 
                                                                        
!  find current zone in input file and write to temporary file          
                                                                        
        subsection = 'number and name of zone' 
                                                                        
        call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                        
        if (found_subsection) then 
                                                                        
          call readzone(itmp,icnv,ilog,zone_name,found_subsection) 
                                                                        
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error in input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define length of zone name                                           
                                                                        
        l_zone_name = index(zone_name,'  ')-1 
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
          l_zone_name = 72 
        end if 
                                                                        
                                                                        
!  define type and value of boundary condition                          
                                                                        
        subsection = 'boundary type' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 

        if (found_subsection) then 
          ierrcd = 2
          read(icnv,'(a)',err=999,end=999) strbuffer
          strbuffer = adjustl(strbuffer)

          if(index(strbuffer,'gradient') == 2) then
#ifdef USG
            if(index(strbuffer,'gradient-top') == 2) then
              itype_grad = 2
            else if(index(strbuffer,'gradient-bottom') == 2) then
              itype_grad = 1
            else
              itype_grad = 0
            end if

            if (.not. b_use_layered_mesh) then
              itype_grad = 0
            end if
#endif
            btypezn = 'gradient'

            if(index(strbuffer,'gradient-radius') == 2) then
              ierrcd = 3
              read(icnv,*,err=999,end=999) dir_grad, rx0, ry0, rz0
              read(icnv,*,err=999,end=999) temp0_grad
              read(icnv,*,err=999,end=999) slope_grad

              bzheat_radius_center(ibz)%x = rx0
              bzheat_radius_center(ibz)%y = ry0
              bzheat_radius_center(ibz)%z = rz0

              !c reset dir_grad to 'r' for gradient-radius type
              if (dir_grad /= 'r') then
                dir_grad = 'r'
              end if

            else
              ierrcd = 4
              read(icnv,*,err=999,end=999) dir_grad
              read(icnv,*,err=999,end=999) temp0_grad
              read(icnv,*,err=999,end=999) slope_grad
            end if

            if (dir_grad /= 'x' .and. dir_grad /= 'y' .and.            &
                dir_grad /= 'z' .and. dir_grad /= 'r') then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "',section_header(:l_string),'"'
                write(ilog,*) 'Error in gradient direction'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

            bzheat_dir_grad(ibz) = dir_grad
            bzheat_itype_grad(ibz) = itype_grad
            bzheat_nparms(ibz) = 2

          else
            ierrcd = 5
            read(strbuffer,*,err=999,end=999) btypezn, bcond

            bzheat_nparms(ibz) = 1
          end if 
                                                                        
        else 
              
          if (rank == 0) then  
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  read coordiantes defining boundary zone,
        type_extent_zone = -1
        type_extent_zone_box = -1
                                                                        
        subsection = 'extent of zone' 

        call findstrg(subsection,icnv,found_subsection)
                                                                        
        if (found_subsection) then 

          type_extent_zone = 0
          ierrcd = 6
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
     &                                 zbmin,zbmax

        end if

#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 7
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xbmin = -1.0d300
          xbmax = 1.0d300
        end if

        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ybmin = -1.0d300
          ybmax = 1.0d300
        end if

        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zbmin = -1.0d300
          zbmax = 1.0d300
        end if
                                                                        
!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then
                 
          if (rank == 0) then  
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define boundary face to be considered (only needed for calculation   
!  of boundary face area for second type boundary conditions)           
                                                                        
        if (type_extent_zone == 0 .and. type_extent_zone_box <= 0 .and.&
            btypezn.eq.'second') then
                                                                        
          found = .false. 
          xy_plane = .false. 
          xz_plane = .false. 
          yz_plane = .false. 
                                                                        
                                                  !xy_plane             
          if (dabs(zbmax-zbmin).lt.tiny) then 
            if ((dabs(xbmax-xbmin).lt.tiny).or.                         &
                (dabs(ybmax-ybmin).lt.tiny)) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED' 
                write(ilog,*) 'error in input file' 
                write(ilog,*) 'section "', section_header(:l_string),'"' 
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                write(ilog,*) 'unable to specify boundary face' 
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            else 
              xy_plane = .true. 
              found = .true. 
            end if 
          end if 
                                                                        
                                                   !xz_plane            
          if (.not.found) then 
            if (dabs(ybmax-ybmin).lt.tiny) then 
              if ((dabs(xbmax-xbmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then 
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "', section_header(:l_string),'"' 
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face' 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                xz_plane = .true. 
                if (xy_plane) then
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                            &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
                                                   !yz_plane            
          if (.not.found) then 
            if (dabs(xbmax-xbmin).lt.tiny) then 
              if ((dabs(ybmax-ybmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then  
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "',section_header(:l_string),'"' 
                  write(ilog,*) 'zone "',zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                yz_plane = .true. 
                if (xy_plane.or.xz_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                         &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
!  exit if boundary face was not found                                  
                                                                        
          if (.not.found) then
#ifdef USG
            if(cell_projection /= projection_xyz) then
#endif
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
#ifdef USG
            end if
#endif
          end if 

          !c define flux direction for unstructured grid
#ifdef USG
          if (discretization_type > 0 .and. type_flux_direction == 0) then
            if (xy_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,0.0d0,1.0d0)
            else if (yz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(1.0d0,0.0d0,0.0d0)
            else if (xz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,1.0d0,0.0d0)
            end if
          end if
#endif
                                  !(btypezn.eq.'second')                
        end if 
                                                                        
!  increment boundary coordinates                                       
                                                                        
        factiny=dabs(xbmax-xbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        xbmin = xbmin-factiny 
        xbmax = xbmax+factiny 
        factiny=dabs(ybmax-ybmin)*tiny 
        if (factiny==r0) factiny=tiny 
        ybmin = ybmin-factiny 
        ybmax = ybmax+factiny 
        factiny=dabs(zbmax-zbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        zbmin = zbmin-factiny 
        zbmax = zbmax+factiny 
                                                                        
!  store type of boundary condition and boundary condition              
!  for global system in compressed storage                              
                                                                        
        do ivol = 1,nngl 
                                                                        
!  check limits of boundary zone                                        
                                                                        
          if (((type_extent_zone==0.or.type_extent_zone_box>0) .and.   &
              (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.        &
              (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.        &
              (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.        &
              (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
              ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
            if (discretization_type > 0 .and. type_extent_zone_box > 0) then
              if ((btest(type_extent_zone_box,1) .and.                 &
                   .not. is_boundary_node(ivol)) .or.                  &
                  (btest(type_extent_zone_box,2) .and.                 &
                   is_boundary_node(ivol))) then
                cycle
              end if
            end if
#endif
                                                                        
!  assign boundary type and boundary condition                          
                                                                        
            nbheat = nbheat + 1
                                                                        
!  exit if nbvs > nn                                                    
                                                                        
            if (nbheat.gt.nngl) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'nbheat > nn ...'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if
                                                                        
!  assign pointer and                                                   
                                                                        
            iabheat(nbheat) = ivol
            btypeheat(nbheat) = btypezn

            ivol2bheat(ivol) = nbheat
            ivol2bzheat(ivol) = ibz            
                                                                        
!  first type boundary condition - constant temperature 

            if (btypeheat(nbheat).eq.'first') then

                tempnew(ivol) = bcond
                tempold(ivol) = bcond
                bcondheat(nbheat) = bcond

            elseif (btypeheat(nbheat).eq.'gradient')then

#ifdef USG
              if (itype_grad == 1)then
                select case(dir_grad)
                case ('x')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                case ('y')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                case ('z')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                end select
              else if (itype_grad == 2)then
                select case(dir_grad)
                case ('x')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                case ('y')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                case ('z')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                end select
              else
#endif
                select case(dir_grad)
                case ('x')
                  pos_grad=xg(ivol)
                case ('y')
                  pos_grad=yg(ivol)
                case ('z')
                  pos_grad=zg(ivol)
                case ('r')
                  pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                  (yg(ivol) - ry0)**2 +  &
                                  (zg(ivol) - rz0)**2)
                end select
#ifdef USG
              end if
#endif

              tempnew(ivol) = temp0_grad + slope_grad*pos_grad
              tempold(ivol) = tempnew(ivol)
              bcondheat(nbheat) = tempnew(ivol)
              btypeheat(nbheat) = 'first'

                
            elseif (btypeheat(nbheat).eq.'free') then
                     
              bcondheat(nbheat) = bcond

              do ibvs = 1,nbvs
                ivolvs = iabvs(ibvs)
                if (ivolvs < 0) then
                  cycle
                end if
                if (ivolvs==ivol.and.btypevs(ibvs)=='second') then
                  ddens_temp = drho_dt*(bcond-tempref_dens)
                  ddens_c = drho_dc * (tds_new(ivol) - ref_tds)
                  !ssdens(ivol) = ref_dens + ddens_temp + ddens_c                 
                end if
              end do


!c  second type boundary condition - specified flux

            elseif (btypezn.eq.'second') then

!c  calculate flux area

              if (discretization_type == 0) then
                if (xy_plane) then
                  areaf = dimcv(1,ivol) * dimcv(2,ivol)
                elseif (xz_plane) then
                  areaf = dimcv(1,ivol) * dimcv(3,ivol)
                elseif (yz_plane) then
                  areaf = dimcv(2,ivol) * dimcv(3,ivol)
                end if
#ifdef USG
              else
                if (cell_type == cell_type_tri .or.                    &
                    cell_type == cell_type_quad) then
                  !c connected control volume
                  if (is_boundary_node(ivol)) then
                    jvol1 = javs(iavs(ivol)+1)
                    jvol2 = javs(iavs(ivol+1)-1)
                    areaf = geometry_veclength(nodes(ivol)-            &
                            nodes(jvol1),flux_direction,               &
                            type_flux_direction)*0.5
                    areaf = areaf+geometry_veclength(nodes(ivol)-      &
                            nodes(jvol2),flux_direction,               &
                            type_flux_direction)*0.5
                  else
                    areaf = 0.0d0
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        if (icell2 > 0) then
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end if
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_tetra) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if
                else if (cell_type == cell_type_hexa) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_prism) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1, 2                              !number of faces, top and bottom faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                        end if
                      end do

                      do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_prism(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if
                else
                  if (rank == 0) then
                    write(ilog,'(2a,i2)') 'boundary surface area calculation ',  &
                          'does not support cell_type initbcenergybal',cell_type
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
#endif
              end if
!cprovi---------------------------------------------------------
!cprovi assign second type boundary condition
!cprovi Transform J => Kj 
!cprovi---------------------------------------------------------
              bcondheat(nbheat) = areaf*bcond/r1000
              areaf_bheat(nbheat) = areaf

            elseif (btypezn.eq.'point') then

              bcondheat(nbheat) = bcond/r1000

            end if     !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.
                       ! btypezn.eq.'seepage')
          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes

!c  write header for boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/a,i0,a,1x,a)') 'zone ',ibz,':',zone_name
          write(igen,'(72a)')('-',i=1,72)
          
          if (btypezn.eq.'first') then
            write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',  &
     &                                     'temperature'
          elseif (btypezn.eq.'second') then
            write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',  &
     &                                   'specified flux'
          end if
        end if

!c  write boundary condition for zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          if (btypezn.ne.'seepage') then         !first and second type
            do ibheat=nbheatp,nbheat
              ivol = iabheat(ibheat)
              write(igen,'(i8,3x,a16,1pe15.6e3)') ivol,btypeheat(ibheat), &
     &                                          bcondheat(ibheat)
            end do
          end if
        end if

!c  conversion of time units for computation in days
!c  if second type boundary condition is specified

        if ((btypezn.eq.'second') .or.    &
     &      (btypezn.eq.'point')) then
          do ibheat=nbheatp,nbheat
            bcondheat(ibheat) = bcondheat(ibheat)*sec_per_days
          end do
        end if

      end do            !end loop over zones

!c  define if boundary conditions are to updated
      update_bcheat=.false. 

      subsection = 'transient boundary conditions'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        update_bcheat = .true.
      else
        subsection = 'transient temperature boundary conditions'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          update_bcheat = .true.
        end if
      end if

!cdsu only update the boundary condition values, with boundary type and zone unchanged.
      update_bcheat_value_only=.false.

      subsection = 'transient boundary conditions: values only'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        update_bcheat = .true.
        update_bcheat_value_only = .true.
      else
        subsection = 'transient temperature boundary conditions: values only'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          update_bcheat = .true.
          update_bcheat_value_only = .true.
        end if
      end if

!cdsu linear interpolation for boundary conditions, only if the 
!cdsu boundary condition type remains the same
      b_interpolation_bcheat = .false.
      b_first_update_bcheat = .false.

      if (update_bcheat_value_only) then
        subsection = 'linear interpolation of boundary conditions'
        call findstrg(subsection,itmp,found_subsection) 
        if (found_subsection) then
          b_interpolation_bcheat = .true.
          b_first_update_bcheat = .true.
        end if 
      end if         

!c  open file containing boundary conditions for variably saturated flow
!c  and read first read time

      if (update_bcheat) then

        !ibcheat = 15
        ibcheat = lun_get()
        open(ibcheat,file=prefix(:l_prfx)//'.bcheat',err=997, status='old')
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(ibcheat)
        read(ibcheat,*,err=998,end=998) time_bcheat
             
      end if
      
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
      update_ext_type_bcheat=.false. 
      subsection = 'update extension and type boundary conditions'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        update_ext_type_bcheat = .true.
      end if



      if (update_ext_type_bcheat) then
       
       !ibcheat1 = 17
       ibcheat1 = lun_get()

       open(ibcheat1,file=prefix(:l_prfx)//'.bcheat1',err=997, status='old')
             
      end if



!c  minimize memory requirement for boundary arrays
!c  array bcondvs    

      nbheat0=nbheat

      allocate (rwork(nbheat,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'rwork',.true.)

      do ibheat = 1,nbheat
        rwork(ibheat,1) = bcondheat(ibheat)
      end do

      call memory_monitor(-sizeof(bcondheat),'bcondheat',.true.)
      deallocate (bcondheat, stat = ierr)
      call checkerr(ierr,'bcondheat',ilog)

      allocate (bcondheat(nbheat), stat = ierr)
      call checkerr(ierr,'bcondheat',ilog)
      call memory_monitor(sizeof(bcondheat),'bcondheat',.true.)
      
      call memory_monitor(-sizeof(bcondheat0),'bcondheat0',.true.)
      deallocate (bcondheat0, stat = ierr)
      call checkerr(ierr,'bcondheat0',ilog)

      allocate (bcondheat0(nbheat), stat = ierr)
      call checkerr(ierr,'bcondheat0',ilog)
      call memory_monitor(sizeof(bcondheat0),'bcondheat0',.true.)

      do ibheat = 1,nbheat
        bcondheat(ibheat) = rwork(ibheat,1)
        bcondheat0(ibheat) = rwork(ibheat,1)
      end do

!c  interpolation of transient boundary condition
      allocate (bcondheat_prev(nbheat), stat = ierr)
      call checkerr(ierr,'bcondheat_prev',ilog)
      call memory_monitor(sizeof(bcondheat_prev),'bcondheat_prev',.true.)
      bcondheat_prev = bcondheat

      allocate (bcondheat_next(nbheat), stat = ierr)
      call checkerr(ierr,'bcondheat_next',ilog)
      call memory_monitor(sizeof(bcondheat_next),'bcondheat_next',.true.)
      bcondheat_next = bcondheat

      call memory_monitor(-sizeof(rwork),'initbcenergybal-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array btypeheat
      allocate (cwork(nbheat), stat = ierr)
      call checkerr(ierr,'cwork',ilog)
      call memory_monitor(sizeof(cwork),'initbcenergybal-cwork',.true.)

      !c btypeheat
      do ibheat = 1,nbheat
        cwork(ibheat) = btypeheat(ibheat)
      end do

      call memory_monitor(-sizeof(btypeheat),'btypeheat',.true.)
      deallocate (btypeheat, stat = ierr)
      call checkerr(ierr,'btypeheat',ilog)

      allocate (btypeheat(nbheat), stat = ierr)
      call checkerr(ierr,'btypeheat',ilog)
      call memory_monitor(sizeof(btypeheat),'btypeheat',.true.)

      do ibheat = 1,nbheat
        btypeheat(ibheat) = cwork(ibheat)
      end do

      call memory_monitor(-sizeof(cwork),'initbcenergybal-cwork',.true.)
      deallocate (cwork, stat = ierr)
      call checkerr(ierr,'cwork',ilog)   
      
!c  array areaf_bheat
      allocate (rwork(nbheat,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcenergybal-rwork',.true.)

      do ibheat = 1,nbheat
        rwork(ibheat,1) = areaf_bheat(ibheat)
      end do

      call memory_monitor(-sizeof(areaf_bheat),'areaf_bheat',.true.)
      deallocate (areaf_bheat, stat = ierr)
      call checkerr(ierr,'areaf_bheat',ilog)

      allocate (areaf_bheat(nbheat), stat = ierr)
      call checkerr(ierr,'areaf_bheat',ilog)
      call memory_monitor(sizeof(areaf_bheat),'areaf_bheat',.true.)

      do ibheat = 1,nbheat
        areaf_bheat(ibheat) = rwork(ibheat,1)
      end do

      call memory_monitor(-sizeof(rwork),'initbcheat-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)            


!c  array iabheat, iabheat0

      allocate (iwork(nbheat), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initbcenergybal-iwork',.true.)

      do ibheat = 1,nbheat
        iwork(ibheat) = iabheat(ibheat)
      end do

      call memory_monitor(-sizeof(iabheat),'iabheat',.true.)
      deallocate (iabheat, stat = ierr)
      call checkerr(ierr,'iabheat',ilog)

      allocate (iabheat(nbheat), stat = ierr)
      call checkerr(ierr,'iabheat',ilog)
      call memory_monitor(sizeof(iabheat),'iabheat',.true.)
      
      call memory_monitor(-sizeof(iabheat0),'iabheat0',.true.)
      deallocate (iabheat0, stat = ierr)
      call checkerr(ierr,'iabheat',ilog)

      allocate (iabheat0(nbheat), stat = ierr)
      call checkerr(ierr,'iabheat',ilog)
      call memory_monitor(sizeof(iabheat0),'iabheat0',.true.)

      do ibheat = 1,nbheat
        iabheat(ibheat) = iwork(ibheat)
        iabheat0(ibheat) = iwork(ibheat)
      end do
      
      do ibheat = 1,nbheat
        do i = nbheat, ibheat + 1, -1
          if (iabheat(i) == iabheat(ibheat)) then
            iabheat(ibheat) = -iabheat(ibheat)
            iabheat0(ibheat) = -iabheat0(ibheat)
            exit
          end if
        end do
      end do

      call memory_monitor(-sizeof(iwork),'initbcenergybal-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      
      !allocate (bvalid_iabheat(nbheat), stat = ierr)
      !call checkerr(ierr,'bvalid_iabheat',ilog)
      !bvalid_iabheat = .true.
      
      !do ibheat = 1,nbheat
      !    do ibheat2 = ibheat +1, nbheat
      !        if(iabheat(ibheat) == iabheat(ibheat2)) then
      !            bvalid_iabheat(ibheat) = .false.
      !            exit
      !        end if
      !    end do
      !end do

      goto 1000

997   write(ilog,*) 'SIMULATION TERMINATED' 
      write(ilog,*) 'file ', prefix(:l_prfx)//'.bcheat missing'
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

998   write(ilog,*) 'SIMULATION TERMINATED' 
      write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcheat'
      close(ilog)

#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading input file, error code ',ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
