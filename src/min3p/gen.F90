!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/gen.F90 $
!---------------------------------------------------------------------
!********************************************************************!

      module gen 

      use parm
      use m_ice_sheet
      use m_heat_transport
      use multidiff
      use geometry_definition
      
      implicit none

! ---------------------------------------------------------------------- 
! common - general variables
!
! ---------------------------------------------------------------------- 
! global control parameters:
! --------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cpuint             = cpu-time (intermediate) [seconds]
!           csec               = cpu-time [seconds]
!           por_thresh_max     = maximum porosity threshold          * +
!                                avoid division by 0 in 
!                                Kozeny-Carman equation
!           por_thresh_min     = minimum porosity threshold          * +
!           permfac_thresh_max = maximum permeability factor threshold  * +
!           permfac_thresh_min = minimum permeability factor threshold  * +
!           marchie            = updated tortuosity as the function
!                                of changed porosity
!                                tau = tau_0 * por^alpha / por_0^alpha
!                                tau_0 = assigned tau or por_0^alpha
!                                marchie = alpha
!           tran_steady_exit_time        -> exit simulation after maximum time is reached
!
!           logical:
!           --------
!           depth_output       = .true.  -> output in terms of
!                                           depth instead of 
!                                           elevation
!           root_uptake        = .true.  -> calculate root water
!                                           uptake
!           full_path          = .true.  -> path for database
!                                           specified in problem
!                                           specific input file
!           fully_saturated    = .true.  -> saturated conditions 
!           geo_chemistry      = .true.  -> local or background and   
!                                           source chemistry         
!           log_file           = .true.  -> write logbook to file
!           not_converged      = .true.  -> continue Newton 
!                                           iteration
!           tran_steady_flow_converged
!                              = .true.  -> flow reaches steady state condition
!                                           when running in transient mode
!           reactive_transport = .true.  -> perform reactive          
!                                           transport simulation      
!           show_module        = .true.  -> write current module
!                                           name to screen
!           steady_flow        = .true.  -> steady state flow
!           pore_clogging      = .true.  -> pore clogging model
!           update_porosity    = .true.  -> update porosity as
!                                           a result of dissolution-
!                                           precipitation reactions
!           update_permeability= .true.  -> update permeability as
!                                           a function of porosity
!           transient_flow     = .true.  -> .not.steady_flow,
!                                        -> transient flow
!           tran_steady_flow   = .true.  -> .not.steady_flow,
!                                        -> transient flow
!                                           Add by DSU on April 26, 2019. This feature is
!                                           same as steady flow but uses transient mode.
!                                           For some steady state flow, because of transient
!                                           effect, there may be converge prolbem if using
!                                           steady flow directly. In this case, transient flow
!                                           can be used instead until the flow reaches steady state
!           tran_steady_stop   = .true.  -> stop simulation after transient steady state is reached.
!
!           tran_steady_drho_0 = .true.
!                                        -> disable density effect when running steady state flow
!                                           flow in transient mode (drho_dc = 0, drho_dt = 0) to obtain 
!                                           steady state flow condition without density change.
!
!           variably_saturated = .true.  -> .not.fully_saturated,
!                                        -> variably saturated 
!                                           conditions
!           varsat_flow        = .true.  -> perform flow simulation   
!           update_tortuosity  = .true.  -> update tortuosity as 
!                                           tau = tau_0*por^tor_factor/
!                                                 por_o^tor_factor
!           assign_marchies    = .true.  -> update tortuosity as a function 
!                                           of tau = tau_0 * (por_0/por)^alpha
!
!           character:
!           ----------
!           problem_title      = problem title
!           dbs_dir            = database directory
!           drive              = drive of program installation
!        -->                                                         <--
! ---------------------------------------------------------------------- 

      real (type_r8) :: cpuint 
      real (type_r8) :: csec
      real (type_r8) :: por_thresh_max
      real (type_r8) :: por_thresh_min
      real (type_r8) :: permfac_thresh_max
      real (type_r8) :: permfac_thresh_min
      real (type_r8) :: rtol_tran_steady_flow
      real (type_r8) :: atol_tran_steady_flow
      real (type_r8) :: rtol_tran_steady_heat
      real (type_r8) :: atol_tran_steady_heat
      real (type_r8) :: tran_steady_exit_time

      logical :: varsat_flow 
      logical :: steady_flow 
      logical :: transient_flow 
      logical :: tran_steady_flow
      logical :: tran_steady_flow_converged
      logical :: tran_steady_heat_converged
      logical :: tran_steady_drho_0
      logical :: tran_steady_stop
      logical :: not_converged
      logical :: full_path
      logical :: fully_saturated
      logical :: variably_saturated
      logical :: geo_chemistry
      logical :: reactive_transport
      logical :: show_module 
      logical :: log_file 
      logical :: depth_output
      logical :: harmonic_porosity
      logical :: pore_clogging
      logical :: update_porosity
      logical :: update_permeability
      logical :: update_porosity_flow
      logical :: update_permeability_flow
      !logical :: iterative_solver_flow
      logical :: radial_coord
      logical :: update_tortuosity
      logical :: assign_marchies

      logical :: root_uptake
      logical :: root_uptake_legacy

      logical :: use_dbs_bk

      character*72 :: problem_title
      character*256 :: dbs_dir
      character*1 ::  drive

! ---------------------------------------------------------------------- 
! global constants:
! -----------------
!        -->                                                         <--
!           real*8:
!           -------
!           sec_per_days       = conversion factor from SI input
!                                units for physico-chemical 
!                                parameters to internal time units
!           gacc               = gravity acceleration
!        -->                                                         <--
! ---------------------------------------------------------------------- 

      real (type_r8) :: sec_per_days
      real (type_r8) :: gacc
      
! ---------------------------------------------------------------------- 
! spatial discretization:
! -----------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cvol(nn)           = nodal volumes
!           delx(nvx)          = spatial increment in x-direction         
!           dely(nvy)          = spatial increment in y-direction         
!           delz(nvz)          = spatial increment in z-direction         
!           dimcv(3,nn)        = dimension of control volumes
!           elevmax            = max. elevation in solution domain
!           xg(nn)             = spatial coordinates in x-direction
!           yg(nn)             = spatial coordinates in y-direction
!           zg(nn)             = spatial coordinates in z-direction
!           xglat(nvx)         = spatial coordinates in x-direction
!           yglat(nvy)         = spatial coordinates in y-direction
!           zglat(nvz)         = spatial coordinates in z-direction
!           xmax(nxx)          = max. coordinate of discretization 
!                                interval in x-direction
!           xmin(nxx)          = min. coordinate of discretization 
!                                interval in x-direction
!           ymax(nyy)          = max. coordinate of discretization 
!                                interval in y-direction
!           ymin(nyy)          = min. coordinate of discretization
!                                interval in y-direction
!           zmax(nzz)          = max. coordinate of discretization
!                                interval in z-direction
!           zmin(nzz)          = min. coordinate of discretization
!                                interval in z-direction
!            toparea            = profil area exposed to atmosphere  CBF
!           areaf_bvs(nbvs)    = area of boundary node in xy_plane
!                                for free-drainage flux calculation
!           gradf_bvs(nbvs)    = gradient of total hydraulic head
!                                for free-drainage flux calculation
!
!           integer:
!           --------
!           nxx                = number of intervals in x-direction  
!           nyy                = number of intervals in y-direction 
!           nzz                = number of intervals in z-direction
!           nvix(nxx)          = number of control volumes in 
!                                x-direction (intervals)
!           nviy(nyy)          = number of control volumes in 
!                                y-direction (intervals)
!           nviz(nzz)          = number of control volumes in 
!                                z-direction (intervals)
!           nxx                = number of intervals in x-direction  + - CBF RLD
!           nyy                = number of intervals in y-direction  + - CBF RLD
!           nzz                = number of intervals in z-direction  + - CBF RLD
!           nvx                = number of control volumes in 
!                                x-direction
!           nvy                = number of control volumes in 
!                                y-direction
!           nvz                = number of control volumes in 
!                                z-direction
!           nvxgl              = number of control volumes in 
!                                x-direction with ghost nodes
!           nvygl              = number of control volumes in 
!                                y-direction with ghost nodes
!           nvzgl              = number of control volumes in 
!                                z-direction with ghost nodes
!           nn                 = total number of control volumes without ghost nodes
!
!           nngl               = total number of control volumes with ghost nodes
!
!           nn_interfacial     = total number of interfacial area contained within 
!                                elemental volume 
!
!           nn_offset          = offset of control volumes without ghost nodes
!
!           nngl_offset        = offset of control volumes with ghost nodes
!
!           nn_interfacial_offset
!                              = offset of interfacial area contained within 
!                                elemental volume 
!
!           nn_ranks(nprcs)    = total number of control volumes without ghost nodes 
!                                for each rank
!
!           nngl_ranks(nprcs)  = total number of control volumes with ghost nodes
!                                for each rank
!
!           nn_interfacial_ranks(nprcs)
!                              = total number of interfacial area contained within 
!                                elemental volume for each rank
!
!           nvxgbl             = number of control volumes in 
!                                x-direction for global grid
!           nvygbl             = number of control volumes in 
!                                y-direction for global grid
!           nvzgbl             = number of control volumes in 
!                                z-direction for global grid
!           nngbl              = total number of control volumes
!                                for global grid
!
!           nvxls              = start number (1-based) of control volumes in
!                                x-direction for local grid
!           nvxle              = end number (1-based) of control volumes in
!                                x-direction for local grid
!           nvyls              = start number (1-based) of control volumes in
!                                y-direction for local grid
!           nvyle              = end number (1-based) of control volumes in
!                                xy-direction for local grid
!           nvzls              = start number (1-based) of control volumes in
!                                z-direction for local grid
!           nvzle              = end number (1-based) of control volumes in
!                                z-direction for local grid
!           nvxgls             = start number (1-based) of control volumes in
!                                x-direction for local grid
!           nvxgle             = end number (1-based) of control volumes in
!                                x-direction for local grid
!           nvygls             = start number (1-based) of control volumes in
!                                y-direction for local grid
!           nvygle             = end number (1-based) of control volumes in
!                                xy-direction for local grid
!           nvzgls             = start number (1-based) of control volumes in
!                                z-direction for local grid
!           nvzgle             = end number (1-based) of control volumes in
!                                z-direction for local grid
!           discretization_type= spatial discretization type
!                                0 structured grid
!                                1 unstructured grid triangulated based on structured grid
!                                2 unstructured grid triangulated on structured grid boundary
!                                3 unstructured grid read from external file
!           xlmin              = min coordinate in x direction for local grid, without ghost node
!           xlmax              = max coordinate in x direction for local grid, without ghost node
!           ylmin              = min coordinate in y direction for local grid, without ghost node
!           ylmax              = max coordinate in y direction for local grid, without ghost node
!           zlmin              = min coordinate in z direction for local grid, without ghost node
!           zlmax              = max coordinate in z direction for local grid, without ghost node
!
!           gxlmin             = min coordinate in x direction for local grid, with ghost node
!           gxlmax             = max coordinate in x direction for local grid, with ghost node
!           gylmin             = min coordinate in y direction for local grid, with ghost node
!           gylmax             = max coordinate in y direction for local grid, with ghost node
!           gzlmin             = min coordinate in z direction for local grid, with ghost node
!           gzlmax             = max coordinate in z direction for local grid, with ghost node
!           
!           xlmingbl             = min coordinate in x direction for global grid
!           xlmaxgbl             = max coordinate in x direction for global grid
!           ylmingbl             = min coordinate in y direction for global grid
!           ylmaxgbl             = max coordinate in y direction for global grid
!           zlmingbl             = min coordinate in z direction for global grid
!           zlmaxgbl             = max coordinate in z direction for global grid
!         pos         = position of the last '/' of the directory path string, CBF RLD
!                  usefull to extract just the path of the directory where output anf input files are located. 
!                  This path is transferred by coupling to ArchiSimple/Root Typ

!           logical:
!           --------
!           half_cells         = .true.  -> half cells on boundary
!           b_legacy_vtk       = .true.  -> legacy vtk mesh file, three points each line 
!                                           e.g., vtk file saved by Paraview
!           type(point):
!           --------
!           node_max           = maximum of x, y, z coordinates
!           node_min           = minimum of x, y, z coordinates
!        -->                                                         <--
! ---------------------------------------------------------------------- 


      real (type_r8), allocatable :: xg(:)
      real (type_r8), allocatable :: yg(:)
      real (type_r8), allocatable :: zg(:)
      real (type_r8), allocatable :: xglat(:)
      real (type_r8), allocatable :: yglat(:)
      real (type_r8), allocatable :: zglat(:)      
      real (type_r8), allocatable :: dimcv(:,:)
      real (type_r8), allocatable :: cvol(:)
      real (type_r8), allocatable :: delx(:)
      real (type_r8), allocatable :: dely(:)
      real (type_r8), allocatable :: delz(:)
      real (type_r8), allocatable :: xmax(:)
      real (type_r8), allocatable :: xmin(:)
      real (type_r8), allocatable :: ymax(:)
      real (type_r8), allocatable :: ymin(:)
      real (type_r8), allocatable :: zmax(:)
      real (type_r8), allocatable :: zmin(:)      
      real (type_r8), allocatable :: areaf_bvs(:)
      real (type_r8), allocatable :: areaf_bheat(:)
      real (type_r8), allocatable :: gradf_bvs(:)
      real (type_r8), allocatable :: gradf_bvs_prev(:)
      real (type_r8), allocatable :: gradf_bvs_next(:)

      real (type_r8) :: cvol_tot

      real (type_r8) :: elevmax
      real (type_r8) :: toparea ! CBF

      integer (type_i4), allocatable :: nvix(:)
      integer (type_i4), allocatable :: nviy(:)
      integer (type_i4), allocatable :: nviz(:)

      integer (type_i4) :: ndim_sys
      integer (type_i4) :: nxx
      integer (type_i4) :: nyy
      integer (type_i4) :: nzz
      integer (type_i4) :: nvx
      integer (type_i4) :: nvy
      integer (type_i4) :: nvz
      integer (type_i4) :: nvxgl
      integer (type_i4) :: nvygl
      integer (type_i4) :: nvzgl      
      integer (type_i4) :: nn
      integer (type_i4) :: nngl
      integer (type_i4) :: nn_interfacial
      integer (type_i4) :: nn_offset
      integer (type_i4) :: nngl_offset
      integer (type_i4) :: nn_interfacial_offset
      integer (type_i4), allocatable :: nn_ranks(:)
      integer (type_i4), allocatable :: nngl_ranks(:)
      integer (type_i4), allocatable :: nn_interfacial_ranks(:)
      integer (type_i4) :: nvxgbl
      integer (type_i4) :: nvygbl
      integer (type_i4) :: nvzgbl
      integer (type_i4) :: nngbl
      integer (type_i4) :: nvxls
      integer (type_i4) :: nvxle
      integer (type_i4) :: nvyls
      integer (type_i4) :: nvyle
      integer (type_i4) :: nvzls
      integer (type_i4) :: nvzle
      integer (type_i4) :: local_node_start
      integer (type_i4) :: local_node_end
      
      integer (type_i4) :: nvxgls
      integer (type_i4) :: nvxgle      
      integer (type_i4) :: nvygls      
      integer (type_i4) :: nvygle      
      integer (type_i4) :: nvzgls      
      integer (type_i4) :: nvzgle  

      integer (type_i4) :: pos ! CBF RLD
      
      integer (type_i4) :: discretization_type

      logical :: b_legacy_vtk

      real (type_r8) :: xlmin
      real (type_r8) :: xlmax
      real (type_r8) :: ylmin
      real (type_r8) :: ylmax
      real (type_r8) :: zlmin
      real (type_r8) :: zlmax 
      
      real (type_r8) :: gxlmin
      real (type_r8) :: gxlmax
      real (type_r8) :: gylmin
      real (type_r8) :: gylmax
      real (type_r8) :: gzlmin
      real (type_r8) :: gzlmax

      real (type_r8) :: xlmingbl
      real (type_r8) :: xlmaxgbl
      real (type_r8) :: ylmingbl
      real (type_r8) :: ylmaxgbl
      real (type_r8) :: zlmingbl
      real (type_r8) :: zlmaxgbl

      logical :: half_cells

      type(point) :: node_min
      type(point) :: node_max

!>
!> node flags
!>   iflag  = -1, outside of the selection boundary
!>          =  0, on the selection boundary
!>          =  1, inside of the selection boundary
!>
      integer (type_i4), allocatable :: node_iflags(:)

!>
!> cell flags
!>   iflag  = -1, outside of the selection boundary
!>          =  0, on the selection boundary
!>          =  1, inside of the selection boundary
!>
      integer (type_i4), allocatable :: cell_iflags(:)

! ----------------------------------------------------------------------
! time step control:
! ------------------
!        -->                                                         <--
!           real*8:
!           -------
!           delta_c(n)         = actual update in log cycles
!           delta_c_max(n)     = maximum update in log cycles
!           delt               = time step         
!           delt_io            = time step (I/O units)        
!           delt_vs            = estimated time step 
!                                (variably saturated flow)
!           delt_rt            = estimated time step 
!                                (reactive transport)
!           deltmax_global     = maximum time step, global
!           deltmax            = maximum time step, current period
!           deltmin            = minimum time step
!           time               = current solution time
!           time_io            = current solution time (I/O units)
!           time_factor        = conversion factor from I/O time
!                                units to internal time units
!           tfinal             = final solution time
!           urtant_log         = anticipated update in log cycles
!
!           mtime_f_ratio      = threshold of failed timestep ratio
!                                stop simulation when
!                                mtime_f/mtime > mtime_f_ratio
!           transient_deltmax(3,n_transient_deltmax)
!                              = transient maximum timestep array
!                                used to control maximum timestep over
!                                the specified period of time
!                                transient_deltmax(1,k): start time of kth period
!                                transient_deltmax(2,k): stop time of kth period
!                                transient_deltmax(3,k): maximum timestep of kth period
!
!           integer:
!           --------
!           l_time_unit        = length of time unit for output
!           mtime              = current time step
!           mtime_f            = number of failed time steps
!           i_transient_deltmax = current period
!           n_transient_deltmax = number of transient maximum timestep
!                                used to control maximum timestep over
!                                the specified period of time
!
!           logical:
!           --------
!           reduce_timestep    = .true.  -> restart with reduced
!                                           timestep
!
!           ignore_restart_time= .true.  -> ignore the time stamp in 
!                                           restart file
!           b_relax_timestep   = .true.  -> adjust timestep if it is 
!                                           around one timestep to the 
!                                           boundary condition updating time,
!                                           use a relaxed timestep to avoid
!                                           very small timestep before updating
!                                           boundary condition. In some cases, 
!                                           very small timestep may cause 
!                                           convergence problem.
!           b_updtbc_min_timestep
!                              = .true.  -> start with minimum timestep 
!                                           after boundary condition update.
!                                           This is more accurate from the aspect of
!                                           boundary condition updating. But it may
!                                           cause convergence problem in some cases.
!           read_spatial_master_proc
!                              = .true.  -> read spatial data using master processor only
!                                           and scatter to all other processors
!                              = .false. -> read spatial data using all processors 
!                                           without message passing (old method)
!           character:
!           ----------
!           time_unit          = time unit for output -> 'years'
!                                                        'days'
!                                                        'hours'
!                                                        'seconds'
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: delta_c(:)
      real (type_r8), allocatable :: delta_c_max(:)

      real (type_r8) :: time
      real (type_r8) :: time_start
      real (type_r8) :: time_io
      real (type_r8) :: time_io_ini 
      real (type_r8) :: time_factor
      real (type_r8) :: tfinal
      real (type_r8) :: delt
      real (type_r8) :: delt_io
      real (type_r8) :: delt_vs
      real (type_r8) :: delt_heat
      real (type_r8) :: delt_rt
      real (type_r8) :: deltmin
      real (type_r8) :: deltmax
      real (type_r8) :: deltmax_global
      real (type_r8) :: urtant_log
      real (type_r8) :: mtime_f_ratio
      real (type_r8) :: tinytime_global

      integer (type_i4) :: l_time_unit
      integer (type_i4) :: mtime
      integer (type_i4) :: mtime_f

      logical :: read_spatial_master_proc

      logical :: reduce_timestep
      logical :: ignore_restart_time
      logical :: b_check_restart_time
      logical :: b_restart_update_bcvs
      logical :: b_updtbc_recall

      logical :: b_relax_timestep
      logical :: b_updtbc_min_timestep


      integer :: i_transient_deltmax
      integer :: n_transient_deltmax
      real (type_r8), allocatable :: transient_deltmax(:,:)

      character*12 :: time_unit

! ----------------------------------------------------------------------
! control parameters for I/O:
! ---------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           gs_tout(ngs)       = specified output times for
!                                contour data 
!           ngb_vol_ijface_area(ngb_ijface)    
!                              = control volumes interface area for 
!                                output of transient data for
!                                control volume interface fluxes
!
!           skip_time_gb_start = start of skip time of transient data
!
!           skip_time_gb_end   = end of skip time of transient data
!
!           integer:
!           --------
!           iamb(nmb)          = pointer array for selected 
!                                species to species concentration
!                                arrays
!           idat               = unit number, run specific input 
!                                             file
!           igen               = unit number, generic output file
!           ifls               = unit number, file information
!           idbg               = unit number, debugging file
!           ilog               = unit number, logbook file
!           idelt              = unit mumber, magnitude of current
!                                             time step
!           itmp               = unit number, temporary storage
!           icnv               = unit number, data conversion
!           ihyc               = unit number, initial hydraulic
!                                             conductivity
!                                             distribution
!           ishfp              = unit number, soil hydraulic function
!                                             parameters
!           ivel               = unit number, average interfacial 
!                                             velocities
!           icdbs              = unit number, database for
!                                             components
!           igdbs              = unit number, database gases 
!           imdbs              = unit number, database for minerals
!           irdbs              = unit number, database for redox 
!                                             couples
!           isdbs              = unit number, database for sorbed
!                                             species
!           isitdbs            = unit number, database for SIT model 
!           item               = unit number, temperature data
!           ixdbs              = unit number, database for 
!                                             secondary species in 
!                                             water phase
!           igb_start          = starting pointer for unit numbers
!                                for transient data
!           imrt               = unit number, mass balance - 
!                                             reactive transport
!           imrt_first         = pointer - first unit number for
!                                mass balance - reactive transport
!           imrt_last          = pointer - last unit number for
!                                mass balance - reactive transport
!           imcd               = unit number, mass balance - 
!                                        multicomponent diffusion
!           imcd_first         = pointer - first unit number for
!                                mass balance - multicomponent diffusion
!           imcd_last          = pointer - last unit number for
!                                mass balance - multicomponent diffusion
!           imvs_first         = pointer - first unit number for
!                                mass balance - variably saturated
!                                 ointer - last unit number for
!                                mass balance - variably saturated
!                                               flow
!           imvs               = unit number, mass balance - 
!                                             variably saturated 
!                                             flow
!           igsp               = unit number, flow variables 
!           igst               = unit number, total aqueous 
!                                             component 
!                                             concentrations 
!                                             - contour data
!           igsb               = unit number, sorbed species
!                                             concentrations 
!                                             - contour data
!           igsc               = unit number, free species and 
!                                             secondary aqueous
!                                             species concentrations 
!                                             - contour data
!           igsd               = unit number, reaction rates of
!                                             dissolution-
!                                             precipitation
!                                             reactions
!                                             - contour data
!           igsg               = unit number, gas concentrations
!                                             - contour data 
!           igsgr              = unit number, rates of degassing
!                                             - contour data 
!           igsm               = unit number, master variables
!                                             - contour data 
!           igss               = unit number, saturation indices 
!                                             - contour data
!           igsv               = unit number, mineral volume 
!                                             fractions
!                                             - contour data
!           igsx               = unit number, saturation indices 
!                                             excluded minerals
!                                             - contour data
!           igsi               = unit number, rates of intra-aqueous
!                                             kinetic reactions
!                                             - contour data
!           igbt               = unit number, total aqueous 
!                                             component 
!                                             concentrations 
!                                             - transient data 
!                                               global system
!           igbb               = unit number, concentrations of
!                                             sorbed species
!                                             - transient data
!                                               global system
!           igbc               = unit number, free species and 
!                                             secondary aqueous 
!                                             species concentrations 
!                                             - transient data
!                                               global system
!           igbd               = unit number, reaction rates for
!                                             dissolution-
!                                             precipitation
!                                             reactions
!                                             - transient data
!                                               global system
!           igbg               = unit number, gas concentrations
!                                             - transient data
!                                                global system
!           igbgr              = unit number, degassing rates
!                                             - transient data
!                                                global system
!           igbm               = unit number, master variables
!                                             - transient data
!                                               global system
!           igbi               = unit number, rates of intra-aqueous 
!                                             kinetic reactions
!                                             - transient data
!                                               global system
!           igbp               = unit number, flow variables
!                                             - transient data
!                                               global system
!           igbs               = unit number, saturation indices 
!                                             - transient data
!                                               global system
!           igbv               = unit number, mineral volume 
!                                             fractions 
!                                             - transient data 
!                                               global system
!           igbx               = unit number, saturation indices
!                                             excluded minerals
!                                             - transient data
!                                               global system
!           icbt               = unit number, totcnew(nn), 
!                                             charge balance
!                                              - contour data
!           igmf               = unit number, total flux                                
!                                              - contour data
!           igbac              = unit number, activity coefficient
!                                              - transient data
!                                                global system
!           igsac              = unit number, activity coefficient
!                                              - countour data
!           igstime            = pointer to next output time for 
!                                contour data
!           ipsp               = unit number, list of possible
!                                             secondary aqueous
!                                             species, gases and 
!                                             minerals
!           idbs_bk            = unit number, list of all the used
!                                             database items
!           itec               = i-index for tecplot
!           jtec               = j-index for tecplot
!           ktec               = k-index for tecplot
!           ntecvel_dif        = difference of spatial data number for velocity
!           ntecvel_dif_gbl    = difference of spatial data number for velocity for global grid
!           itec_gbl           = i-index of global grid for tecplot
!           jtec_gbl           = j-index of global grid for tecplot
!           ktec_gbl           = k-index of global grid for tecplot
!           l_dbs_dir          = length of string for database
!           l_prfx             = length of prefix of I/O files
!           l_zone_name        = length of zone name
!           ngb                = number of output locations for
!                                transient data
!           ngb_ijface         = number of output locations for transient data for
!                                control volume interface fluxes
!           ngb_step           = number of time steps between 
!                                output of transient data
!           ngb_step_bk        = number of time steps between 
!                                output of transient data - backup
!           ngb_vol(ngb)       = control volumes numbers for 
!                                output of transient data
!           ngb_vol_ijface(2,ngb_ijface)    
!                              = control volumes numbers for output of transient data for
!                                control volume interface fluxes
!           ngb_vol_ijface_jtemp(ngb_ijface)
!                              = edge index for the selected control volume pair
!           ngs                = number of output times for
!                                contour data 
!           nmb                = number of mass balance files
!                                for species concentrations
!cdsu output of flux and mass through specified boundary nodes
!           ntmsb              = number of total mass through specified boundary nodes
!           iatmsb(:)          = ia array to store specified boundary nodes for total mass
!           jatmsb(:)          = ja array to store specified boundary nodes for total mass
!           mproptmsb(nngl)    = volume to the index of specified boundary nodes for total mass
!
!           logical:
!           --------
!           extended_output_gs = .true.  -> extended output of 
!                                           contour data for 
!                                           reaction-transport 
!                                           simulation
!                                .false. -> basic output of 
!                                           contour data for  
!                                           for reaction-transport 
!                                           simulation
!           gb_output          = .true.  -> output of transient data
!           gs_output          = .true.  -> output of contour data
!           flux_out           = .true.  -> output of flux data (MCD)
!           initial_condition  = .true.  -> output of initial 
!                                           condition for contour 
!                                           data
!                                .false. -> output of contour data
!                                           for steady state or
!                                           transient solutions
!           tec_header         = .true.  -> write header for tecplot
!                                           postprocessing to output
!                                           files
!                                .false. -> skip headers
!
!           b_output_activity  = .true.  -> output activity coefficient
!                                .false. -> disable output of activity coefficient
!           b_overlap_tmsb     = .true.  -> allow overlap in the specified boundary
!                                .false. -> no overlap is allowed
!
!           skip_time_gb       = .true.  -> allow skip time of transient data
!
!           character:
!           ----------
!           prefix             = prefix name for all I/O files
!           section_header     = section header
!           namemb(nmb)        = names of species with mass balance
!                                for species
!           name_tfsb(ntfsb)   = name of total flux through specified boundary nodes
!           name_mfsb(nmfsb)   = name of total mass through specified boundary nodes
!           zone_name          = name of zone
!        -->                                                         <--
! ----------------------------------------------------------------------
      real (type_r8) :: skip_time_gb_start
      real (type_r8) :: skip_time_gb_end

      real (type_r8), allocatable :: gs_tout(:)
      real (type_r8), allocatable :: ngb_vol_ijface_area(:)
      real (type_r8), allocatable :: ngb_vol_ijface_velratio(:,:)

      integer (type_i4), allocatable :: iamb(:)
      integer (type_i4), allocatable :: ngb_vol(:)
      
      integer (type_i4), allocatable :: ngb_vol_ijface(:,:)
      integer (type_i4), allocatable :: ngb_vol_ijface_jtemp(:)

      integer (type_i4) :: ngb,ngs,ngb_ijface
      integer (type_i4) :: igstime
      integer (type_i4) :: ircm_tz
      integer (type_i4) :: ircm_stage
      integer (type_i4) :: ngb_step
      integer (type_i4) :: ngb_step_bk
      integer (type_i4) :: ngb_step_ijface      
      integer (type_i4) :: nmb
      integer (type_i4) :: l_prfx
      integer (type_i4) :: l_dbs_dir
      integer (type_i4) :: idat
      integer (type_i4) :: igen
      integer (type_i4) :: ifls
      integer (type_i4) :: idbg
      integer (type_i4) :: ilog
      integer (type_i4) :: idelt
      integer (type_i4) :: icnv
      integer (type_i4) :: ihyc
      integer (type_i4) :: ihycx
      integer (type_i4) :: ishfp
      integer (type_i4) :: idbs_bk

      logical :: ircm_tz_restart
      logical :: skip_time_gb

!cdsu exclude solute uptake in recycling during return time.
      logical :: exclude_return_uptake

!cdsu allow overlap in mineral return zones. With this feature, the specific zone 
!cdsu can accept component recycle from different respiration/solute uptake zones.
      logical :: flag_overlap_rcm

!cprovi-----------------------------------------------------------
!cprovi unit for to read porosity field
!cprovi Sergio Andres Bea Jofre 
!cprovi-----------------------------------------------------------
      integer (type_i4) :: ipor   ! Unit for porosity field 
      integer (type_i4) :: istor  ! Unit for specific storage coefficient
!cprovi-----------------------------------------------------------
!cprovi unit for to read tortuosity field
!cprovi Sergio Andres Bea Jofre 
!cprovi-----------------------------------------------------------
      integer (type_i4) :: itor   ! Unit for porosity field 
!cprovi-----------------------------------------------------------
      integer (type_i4) :: itmp
      integer (type_i4) :: ivel
      integer (type_i4) :: icdbs
      integer (type_i4) :: ixdbs
      integer (type_i4) :: imdbs
      integer (type_i4) :: isdbs
      integer (type_i4) :: isitdbs
      integer (type_i4) :: irdbs
      integer (type_i4) :: igdbs
      integer (type_i4) :: imvs
      integer (type_i4) :: imvs_first
      integer (type_i4) :: imvs_last
      integer (type_i4) :: iresp            !root respiration
      integer (type_i4) :: irup             !root uptake, including respiration and passive uptake
      integer (type_i4) :: irupcm           !recyclable root uptake for component-mineral
      integer (type_i4) :: imrt
      integer (type_i4) :: imrt_first
      integer (type_i4) :: imrt_last 
      integer (type_i4) :: idix
      integer (type_i4) :: ispm
      integer (type_i4) :: imcd
      integer (type_i4) :: imcd_first
      integer (type_i4) :: imcd_last 
      integer (type_i4) :: igsaqt
      integer (type_i4) :: igsmech
      integer (type_i4) :: igsp
      integer (type_i4) :: igsb
      integer (type_i4) :: igsc
      integer (type_i4) :: igsd
      integer (type_i4) :: igsg
      integer (type_i4) :: igsgr
      integer (type_i4) :: igsm
      integer (type_i4) :: igsi
      integer (type_i4) :: igss
      integer (type_i4) :: igst
      integer (type_i4) :: igsv
      integer (type_i4) :: igsx
      integer (type_i4) :: igb_start
      integer (type_i4) :: igbb
      integer (type_i4) :: igbc
      integer (type_i4) :: igbd
      integer (type_i4) :: igbg
      integer (type_i4) :: igbgr
      integer (type_i4) :: igbm
      integer (type_i4) :: igbp
      integer (type_i4) :: igbi
      integer (type_i4) :: igbs
      integer (type_i4) :: igbt
      integer (type_i4) :: igbv
      integer (type_i4) :: igbx
      integer (type_i4) :: igbis        !c_isotope
      integer (type_i4) :: igsis        !c_isotope
      integer (type_i4) :: igbmip       !c mip_mt model
      integer (type_i4) :: igbroot      !c root related model
      integer (type_i4) :: ipsp
      integer (type_i4) :: itec
      integer (type_i4) :: itec_vel
      integer (type_i4) :: itec_gbl
      integer (type_i4) :: itec_vel_gbl
      integer (type_i4) :: item
      integer (type_i4) :: jtec
      integer (type_i4) :: jtec_vel
      integer (type_i4) :: jtec_gbl
      integer (type_i4) :: jtec_vel_gbl
      integer (type_i4) :: ktec
      integer (type_i4) :: ktec_vel
      integer (type_i4) :: ktec_gbl
      integer (type_i4) :: ktec_vel_gbl
      integer (type_i4) :: ntecvel_dif
      integer (type_i4) :: ntecvel_dif_gbl
      integer (type_i4) :: l_zone_name
      integer (type_i4) :: igsa       ! advective velocity and fluxes
      integer (type_i4) :: igsa_first ! 
      integer (type_i4) :: igsa_last  !
      integer (type_i4) :: igs2       ! (cumulative) mol fractions
      integer (type_i4) :: igsr       ! gas density
      integer (type_i4) :: igsy       ! gas viscosity
      integer (type_i4) :: igsf       ! variable diffusion coefficients
      integer (type_i4) :: igsf_first ! 
      integer (type_i4) :: igsf_last  !
      integer (type_i4) :: igsk       ! gradients
      integer (type_i4) :: igsw       ! rates of chemical water
      integer (type_i4) :: icbt
      integer (type_i4) :: igmf
      integer (type_i4) :: igbac
      integer (type_i4) :: igsac

      integer (type_i4) :: igsre      ! concentration of radioelement related to noble gas ingrowth
      integer (type_i4) :: igbre      ! concentration of radioelement related to noble gas ingrowth
      

      character*72, allocatable :: namemb(:)

      !character*72 :: prefix
      character*256 :: prefix           !dsu, change the length of prefix to 256 to support long file path
      character*72 :: section_header
      character*72 :: zone_name
 
      logical :: initial_condition
      logical :: extended_output_gs
      logical :: extended_output_gb
      logical :: combined_gst_gsb_output
      logical :: gs_output
      logical :: gb_output
      logical :: gb_output_faceflux
      logical :: tec_header
      logical :: flux_out
      logical :: b_output_activity

      !cdsu output of total flux/mass through specified boundary nodes
      integer (type_i4) :: ntmsb
      character*72, allocatable :: name_tmsb(:)
      integer (type_i4), allocatable :: iatmsb(:)
      integer (type_i4), allocatable :: jatmsb(:)
      integer (type_i8), allocatable :: mproptmsb(:)
      logical :: b_overlap_tmsb

 
! ----------------------------------------------------------------------
! control parameters - reactive transport
! ---------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           dinc_rt            = factor to compute increment for
!                                numerical differentiation
!           srelfac_rt         = user specified underrelaxation 
!                                factor (reactive transport)
!           tol_rt             = convergence tolerance
!                                (reactive transport)
!           div_rt(5)          = divergence check for previous iteration
!
!           integer:
!           --------
!           iter_rt            = iteration counter
!                                (reactive transport)
!           iter_rt_ant        = anticipated number of iterations
!                                (reactive transport)
!           itsolvtot_rt       = total number of solver 
!                                iterations
!                                (reactive transport)
!           ittot_rt           = total number of iterations 
!                                (reactive transport)
!           maxit_rt           = max. number of iterations
!                                (reactive transport)
!           n                  = number of components excluding h2o 
!                                equals number of unknowns per 
!                                control volume
!
!           logical:
!           --------
!           analyt_deriv_rt    = .true.  -> form derivatives
!                                           analytically
!           mass_balance_rt    = .true.  -> compute mass balance 
!                                           (reactive tramsport)
!           redox_equil_rt     = .true.  -> equilibrium redox
!                                           reactions
!           sparse_blocks      = .true.  -> make use of sparsity
!                                           of block matrices
!           under_relax_rt     = .true.  -> underrelaxation   
!           gas_advection      = .true.  -> enable gas advection
!           cum_molfrac        = .true.--> .gs2 results in terms
!                                           of cummulative molar fractions
!           gas_gravity        = .true.  -> enable gravity when gas advection
!           tortuosity_corr    = .true.  -> Millington-Quirk 
!                                           tortuosity correction
!                                           for diffusion
!                                           coefficients
!           b_check_div_rt      = .true.-> check divergence in reactive transport iteration
!
!           character:
!           ----------
!           update_activity_rt = 'no_update' -> unity activity
!                                 coefficients
!                                'time_lagged' -> update activity
!                                 coefficients after each time step
!                                'double_update' -> double update
!                                 of activity coefficients during
!                                 Newton iterations
!                                 (reactive transport)
!           spatial_weighting  = 'upstream' -> upstream weigthing
!                                'centered' -> centered weighting
!                                'vanleer' -> Van Leer flux limiter
!                                              (upstream-downstream)
!                                'vanleer2' -> Van Leer flux limiter
!                                              (upstream-centered)
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: dinc_rt
      real (type_r8) :: tol_rt
      real (type_r8) :: srelfac_rt
      real (type_r8) :: srelrange_rt_min
      real (type_r8) :: srelrange_rt_max 
      real (type_r8) :: div_rt(5)

      integer (type_i4) :: n
      integer (type_i4) :: iter_rt
      integer (type_i4) :: iter_rt_ant
      integer (type_i4) :: maxit_rt
      integer (type_i4) :: itsolvtot_rt
      integer (type_i4) :: ittot_rt

      logical :: analyt_deriv_rt
      logical :: mass_balance_rt
      logical :: b_dilution_index
      logical :: b_spatial_moment
      logical :: sparse_blocks
      logical :: redox_equil_rt
      logical :: tortuosity_corr
      logical :: under_relax_rt
      logical :: under_relax_range_rt
      logical :: b_check_div_rt
      
      logical :: gas_advection  ! .true.--> enable gas advection
      logical :: cum_molfrac    ! .true.--> .gs2 results in terms
                                !           of cummulative molar fractions
      logical :: gas_gravity    ! .true.--> enable gravity when gas advection
            
      
!cprovi---------------------------------------------------------------
!cprovi Assigned tau 
!cprovi---------------------------------------------------------------      
      logical                 :: assigned_tau
      logical                 :: assigned_tau_gas
      real (type_r8), allocatable :: tau(:)
!cprovi---------------------------------------------------------------
!cprovi tortuosity type 
!cprovi---------------------------------------------------------------      
      character(len=100)      :: type_tortuosity
      real (type_r8)          :: marchie
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi For diffusion coefficients for each component 
!cprovi---------------------------------------------------------------      
      logical :: diff_coff      
      
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
      character*12 :: spatial_weighting
      character*72 :: update_activity_rt
      character*20 :: gas_tortuosity     ! gas_tortuosity = 'same as aqueous'
!c                                                          'millington'
!c                                                          'no correction'
!c                                                          'moldrup repacked'
!prc---------------------------------------------------------------
!prc   Diffusion averaging type
!prc---------------------------------------------------------------
      logical :: averaging_diffusion
      logical :: no_average

      character(len=30)      :: type_averaging_De
!prc---------------------------------------------------------------
!prc--------------------------------------------------------------- 
! prc ----------------------------------------------------------------
! ----------------------------------------------------------------------
! main variables (reactive transport):
! ------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           c(nc,nn)           = concentrations of free species
!                                - old time level [moles/l water]
!           cnew(nc,nn)        = concentrations of free species
!                                - new time level [moles/l water]
!           cec_g(nn)          = cation exchange capacity
!                                - global system
!           cec_fraction_g(nsites_ion,nn)                            * +
!                              = cec fractions of multisite ion 
!                                exchange [-] - global system
!           totaold(n,nn)      = total sorbed component 
!                                concentrations
!                                non-competitive sorption 
!                                - old time level [moles/l bulk]
!           totanew(n,nn)      = total aqueous component
!                                concentrations
!                                non-competitive sorption
!                                - new time level [moles/l bulk]
!           totcold(n,nn)      = total aqueous component 
!                                concentrations 
!                                - old time level [moles/l water]
!           totcnew(n,nn)      = total aqueous component
!                                concentrations
!                                - new time level [moles/l water]
!           totgold(nc,nn)      = total gaseous component
!                                concentrations 
!                                - old time level [moles/l air]]
!           totgnew(nc,nn)      = total gaseous component
!                                concentrations
!                                - new time level [moles/l air]
!           totsold(n,nn)      = total sorbed component 
!                                concentrations 
!                                - old time level [moles/l bulk]
!           totsold_ion(n,nn)  = total sorbed component 
!                                concentrations 
!                                - old time level [moles/l bulk]
!                                (ion-exchange)
!           totsold_surf(n,nn) = total sorbed component 
!                                concentrations 
!                                - old time level [moles/l bulk]
!                                (surface-complex)
!           totsnew(n,nn)      = total sorbed component 
!                                concentrations
!                                - new time level [moles/l bulk]
!           totsnew_ion(n,nn)  = total sorbed component 
!                                concentrations
!                                - new time level [moles/l bulk]
!                                (ion-exchange)
!           totsnew_surf(n,nn) = total sorbed component 
!                                concentrations
!                                - new time level [moles/l bulk]
!                                (surface-complex)
!           cm_init(nm,nn)       = mineral concentrations 
!                                - (initial condition) [moles/l bulk]
!           cmold(nm,nn)       = mineral concentrations 
!                                - old time level [moles/l bulk]
!           cmnew(nm,nn)       = mineral concentrations 
!                                - new time level [moles/l bulk]
!           distcoff_rt(nc,nn) = sorption distribution coefficient
!                                [-], [l bulk/l bulk]
!                                - reactive transport
!           gold(ng,nn)        = gas concentrations 
!                                - old time level [moles/l air]
!           gnew(ng,nn)        = gas concentrations
!                                - new time level [moles/l air]
!           gmfrac(ng,nn)      = molar fraction 
!                                - new time level [moles/l air]
!           totgmfrac(n,nn)    = total molar gas fractions
!           cx(nx,nn)          = concentrations of secondary aqueous 
!                                species [moles/l water]-new time level
!           cxold(nx,nn)       = concentrations of secondary aqueous 
!                                species [moles/l water]-old time level
!           gamma(nc+nx,nn)    = activity coefficients of aqueous
!                                species [-]
!           gammaold(nc+nx,nn) = activity coefficients of aqueous
!                                species [-] -old time level
!           sionnew(nn)        = ionic strength of solution
!                                - new time level
!           sionold(nn)        = ionic strength of solution
!                                - old time level
!           phi(nm,nn)         = volume fractions of minerals
!           phiold(nm,nn)      = volume fractions of minerals
!                                (old time level)
!           phi_init(nm,nn)    = volume fractions of minerals
!                                (initial condition)
!           phinucthrd(nm,nn)  = volume fractions of mineral for
!                                 nucleation threshold
!           area(nm,nn)        = mineral reactivity term
!                                (global system)
!           area_init(nm,nn)   = initial mineral reactivity term
!                                (global system)!
!           areanucthrd(nm,nn) = reference area for the the specified nucleation threshold
!                                (global system)!
!           cinfrt_va(njavs)   = influence coefficients  
!                                (advection - aqueous phase)
!           cinfrt_da(njavs)   = influence coefficients 
!                                (dispersion - aqueous phase)
!           cinfrt_dg(njavs)   = influence coefficients 
!                                (diffusion - gaseous phase)
!           gsatij(njavs)      = gas saturation at interface i-j
!           tkel(nn)           = nodal temperatures in Kelvin
!
!           integer:
!           --------
!           mpropc(nn)         = pointer array for allocation of 
!                                chemical material properties
!           logical:
!           --------
!           phiUnitSolid       = false: mineral input unit is volume fraction of bulk
!                              = true: mineral input unit is volume fraction of solid phase
!        -->                                                         <--
! ----------------------------------------------------------------------
 
      real (type_r8), allocatable :: c(:,:)
      real (type_r8), allocatable :: cnew(:,:)
      real (type_r8), allocatable :: cec_g(:)
      real (type_r8), allocatable :: cec_fraction_g(:,:)
      real (type_r8), allocatable :: rhobulk_g(:)
      real (type_r8), allocatable :: gamma(:,:)
      real (type_r8), allocatable :: gammaold(:,:)
      real (type_r8), allocatable :: totaold(:,:)
      real (type_r8), allocatable :: totanew(:,:)
      real (type_r8), allocatable :: totcold(:,:)
      real (type_r8), allocatable :: totcoldf(:,:)
      real (type_r8), allocatable :: totcnew(:,:)
      real (type_r8), allocatable :: totcnewf(:,:)
      real (type_r8), allocatable :: totgold(:,:)
      real (type_r8), allocatable :: totgnew(:,:)
      !real (type_r8), allocatable :: totsold(:,:)
      real (type_r8), allocatable :: totsold_ion(:,:)
      real (type_r8), allocatable :: totsold_surf(:,:)
      !real (type_r8), allocatable :: totsnew(:,:)
      real (type_r8), allocatable :: totsnew_ion(:,:)
      real (type_r8), allocatable :: totsnew_surf(:,:)
      real (type_r8), allocatable :: cm_init(:,:)
      real (type_r8), allocatable :: cmold(:,:)
      real (type_r8), allocatable :: cmnew(:,:)
      real (type_r8), allocatable :: distcoff_rt(:,:)
      real (type_r8), allocatable :: gold(:,:)
      real (type_r8), allocatable :: gnew(:,:)
      real (type_r8), allocatable :: cx(:,:)
      real (type_r8), allocatable :: cxold(:,:)
      real (type_r8), allocatable :: sionnew(:)
      real (type_r8), allocatable :: sionold(:)
      real (type_r8), allocatable :: phi(:,:)
      real (type_r8), allocatable :: phiold(:,:)
      real (type_r8), allocatable :: phi_init(:,:)
      real (type_r8), allocatable :: phinucthrd(:,:)
      real (type_r8), allocatable :: area(:,:)
      real (type_r8), allocatable :: area_init(:,:)
      real (type_r8), allocatable :: areanucthrd(:,:)
      real (type_r8), allocatable :: cinfrt_va(:)
      real (type_r8), allocatable :: cinfrt_da(:)
      real (type_r8), allocatable :: cinfrt_dg(:)
      real (type_r8), allocatable :: gporij(:)      ! gas filled porosity at i-j
      real (type_r8), allocatable :: gsatij(:)      ! gas saturation at i-j
      real (type_r8), allocatable :: tkel(:)
      real (type_r8), allocatable :: gmfrac(:,:)    ! molar fractions
      real (type_r8), allocatable :: totgmfrac(:,:) ! total molar fractions

      logical :: phiUnitSolid

!cdsu---------------------------------------------------------------
!cdsu      Intermittent reaction that control reaction rate during specified period
!cdsu---------------------------------------------------------------
      integer (type_i4), allocatable :: iairm(:)           ! index array of intermittent reactions variables, ia array, number of minerals
      integer (type_i4), allocatable :: jairm(:)           ! index array of intermittent reactions variables, ja array, index of minerals
      
      integer (type_i4), allocatable :: iairt(:)           ! index array of intermittent reactions variables, ia array, number of times
      real (type_r8),    allocatable :: irt(:)             ! array of intermittent reactions variables, value of times
      
      integer (type_i4), allocatable :: iairc(:)           ! index array of intermittent reactions variables, ia array, number of intermittent coefficients
      real (type_r8),    allocatable :: irc(:)             ! array of intermittent reactions variables, value of intermittent coefficients      

      integer (type_i4), allocatable :: imizn2jairm(:,:)   ! index of mineral and zone index to jairm index
      real (type_r8),    allocatable :: imizn2irc(:,:)     ! array of intermittent reactions variables, value of intermittent coefficients for mineral im in zone izn

      logical :: flag_intermittent_react                   ! flag to use intermittent reaction
      integer (type_i4)              :: niz_irm            ! number of zones of intermittent reaction minerals

!cdsu---------------------------------------------------------------
!cdsu      Gas advection variables in jacobi matrix assembly
!cdsu---------------------------------------------------------------
!c             dg(ng)
!c             gdens(nn)
!c             gij(ng)
!c             gvisc(nn)
!c             gpivol(nn)
!c             gmfracij(ng)
!c             gmfrac_brt(ng)
!c             gmfrac_ivol(ng)
!c             totgnew_brt(nc)
!c             totgmfrac_brt(nc)
!c             totgmfrac_ivol(nc)
!c             totgij(nc)
      real (type_r8), allocatable :: dg(:)           
      real (type_r8), allocatable :: gdens(:) 
      real (type_r8), allocatable :: gij(:)
      real (type_r8), allocatable :: gvisc(:)        
      real (type_r8), allocatable :: gpivol(:)
      real (type_r8), allocatable :: gmfracij(:)
      real (type_r8), allocatable :: gmfrac_brt(:) 
      real (type_r8), allocatable :: gmfrac_ivol(:)
      real (type_r8), allocatable :: totgnew_brt(:)
      real (type_r8), allocatable :: totgmfrac_brt(:) 
      real (type_r8), allocatable :: totgmfrac_ivol(:)
      real (type_r8), allocatable :: totgij(:) 
      
      
!cprovi--------------------------------------------------------------
!cprovi--------------------------------------------------------------
!cprovi--------------------------------------------------------------
      real (type_r8), allocatable :: cinfrt_da_ic(:,:)

!cprovi--------------------------------------------------------------      
!cprovi--------------------------------------------------------------      
!cprovi--------------------------------------------------------------
      integer (type_i4), allocatable :: mpropc(:)      
! prc ---------------------------------------------------------------
! defining the vectors for diffusion coefficients for primary and 
! secondary spices
! prc ---------------------------------------------------------------
      real (type_r8), allocatable :: diff_ic(:)

!cdsu multi component diffusion coefficient tensor      
      type(tensor), allocatable :: diff_ic_tensor(:) 

      integer (type_i4), allocatable :: diff_brt_dim(:) 

!cdsu type of diffusion/dispersion coefficient/conductivity/permeability tensor
!cdsu 0: isotropic
!cdsu 1: anisotropic, principle term (diagonal term)
!cdsu 2: full tensor
      integer (type_i4) :: type_diff_coeff  
      integer (type_i4) :: type_diff_ic_coeff
      integer (type_i4) :: type_disp_coeff 

      integer (type_i4) :: type_cond_perm

!cdsu anisotropic material properties correction for principle axis
      logical :: useAnisoCorr              !apply anisotropic material properties correction
      logical :: useAnisoDispCorr          !apply to anisotropic dispersivity correction
      logical :: useAnisoTauCorr           !apply to anisotropic tortuosity correction
      logical :: useAnisoCondCorr          !apply to anisotropic hydraulic conductivity/permeability correction

      logical :: useAnisoHeatDispCorr      !apply to anisotropic heat dispersivity correction    
      logical :: useAnisoHeatCondCorr      !apply to anisotropic water/solid thermal conductivity correction
! prc ---------------------------------------------------------------
! cmx ---------------------------------------------------------------          
! defining the vectors for effective porosity factors for primary and 
! secondary spices
! cmx ---------------------------------------------------------------
      real (type_r8), allocatable ::  f_epor_ps(:,:)
      real (type_r8), allocatable ::  f_etau_ps(:,:)
      real (type_r8), allocatable ::  f_epor_ss(:,:)
      real (type_r8), allocatable ::  f_etau_ss(:,:)
! cmx ---------------------------------------------------------------           


! ----------------------------------------------------------------------
! boundary and initial conditions (reactive transport):
! -----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           bcondrt_a(nc,nbrt) = concentrations in boundary control 
!                                volumes (aqueous phase)
!                                first type b.c. -> free species 
!                                                   concentrations 
!                                third type b.c. -> total aqueous 
!                                                   component
!                                                   concentrations 
!           bcondrt_g(nc,nbrt) = concentrations in boundary control
!                                volumes (gaseous phase)
!                                third type b.c. -> total gaseous
!                                                   component
!                                                   concentrations
!           bdycrt_d(nbrt)     = boundary influence coefficients for
!                                diffusive mass fluxes across
!                                boundary (excluding diffusion 
!                                coefficient)
!           zgbrt(nbrt)        = elevation of dummy boundary nodes (mixed 
!                                type b.c.) used to calculate gas transport
!           gbrt(ng,nbrt)      = gas concentrations in boundary 
!                                control volumes
!           tsrc(ntsrc)        = target read times - transient
!                                source chemistry
!                                (reactive transport)
!
!           integer:
!           --------
!           iabrt(nbzrt+1)     = pointer array - boundary conditions
!                                (reactive transport)
!           itsrc              = pointer to target read time for 
!                                transient source chemistry
!           jabrt(nbrt)        = pointer array - boundary conditions
!                                (reactive transport)
!           nbrt               = number of specified boundary 
!                                control volumes
!           nbzrt              = number of boundary zones
!                                (reactive transport)
!           ntsrc              = pointer to target read times for 
!                                transient source chemistry
!
!           logical:
!           --------
!           spec_conc          = .true.  -> source concentrations 
!                                           specified
!                                .false. -> background 
!                                           concentrations as 
!                                           boundary condition
!           transient_source   = .true.  -> transient source 
!                                           chemistry
!                                .false. -> constant source 
!                                           chemistry
!           b_update_zone_func(nbzrt) 
!                              = .true.  -> transient boundary
!                              = .false. -> steady boundary
!           b_fluxd_bcond(nn) 
!                              = .true.  -> with diffusive flux for 
!                                           third/mixed boundary condition
!                                .false. -> without diffusive flux for 
!                                           third/mixed boundary condition
!                                default value is .true.
!
!           character:
!           ----------
!           btypert(nn)        = type of boundary control volumes    
!                                'first'  = Dirichlet 
!                                           (specified 
!                                            concentration)
!                                'second' = Neumann
!                                           (free advective mass
!                                            outflux for aqueous 
!                                            phase)
!                                'third'  = Cauchy
!                                           (specified advective 
!                                            mass influx for 
!                                            aqueous phase)
!                                'third-evap'
!                                         = Cauchy
!                                           (specified advective
!                                            mass influx for
!                                            aqueous phase, for outflux,
!                                            use closed boundary for transport,
!                                            like evaporation)
!                                'mixed'  = mixed
!                                           (specified advective
!                                            mass influx and
!                                            free diffusive mass
!                                            influx for aqueous 
!                                            phase and gaseous phase
!                                'mixed-evap'  = mixed-evap
!                                           (specified advective
!                                            mass influx and
!                                            free diffusive mass
!                                            influx for aqueous
!                                            phase and gaseous phase,
!                                            for outflux, use closed boundary
!                                            for transport for aqueous phase,
!                                            like evaporation)
!           iupsgbrt(nbrt)     = upstream node 'i', 'j', 'a'
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: bcondrt_a(:,:)
      real (type_r8), allocatable :: bcondrt_g(:,:)
      real (type_r8), allocatable :: bdycrt_d(:)
      real (type_r8), allocatable :: zgbrt(:)
      real (type_r8), allocatable :: gbrt(:,:)
      real (type_r8), allocatable :: tsrc(:)
      
      real (type_r8), allocatable :: dijbrt(:)       !gas transport
      real (type_r8), allocatable :: permbrt(:)      !gas transport
      real (type_r8), allocatable :: cinfvs_gbrt(:)  !gas transport

      integer (type_i4), allocatable :: iabrt(:)
      !Boundary condition can be duplicated, use negative value for those overwritten boundary condition in jabrt, by DSU, 2018-02-02
      !This is important in parallel code as the boundary condition assignment to the nodes is not in the same order as sequential code
      !For the sequential code, the latter boundary condition will overwrite the previous boundary condition if assign to the same node.
      integer (type_i4), allocatable :: jabrt(:)

      integer (type_i4) :: itsrc
      integer (type_i4) :: nbrt
      integer (type_i4) :: nbzrt
      integer (type_i4) :: ntsrc

      logical :: spec_conc 
      logical :: transient_source
      logical :: transient_source_function
      logical, allocatable :: b_update_zone_func(:)      

      character*12, allocatable :: btypert(:)      
      
      logical, allocatable :: b_fluxd_bcond(:)
      character*1, allocatable ::  iupsgbrt(:)   !gas transport

! ----------------------------------------------------------------------
! newton iteration (reactive transport):
! --------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           astor(n)           = storage term (non-competitive
!                                sorption)
!           cflux(ncon,n)      = interfacial mass fluxes           
!                                (aqueous phase)
!           cstor(n)           = storage term (aqueous phase)
!           gflux(ncon,n)      = interfacial mass fluxes 
!                                (gaseous phase)
!           gstor(n)           = storage term (gaseous phase)
!           dtotcflux(n)       = derivatives of total mass fluxes
!                                (aqueous phase)
!           dtotgflux(n)       = derivatives of total mass fluxes
!                                (gaseous phase)
!           ratemdp(nm,nn)     = absolute dissolution-precipitation 
!                                rates of minerals
!           totcflux(n)        = total mass fluxes (aqueous phase)
!           totcflux_diff(n)   = total mass fluxes (diffused aqueous phase)
!           totcflux_mig(n)    = total mass fluxes (MCD, electrochemical 
!                                migration, aqueous phase)
!           totgflux(n)        = total mass fluxes (gaseous phase)
!           totgaflux(n)       = total mass fluxes (gaseous phase, advective)
!           totmdp(n,nn)       = total source/sink term towards 
!                                total aqueous component 
!                                concentrations due to mineral
!                                dissolution-precipitation reactions
!           integer:
!           --------
!           i2up(nn)           = pointer array to second upstream 
!                                point
!
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: astor(:)
      real (type_r8), allocatable :: cflux(:,:)
      real (type_r8), allocatable :: cstor(:)
      real (type_r8), allocatable :: gflux(:,:)
      real (type_r8), allocatable :: gstor(:)
      real (type_r8), allocatable :: dtotcflux(:)
      real (type_r8), allocatable :: dtotgflux(:)
      real (type_r8), allocatable :: ratemdp(:,:)
      real (type_r8), allocatable :: totcflux(:)
      real (type_r8), allocatable :: totcflux_diff(:)
      real (type_r8), allocatable :: totcflux_mig(:)
      real (type_r8), allocatable :: totgflux(:)
      real (type_r8), allocatable :: totgaflux(:)
      real (type_r8), allocatable :: totmdp(:,:)
      real (type_r8), allocatable :: totrootdiff(:)
 
      integer (type_i4), allocatable :: i2up(:) 

! ----------------------------------------------------------------------
! data structure and solver - reactive transport:
! -----------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           art(njart)         = jacobian matrix
!           afrt(njafrt)       = incomplete factorization
!           brt(nn*n)          = rhs vector
!           deltol_rt          = solver update tolerance
!           resrt(nn*n)        = residual
!           restol_rt          = solver residual tolerance
!           urt(nn*n)          = update towards solution-vector
!           urtlim_log         = maximum tolerated update
!                                in log cycles
!
!           integer:
!           --------
!           iart(nn*n+1)       = row pointer array for n-d scalar 
!                                matrix
!           jart(njart)        = connectivity list for n-d scalar 
!                                matrix
!           lart(njavs+1)      = pointer array
!           kart(njart)        = mapping pointer 
!                                (global block -> n-d scalar)
!           iafrt(nn*n+1)      = row pointer array for afrt
!           jafrt(njafrt)      = column pointer array for afrt
!           iafdrt(nn*n)       = diagonal pointer array for afrt
!           kbl(n,n)           = connectivity list for block
!                                matrices (full format)
!           kblsorb(n,n)       = Additional connectivity list for components in 
!                                sorbed species in block matrices (full format).
!           kblredox(n,n)      = Additional connectivity list for redox couples in 
!                                block matrices (full format).
!           iadbl(n+1)         = row pointer array (diagonal block  
!                                matrices)
!           jadbl(n*n)         = column pointer array (diagonal 
!                                block matrices)
!           kadbl(n,n)         = pointer array for conversion to 
!                                sparse format (diagonal block 
!                                matrices)
!           iaobl(n+1)         = row pointer array 
!                                (off-diagonal block matrices)
!           jaobl(n*n)         = column pointer array 
!                                (diagonal block matrices)
!           kaobl(n,n)         = pointer array for conversion 
!                                to sparse format 
!                                (off-diagonal block matrices)
!           lorderrt(nn*n)     = array containing ordering
!           invordrt(nn*n)     = array containing inverse ordering
!           mnjart             = max. number of global connections
!           mnjafrt            = max. number of factored connections
!           njart              = number of global connections
!           njafrt             = number of factored connections
!           njadbl             = actual number of entries in 
!                                diagonal block matrices
!           njaobl             = actual number of entries in 
!                                off-diagonal block matrices
!           njabl              = actual number of entries in
!                                block matrices
!           level_rt           = incomplete factorization level
!           msolvit_rt         = max. number of solver iterations
!           nexvol_old_rt      = number of nonconvergent control
!                                volumes from last time step
!           idetail_rt         = information level
!
!           logical:
!           --------
!           rcm_ordering_rt    = .true.  -> rcm ordering for 
!                                           n-d scalar matrix
!           metis_ordering_rt  = .true.  -> metis ordering for
!                                           n-d scalar matrix
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: art(:)
      real (type_r8), allocatable :: brt(:)
      real (type_r8), allocatable :: urt(:)
      real (type_r8), allocatable :: resrt(:)
      real (type_r8), allocatable :: afrt(:)

      real (type_r8) :: restol_rt
      real (type_r8) :: deltol_rt
      real (type_r8) :: urtlim_log

      integer (type_i4), allocatable :: iart(:)
      integer (type_i4), allocatable :: jart(:)
      integer (type_i4), allocatable :: lart(:)
      integer (type_i4), allocatable :: kbl(:,:)
      integer (type_i4), allocatable :: kblsorb(:,:)
      integer (type_i4), allocatable :: kblredox(:,:)
      integer (type_i4), allocatable :: kart(:)
      integer (type_i4), allocatable :: iafrt(:)
      integer (type_i4), allocatable :: jafrt(:)
      integer (type_i4), allocatable :: iafdrt(:)
      integer (type_i4), allocatable :: lorderrt(:)
      integer (type_i4), allocatable :: invordrt(:)
      integer (type_i4), allocatable :: iadbl(:)
      integer (type_i4), allocatable :: jadbl(:)
      integer (type_i4), allocatable :: kadbl(:,:)
      integer (type_i4), allocatable :: iaobl(:)
      integer (type_i4), allocatable :: jaobl(:)
      integer (type_i4), allocatable :: kaobl(:,:)      

      real(type_r8), allocatable :: resrt_check(:)
      real(type_r8) :: rnorm_check
      !logical :: b_doublecheck_residual

      integer (type_i4) :: mnjart
      integer (type_i4) :: mnjafrt
      integer (type_i4) :: njart
      integer (type_i4) :: njafrt
      integer (type_i4) :: njabl
      integer (type_i4) :: njadbl
      integer (type_i4) :: njaobl
      integer (type_i4) :: level_rt
      integer (type_i4) :: msolvit_rt
      integer (type_i4) :: nexvol_old_rt
      integer (type_i4) :: idetail_rt
      integer (type_i4) :: coeff_fac_conn_rt

      logical :: rcm_ordering_rt
      logical :: metis_ordering_rt
      
! ----------------------------------------------------------------------
! standard data structure and solver - reactive transport: 
! ----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           art_std(njart)     = jacobian matrix for standard sparse
!                                 matrix
!           integer:
!           --------
!           jart_std(njart)    = connectivity list for 1d-scalar 
!                                matrix
!           imaprt_std(njart) = point of standard sparse matrix to 
!                                 sparse matrix used in ws209
!                                 
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: art_std(:)
      real (type_r8), allocatable :: urt_std(:)         !for test, dsu
      integer (type_i4), allocatable :: jart_std(:)      
      integer (type_i4), allocatable :: imaprt_std(:)     
      logical :: bsymbolicfactor_rt  =  .true.

!-----------------------------------------------------------------------
! variables for water freezing control
! added by Danyang Su, 2015-03-24
! modified by Danyang Su, 2018-06-21
!-----------------------------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           water_freezing_tempkel  = water freezing temperature
!           water_freezing_cond    = hydraulic conductivity after
!                                    water freezing, e.g., 1.0d-20
!                                    DO NOT set to zero.
!           water_freezing_ratemin = reaction rate when water is freezing
!
!           water_freezing_curve_a = parameter a of water freezing relative conductivity
!                                    curve r=d+(a-d)(1+((x+2)/c)^b), e.g., 0.01273
!
!           water_freezing_curve_b = parameter b of water freezing relative conductivity
!                                    curve r=d+(a-d)(1+((x+2)/c)^b), e.g., 22.47
!
!           water_freezing_curve_c = parameter c of water freezing relative conductivity
!                                    curve r=d+(a-d)(1+((x+2)/c)^b), e.g., 2.002
!
!           water_freezing_curve_d = parameter d of water freezing relative conductivity
!                                    curve r=d+(a-d)(1+((x+2)/c)^b), e.g., 1.002
!
!           water_freezing_curve_tempmin
!                                  = lower limitation of temperature for the curve, e.g., -1.0 C
!
!           water_freezing_curve_tempmax
!                                  = upper limitation of temperature for the curve, e.g., 1.0 C
!
!           water_freezing_relcond_min
!                                  = lower limitation of water freezing relative conductivity, e.g., 0.01
!
!           water_freezing_relcond_max
!                                  = upper limitation of water freezing relative conductivity, e.g., 1.0
!
!           tol_freezing_pond(nbvs)      
!                                  = tolerance of water depth over boundary nodes with influx (second, point type)
!
!           seepage_bits(nbvs)     = pos 0->1: Dirichlet boundary (zero pressure, atmospheric boundary condition)
!                                    pos 1->1: Neumann boundary (zero flux, closed boundary condition, or influx)
!                                    pos 2->1: Neumann boundary is turned off for current seepage iteration. 
!                                              This is a transient seepage condition between Dirichlet and Neumann
!                                              It is used to stop influx when seepage face boundary node is close
!                                              to saturation, to avoid seepage face fluctuation back and forth.
!                                    
!
!           water_freezing_pts(ntemp,2)     
!                                  = temperature and relative conductivity coefficient pairs
!                                    first column is temperature and second column is coefficient      
!           logical:
!           --------
!           b_temperature_inhibition= if true, use temperature inhibitation for reaction
!                        
!           b_water_freezing        = if true, use water freezing
!                                     when temperature is below
!                                     freezing temperature
!
!           b_water_freezing_cond  = if true, use adjusted hydraulic conductivity
!                                    when water is freezing
!
!           b_water_freezing_ratemin
!                                  = if true, use specific reaction rate
!                                    when water is freezing.
!           b_water_freezing_curve = if true, use water freezing relative conductivity curve
!           
!           b_water_freezing_func   = if true, use sine function to calculate water freezing relative conductivity
!                                    r = 0.5*(relcond_max+relcond_min)*
!                                        (sin(pi/(tempmax-tempmin)*(T-0.5*(tempmax+tempmin)))+1.0)
!
!           b_water_freezing_pts   = if true, use water freezing relative conductivity curve
!                                    by interpolation based on specified temperature-coefficient pairs
!           b_freezing_adjacent_bd = if true, do not allow boundary flux into freezing node
!
!           b_freezing_no_pond     = if true, do not allow ponding on the boundary nodes with influx 
!
!           b_pressure_melting     = if true, compute pressure melting point or default zero degree as ice melting point
!
!-----------------------------------------------------------------------
      real (type_r8) :: temperature_inhibition
      real (type_r8) :: temperature_inhibition_coef
      real (type_r8) :: water_freezing_tempkel
      real (type_r8) :: water_freezing_cond
      real (type_r8) :: water_freezing_ratemin
      real (type_r8) :: water_freezing_curve_a
      real (type_r8) :: water_freezing_curve_b
      real (type_r8) :: water_freezing_curve_c
      real (type_r8) :: water_freezing_curve_d
      real (type_r8) :: water_freezing_curve_tempmin
      real (type_r8) :: water_freezing_curve_tempmax
      real (type_r8) :: water_freezing_relcond_min
      real (type_r8) :: water_freezing_relcond_max

      real (type_r8) :: rate_satcorr
      real (type_r8) :: rate_satcorr_a
      real (type_r8) :: rate_satcorr_b
      real (type_r8) :: rate_satcorr_c
      real (type_r8) :: rate_satcorr_d
      real (type_r8) :: rate_satcorr_satmin
      real (type_r8) :: rate_satcorr_satmax
      real (type_r8) :: rate_satcorr_min
      real (type_r8) :: rate_satcorr_max     
      
      real (type_r8), allocatable :: water_freezing_pts(:,:)
      real (type_r8), allocatable :: tol_freezing_pond(:)

      integer, allocatable :: seepage_bits(:)

      logical        :: b_temperature_inhibition
      logical        :: b_rate_satcorr
      logical        :: b_water_freezing      
      logical        :: b_water_freezing_ratemin
      logical        :: b_water_freezing_cond
      logical        :: b_water_freezing_curve
      logical        :: b_water_freezing_func
      logical        :: b_water_freezing_pts
      logical        :: b_freezing_adjacent_bd
      logical        :: b_freezing_no_pond
      logical        :: b_pressure_melting

! ----------------------------------------------------------------------
! mass balance (reactive transport):
! ----------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cfluxin(n)         = mass gain due to inflow in water  
!                                phase in terms of total aqueous 
!                                component concentrations
!           cfluxout(n)        = mass loss due to outflow in water 
!                                phase in terms of total aqueous
!                                component concentrations
!           cfluxin_diff(n)    = mass gain due to diffusion in water  
!                                phase in terms of total aqueous 
!                                component concentrations
!           cfluxout(n)        = mass loss due to diffusion in water 
!                                phase in terms of total aqueous
!                                component concentrations
!           cfluxin_mig(n)     = mass gain due to electrochemical    
!                                migration in water phase in terms  
!                                of total aqueous component 
!                                concentrations
!           cfluxout_mig(n)    = mass loss due to electrochemical    
!                                migration in water phase in terms  
!                                of total aqueous component 
!                                concentrations
!           gfluxtbdy(ng)      = mass flux across boundary
!                                (gaseous phase)
!           gfluxin(n)         = mass gain due to inflow in air   
!                                phase in terms of total gaseous
!                                component concentrations
!           gfluxout(n)        = mass loss due to outflow in air   
!                                phase in terms of total gaseous
!                                component concentrations
!           cstordiff(n+nm)    = change in storage in terms of total
!                                aqueous component concentrations
!           gdegas(n)          = mass loss from aqueous phse due 
!                                to degassing
!           gstordiff(n)       = change in storage in terms of total
!                                gaseous component concentrations
!           ordiff(n)          = global source-sink term due to
!                                oxidation/reduction reactions
!           intradiff(n)       = global source-sink term due to
!                                intra-aqueous kinetic reactions
!           dpdiff(n+nm)       = source-sink term due to phase
!                                exchange with solid phase 
!                                (minerals)
!           dpdiffp(ndr*nm)    = individual source-sink terms due
!                                to parallel dissolution-
!                                precipitation reactions
!           gdiff(n+ng)        = source-sink term due to phase
!                                exchange with air phase 
!           amass(n)           = total adsorbed mass -
!                                non-competitive sorption [moles]
!           tmass(n)           = total mass in aqueous and gaseous 
!                                phase in terms of total 
!                                component concentrations [moles]
!           cmass(n)           = total mass in aqueous phase in 
!                                terms of total aqueous component 
!                                concentrations [moles]
!           gmass(ng)          = total mass in gaseous phase in
!                                terms of total gaseous component 
!                                concentrations [moles]
!           cmmass(nm)         = total mineral mass in system       
!                                [moles]
!           csbmass(nsb)       = total sorbed mass in system       
!                                [moles]
!           csbmass_ion(nsb_ion)       = total sorbed mass in system       
!                                        [moles] (ion-exchange)
!           csbmass_surf(nsb_surf)     = total sorbed mass in system       
!                                        [moles] (surface-complex)
!           csbmass_c(nsites)  = total sorbed mass in system
!                                - non-aqueous components [moles]
!           cculabsbal(n)      = accumulative absolute mass balance
!                                error for dissolved species
!                                [moles/elapsed time]
!           cculrelbal(n)      = accumulative relative mass balance
!                                error for dissolved species [%]
!           gculabsbal(ng)     = accumulative absolute mass balance
!                                error for gaseous species
!                                [moles/elapsed time]
!           gculrelbal(ng)     = accumulative relative mass balance
!                                error for gaseous species [%]
!           cmculabsbal(nm)    = accumulative absolute mass balance
!                                error for minerals 
!                                [moles/elapsed time]
!           cmculrelbal(nm)    = accumulative relative mass balance
!                                error for minerals [%]
!           sbdiff(n)          = source-sink term due to phase
!                                exchange with sorbed phase 
!           smass(nmb)         = total mass of selected species in
!                                aqueous phase [moles]
!           rateaqtot(naq)     = total rate of intra-aqueous kinetic
!                                reaction in solution domain
!                                [moles/day]
!           contaqtot(naq)     = contribution of intra-aqueous 
!                                kinetic reactions to mass balance
!                                [moles/elapsed time]
!           contmintot(nm)     = contribution of dissolution-
!                                precipitation reactions to mass
!                                balance [moles/elapsed time]
!           totdpdiffp(ndr*nm) = individual contribution of parallel 
!                                reaction pathways of dissolution-
!                                precipitation reactions to mass
!                                balance [moles/elapsed time]
!           totcfluxin(nc)     = total mass gain due to inflow in
!                                auqueous phase in terms of total 
!                                aqueous component concentrations
!           totcfluxout(nc)    = total mass loss due to inflow in
!                                aqueous phase in terms of total 
!                                aqueous component concentrations

!      real (type_r8), allocatable :: totcfluxin_diff(:)
!      real (type_r8), allocatable :: totcfluxin_mig(:)
!      real (type_r8), allocatable :: totcfluxout_diff(:)
!      real (type_r8), allocatable :: totcfluxout_mig(:)

!           totcstordiff(nc)   = total change in storage in
!                                aqueous phase in terms of total 
!                                aqueous component concentrations
!           totordiff(nc)      = total source/sink to total 
!                                aqueous component concentrations
!                                due to oxidation/reduction
!                                reactions
!           totintradiff(nc)   = total source/sink to total
!                                aqueous component concentrations
!                                due to intra-aqueous kinetic 
!                                reactions
!           totdpdiff(nc)      = total source/sink to total 
!                                aqueous component concentrations
!                                due to dissolution-precipitation 
!                                reactions
!           totgdegas(nc)      = total mass loss from aqueous 
!                                phase due to degassing
!           totgdiff(nc)       = total source/sink to total 
!                                aqueous component concentrations
!                                due to gas dissolution-esolution
!                                reactions
!           totgfluxin(nc)     = total mass gain due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!           totgfluxout(nc)    = total mass loss due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!           totgafluxin(nc)    = total mass gain due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!                                advective part
!           totgafluxout(nc)   = total mass loss due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!                                advective part
!           totgstordiff(nc)   = total change in storage in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!           totsbdiff(nc)      = total source/sink to total 
!                                aqueous component concentrations
!                                due to sorption or ion-exchange
!                                reactions
!
!           tmsb_totcfluxin(n,ntmsb)
!                              = total aqueous influx through
!                                specified boundary
!           tmsb_totcfluxout(n,ntmsb)
!                              = total aqueous outflux through
!                                specified boundary
!           tmsb_totgfluxin(n,ntmsb)
!                              = total aqueous influx through
!                                specified boundary by gas diffusion
!           tmsb_totgfluxout(n,ntmsb)
!                              = total aqueous outflux through
!                                specified boundary by gas diffusion
!           tmsb_totgafluxin(n,ntmsb)
!                              = total aqueous influx through
!                                specified boundary by gas advection
!           tmsb_totgafluxout(n,ntmsb)
!                              = total aqueous outflux through
!                                specified boundary by gas advection
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: cfluxin(:)
      real (type_r8), allocatable :: cfluxin_diff(:)
      real (type_r8), allocatable :: cfluxin_mig(:)
      real (type_r8), allocatable :: cfluxout_diff(:)
      real (type_r8), allocatable :: cfluxout_mig(:)
      real (type_r8), allocatable :: cfluxout(:)
      real (type_r8), allocatable :: gfluxtbdy(:)
      real (type_r8), allocatable :: gfluxin(:)
      real (type_r8), allocatable :: gfluxout(:)
      real (type_r8), allocatable :: gafluxin(:)
      real (type_r8), allocatable :: gafluxout(:)
      real (type_r8), allocatable :: cstordiff(:)
      real (type_r8), allocatable :: gdegas(:)
      real (type_r8), allocatable :: gstordiff(:)
      real (type_r8), allocatable :: ordiff(:)
      real (type_r8), allocatable :: intradiff(:)
      real (type_r8), allocatable :: dpdiff(:)
      real (type_r8), allocatable :: gdiff(:)
      real (type_r8), allocatable :: amass(:)
      real (type_r8), allocatable :: amass_gbl(:)
      real (type_r8), allocatable :: tmass(:)
      real (type_r8), allocatable :: tmass_gbl(:)
      real (type_r8), allocatable :: cmass(:)
      real (type_r8), allocatable :: cmass_gbl(:)
      real (type_r8), allocatable :: gmass(:)
      real (type_r8), allocatable :: gmass_gbl(:)
      real (type_r8), allocatable :: cmmass(:)
      real (type_r8), allocatable :: cmmass_gbl(:)
      !real (type_r8), allocatable :: csbmass(:)
      real (type_r8), allocatable :: csbmass_ion(:)
      real (type_r8), allocatable :: csbmass_ion_gbl(:)
      real (type_r8), allocatable :: csbmass_surf(:)
      real (type_r8), allocatable :: csbmass_surf_gbl(:)
      real (type_r8), allocatable :: csbmass_c(:)
      real (type_r8), allocatable :: csbmass_c_gbl(:)
      real (type_r8), allocatable :: cculabsbal(:)
      real (type_r8), allocatable :: cculrelbal(:)
      real (type_r8), allocatable :: gculabsbal(:)
      real (type_r8), allocatable :: gculrelbal(:)
      real (type_r8), allocatable :: cmculabsbal(:)
      real (type_r8), allocatable :: cmculrelbal(:)
      real (type_r8), allocatable :: smass(:)
      real (type_r8), allocatable :: smass_gbl(:)
      real (type_r8), allocatable :: sbdiff(:)
      real (type_r8), allocatable :: rateaqtot(:)
      real (type_r8), allocatable :: contaqtot(:)
      real (type_r8), allocatable :: contmintot(:)
#ifdef PETSC
      real (type_r8), allocatable :: contmintot_mpi(:)
#endif
      real (type_r8), allocatable :: totcfluxin(:)
      real (type_r8), allocatable :: totcfluxin_diff(:)
      real (type_r8), allocatable :: totcfluxin_mig(:)
      real (type_r8), allocatable :: totcfluxout(:)
      real (type_r8), allocatable :: totcfluxout_diff(:)
      real (type_r8), allocatable :: totcfluxout_mig(:)
      real (type_r8), allocatable :: totcstordiff(:)
      real (type_r8), allocatable :: totordiff(:)
      real (type_r8), allocatable :: totintradiff(:)
      real (type_r8), allocatable :: totdpdiff(:)
      real (type_r8), allocatable :: totgdegas(:)
      real (type_r8), allocatable :: totgdiff(:)
      real (type_r8), allocatable :: totgfluxin(:)
      real (type_r8), allocatable :: totgfluxout(:)
      real (type_r8), allocatable :: totgafluxin(:)
      real (type_r8), allocatable :: totgafluxout(:)
      real (type_r8), allocatable :: totgstordiff(:)
      real (type_r8), allocatable :: totsbdiff(:) 
      real (type_r8), allocatable :: dpdiffp(:)
      real (type_r8), allocatable :: totdpdiffp(:)
#ifdef PETSC
      real (type_r8), allocatable :: totdpdiffp_mpi(:)
#endif

      !c solute uptake
      real (type_r8), allocatable :: totrootresp(:)     !respiration uptake
      real (type_r8), allocatable :: totrootuptake(:)   !total uptake by passive uptake and respiration

      real (type_r8), allocatable :: totrcm_c(:)        !total uptake in component-mineral recycles
      real (type_r8), allocatable :: totrcm_c_tz(:)     !total uptake in component-mineral recycles - current cycle
      real (type_r8), allocatable :: totrcm_c_nz(:,:)   !total uptake in component-mineral recycles - current cycle for different zones
      real (type_r8), allocatable :: totrcm_c_ave1st(:,:) !average return rate in component-mineral recycles - first stage of current cycle
      real (type_r8), allocatable :: totrcm_m(:)        !total return in component-mineral recycles
      real (type_r8), allocatable :: totrcm_m_tz(:)     !total return in component-mineral recycles - current cycle
      integer (type_i8), allocatable :: rcm_flag_cvol(:)!flag to indicate if the current control volume is inside the recycle zone
      real (type_r8), allocatable :: rcm_totcvol(:)

      !c accumulative mass through specified boundary
      real (type_r8), allocatable :: tmsb_totcfluxin(:,:)
      real (type_r8), allocatable :: tmsb_totcfluxout(:,:)
      real (type_r8), allocatable :: tmsb_totgfluxin(:,:)
      real (type_r8), allocatable :: tmsb_totgfluxout(:,:)
      real (type_r8), allocatable :: tmsb_totgafluxin(:,:)
      real (type_r8), allocatable :: tmsb_totgafluxout(:,:)

! ----------------------------------------------------------------------
! control parameters - variably saturated flow
! --------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           sw_star            = anticipated change in saturation 
!                                per time step
!           uvslim             = user specified upper limit for 
!                                magnitude of solution update
!                                (flow)
!           utemplim           = user specified upper limit for 
!                                magnitude of solution update
!                                (energy balance, temperature)
! 
!           integer:
!           --------
!           iter_seep          = iteration counter 
!                                (seepage face iterations)
!           itseep_tot         = total number of seepage face 
!                                iterations
!           itsolvtot_vs       = total number of solver
!                                iterations
!                                (variably saturated flow)
!           nseep_first        = number of seepage face nodes
!
!           logical:
!           --------
!           hydraulic_head     = .true.  -> initial condition in 
!                                           terms of hydraulic head
!           increment_tol_head = .true.  -> input units is water head for numerical 
!                                           differentiation and newton convergence tolerance     
!           mass_balance_vs    = .true.  -> compute mass balance
!                                           (variably_saturated
!                                            flow)
!           pressure_head      = .true.  -> initial condition in 
!                                           terms of pressure head
!           seepage_face       = .true.  -> seepage face boundary 
!                                           specified
!           seep_iter          = .true.  -> continue seepage face 
!                                           iteration
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: sw_star
      real (type_r8) :: uvslim
      real (type_r8) :: utemplim

      integer (type_i4) :: iter_seep
      integer (type_i4) :: itseep_tot
      integer (type_i4) :: itsolvtot_vs
      integer (type_i4) :: nseep_first

      logical :: pressure_head
      logical :: hydraulic_head
      logical :: increment_tol_head
      logical :: seepage_face
      logical :: seep_iter
      logical :: mass_balance_vs

! ----------------------------------------------------------------------
! main variables (variably saturated flow):
! -----------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cinfvs(njavs)      = influence coefficients
!                                (variably saturated flow)
!           hhead(nn)          = hydraulic head
!           perm_fac(nn)       = scaling factor for permeability
!                                as a function of porosity changes
!           tau_fac(nn)        = updated tortuosity as the function
!                                of changed porosity
!                                tau = tau_0 * por^alpha / por_0^alpha
!                                tau_fac = por^alpha / por_0^alpha
!           marchies(nn)       = tortuosity update factor in archie's equation
!                                tau = por^alpha
!                                alpha = marchies(i)
!           pornew(nn)         = porosity           
!           por_init(nn)       = initial porosity  
!           por_init_ave       = average of initial porosity
!           sgnew(nn)          = gaseous phase saturation 
!                                (new time level)
!           sgold(nn)          = gaseous phase saturation 
!                                (old time level)
!           sainc(nn)          = aqueous phase saturation 
!                                (incremented)
!           sanew(nn)          = aqueous phase saturation 
!                                (new time level)
!           saold(nn)          = aqueous phase saturation 
!                                (time level N)
!           saold2(nn)         = aqueous phase saturation 
!                                (time level N-1)
!           sonew(nn)          = oil saturation
!           snnew(nn)          = napl saturations time level N+1
!           relperm(nn)        = relative permeability
!           relpermg(nn)       = relative permeability for the 
!                                gas phase
!           relpinc(nn)        = relative permeability (incremented)
!           uvsinc(nn)         = solution vector (incremented)
!           uvsnew(nn)         = solution vector (new time level)
!           uvsold(nn)         = solution vector (old time level)
!           cinfvs_a(njavs)    = influence coefficients for the 
!                                aqueous phase
!           cinfvs_g(njavs)    = influence coefficients for the 
!                                gas phase
!
!           Added by Anna Harrison Jan 24, 2014, ported by Danyang Su
!           qh20(nn)           = equation to remove water during
!                                hydrated mineral precipitation
!                                [L]
!           rwaterremovalcoeff(nm)  
!                              = water removal coefficient,
!                                e.g., 2 for nesquehonite Mg(HCO3)(OH)�2H2O
!                                      3 for artinite     Mg2(CO3)(OH)2�3H2O
!                                Note: this coefficient is a little different
!                                from the stoichiometric of mineral reaction 
!                                equation. Danyang SU, 2015-03-27
!
!           tor_corr_a_mq      = empirical parameter a for tortuosity correction 
!                                'millington-quirk experimental'
!
!                                'tortuosity correction'                                                               
!                                'millington-quirk experimental'                    
!                                2.0d0     ! a, e.g., r1/r3
!                                4.2d0     ! b, e.g., r7/r3
!
!           tor_corr_b_mq      = empirical parameter b for tortuosity correction 
!                                'millington-quirk experimental'
!
!                                'tortuosity correction'                                                               
!                                'millington-quirk experimental'                    
!                                2.0d0     ! a, e.g., r1/r3
!                                4.2d0     ! b, e.g., r7/r3
!
!           integer:
!           --------
!           mpropvs(nn)        = pointer array for allocation of 
!                                material properties
!           logical::
!           --------
!           water_removal      = true to use water removal feature
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: uvsnew(:)
      real (type_r8), allocatable :: uvsold(:)
      real (type_r8), allocatable :: uvsinc(:)
      real (type_r8), allocatable :: hhead(:)
      real (type_r8), allocatable :: saold(:)
      real (type_r8), allocatable :: sanew(:)
      real (type_r8), allocatable :: sgold(:)
      real (type_r8), allocatable :: sgnew(:)
      real (type_r8), allocatable :: sainc(:)
      real (type_r8), allocatable :: sginc(:)
      real (type_r8), allocatable :: sonew(:) ! oil sat - May 15, 06
      real (type_r8), allocatable :: relperm(:)
      real (type_r8), allocatable :: relpermg(:)
      real (type_r8), allocatable :: relpinc(:)
      real (type_r8), allocatable :: relpincg(:)
      real (type_r8), allocatable :: pornew(:)
      real (type_r8), allocatable :: porold(:)
      real (type_r8), allocatable :: por_init(:)
      real (type_r8), allocatable :: perm_fac(:)
      real (type_r8), allocatable :: tau_fac(:)
      real (type_r8), allocatable :: marchies(:)
      real (type_r8), allocatable :: cinfvs(:)
      real (type_r8), allocatable :: cinfvs_a(:)
      real (type_r8), allocatable :: cinfvs_g(:)
      real (type_r8), allocatable :: permij(:)
      real (type_r8), allocatable :: cinfrad(:)
      real (type_r8), allocatable :: snnew(:)
      real (type_r8), allocatable :: saold2(:)
      
      logical :: water_removal
      real (type_r8), allocatable :: qh2o(:)
      real (type_r8), allocatable :: rwaterremovalcoeff(:) 
      
      real (type_r8), allocatable :: taugas(:)

      real (type_r8), allocatable :: stor(:)
      
      real (type_r8)              :: facpormin 
      
      real (type_r8)              :: tor_corr_a_mq
      real (type_r8)              :: tor_corr_b_mq
      
      real (type_r8)              :: por_init_ave

      integer (type_i4), allocatable :: mpropvs(:)
      integer (type_i4), allocatable :: property_iflag(:)       ! control volume property flag

! ----------------------------------------------------------------------
! main variables (variably saturated flow):
! -----------------------------------------
!
!           b_use_fixed_flow_vel = .true.-> use fixed flow velocity throught domain.
!                                           For USG mesh, unless the mesh is fully orthogonal,
!                                           it is not possible to generate flow velocity strictly
!                                           in one direction. The flow field will be skipped and 
!                                           user specified velocity is used.
!
!           b_use_zero_flow_vel  = .true.-> set flow velocity to zero throughout the domain.
!           b_disable_sat_updt   = .true.-> disable saturation update when initial condition
!                                           is read from file and zero flow volocity is used.
!
!           type(point):
!           -------
!
!           fixed_flow_vel     = value of fixed flow velocity preset for USG mesh, unit m/day
!                                     
      logical :: b_use_fixed_flow_vel
      logical :: b_use_zero_flow_vel
      logical :: b_disable_sat_updt
      type (point) :: fixed_flow_vel      

#ifdef USG
      integer (type_i4), allocatable :: mpropvs_cell(:)
      integer (type_i4), allocatable :: property_cell_iflag(:)
#endif

! ----------------------------------------------------------------------
! unstructured grid related variables
! ----------------------------------------------------------------------
!        -->                                                         <--
!           logical:
!           -------
!           b_use_cross_diffusion_flow
!                              = If true, use cross diffusion term in
!                                diffusive/dispersive flux calculation for flow simulation.
!                                If the mesh is orthogonal, the control
!                                volume interface is always perpendicular
!                                to the edge, in this case,
!                                cross diffusion is zero.
!           b_use_cross_diffusion_heat
!                              = If true, use cross diffusion term in
!                                diffusive/dispersive flux calculation for heat simulation.
!                                If the mesh is orthogonal, the control
!                                volume interface is always perpendicular
!                                to the edge, in this case,
!                                cross diffusion is zero.
!           b_use_cross_diffusion_react
!                              = If true, use cross diffusion term in
!                                diffusive/dispersive flux calculation for reactive transport simulation.
!                                If the mesh is orthogonal, the control
!                                volume interface is always perpendicular
!                                to the edge, in this case,
!                                cross diffusion is zero.
!
!           b_use_hls_correction
!                              = If true, use high order least-squares gradient reconstruction
!                                and calculate the truncation error for second and higher
!                                taylor's expansion term
!
!           b_grad_interpolate_cell
!                              = .true.  -> interpolate control volume interface midpoint
!                                           gradient based on all neighbour cell nodes
!                              = .false. -> interpolate control volume interface midpoint
!                                           gradient based on linked edge nodes (default)
!
!           b_use_layered_mesh = .true.  -> mesh is layered and with top and bottom coordinates
!                                           of nodes saved
!           b_use_perot_flow_vel = .true.-> use velocity reconstruction with Perot's method
!                                           See Eveline Visee, 2016, Master Thesis,
!                                           Second order velocity reconstruction on unstructured grids
!
!           b_use_cell_vel     = .true. -> output cell-based velocity field 
!
!           b_mpfa_upstream    = .true. -> calculate upstream point based on gradient value
!                                          For structured grid, upstream is calculated by
!                                          comparing the hydraulic head value of ivol-jvol
!                                          directly. However, for unstructured grid,
!                                          gradient is calculated based on neighboring nodes.
!                                          For highly heterogeneous and anisopic properties,
!                                          comparing hydraulic head value of ivol-jvol may be
!                                          not sufficient. sign of -(Kn dot Grad) is used to
!                                          define the flux direction.
!
!           integer:
!           -------
!           num_crossdifficv_max = number of maximum control volumes used to calculate the cross diffusive term
!
!           janumcell(njavs)   = Number of cells attached to the edge
!
!           jacell(ncell,njavs)= Index of cells attached to the edge
!
!           jacrossdifficvnum(ncell,njavs)
!                              = number of nodes or cells used to interpolate gradient for this edge
!
!           jacrossdifficv(number of related vols or cells,ncell,njavs)
!                              = indices of nodes used to interpolate gradient for this edge
!
!           real*8:
!           -------
!           permbrt_usg(:)     = permeability at the boundary node, for different control
!                                volume interface
!
!
!           jaedgelen(njavs)   = edge length
!
!
!           jacrossdiffweight(ndvol,ncell,njavs)
!                              = cell weight used to interpolate the gradient at
!                                the midpoint of the edge
!
!           cinfrt_va_usg(njavs)
!                              = sum of velocity influence coefficients (advection - aqueous phase)
!                              = for the left and right interfacial linked to the
!                              = the same edge. ndvol is 1 for 2D and 2 for 3D problem.
!
!           jagradweight(njavs)= gradient interpolation spatial weighting for control volume interface
!
!           tol_vc_vel_ave     = tolerance of variation coefficient for velocity average,
!                                if variation coefficient is smaller than this value,
!                                use arithmetic mean to calculate output velocity;
!                                if variation coefficient is bigger than this value, disable
!                                velocity average. This is used to get smoother velocity output.
!
!
!           type(point):
!           -------
!
!
!           vels(nngl)         = interpolated velocity from control volume interface to node
!
!           jaedgeunitdirection(njavs)
!                              = edge unit direction
!
!
! ----------------------------------------------------------------------

#ifdef USG
      logical :: b_use_cross_diffusion_flow
      logical :: b_use_cross_diffusion_heat
      logical :: b_use_cross_diffusion_react
      logical :: b_use_hls_correction
      logical :: b_grad_interpolate_cell
      logical :: b_use_layered_mesh
      logical :: b_use_perot_flow_vel
      logical :: b_use_cell_vel
      logical :: b_mpfa_upstream

      character(len=72) :: ctype_num_node_layers

      integer (type_i4)              :: num_node_layers_inp

      integer (type_i4)              :: num_crossdifficv_max
      integer (type_i4), allocatable :: janumcell(:)
      integer (type_i4), allocatable :: jacell(:,:)
      integer (type_i4), allocatable :: jacrossdifficvnum(:,:)
      integer (type_i4), allocatable :: jacrossdifficv(:,:,:)

      real (type_r8)   , allocatable :: permbrt_usg(:)
      real (type_r8)   , allocatable :: jaedgelen(:)
      real (type_r8)   , allocatable :: jacrossdiffweight(:,:,:)
      real (type_r8)   , allocatable :: cinfrt_va_usg(:)
      real (type_r8)   , allocatable :: jagradweight(:)

      real (type_r8)                 :: tol_vc_vel_ave

      type (point)     , allocatable :: vels(:)
      type (point)     , allocatable :: jaedgeunitdirection(:)

#else
      !>
      !> condition of zone extention type in bit position
      !> bit pos               meaning of 1
      !>  = 0,        selection for cells, if 0, selection for nodes using general method, extent of zone
      !>  = 1,        boundary nodes/cells in the zone
      !>  = 2,        internal nodes/cells in the zone
      !>  = 3,        all nodes/cells in the zone
      !>  = 4,        boundary nodes/cells by id
      !>  = 5,        internal nodes/cells by id
      !>  = 6,        all nodes/cells by id
      !>
      integer :: type_extent_zone      
      
      !>
      !> condition of zone extention type in bit position, for general method
      !> bit pos               meaning of 1
      !>  = 0,        selection for cells, if 0, selection for nodes using general method, extent of zone
      !>  = 1,        boundary nodes/cells in the zone
      !>  = 2,        internal nodes/cells in the zone
      !>  = 3,        all nodes/cells in the zone
      !>  = 4,        boundary nodes/cells by id
      !>  = 5,        internal nodes/cells by id
      !>  = 6,        all nodes/cells by id
      integer :: type_extent_zone_box

      !>
      !> cell_projection used to indicate 2d or 3D problem
      !>
      integer :: cell_projection
#endif

      !> buffer of zone selection using polygon
      real (type_r8) :: zone_buffer
! ----------------------------------------------------------------------
! mass balance (variably saturated flow):
! ---------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           culabsbalvs        = accumulative absolute mass balance 
!                                error
!           totvsmass          = total system mass
!           rtol_relbalance_vs = relative mass balance tolerance for
!                                convergence check
!           rtol_absbalance_vs = absolute mass balance tolerance for
!                                convergence check
!           relbalance_vs      = relative mass balance for                            
!                                convergence check                                              
!           absbalance_vs      = absolute mass balance for                            
!                                convergence check 
!           tmsb_influx_accu(n,ntmsb)
!                              = total accumulative influx through
!                                specified boundary
!           tmsb_outflux_accu(n,ntmsb)
!                              = total accumulative outflux through
!                                specified boundary
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: totvsmass
      real (type_r8) :: culabsbalvs 

      real (type_r8) :: rtol_relbalance_vs
      real (type_r8) :: rtol_absbalance_vs
      real (type_r8) :: relbalance_vs
      real (type_r8) :: absbalance_vs

      real (type_r8), allocatable :: tmsb_influx_accu(:)
      real (type_r8), allocatable :: tmsb_outflux_accu(:)
! ----------------------------------------------------------------------
! boundary conditions (ice loading/unloading):
! ----------------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           time_bcice_prev    = previous read time for flow boundary 
!                                conditions      
!           time_bcice         = next read time for flow boundary 
!                                conditions
!      
!           integer:
!           --------
!           iunitbcice         = file unit of ice sheet boundary
!           nbzice             = number of zones of ice sheet boundary
!           logical:
!           --------
!           update_bcice       = .true.  -> transient boundary condition for 
!                                           ice loading/unloading
!
!           update_bcice_value_only
!                              = .true.  -> transient boundary condition for
!                                           ice loading/unloading
!                                           with same types and zones
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: time_bcice_prev
      real (type_r8) :: time_bcice

      !Boundary condition can be duplicated, use negative value for those overwritten boundary condition in jabrt, by DSU, 2018-02-02
      !This is important in parallel code as the boundary condition assignment to the nodes is not in the same order as sequential code
      !For the sequential code, the latter boundary condition will overwrite the previous boundary condition if assign to the same node.

      integer (type_i4) :: nbzice
      integer (type_i4) :: ibcice

      logical :: update_bcice
      logical :: update_bcice_value_only 
      logical :: b_restart_update_bcice
      logical :: b_first_update_bcice
      logical :: b_interpolation_bcice

! ----------------------------------------------------------------------
! scaling factor of pressure head, pore stress and boundary pore pressure :
! ----------------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           time_ice_scalfac_prev    = previous read time for scaling factors      
!           time_ice_scalfac         = next read time for scaling factors
!      
!           integer:
!           --------
!           file_ice_scalfac         = file unit of ice sheet boundary

!           logical:
!           --------
!           b_linear_ice_scalfac       = .true.  -> linear interpolation type of 
!                                                 scaling factors
!           update_ice_scalfac       = .true.  -> transient scaling factors
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: time_ice_scalfac_prev
      real (type_r8) :: time_ice_scalfac
      real (type_r8) :: ice_scalfac_pre(6)
      real (type_r8) :: ice_scalfac_next(6)

      integer :: file_ice_scalfac

      logical :: update_ice_scalfac
      logical :: b_linear_ice_scalfac
      logical :: b_first_update_ice_scalfac
      logical :: b_restart_update_ice_scalfac

! ----------------------------------------------------------------------
! boundary and initial conditions (variably saturated flow):
! ----------------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           bcondvs(nbvs)      = boundary condition 
!                                (pressure head or flux) or 
!                                identification of seepage face 
!                                boundary type
!           bcondvs_prev(nbvs) = previous boundary condition 
!                                (pressure head or flux) or 
!                                identification of seepage face 
!                                boundary type (for interpolation)
!           bcondvs_next(nbvs) = next boundary condition 
!                                (pressure head or flux) or 
!                                identification of seepage face 
!                                boundary type (for interpolation)  
!           time_bcvs_prev     = previous read time for flow boundary
!                                conditions
!           time_bcvs          = next read time for flow boundary 
!                                conditions
!      
!           integer:
!           --------
!           iabvs(nbvs)        = pointer to boundary control volumes
!                                for variably saturated flow
!           ivol2bvs(nngl)     = pointer from control volume number to
!                                boundary control volume index
!           ivol2bzvs(nngl)    = pointer from control volume number to
!                                the zone index of boundary control volume    
!           bvalid_iabvs(nbvs) = flag to indicate if this boundary 
!                                condition is valid. If the boundary
!                                condition is overwritten, it is 
!                                an invalid boundary condition
!                                .true.  => valid
!                                .false. => invalid
!                                
!           ibcvs              = unit number, transient boundary 
!                                             conditions, variably
!                                             saturated flow
!           isoi               = unit number, soil specific 
!                                             parameters
!           nbvs               = number of specified boundary 
!                                control volumes 
!                                (variably saturated flow)
!           nbzvs              = number of specified boundary
!                                zones
!                                (variably saturated flow)
!
!           logical:
!           --------
!           update_bcvs        = .true.  -> transient boundary  
!                                           condition for variably 
!                                           saturated flow
!           update_bcvs_value_only
!                              = .true.  -> transient boundary
!                                           condition for variably
!                                           saturated flow
!                                           with same types and zones
!           b_interpolation_bcvs
!                              = .true.  -> linear interpolation for 
!                                           transient boundary conditions
!           b_first_update_bcvs
!                              = .true.  -> flag to indicate if it is the
!                                           first time to update the boundary
!           character:
!           ----------
!           btypevs(nbvs)      = boundary type array 
!                                (variably saturated flow)
!                                'first'   = Dirichlet 
!                                'second'  = Neumann
!                                'seepage' = seepage face
!                                'free-drainage' = free-drainage
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: time_bcvs_prev
      real (type_r8) :: time_bcvs
      real (type_r8), allocatable :: bcondvs(:)
      real (type_r8), allocatable :: bcondvs_prev(:)
      real (type_r8), allocatable :: bcondvs_next(:)


      !Boundary condition can be duplicated, use negative value for those overwritten boundary condition in jabrt, by DSU, 2018-02-02
      !This is important in parallel code as the boundary condition assignment to the nodes is not in the same order as sequential code
      !For the sequential code, the latter boundary condition will overwrite the previous boundary condition if assign to the same node.
      integer (type_i4), allocatable :: iabvs(:)
      integer (type_i4), allocatable :: ivol2bvs(:)
      integer (type_i4), allocatable :: ivol2bzvs(:)      

      !logical, allocatable :: bvalid_iabvs(:)

      integer (type_i4) :: nbvs
      integer (type_i4) :: nbzvs
      integer (type_i4) :: ibcvs
      integer (type_i4) :: isoi

      logical :: update_bcvs
      logical :: update_bcvs_value_only
      logical :: b_interpolation_bcvs
      logical :: b_first_update_bcvs

!cprovi-----------------------------------------------------------------      
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
      logical :: update_ext_type_bcvs
      integer (type_i4) :: ibcvs1

  
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------      

      character*16, allocatable :: btypevs(:)
      character*1, allocatable :: bzvs_dir_grad(:)
      type(point), allocatable :: bzvs_radius_center(:)
      integer, allocatable :: bzvs_itype_grad(:)
      integer, allocatable :: bzvs_nparms(:)

! ----------------------------------------------------------------------
! transient dispersivity for heat and reactive transport:
! ----------------------------------------------------------
!           update_disprt      = .true.  -> transient dispersivity  
!                                           coefficient for reactive  
!                                           transport
!           update_disprt_value_only
!                              = .true.  -> transient dispersivity
!                                           coefficient for reactive
!                                           transport 
!                                           with same types and zones
!           b_interpolation_disprt
!                              = .true.  -> linear interpolation for 
!                                           transient dispersivity
!                                           for reactive transport
!           b_first_update_disprt
!                              = .true.  -> flag to indicate if it is the
!                                           first time to update the dispersivity
!
      integer (type_i4) :: idisprt
      
      logical :: update_disprt
      logical :: update_disprt_value_only
      logical :: b_interpolation_disprt
      logical :: b_first_update_disprt
      logical :: b_restart_update_disprt
      
      real (type_r8) :: time_disprt_prev
      real (type_r8) :: time_disprt

! ----------------------------------------------------------------------
! newton iteration - variably saturated flow
! ------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           dinc_vs            = increment for numerical 
!                                differentiation
!           relfacold          = underrelaxation factor 
!                                (old time level)
!           relfactempold      = underrelaxation factor 
!                                (old time level, temperature)
!           srelfac_vs         = user specified underrelaxation 
!                                factor
!           srelfac_temp       = user specified underrelaxation 
!                                factor (temperature)
!           tol_vs             = convergence tolerance 
!                                (variably saturated flow)
!           uvsmaxold          = maximum solution update 
!                                (old time level)
!           utempmaxold        = maximum solution update 
!                                (old time level, temperature)
!           vsflux(ncon-1)     = interfacial fluxes
!           div_vs(5)          = divergence check for previous 3 iteration
!
!           integer:
!           --------
!           iter_vs            = iteration counter 
!                                (variably saturated flow)
!           ittot_vs           = total number of iterations 
!                                (variably saturated flow)
!           ittot_glob          = total number of iterations
!                                (heat transport)
!           maxit_vs           = max. number of newton iterations
!                                (variably saturated flow)
!           maxit_seepage      = max. number of picard iterations
!                                (seepage boundary condition)
!
!           logical:
!           --------
!           comp_relax         = .true.  -> compute underelaxation 
!                                           factor
!           comp_relax_temp    = .true.  -> compute underelaxation 
!                                           factor for temperature
!           under_relax        = .true.  -> underrelaxation
!           upstream           = .true.  -> upstream weighting
!           under_relax_temp   = .true.  -> underrelaxation for temperature
!           b_check_div_vs     = .true.  -> check divergence for flow iteration
!
!           character:
!           ----------
!           iups(ncon-1)       = upstream pointer
!           iupsg(njavs)       = upstream node for gas transport
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: vsflux(:)
      real (type_r8)    :: dinc_vs
      real (type_r8)    :: tol_vs
      real (type_r8)    :: uvsmaxold
      real (type_r8)    :: relfacold
      real (type_r8)    :: srelfac_vs
      real (type_r8)    :: srelrange_vs_min
      real (type_r8)    :: srelrange_vs_max
      real (type_r8)    :: srelrange_temp_min
      real (type_r8)    :: srelrange_temp_max

      real (type_r8) :: div_vs(5)

      integer (type_i4) :: maxit_vs
      integer (type_i4) :: iter_vs
      integer (type_i4) :: ittot_vs
      integer (type_i4) :: ittot_glob  
      
      integer (type_i4) :: iter_vs_ant
      real (type_r8)    :: iter_vs_ave      

      real (type_r8) :: div_heat(5)
      integer (type_i4) :: maxit_heat

      integer (type_i4) :: iter_heat_ant
      real (type_r8)    :: iter_heat_ave

      integer (type_i4) :: iter_heat
      integer (type_i4) :: ittot_heat

      integer (type_i4) :: maxit_seepage

      logical           :: upstream
      logical           :: under_relax
      logical           :: under_relax_range_vs
      logical           :: comp_relax
      logical           :: b_check_div_vs
      logical           :: b_check_div_heat
      
      real (type_r8)    :: utempmaxold
      real (type_r8)    :: relfactempold
      real (type_r8)    :: srelfac_temp
      
      logical           :: under_relax_temp
      logical           :: under_relax_range_temp
      logical           :: comp_relax_temp

      character*1, allocatable :: iups(:)

      character*1, allocatable :: iupsg(:) ! upstream node for gas trans

! ----------------------------------------------------------------------
! data structure and solver - variably saturated flow: 
! ----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           avs(njavs)         = jacobian matrix
!           afvs(njafvs)       = incomplete factorization
!           bvs(nn)            = rhs vector
!           deltol_vs          = solver update tolerance
!           res_vs(nn)          = residual
!           restol_vs          = solver residual tolerance
!           uvs(nn)            = update towards solution-vector
!           jaedgelen(njavs)   = distance between two nodes
!
!           jacrossdiffweight(ncell,njavs)
!                              = weight to interpolate the gradient for the control volume interface.
!                                if the cross diffusion gradient interpolation is based on edge, then
!                                only the edge nodes is used, otherwise, if interpolation is based on cell,
!                                all the nodes from the neighbouring cells are used.
!
!           integer:
!           --------
!           iavs(nn+1)         = row pointer array for 1d-scalar 
!                                matrix
!           iafvs(nn+1)        = row pointer array for afvs
!           idetail_vs         = information level
!           javs(njavs)        = connectivity list for 1d-scalar 
!                                matrix
!           javsrec(njavs)     = array to save the times of the data being set
!           janumcell(njavs)   = number of cells linked to the edge
!           jacell(nconc,njavs)= connectivity of cell id list, nconc represents
!                                the connection number where nconc = 2 represents
!                                left and right
!                              = corresponding
!           jafvs(njafvs)      = column pointer array for afvs
!           iafdvs(nn)         = diagonal pointer array for afvs
!           isymvs(njavs)      = symmetry pointer array 
!           lordervs(nn)       = array containing ordering
!           invordvs(nn)       = array containing inverse ordering
!           level_vs           = incomplete factorization level
!           msolvit_vs         = max. number of solver iterations
!           mnjavs             = max. number of global connections
!           mnjafvs            = max. number of factored connections
!           njavs              = number of global connections
!           njafvs             = number of factored connections
!           usg_mesh_ordering  = 32-bit unstructured mesh ordering type
!                                bit position 0 - use mesh reordering
!                                bit position 1 - mesh reordering done
!                                bit position 2 - use rcm ordering
!                                bit position 3 - use other ordering (to do)
!
!           logical:
!           --------
!           rcm_ordering_vs    = .true.  -> rcm ordering for 
!                                           1-d scalar matrix
!           metis_ordering_vs  = .true.  -> metis ordering for
!                                           1-d scalar matrix
!           is_javsrec_set     = .true.  -> variable javsrec is set
!
!           vector:
!
!           jaedgeunitdirection(njavs)
!                              = unit vector of edge ivol-jvol
!
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: avs(:)
      real (type_r8), allocatable :: bvs(:)
      real (type_r8), allocatable :: uvs(:)
      real (type_r8), allocatable :: res_vs(:)
      real (type_r8), allocatable :: afvs(:)

      real (type_r8) :: restol_vs
      real (type_r8) :: deltol_vs

      integer (type_i4), allocatable :: iavs(:)
      integer (type_i4), allocatable :: javs(:)
      integer (type_i4), allocatable :: iafvs(:)
      integer (type_i4), allocatable :: jafvs(:)
      integer (type_i4), allocatable :: iafdvs(:)
      integer (type_i4), allocatable :: isymvs(:)
      integer (type_i4), allocatable :: lordervs(:)
      integer (type_i4), allocatable :: invordvs(:)
      integer (type_i4), allocatable :: javsrec(:)

      integer (type_i4) :: mnjavs
      integer (type_i4) :: mnjafvs
      integer (type_i4) :: njavs
      integer (type_i4) :: njafvs
      integer (type_i4) :: level_vs
      integer (type_i4) :: msolvit_vs
      integer (type_i4) :: idetail_vs
      integer (type_i4) :: coeff_fac_conn_vs

      integer (type_i4) :: usg_mesh_ordering

      logical           :: rcm_ordering_vs
      logical           :: metis_ordering_vs
      logical           :: is_javsrec_set
      
! ----------------------------------------------------------------------
! standard data structure and solver - variably saturated flow: 
! ----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           avs_std(njavs)     = jacobian matrix for standard sparse
!                                 matrix
!           integer:
!           --------
!           javs_std(njavs)    = connectivity list for 1d-scalar 
!                                matrix
!           imapvs_std(njavs) = point of standard sparse matrix to 
!                                 sparse matrix used in ws209
!                                 
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: avs_std(:)
      real (type_r8), allocatable :: uvs_std(:)         !for test, dsu      
      integer (type_i4), allocatable :: javs_std(:)
      integer (type_i4), allocatable :: imapvs_std(:)  
      logical :: bsymbolicfactor_vs  =  .true.

! ----------------------------------------------------------------------
! solver - general
! ----------------
!        -->                                                         <--
!           real*8:
!           -------
!           rwork(:,:)         = real*8 work array
!           rwork_next(:,:)    = real*8 work array
!           rwork_max(:,:)     = real*8 work array, maximum work array for 
!                                solver in flow and reactive transport equations
!           rnorm              = residual 2-norm 
!           rmupdate           = maximum solution update (solver)
!
!           integer:
!           --------
!           iwork(:)           = integer work array
!           iwork_max(:)       = integer work array, maximum work array for 
!                                solver in flow and reactive transport equations
!           itsolv             = actual number of solver iterations
!           n_rwork_max        = maximum size of rwork for flow and reactive transport
!
!           logical:
!           --------
!           lwork(:)           = logical work array
! ----------------------------------------------------------------------


      real (type_r8), allocatable :: rwork(:,:)
      real (type_r8), allocatable :: rwork_next(:,:)
      real (type_r8), allocatable :: rwork_max(:)      
      
      real (type_r8) :: rnorm
      real (type_r8) :: rmupdate
      logical :: over_flow_vs
      logical :: over_flow_heat
      logical :: over_flow_rt


      integer (type_i4), allocatable :: iwork(:)
      integer (type_i4), allocatable :: iwork_max(:)

      integer (type_i4) :: itsolv
      
      integer :: n_rwork_max
      integer :: n_iwork_max

      logical, allocatable :: lwork(:)
      
! ----------------------------------------------------------------------
      integer (type_i4) :: skip_time, nskip_time    ! skip writing output in logfile
                                                    ! for long simulations

      logical :: chemical_water

      real (type_r8), allocatable :: qwater(:)
      
!cprovi--------------------------------------------------------
!cprovi Restart process
!cprovi Based on Richard Amos implementation 
!cprovi integer (type_i4) :: rsrt_cnt           ! restart counter
!cprovi    integer (type_i4) :: irsrt              ! output unit for restart files
!cprovi    integer (type_i4) :: backup_frequency   ! backup frecuency 
!cprovi    logical           :: restart_sim        ! if true, the simulations is restarted according to restart.dat file 
!cptovi 
!cprovi It was added 09/08/2009 
!cprovi Sergio Andres Bea Jofre 
!cprovi--------------------------------------------------------
      integer (type_i4) :: rsrt_cnt           ! restart counter
      integer (type_i4) :: irsrt              ! output unit for restart files
      integer (type_i4) :: backup_frequency   ! backup frecuency 
      real (type_r8)    :: time_io_rs         ! restart time saved in restart file
      real (type_r8)    :: delt_io_rs         ! restart time saved in restart file
      logical           :: restart_sim        ! if true, the simulations is restarted according to restart.dat file 
      integer           :: i_append_sim                 ! if = 1, the simulation results will be appended to the previous results
                                                        ! if = 2, the simulation results will be appended to the previous results in legacy mode.
                                                        ! In this mode, user needs to use the first restart file and the code will append results
                                                        ! to the transient output when it reaches the next restart time, to avoid blips due to the loss
                                                        ! of significance in the restart file.
      integer           :: mtime_append                 ! timestep to begin appending results

      logical           :: b_distributed_restart_read   ! If true, the simulations is restarted according to restart_rank_n.dat file. 
                                                        ! Note: activate this if domain decomposition method is used.
      logical           :: b_distributed_restart_write  ! If true, the simulations is restarted according to restart_rank_n.dat file. 
                                                        ! Note: activate this if domain decomposition method is used.
                                               
      logical           :: b_binary_restart_read   ! if true, use binary fortat tp read restart file
      logical           :: b_binary_restart_write  ! if true, use binary fortat to write restart file
!cprovi--------------------------------------------------------
!cprovi
!cprovi Ice sheet 
!cprovi Sergio Andres Bea Jofre 
!cdsu   Add b_iabvs_ice and b_jabrt_ice to set those volumes in affected area
!cdsu   during ice advanc process, the flags of boundary nodes under ice are set to false,
!cdsu   during ice retreat process, the flags of boundary nodes under ice are set to true,
!cdsu   on other conditions, the flags of boundary nodes are set to true.
!cdsu   Modified by DSU, 2017-07-30
!cprovi 
!cprovi--------------------------------------------------------
      type(t_ice_sheet), pointer    :: ice_sheet
      logical                       :: compute_ice_sheet_loading
      logical                       :: compute_permafrost 
      real (type_r8), allocatable   :: skempton(:)
      real (type_r8), allocatable   :: loading_factor(:)
      integer (type_i4)             :: iskempton  ! Unit for skempton's coefficient

      !cdsu boundary condition update time for reactive transport, 
      !cdsu only used as a mark in restart for now. 
      real (type_r8) :: time_bcrt_prev
      real (type_r8) :: time_bcrt

      !cdsu the following variables are commented out, 
      !cdsu replaced with new indicator b_iabvs_ice and b_jabrt_ice
      real (type_r8), allocatable   :: bcondvs0(:)
      real (type_r8), allocatable   :: bcondvs1(:)
      real (type_r8), allocatable   :: bcondrt_a0(:,:)
      !integer(type_i4), allocatable :: iabvs0(:)
      !integer(type_i4), allocatable :: jabrt0(:)      
      !integer(type_i4)              :: nbvs0
      !integer(type_i4)              :: nbrt0

!cdsu b_iabvs_ice          = true,   apply normal boundary condition or 
!cdsu                                ice retreat boundary condition
!cdsu                        false,  apply ice advance boundary condition or
!cdsu                                closed boundary condition.
!cdsu b_jabrt_ice          = true,   apply normal boundary condition or 
!cdsu                                ice retreat boundary condition
!cdsu                        false,  apply ice advance boundary condition or
!cdsu                                closed boundary condition.      
      logical, allocatable :: b_iabvs_ice(:)
      logical, allocatable :: b_jabrt_ice(:)
      
      real (type_r8), allocatable   :: por_stress_dt(:)        ! - stor * skempton * delta stress  
      !real (type_r8), allocatable   :: por_stress(:)          ! current porosity change due to stress, equal accumulative por_stress_dt
      
      integer(type_i4), allocatable :: iwork_bc(:)
      real(type_r8), allocatable    :: rwork_bc(:)
      
!cdsu ice loading/unloading timeline variables
!cdsu this variables are used to modify the timestep to make sure the timestep will 
!cdsu not span the ice loading/unloading stages.
!cdsu assume the time is in ascending order and continuous, icetimeline(2,nstages)
!cdsu these 
      integer(type_i4)              :: icestage, nicestages
      real(type_r8), allocatable    :: icetimeline(:,:)

!cdsu ice sheet initial/boundary condition in general format that
!cdsu works for both structured and unstructured mesh
!cdsu ice_sheet_type = 0, old format using block 'ice sheet loading/unloading'
!cdsu                = 1, new format using block 'ice sheet loading/unloading - curve fitting'

      integer :: ice_sheet_type

!cdsu --------------------------------------------------------
!cdsu Fracture related parameters
!cdsu Cushman, J. H. & Tartakovsky, D. M. The Handbook of Groundwater Engineering, 2016 
!cdsu --------------------------------------------------------
      integer :: ifrac                                !file unit of fracture aperture
      integer, allocatable :: fractureFlowType(:)    !define fracture flow type, e.g., 0 - darcy flow, 1 - cublic law flow
      real*8, allocatable :: aperture(:)             !aperture of fracture


!> Parameter for output control
!> dsu
!> b_writeversion_tecplot
!> If ture, write version information to the output tecplot data file or not
      logical :: b_writeversion_tecplot = .false.

!>dsu----------------------------------------------------------
!>Parameters for parallel version of min3p, OpenMP
!>dsu----------------------------------------------------------
! path of parallel solver configuration file
     character(2048) :: str_solvercfg
!> b_solver_cfg_arg: if true, the solver configuration file is specified from the input arguments
!> Otherwise, it is specified from the input file
     logical :: b_solver_cfg_arg = .false.

!> isolvercfg
!> file unit of solver configuration
     integer(type_i4) :: isolvercfg
!
!> b_solver_test_pardiso
     logical :: b_solver_test_pardiso   = .false.             !.true.
     
!
!> b_solver_test_petsc
     logical :: b_solver_test_petsc     = .false.             !.true.

!
!> b_solver_test_lis
     logical :: b_solver_test_lis       = .false.
     
!
!> b_output_condition_number
     logical :: b_output_condition_number = .false. 

!> b_dynamic_memory 
!> use static memory is more efficient than dynamic memory, especially when memory is large enough
     logical :: b_dynamic_memory        = .false.
     
!> b_enable_output
!> If fasle, the output will be disabled. Only some log information are output.
     logical :: b_enable_output = .true.
     
!> b_enable_output_gen
     logical :: b_enable_output_gen = .true.
     
!> b_min3p_input_param_first
!> If true, it indicates that the input parameters in the MIN3P input
!> file have the priority over the input parameters in the parallel
!> solver configuration file.
!> By default, the parameters in this file will overwrite the same
!> parameters in the MIN3P input file.
!> For example, if there are solver convergence parameters in both 
!> files, you can use the following command if you want to use MIN3P
!> input parameters first.
!> Requirement: Optional
!> 
     logical :: b_min3p_input_param_first = .false.
     
!> b_mpi_process_flag = .true. stop or return all process
     logical :: b_mpi_process_flag = .false.

!> command line to invoke the program
     character(len=2048) :: strcommand
    
    
!> i_solver_type = 0 use ws209 solver
!>                 1 use pardiso solver
!>                 2 use PETSc solver
!>                 3 use LIS solver

     integer :: i_solver_type           = 0 
!> i_solver_type_flow = 0 use ws209 solver
!>                      1 use pardiso solver
!>                      2 use PETSc solver
!>                      3 use LIS solver
     integer :: i_solver_type_flow      = 0

!> i_solver_type_heat = 0 use ws209 solver
!>                      1 use pardiso solver
!>                      2 use PETSc solver
!>                      3 use LIS solver
     integer :: i_solver_type_heat      = 0

!> i_solver_type_react = 0 use ws209 solver
!>                       1 use pardiso solver
!>                       2 use PETSc solver
!>                       3 use LIS solver
     integer :: i_solver_type_react     = 0
     
!> i_symfactor_type_flow = 0 symbolic factorization at first run
!>                         1 symbolic factorization every step
     integer :: i_symfactor_type_flow   = 0

!> i_symfactor_type_heat = 0 symbolic factorization at first run
!>                         1 symbolic factorization every step
     integer :: i_symfactor_type_heat   = 0

!> i_symfactor_type_react = 0 symbolic factorization at first run
!>                          1 symbolic factorization every step
     integer :: i_symfactor_type_react  = 0
     
!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time.
!> When preconditioned CGS is used, this value will be compared to the number of completed iterations,
!> otherwise, this value will be compared to the number of iterative refinement steps performed.
!> When the iteration number is larger than the provided, do symblic factorization again.
!> Maximum pardiso solver iteration in flow
     integer :: n_max_iteration_flow  = 9

!> Maximum pardiso solver iteration in heat transport
     integer :: n_max_iteration_heat  = 9

!> Maximum pardiso solver iteration in reactive transport   
     integer :: n_max_iteration_react = 9
     
!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time. 
!> When the maximum residual is larger than the provided, do symblic factorization again.
!> Maximum residual in flow
     real (type_r8) :: r_max_residual_flow  = 1.0E-5

!> Maximum residual in heat transport
     real (type_r8) :: r_max_residual_heat  = 1.0E-5

!> maximum residual in reactive transport
     real (type_r8) :: r_max_residual_react = 1.0E-5
     
!> b_prtfile write files of parallel runtime (prt) for different modules
     logical :: b_prtfile = .false.
     
!> b_output_matrix output sparse matrix data set and rhs for different modules    
     logical :: b_output_matrix = .false.
     
!> b_output_matrix output sparse matrix data set and rhs for different modules using petsc
     logical :: b_output_matrix_petsc = .false.

!> output sparse matrix data set and rhs at specific timestep
     integer(type_i4) :: itimestep_output_matrix = -1

!> Set the output matrix format  
!> 0: export a (ia, ja), b, x as 1d array into separated files
!> 1: export a (ia, ja) as matrix market exchange format, 
!>    and b and x as 1d array into separated files
!> E.g.
!> OUTPUT MATRIX FORMAT SELECTION
!> 1
     integer(type_i4) :: itype_matrix_format = 1

!> file unit of parallel runtime (prt) for different modules
!> file unit of parallel runtime for flow
     integer(type_i4) :: iprt_flow
!> file unit of parallel runtime for decoupled heat transport
     integer(type_i4) :: iprt_heat
!> file unit of parallel runtime for reactive transport
     integer(type_i4) :: iprt_react
!> file unit of parallel runtime for flow for lis solver
     integer(type_i4) :: iprt_flow_lis
!> file unit of parallel runtime for decoupled heat transport for lis solver
     integer(type_i4) :: iprt_heat_lis
!> file unit of parallel runtime for reactive transport for lis solver
     integer(type_i4) :: iprt_react_lis
!> file unit of parallel runtime for reactive transport
     integer(type_i4) :: iprt_react_jac     
!> file unit of parallel runtime for flow
     integer(type_i4) :: iprt_flow_comp
!> file unit of parallel runtime for decoupled heat transport
     integer(type_i4) :: iprt_heat_comp
!> file unit of parallel runtime for reactive transport
     integer(type_i4) :: iprt_react_comp     
!> file unit of parallel runtime for non-linear euqations in every time step
     integer(type_i4) :: iprt_nonlinear
!> file unit of parallel runtime for time steps
     integer(type_i4) :: iprt_timestep    
     
!> parallel runtime for flow module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_flow_tot       = 0
     real (type_r8) :: prt_flow_jac       = 0
     real (type_r8) :: prt_flow_symbfac   = 0
     real (type_r8) :: prt_flow_fac       = 0
     real (type_r8) :: prt_flow_sub       = 0
     real (type_r8) :: prt_flow_solver    = 0   !total time of symbfac, fac and sub

!> parallel runtime for decoupled heat transport module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_heat_tot       = 0
     real (type_r8) :: prt_heat_jac       = 0
     real (type_r8) :: prt_heat_symbfac   = 0
     real (type_r8) :: prt_heat_fac       = 0
     real (type_r8) :: prt_heat_sub       = 0
     real (type_r8) :: prt_heat_solver    = 0   !total time of symbfac, fac and sub
     
!> parallel runtime for reactive transport module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_react_tot      = 0
     real (type_r8) :: prt_react_jac      = 0
     real (type_r8) :: prt_react_symbfac  = 0
     real (type_r8) :: prt_react_fac      = 0
     real (type_r8) :: prt_react_sub      = 0
     real (type_r8) :: prt_react_solver   = 0   !total time of symbfac, fac and sub
     
!> parallel runtime for flow module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_flow_symbfac_comp  = 0
     real (type_r8) :: prt_flow_fac_comp  = 0
     real (type_r8) :: prt_flow_sub_comp  = 0

!> parallel runtime for decoupled heat transport module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_heat_symbfac_comp  = 0
     real (type_r8) :: prt_heat_fac_comp  = 0
     real (type_r8) :: prt_heat_sub_comp  = 0
     
!> parallel runtime for reactive transport module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_react_symbfac_comp = 0
     real (type_r8) :: prt_react_fac_comp = 0
     real (type_r8) :: prt_react_sub_comp = 0 

!> parallel runtime for coupling iterations
     real (type_r8) :: prt_nonlinear_tot   = 0
     real (type_r8) :: prt_nonlinear_flow  = 0
     real (type_r8) :: prt_nonlinear_heat  = 0
     real (type_r8) :: prt_nonlinear_react = 0
     
!> parallel runtime for time steps
     real (type_r8) :: prt_timestep_tot       = 0
     real (type_r8) :: prt_timestep_nonlinear  = 0
     
!> time for different part of matrix assemble in reactive transport  
!> For test only, dsu
     real (type_r8) :: prt_react_jac_part(6)
    
!>
!> Set the number of threads for global use
!> Default value: 1
!> Requirement: Optional
!> This value should maybe reset to the maximum number of threads
!> used for each process.
    integer(type_i4) :: numofthreads_global = 1
    
!>
!> Set the maximum number of threads used.
    integer(type_i4) :: nthreads = 1
    
!>
!> Set the number of parallel loop threshold for general use
!> Default value: 10000
!> Requirement: Optional  
    integer(type_i8) :: numofloops_thred_global = 1
    
!>
!> Set the matrix assembly type for flow problem
!> i_matrix_assembly_type_flow = 0 use sequential mode (default)
!>                               1 use Openmp parallel mode
!>                               2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode    
    integer(type_i4) :: i_matrix_assembly_type_flow = 0
    
!>
!> Set the number of threads in matrix assembly for flow problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: numofthreads_matrix_flow = 1
    
!> Set the schedule type in matrix assembly for flow problem.
!> If not specified, use the static schedule method.
!> i_schedule_type_flow = 0 use static schedule method (default)
!>                        1 use dynamic schedule method 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_schedule_type_flow = 0


!> Set the chunk size factor for matrix assembly for flow problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_flow = 0 use system default size
!>                           1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_chunksize_factor_flow = 0

!>
!> Set the matrix assembly type for decoupled heat tranport problem
!> i_matrix_assembly_type_heat = 0 use sequential mode (default)
!>                               1 use Openmp parallel mode
!>                               2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode    
    integer(type_i4) :: i_matrix_assembly_type_heat = 0
    
!>
!> Set the number of threads in matrix assembly for decoupled heat transport problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: numofthreads_matrix_heat = 1
    
!> Set the schedule type in matrix assembly for heat transport problem.
!> If not specified, use the static schedule method.
!> i_schedule_type_heat = 0 use static schedule method (default)
!>                        1 use dynamic schedule method 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_schedule_type_heat = 0


!> Set the chunk size factor for matrix assembly for decoupled heat transport problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_heat = 0 use system default size
!>                           1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_chunksize_factor_heat = 0       
    
!>
!> Set the matrix assembly type for reactive transport problem
!> i_matrix_assembly_type_react = 0 use sequential mode (default)
!>                                1 use Openmp parallel mode
!>                                2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_matrix_assembly_type_react = 0
    integer(type_i4) :: i_matrix_assembly_type_jacrt = 0
    integer(type_i4) :: i_matrix_assembly_type_jacbrt = 0
    
!>
!> Set the number of threads in matrix assembly for reactive 
!> transport problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: numofthreads_matrix_react = 1
    
!> Set the schedule type in matrix assembly for reactive 
!> transport problem.
!> If not specified, use the static schedule method.
!> i_schedule_type_react = 0 use static schedule method (default)
!>                         1 use dynamic schedule method 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_schedule_type_react = 0

!> Set the chunk size factor for matrix assembly for reactive 
!> transport problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_react = 0 use system default size
!>                            1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_chunksize_factor_react = 0

!> Set the schedule type for MIP bubble model
!> i_omp_type_mip_bubble = 0 use sequential mode (default)
!>                         1 use Openmp parallel mode
!>                         2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_omp_type_mip_bubble = 0
    
!>
!> Set the number of threads in MIP bubble model
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: numofthreads_mip_bubble = 1
    
!> Set the number of threads for ws209 solver.
!> Only works when the solver type is ws209.
!> Default value: 1
    integer(type_i4) :: numofthreads_ws209 = 1
    
!> Condition number of Jacobi matrix
!> condition_number(1): classical condition number in the infinite-norm
!> condition_number(2): Skeel's condition number
!> In the case of an error return, condition_number is set to zero.
    real(type_r8) :: condition_number(2)
!> Return information of estimating condition number
    integer :: condition_number_info(5)

!> Variables for OpenMP version 
#ifdef OPENMP
    character*72, allocatable :: string_omp(:)
    
    integer(type_i4), allocatable :: maxvol_omp(:)
    real(type_r8),    allocatable :: maxval_omp(:)
    
    integer(type_i4), allocatable :: maxvol_omp2(:)
    real(type_r8),    allocatable :: maxval_omp2(:) 
    
    logical, allocatable :: bflag_omp1(:)
    logical, allocatable :: bflag_omp2(:)
    logical, allocatable :: bflag_omp3(:)
    
#endif

!> Openmp parallel debug variables
#ifdef OPENMP
    integer(type_i8) :: numofloops_thred_mbalrt_1
    integer(type_i8) :: numofloops_thred_mbalrt_2
    integer(type_i8) :: numofloops_thred_mbalrt_3
    integer(type_i8) :: numofloops_thred_mbalrt_4
    integer(type_i8) :: numofloops_thred_mbalrt_5
    integer(type_i8) :: numofloops_thred_mbalrt_6
    integer(type_i8) :: numofloops_thred_mbalrt_7
    integer(type_i8) :: numofloops_thred_mbalrt_8
    integer(type_i8) :: numofloops_thred_mbalrt_9
    integer(type_i8) :: numofloops_thred_mbalrt_10
    integer(type_i8) :: numofloops_thred_mbalrt_11

    integer(type_i8) :: numofloops_thred_msysrt_1
    integer(type_i8) :: numofloops_thred_msysrt_2
    integer(type_i8) :: numofloops_thred_msysrt_3
    integer(type_i8) :: numofloops_thred_msysrt_4
    integer(type_i8) :: numofloops_thred_msysrt_5
    integer(type_i8) :: numofloops_thred_msysrt_6 
    
    integer(type_i8) :: numofloops_thred_mcd_1
    integer(type_i8) :: numofloops_thred_mcd_2
    integer(type_i8) :: numofloops_thred_mcd_3
    
    integer(type_i8) :: numofloops_thred_infcrtdd_1
    integer(type_i8) :: numofloops_thred_infcrtdd_2
    integer(type_i8) :: numofloops_thred_infcrtdd_3
    
    integer(type_i8) :: numofloops_thred_infcrt_a_1
    integer(type_i8) :: numofloops_thred_infcrt_a_2
    integer(type_i8) :: numofloops_thred_infcrt_a_3  
    
    integer(type_i8) :: numofloops_thred_infcrt_g_1
    integer(type_i8) :: numofloops_thred_infcrt_g_2 
    
    integer(type_i8) :: numofloops_thred_infcrt_mcd_1
    integer(type_i8) :: numofloops_thred_infcrt_mcd_2 
    
    integer(type_i8) :: numofloops_thred_diffcoff_mcd_1
    
    integer(type_i8) :: numofloops_thred_i2upfind_heat_1
        
    integer(type_i8) :: numofloops_thred_i2upfind_1
    
    integer(type_i8) :: numofloops_thred_ddtds_1
    
    integer(type_i8) :: numofloops_thred_ddtds_energybal_1
    integer(type_i8) :: numofloops_thred_ddtds_energybal_2
    
    integer(type_i8) :: numofloops_thred_comp_bc_ice_1
    integer(type_i8) :: numofloops_thred_comp_bc_ice_2
    
    integer(type_i8) :: numofloops_thred_timeloop_1
    
    integer(type_i8) :: numofloops_thred_infheat_c_1
    
    integer(type_i8) :: numofloops_thred_infheat_d_1
    
    integer(type_i8) :: numofloops_thred_infevap_1
    
    integer(type_i8) :: numofloops_thred_updatedd_1
    integer(type_i8) :: numofloops_thred_updatedd_2
    
    integer(type_i8) :: numofloops_thred_updatedd_ener_1    
    integer(type_i8) :: numofloops_thred_updatedd_ener_2
    integer(type_i8) :: numofloops_thred_updatedd_ener_3
    
    integer(type_i8) :: numofloops_thred_ddvsflow_1
    
    integer(type_i8) :: numofloops_thred_seepfdd_1
    
    integer(type_i8) :: numofloops_thred_tstepvs_1
    
    integer(type_i8) :: numofloops_thred_updatevs_1
    integer(type_i8) :: numofloops_thred_updatevs_2
    
    integer(type_i8) :: numofloops_thred_seepface_1    
    
    integer(type_i8) :: numofloops_thred_soilparm_1
    
    integer(type_i8) :: numofloops_thred_msysdd_1
    integer(type_i8) :: numofloops_thred_msysdd_2
    integer(type_i8) :: numofloops_thred_msysdd_3
    
    integer(type_i8) :: numofloops_thred_msysvs_1
    
    integer(type_i8) :: numofloops_thred_mbalvs_1
    integer(type_i8) :: numofloops_thred_mbalvs_2
    integer(type_i8) :: numofloops_thred_mbalvs_3
    
    integer(type_i8) :: numofloops_thred_energysys_1
    
    integer(type_i8) :: numofloops_thred_energy_bal_1
    integer(type_i8) :: numofloops_thred_energy_bal_2
    
    integer(type_i8) :: numofloops_thred_velodd_1
    
    integer(type_i8) :: numofloops_thred_nexttime_1
    integer(type_i8) :: numofloops_thred_nexttime_2
    
    integer(type_i8) :: numofloops_thred_infcvs_1
    
    integer(type_i8) :: numofloops_thred_xyzcoord_1
    
    integer(type_i8) :: numofloops_thred_cvolume_1

    integer(type_i8) :: numofloops_thred_iajavs_1
    integer(type_i8) :: numofloops_thred_iajavs_2
    
    integer(type_i8) :: numofloops_thred_iajavs_dp_1
    
    integer(type_i8) :: numofloops_thred_iajavs_ener_1
    integer(type_i8) :: numofloops_thred_iajavs_ener_2
    
    integer(type_i8) :: numofloops_thred_matrix_uti_1
    
    integer(type_i8) :: numofloops_thred_initpppm_1
    
    integer(type_i8) :: numofloops_thred_initppvs_1    
    integer(type_i8) :: numofloops_thred_initppvs_2
    
    integer(type_i8) :: numofloops_thred_initppdd_1
    
    integer(type_i8) :: numofloops_thred_initppeb_1
    integer(type_i8) :: numofloops_thred_initppeb_2
    
    integer(type_i8) :: numofloops_thred_initicvs_1
    
    integer(type_i8) :: numofloops_thred_initsatw_1
    integer(type_i8) :: numofloops_thred_initsatw_2
    integer(type_i8) :: numofloops_thred_initsatw_3
    
    integer(type_i8) :: numofloops_thred_initicener_1
    
    integer(type_i8) :: numofloops_thred_initprob_1
    integer(type_i8) :: numofloops_thred_initprob_2
    
    integer(type_i8) :: numofloops_thred_initicrt_1
    
    integer(type_i8) :: numofloops_thred_initicdd_1
    
    integer(type_i8) :: numofloops_thred_restart_1
    
    integer(type_i8) :: numofloops_thred_batreac_1
    integer(type_i8) :: numofloops_thred_batreac_2
    
    integer(type_i8) :: numofloops_thred_intpolt
    
    integer(type_i8) :: numofloops_thred_mbaldd_1
    integer(type_i8) :: numofloops_thred_mbaldd_2
    integer(type_i8) :: numofloops_thred_mbaldd_3
    integer(type_i8) :: numofloops_thred_mbaldd_4
    
    integer(type_i8) :: numofloops_thred_gasbub_1
    integer(type_i8) :: numofloops_thred_gasbub_2
    integer(type_i8) :: numofloops_thred_gasbub_3
    integer(type_i8) :: numofloops_thred_gasbub_4
    integer(type_i8) :: numofloops_thred_gasbub_5
    
    integer(type_i8) :: numofloops_thred_rateh2o_1
    
#endif

!>dsu----------------------------------------------------------
!>Parameters for parallel version of min3p, OpenMP
!>dsu----------------------------------------------------------

    logical :: b_use_mpi_nprcs_omp_nthreads
    
    integer*4 :: rank 
    integer*4 :: nprcs
    integer*4 :: nthreads_per_proc
    character(14) :: str_rank

#ifndef PETSC
    integer*4 :: Petsc_Comm_World
    integer*4 :: Petsc_Comm_Self 
    integer*4 :: Petsc_Comm_Group
#endif

    !Variables used for mpi reduce operation
    real(type_r8):: mpireduce_gbl
    real(type_r8), allocatable :: mpireduce_n(:)
    real(type_r8), allocatable :: mpireduce_ng(:)
    real(type_r8), allocatable :: mpireduce_nm(:)
    real(type_r8), allocatable :: mpireduce_naq(:)
    
    
    !>       MIN3P                       MIN3P
    !> Local volume number   to   Global volume number
    !> without ghost nodes 
    !>         (a)                        (b)
    !> ------------------         ------------------
    !> | 4  5  6 | 3  4 |         | 21 22 23| 24 25|
    !> | 1  2  3 | 1  2 |         | 16 17 18| 19 20|
    !> ------------------   <-->  ------------------
    !> | 7  8  9 | 5  6 |         | 11 12 13| 14 15|
    !> | 4  5  6 | 3  4 |         | 6  7  8 | 9  10|
    !> | 1  2  3 | 1  2 |         | 1  2  3 | 4  5 |
    !> ------------------         ------------------
    !>        /\                          /\
    !>        \/                          \/
    !>                    
    !>     MIN3P/PETSc                   PETSc
    !> Local volume number   to   Global volume number
    !> with ghost nodes 
    !>         (c)                        (d)
    !> ------------------         ------------------
    !> | X  X  X | X  X |         | 19 20 21| 24 25|
    !> | 13 14 15| 16 X |         | 16 17 18| 22 23|
    !> ------------------   <-->  ------------------
    !> | 9  10 11| 12 X |         | 7  8  9 | 14 15|
    !> | 5  6  7 | 8  X |         | 4  5  6 | 12 13|
    !> | 1  2  3 | 4  X |         | 1  2  3 | 10 11|
    !> ------------------         ------------------  
    
    !>     MIN3P/PETSc                MIN3P/PETSc
    !> Local volume number        local boundary nodes 
    !> with ghost nodes           without ghost nodes
    !>         (e)                        (f)
    !> ------------------         -----------------
    !> |-1  13 14| 15 16|         | X  X  X | X  X |
    !> |-1  9  10| 11 12|         | X  X  X | X  X |
    !> ------------------         -----------------
    !> |-1  5  6 | 7  8 |         | 9  10 11| X  X |
    !> |-1  1  2 | 3  4 |         | X  X  7 | X  X |
    !> |-1 -1 -1 |-1 -1 |         | X  X  3 | X  X |
    !> ------------------         ------------------
    
    !>       MIN3P
    !> Global volume number
    !> of unstructured mesh
    !> before reordering
    !>         (g)
    !> ------------------
    !> | 13 12 11| 10 9|
    !> | 14 17 20| 19 8|
    !> ------------------
    !> | 15 21 18| 25 7|
    !> | 16 23 24| 22 6|
    !> | 1  2  3 | 4  5|
    !> ------------------

    !> MIN3P local volume number map with ghost nodes to 
    !> MIN3P local volume number map without ghost nodes, (c)->(a)
    !> If the value is -1, this is a ghost value 
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_lg2l(:)
    
    !> MIN3P local volume number map with ghost nodes to 
    !> min3p global node number map, (c)->(b)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_lg2g(:)
   
    !> MIN3P local volume number map with ghost nodes to 
    !> PETSc global volume number map, (c)->(d)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_lg2pg(:)  
    
    !> MIN3P local volume number map without ghost nodes to 
    !> MIN3P local volume number map with ghost nodes, (a)->(c)
    !> Size nn
    integer(type_i4), allocatable :: node_idx_l2lg(:)
    
    !> MIN3P local volume number map with ghost nodes to 
    !> min3p global node number map for velocity output, 
    !> If the value is -1, this is not a valid velocity node.
    !> (c)->(e)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_vel_lg2g(:)

    !> MIN3P local cell number map with ghost cells to
    !> min3p global cell number map, (c)->(b)
    !> Size nngl
    integer(type_i4), allocatable :: cell_idx_lg2g(:)

    !> MIN3P global cell number map to min3p local
    !> cell number map with ghost cells, (b)->(c)
    !> Size ncell_gl
    integer(type_i4), allocatable :: cell_idx_g2lg(:)

    !> MIN3P global node number map to min3p local
    !> node number map with ghost nodes, (b)->(c)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_g2lg(:)

    !> MIN3P unstructured node number map after reodering
    !> to node number map before reordering, (g)->(b)
    integer(type_i4), allocatable :: node_idx_g2g_invord(:)

    !> MIN3P unstructured node number map before reodering
    !> to node number map after reordering, (g)->(b)
    integer(type_i4), allocatable :: node_idx_g2g_lorder(:)

    !> MIN3P local boundary nodes without ghost nodes to
    !> global node number map
    !> Only the local node connected to ghost nodes are set.
    !> (f)->(d)
    !> Size nngl
    !c integer(type_i4), allocatable :: node_idx_lb2pg(:)
    
    !> MIN3P local matrix pointer to global matrix pointer
    !> for flow problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_vs(:)
    integer(type_i4), allocatable :: col_idx_l2pg_vs(:)
    
    !> MIN3P local matrix pointer to global matrix pointer
    !> for density depedent flow problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_glob(:)
    integer(type_i4), allocatable :: col_idx_l2pg_glob(:)

    !> MIN3P local matrix pointer to heat matrix pointer
    !> for heat transport problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_heat(:)
    integer(type_i4), allocatable :: col_idx_l2pg_heat(:)
    
    !> MIN3P local matrix pointer to global matrix pointer
    !> for reactive transport problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_rt(:)
    integer(type_i4), allocatable :: col_idx_l2pg_rt(:)

    
!>dsu----------------------------------------------------------
!> I/O flush control, this is used to flush IO buffer back to file
!> the external flush function may be not compatible with compiler
!> on specific OS.
!>dsu----------------------------------------------------------
    logical :: b_disable_flush

!>dsu----------------------------------------------------------
!> Output spatial output immediately after restart
!>dsu----------------------------------------------------------
    logical :: b_output_restart

!>dsu----------------------------------------------------------
!> output precision in ascii format, by default, single precision is used
!>dsu----------------------------------------------------------
    character*72 :: ascii_fmt
    character*72 :: ascii_fmt_iir

!>dsu----------------------------------------------------------
!>Parameters for binary output of tecplot and paraview data file
!>dsu----------------------------------------------------------
    !> b_output_binary: if true, use binary output, otherwise, use ascii output
    logical :: b_output_binary

    !> b_output_mpiio_single: if true, use parallel mpi I/O to export the result
    !> as a single file from different ranks, otherwise, use parallel mpi I/O to 
    !> export nrank files from different ranks. Only binary output is supported
    !> for mpi I/O single file export.
    logical :: b_output_mpiio_single

    !> b_output_multizone: if true, the binary output will use multizone data format
    !> for spatial output, otherwise, the results of different zones are merged into
    !> one domain. By default, this is false.
    logical :: b_output_multizone
    
    !>
    !> b_output_separate_mesh_result: if true, the mesh data (prefix_domain.h5) and
    !> results data in the hdf5 file are separated, this can save storage space as
    !> these mesh data are the same for all the spatial output as no adaptive mesh
    !> refinement is used. By default, this is false.
    logical :: b_output_separate_mesh_result


    !> b_output_trans_binary: if true, the transient output will be written in binary
    !> format.By default, if 'use binary format' is specified, this value is also true,
    !> otherwise, this value is false. If 'use binary format' is specified and you want
    !> to use ascii data format for the transient output, please add   
    !> 'use ascii data format for transient output' in the output section.
    logical :: b_output_trans_binary
    
    !>
    !> hdf5_compress_level: the compression level, is a value from zero to nine, inclusive.
    !> A compression level of 0 (zero) indicates no compression; compression improves
    !> but speed slows progressively from levels 1 through 9.
    !> HDF5 relies on GNU gzip for this compression
    !> Compression level    Gzip action.
    !> 0                    No compression
    !> 1                    Best compression speed; least compression
    !> 2 through 8          Compression improves; speed degrades
    !> 9                    Best compression ratio; slowest speed
    !> default value is 0 if not specified.
    integer :: hdf5_compress_level

!>dsu----------------------------------------------------------
!>Parameters for binary output of hdf5 data file
!>dsu----------------------------------------------------------

    !> b_init_hdf5_lg2g: if true, use parallel data layout (global/natural ordering) to read hdf5 data
    logical :: b_init_hdf5_lg2g

    !> current global ordering to previous global ordering in hdf5 data layout
    !> used to read data from hdf5 file when number of processors are different between current simulation
    !> and previous simulation.
    integer(type_i4), allocatable :: node_hdf5_lg2g_pre(:)

    !> the default binary output is in double precision. If single precision is 
    !> needed, add 'OUTPUT_SINGLE' to the preprocessor definition.
#ifdef OUTPUT_SINGLE
    integer, parameter :: nfloatbit = 4 
    real*4, allocatable :: realbuffer_hdf(:)
    real*4, allocatable :: realbuffer(:)
    real*4, allocatable :: realbuffer2(:)
    real*4, allocatable :: realbuffer3(:)
    real*4, allocatable :: realbuffer4(:)
    real*4, allocatable :: realbuffer5(:)
    real*4, allocatable :: realbuffer6(:)
    real*4, allocatable :: realbuffer7(:)
    real*4, allocatable :: realbuffer8(:)
    real*4, allocatable :: realbuffer9(:)
    real*4, allocatable :: realbuffer10(:)
    real*4, allocatable :: realbuffer11(:)
    real*4, allocatable :: realbuffer12(:)
    real*4, allocatable :: realbuffer13(:)
    real*4, allocatable :: realbuffer14(:)
    real*4, allocatable :: realbuffer2d(:,:)
    real*4, allocatable :: realbuffer2d_2(:,:)
    real*4              :: realbuffer_gb(1000)
#else
    integer, parameter :: nfloatbit = 8 
    real*8, allocatable :: realbuffer_hdf(:)
    real*8, allocatable :: realbuffer(:)
    real*8, allocatable :: realbuffer2(:)
    real*8, allocatable :: realbuffer3(:)
    real*8, allocatable :: realbuffer4(:)
    real*8, allocatable :: realbuffer5(:)
    real*8, allocatable :: realbuffer6(:)
    real*8, allocatable :: realbuffer7(:)
    real*8, allocatable :: realbuffer8(:)
    real*8, allocatable :: realbuffer9(:)
    real*8, allocatable :: realbuffer10(:)
    real*8, allocatable :: realbuffer11(:)
    real*8, allocatable :: realbuffer12(:)
    real*8, allocatable :: realbuffer13(:)
    real*8, allocatable :: realbuffer14(:)
    real*8, allocatable :: realbuffer15(:)
    real*8, allocatable :: realbuffer2d(:,:)
    real*8, allocatable :: realbuffer2d_2(:,:)
    real*8              :: realbuffer_gb(1000)
#endif

#ifdef USG
    integer, allocatable :: integerbuffer(:)
    integer, allocatable :: integerbuffer_hdf(:)
#endif

!c  file unit for writing transient data (*.gb*)
    integer(type_i4), allocatable :: igbp_mpi(:)
    integer(type_i4), allocatable :: igbt_mpi(:)
    integer(type_i4), allocatable :: igbc_mpi(:)
    integer(type_i4), allocatable :: igbm_mpi(:)
    integer(type_i4), allocatable :: igbgr_mpi(:)
    integer(type_i4), allocatable :: igbg_mpi(:)
    integer(type_i4), allocatable :: igbi_mpi(:)
    integer(type_i4), allocatable :: igbb_mpi(:)
    integer(type_i4), allocatable :: igbs_mpi(:)
    integer(type_i4), allocatable :: igbv_mpi(:)
    integer(type_i4), allocatable :: igbd_mpi(:)
    integer(type_i4), allocatable :: igbx_mpi(:)
    integer(type_i4), allocatable :: igbis_mpi(:)
    integer(type_i4), allocatable :: igbac_mpi(:)
    integer(type_i4), allocatable :: igbmip_mpi(:)
    integer(type_i4), allocatable :: igbroot_mpi(:)
    integer(type_i4), allocatable :: igbre_mpi(:)
    
!c  offset for writing transient data (*.gb*) 
    integer*8, allocatable :: offset_igbp(:)
    integer*8, allocatable :: offset_igbt(:)
    integer*8, allocatable :: offset_igbc(:)
    integer*8, allocatable :: offset_igbm(:)
    integer*8, allocatable :: offset_igbgr(:)
    integer*8, allocatable :: offset_igbg(:)
    integer*8, allocatable :: offset_igbi(:)
    integer*8, allocatable :: offset_igbb(:)
    integer*8, allocatable :: offset_igbs(:)
    integer*8, allocatable :: offset_igbv(:)
    integer*8, allocatable :: offset_igbd(:)
    integer*8, allocatable :: offset_igbx(:)
    integer*8, allocatable :: offset_igbis(:)
    integer*8, allocatable :: offset_igbac(:)
    integer*8, allocatable :: offset_igbmip(:)
    integer*8, allocatable :: offset_igbroot(:)
    integer*8, allocatable :: offset_igbre(:)
    
    integer*8, allocatable :: offset_igbp_ijk(:)
    integer*8, allocatable :: offset_igbt_ijk(:)
    integer*8, allocatable :: offset_igbc_ijk(:)
    integer*8, allocatable :: offset_igbm_ijk(:)
    integer*8, allocatable :: offset_igbgr_ijk(:)
    integer*8, allocatable :: offset_igbg_ijk(:)
    integer*8, allocatable :: offset_igbi_ijk(:)
    integer*8, allocatable :: offset_igbb_ijk(:)
    integer*8, allocatable :: offset_igbs_ijk(:)
    integer*8, allocatable :: offset_igbv_ijk(:)
    integer*8, allocatable :: offset_igbd_ijk(:)
    integer*8, allocatable :: offset_igbx_ijk(:)
    integer*8, allocatable :: offset_igbis_ijk(:)
    integer*8, allocatable :: offset_igbac_ijk(:)
    integer*8, allocatable :: offset_igbre_ijk(:)
    
!c  file unit for writing transient data (*.gfvel, *.gcvel) 
    integer(type_i4), allocatable :: igfvel(:)
    integer(type_i4), allocatable :: igcvel(:,:)
    
!c  offset for writing transient data (*.gfvel, *.gcvel) 
    integer*8, allocatable :: offset_igfvel(:)
    integer*8, allocatable :: offset_igfvel_ijk(:)
    
    integer*8, allocatable :: offset_igcvel(:,:)
    integer*8, allocatable :: offset_igcvel_temp(:,:)
    integer*8, allocatable :: offset_igcvel_ijk(:,:)
    
!c  file unit for writing transient data e.g., 
!c  .mas, .mss, .mgs, .mss, .mms, .mac, .mae, .msc, .mic, .mgc, .mmc, idx
    integer(type_i4), allocatable :: imrt_mpi(:)
    integer(type_i4), allocatable :: imvs_mpi(:)
    integer(type_i4), allocatable :: imcd_mpi(:)

    integer(type_i4)              :: idix_mpi
    integer(type_i4)              :: ispm_mpi
   
!c  offset for writing transient data e.g., 
!c  .mas, .mss, .mgs, .mss, .mms, .mac, .mae, .msc, .mic, .mgc, .mmc, idx
    integer*8, allocatable :: offset_imrt(:)
    integer*8, allocatable :: offset_imrt_ijk(:)
    integer*8, allocatable :: offset_imvs(:)
    integer*8, allocatable :: offset_imvs_ijk(:)
    integer*8, allocatable :: offset_imcd(:)
    integer*8, allocatable :: offset_imcd_ijk(:)

    integer*8              :: offset_idix
    integer*8              :: offset_idix_ijk

    integer*8              :: offset_ispm
    integer*8              :: offset_ispm_ijk

!c  root respiration and uptake, _o.resp
    integer(type_i4) :: iresp_mpi

!c  offset for writing transient data e.g., _o.resp
    integer*8 :: offset_iresp
    integer*8 :: offset_iresp_ijk

!c  root respiration and uptake, _o.rup
    integer(type_i4) :: irup_mpi
    integer(type_i4) :: irupcm_mpi

!c  offset for writing transient data e.g., _o.rup
    integer*8 :: offset_irup
    integer*8 :: offset_irup_ijk
    integer*8 :: offset_irupcm
    integer*8 :: offset_irupcm_ijk
    
!c  variables for MPI_TYPE_CREATE_SUBARRAY
!c  these variables are used for binary output only.  

    integer*4 :: mpiarray_ndim
    integer*4 :: mpiarray_filetype
    integer*4 :: mpiarray_filetype_vel
    
    integer*4 :: mpiarray_sizes_gbl(3)
    integer*4 :: mpiarray_sizes_sub(3)
    integer*4 :: mpiarray_starts_sub(3)
    
    integer*4 :: mpiarray_sizes_vel_gbl(3)
    integer*4 :: mpiarray_sizes_vel_sub(3)
    integer*4 :: mpiarray_starts_vel_sub(3)

    logical   :: b_mpiarray_igsp_init = .false.
    integer*4 :: mpiarray_filetype_igsp
    integer*4 :: mpiarray_sizes_gbl_igsp(3)
    integer*4 :: mpiarray_sizes_sub_igsp(3)
    integer*4 :: mpiarray_starts_sub_igsp(3)

    logical   :: b_mpiarray_igsmech_init = .false.
    integer*4 :: mpiarray_filetype_igsmech
    integer*4 :: mpiarray_sizes_gbl_igsmech(3)
    integer*4 :: mpiarray_sizes_sub_igsmech(3)
    integer*4 :: mpiarray_starts_sub_igsmech(3)
    
    logical   :: b_mpiarray_ihyc_init = .false.
    integer*4 :: mpiarray_filetype_ihyc
    integer*4 :: mpiarray_sizes_gbl_ihyc(3)
    integer*4 :: mpiarray_sizes_sub_ihyc(3)
    integer*4 :: mpiarray_starts_sub_ihyc(3)
    
    logical   :: b_mpiarray_idens_init = .false.
    integer*4 :: mpiarray_filetype_idens
    integer*4 :: mpiarray_sizes_gbl_idens(3)
    integer*4 :: mpiarray_sizes_sub_idens(3)
    integer*4 :: mpiarray_starts_sub_idens(3)

    logical   :: b_mpiarray_iaqt_init = .false.
    integer*4 :: mpiarray_filetype_iaqt
    integer*4 :: mpiarray_sizes_gbl_iaqt(3)
    integer*4 :: mpiarray_sizes_sub_iaqt(3)
    integer*4 :: mpiarray_starts_sub_iaqt(3)

    logical   :: b_mpiarray_igst_init = .false.
    integer*4 :: mpiarray_filetype_igst
    integer*4 :: mpiarray_sizes_gbl_igst(3)
    integer*4 :: mpiarray_sizes_sub_igst(3)
    integer*4 :: mpiarray_starts_sub_igst(3)

    logical   :: b_mpiarray_icbt_init = .false.
    integer*4 :: mpiarray_filetype_icbt
    integer*4 :: mpiarray_sizes_gbl_icbt(3)
    integer*4 :: mpiarray_sizes_sub_icbt(3)
    integer*4 :: mpiarray_starts_sub_icbt(3)

    logical   :: b_mpiarray_igmf_init = .false.
    integer*4 :: mpiarray_filetype_igmf
    integer*4 :: mpiarray_sizes_gbl_igmf(3)
    integer*4 :: mpiarray_sizes_sub_igmf(3)
    integer*4 :: mpiarray_starts_sub_igmf(3)

    logical   :: b_mpiarray_igsre_init = .false.
    integer*4 :: mpiarray_filetype_igsre
    integer*4 :: mpiarray_sizes_gbl_igsre(3)
    integer*4 :: mpiarray_sizes_sub_igsre(3)
    integer*4 :: mpiarray_starts_sub_igsre(3)
    
    logical   :: b_mpiarray_igsc_init = .false.
    integer*4 :: mpiarray_filetype_igsc
    integer*4 :: mpiarray_sizes_gbl_igsc(3)
    integer*4 :: mpiarray_sizes_sub_igsc(3)
    integer*4 :: mpiarray_starts_sub_igsc(3)
    
    logical   :: b_mpiarray_igsac_init = .false.
    integer*4 :: mpiarray_filetype_igsac
    integer*4 :: mpiarray_sizes_gbl_igsac(3)
    integer*4 :: mpiarray_sizes_sub_igsac(3)
    integer*4 :: mpiarray_starts_sub_igsac(3)

    logical   :: b_mpiarray_igsm_init = .false.
    integer*4 :: mpiarray_filetype_igsm
    integer*4 :: mpiarray_sizes_gbl_igsm(3)
    integer*4 :: mpiarray_sizes_sub_igsm(3)
    integer*4 :: mpiarray_starts_sub_igsm(3)
    
    logical   :: b_mpiarray_igsi_init = .false.
    integer*4 :: mpiarray_filetype_igsi
    integer*4 :: mpiarray_sizes_gbl_igsi(3)
    integer*4 :: mpiarray_sizes_sub_igsi(3)
    integer*4 :: mpiarray_starts_sub_igsi(3)

    logical   :: b_mpiarray_igsg_init = .false.
    integer*4 :: mpiarray_filetype_igsg
    integer*4 :: mpiarray_sizes_gbl_igsg(3)
    integer*4 :: mpiarray_sizes_sub_igsg(3)
    integer*4 :: mpiarray_starts_sub_igsg(3)

    logical   :: b_mpiarray_igs2_init = .false.
    integer*4 :: mpiarray_filetype_igs2
    integer*4 :: mpiarray_sizes_gbl_igs2(3)
    integer*4 :: mpiarray_sizes_sub_igs2(3)
    integer*4 :: mpiarray_starts_sub_igs2(3)

    logical   :: b_mpiarray_igsgr_init = .false.
    integer*4 :: mpiarray_filetype_igsgr
    integer*4 :: mpiarray_sizes_gbl_igsgr(3)
    integer*4 :: mpiarray_sizes_sub_igsgr(3)
    integer*4 :: mpiarray_starts_sub_igsgr(3)

    logical   :: b_mpiarray_igsb_init = .false.
    integer*4 :: mpiarray_filetype_igsb
    integer*4 :: mpiarray_sizes_gbl_igsb(3)
    integer*4 :: mpiarray_sizes_sub_igsb(3)
    integer*4 :: mpiarray_starts_sub_igsb(3)

    logical   :: b_mpiarray_igss_init = .false.
    integer*4 :: mpiarray_filetype_igss
    integer*4 :: mpiarray_sizes_gbl_igss(3)
    integer*4 :: mpiarray_sizes_sub_igss(3)
    integer*4 :: mpiarray_starts_sub_igss(3)

    logical   :: b_mpiarray_igsd_init = .false.
    integer*4 :: mpiarray_filetype_igsd
    integer*4 :: mpiarray_sizes_gbl_igsd(3)
    integer*4 :: mpiarray_sizes_sub_igsd(3)
    integer*4 :: mpiarray_starts_sub_igsd(3)

    logical   :: b_mpiarray_igsv_init = .false.
    integer*4 :: mpiarray_filetype_igsv
    integer*4 :: mpiarray_sizes_gbl_igsv(3)
    integer*4 :: mpiarray_sizes_sub_igsv(3)
    integer*4 :: mpiarray_starts_sub_igsv(3)
    
    logical   :: b_mpiarray_igsx_init = .false.
    integer*4 :: mpiarray_filetype_igsx
    integer*4 :: mpiarray_sizes_gbl_igsx(3)
    integer*4 :: mpiarray_sizes_sub_igsx(3)
    integer*4 :: mpiarray_starts_sub_igsx(3)
    
    logical   :: b_mpiarray_igsis_init = .false.
    integer*4 :: mpiarray_filetype_igsis
    integer*4 :: mpiarray_sizes_gbl_igsis(3)
    integer*4 :: mpiarray_sizes_sub_igsis(3)
    integer*4 :: mpiarray_starts_sub_igsis(3)
    
    logical   :: b_mpiarray_igsw_init = .false.
    integer*4 :: mpiarray_filetype_igsw
    integer*4 :: mpiarray_sizes_gbl_igsw(3)
    integer*4 :: mpiarray_sizes_sub_igsw(3)
    integer*4 :: mpiarray_starts_sub_igsw(3)

    logical   :: b_mpiarray_ivel_init = .false.
    integer*4 :: mpiarray_filetype_ivel
    integer*4 :: mpiarray_sizes_gbl_ivel(3)
    integer*4 :: mpiarray_sizes_sub_ivel(3)
    integer*4 :: mpiarray_starts_sub_ivel(3)

    logical   :: b_mpiarray_ivel_dd_init = .false.
    integer*4 :: mpiarray_filetype_ivel_dd
    integer*4 :: mpiarray_sizes_gbl_ivel_dd(3)
    integer*4 :: mpiarray_sizes_sub_ivel_dd(3)
    integer*4 :: mpiarray_starts_sub_ivel_dd(3)
    
    logical   :: b_mpiarray_igsa2_init = .false.
    integer*4 :: mpiarray_filetype_igsa2
    integer*4 :: mpiarray_sizes_gbl_igsa2(3)
    integer*4 :: mpiarray_sizes_sub_igsa2(3)
    integer*4 :: mpiarray_starts_sub_igsa2(3)

    logical   :: b_mpiarray_igsa_g_init = .false.
    integer*4 :: mpiarray_filetype_igsa_g
    integer*4 :: mpiarray_sizes_gbl_igsa_g(3)
    integer*4 :: mpiarray_sizes_sub_igsa_g(3)
    integer*4 :: mpiarray_starts_sub_igsa_g(3)

    logical   :: b_mpiarray_igsa2_g_init = .false.
    integer*4 :: mpiarray_filetype_igsa2_g
    integer*4 :: mpiarray_sizes_gbl_igsa2_g(3)
    integer*4 :: mpiarray_sizes_sub_igsa2_g(3)
    integer*4 :: mpiarray_starts_sub_igsa2_g(3)
    
    logical   :: b_mpiarray_igsf2_g_init = .false.
    integer*4 :: mpiarray_filetype_igsf2_g
    integer*4 :: mpiarray_sizes_gbl_igsf2_g(3)
    integer*4 :: mpiarray_sizes_sub_igsf2_g(3)
    integer*4 :: mpiarray_starts_sub_igsf2_g(3)

    logical   :: b_mpiarray_igsr_g_init = .false.
    integer*4 :: mpiarray_filetype_igsr_g
    integer*4 :: mpiarray_sizes_gbl_igsr_g(3)
    integer*4 :: mpiarray_sizes_sub_igsr_g(3)
    integer*4 :: mpiarray_starts_sub_igsr_g(3)
    
    logical   :: b_mpiarray_igsy_g_init = .false.
    integer*4 :: mpiarray_filetype_igsy_g
    integer*4 :: mpiarray_sizes_gbl_igsy_g(3)
    integer*4 :: mpiarray_sizes_sub_igsy_g(3)
    integer*4 :: mpiarray_starts_sub_igsy_g(3)

    logical   :: b_mpiarray_igsk_g_init = .false.
    integer*4 :: mpiarray_filetype_igsk_g
    integer*4 :: mpiarray_sizes_gbl_igsk_g(3)
    integer*4 :: mpiarray_sizes_sub_igsk_g(3)
    integer*4 :: mpiarray_starts_sub_igsk_g(3)

    logical   :: b_mpiarray_ihycx_g_init = .false.
    integer*4 :: mpiarray_filetype_ihycx_g
    integer*4 :: mpiarray_sizes_gbl_ihycx_g(3)
    integer*4 :: mpiarray_sizes_sub_ihycx_g(3)
    integer*4 :: mpiarray_starts_sub_ihycx_g(3)
    
    logical   :: b_mpiarray_ivelvap_init = .false.
    integer*4 :: mpiarray_filetype_ivelvap
    integer*4 :: mpiarray_sizes_gbl_ivelvap(3)
    integer*4 :: mpiarray_sizes_sub_ivelvap(3)
    integer*4 :: mpiarray_starts_sub_ivelvap(3)

    logical   :: b_mpiarray_irsrt_init = .false.
    integer*4 :: mpiarray_filetype_irsrt
    integer*4 :: mpiarray_sizes_gbl_irsrt(3)
    integer*4 :: mpiarray_sizes_sub_irsrt(3)
    integer*4 :: mpiarray_starts_sub_irsrt(3)
    
    logical   :: b_mpiarray_igsbub_init = .false.
    integer*4 :: mpiarray_filetype_igsbub
    integer*4 :: mpiarray_sizes_gbl_igsbub(3)
    integer*4 :: mpiarray_sizes_sub_igsbub(3)
    integer*4 :: mpiarray_starts_sub_igsbub(3)
    
    !c
    !c statistics of memory usage, estimated based on arrays, reported for each processor
    !c note, local array that is allocated by does not call deallocate is counted in, but
    !c may overestimatation since system call deallocate implicitly.
    !c
    !c current memory usage for each processor
    integer*8 :: mem_cur

    !c maximum memory usage for each processor
    integer*8 :: mem_max

    !c current total memory usage for master processor
    integer*8 :: mem_cur_tot

    !c maximum total memory usage for master processor
    integer*8 :: mem_max_tot

    !c memory limitation for master processor
    integer*8 :: mem_limit

    !c input unit of memory limitation for master processor
    character(len=2) :: mem_unit

#ifdef MEMORY_MONITOR
#ifdef PETSC
    !c current memory usage for each processor
    real*8 :: mem_petsc_cur

    !c maximum memory usage for each processor
    real*8 :: mem_petsc_max

    !c current total memory usage for master processor
    real*8 :: mem_petsc_cur_tot

    !c maximum total memory usage for master processor
    real*8 :: mem_petsc_max_tot
#endif
#endif

    logical :: b_output_mem_detail
    integer :: ifile_mem

    contains

    !>
    !> calculate memory usage based on given array size
    !>
    subroutine memory_monitor(nbyte,varname,is_collective)
    
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PGI
      integer*4, intent(in) :: nbyte
#else
      integer*8, intent(in) :: nbyte
#endif

      character(len=*), intent(in) :: varname
      logical, intent(in) :: is_collective

      !c local variables
      logical :: bflag, bflag_gbl

#ifdef MEMORY_MONITOR
      !c local variables
      integer :: ierrcode
      character(len=1) :: char_op
#endif

      bflag = .false.
      bflag_gbl = .false.

#ifdef MEMORY_MONITOR
      mem_cur = max(mem_cur + nbyte, 0)

      if (nbyte > 0) then
        mem_max = max(mem_max,mem_cur)
      end if

#ifdef PETSC
      call PetscMemoryGetCurrentUsage(mem_petsc_cur,ierrcode)
      CHKERRQ(ierrcode)

      call PetscMemoryGetMaximumUsage(mem_petsc_max,ierrcode)
      CHKERRQ(ierrcode)

      if (is_collective .and. b_output_mem_detail) then
        !c collective memory usage for all processors
        mem_cur_tot = 0
        call MPI_Allreduce(mem_cur, mem_cur_tot,1,MPI_INTEGER8,MPI_SUM,&
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        mem_max_tot = 0
        call MPI_Allreduce(mem_max, mem_max_tot,1,MPI_INTEGER8,MPI_SUM,&
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        mem_petsc_cur_tot = 0
        call MPI_Allreduce(mem_petsc_cur, mem_petsc_cur_tot,1,           &
                           MPI_REAL8,MPI_SUM,                            &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)

        mem_petsc_max_tot = 0
        call MPI_Allreduce(mem_petsc_max, mem_petsc_max_tot,1,           &
                           MPI_REAL8,MPI_SUM,                            &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
      end if
#else
      mem_cur_tot = mem_cur
      mem_max_tot = mem_max
#endif



      if (rank == 0 .and. b_output_mem_detail) then
        if (nbyte > 0) then
          char_op = '+'
        else
          char_op = '-'
        end if

        if (nprcs > 1) then
#ifdef PETSC
          write(ifile_mem,'(2x,a,2x,a22,1x,(e10.3,2x),2(2(e10.3,2x),2(2x,e10.3,2x)))')&
                char_op,varname,nbyte/1.0d0,                           &
                mem_cur/1.0d6,mem_max/1.0d6,                           &
                mem_cur_tot/1.0d6,mem_max_tot/1.0d6,                   &
                mem_petsc_cur/1.0d6,mem_petsc_max/1.0d6,               &
                mem_petsc_cur_tot/1.0d6,mem_petsc_max_tot/1.0d6
#endif
        else
          write(ifile_mem,'(2x,a,2x,a22,1x,3(e10.3,2x),2(2x,e10.3,2x))')&
                char_op,varname,nbyte/1.0d0,                           &
                mem_cur/1.0d6,mem_max/1.0d6,                           &
                mem_cur_tot/1.0d6,mem_max_tot/1.0d6
        end if

      end if

      if (is_collective) then

        if (mem_max/1.0d6 > mem_limit) then 
          bflag = .true.
        end if  
        
#ifdef PETSC
        call MPI_Allreduce(bflag,bflag_gbl,1,MPI_LOGICAL,MPI_LOR,      &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        bflag = bflag_gbl
#endif

        if (bflag) then
          if (rank == 0) then
            write(*,'(2(a,1x,f14.2,1x),a)')                            &
                  'Error: current memory usage',mem_max/1.0d6,         &
                  'MB, maximum memory available',mem_limit*1.0d0,'MB'
            write(ilog,'(2(a,1x,f14.2,1x),a)')                         &
                  'Error: current memory usage',mem_max/1.0d6,         &
                  'MB, maximum memory available',mem_limit*1.0d0,'MB'
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if

#endif

    end subroutine memory_monitor

    end module gen

