!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacfs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacfs
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (fully saturated flow)
!c
!c written by:      Uli Mayer - May 2, 96
!c
!c last modified:   Uli Mayer - December 5, 96
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     + +
!c           bvs(nn)            = rhs vector                          + +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation 
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           uvsinc(nn)         = solution vector (incremented)       * +
!c           vsflux(ncon-1)     = interfacial fluxes                  * +
!c           por_thresh_min     = minimal porosity threshold          + -
!c       
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging              + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties 
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           pore_clogging      = .true.  -> pore clogging model      + -
!c
!c local:    real*8:
!c           -------
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsflux            = derivative of flux term
!c           dvsstor            = derivative of storage term
!c           totvsflux          = total flux into current control
!c                                volume
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (spatial discretization 
!c                                points)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           i1                 = counter (row entries)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           jvol               = row-column pointer
!c           isym               = symmetry pointer
!c
!c external: rhsvs     = assembly of rhs vector 
!c           storfs    = storage function for variably saturated 
!c                       flow 
!c           fluxfs    = flux function for fully saturated flow
!c ----------------------------------------------------------------------
 
      subroutine jacfs 
 
      use parm
      use gen
      
#ifdef OPENMP
      use omp_lib 
#endif 
#ifdef USG
      use math_common
      use geometry
      use gradient_usg, only : gradient_cross_diff,                    &
                               gradient_cross_diff_inc

      use usg_mesh_data, only : num_edge_dvols,cells,                  &
                                num_edge_maxcells
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxfs_usg
#endif
      implicit none
      
      integer :: i1, i2, ivol, icon, idiag, istart, iend, isym, jvol,  &
                 info_debug, ivol_track, ivol_gbl
      
      real*8 :: vsstorinc, vsstor, totvsflux, dtotvsflux, vsfluxinc,   &
                dvsflux, dvsstor
      real*8, external :: storfs, fluxfs
      
      integer :: chunk

      external rhsvs
#ifdef USG
      integer :: icell, icell2, idvol, kvol, ncell, ndvol
      real*8 :: rswitch1
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_flow_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_locs(num_crossdifficv_max),                  &
                     grad_flow_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_flow_inc_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif
 
      real*8, parameter :: r0 = 0.0d0, r2 = 2.0d0, r3 = 3.0d0
      
      if(iter_vs.eq.1) then
        info_debug = -1
        ivol_track = -1
      else
        info_debug = -1
        ivol_track = -1
      end if

#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
        chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
        if(mod(chunk, i_chunksize_factor_flow) > 0) then
          chunk = chunk/i_chunksize_factor_flow + 1
        else
          chunk = chunk/i_chunksize_factor_flow
        end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif 

!c  construct Jacobian matrix
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp i2, icell, idvol, kvol, ncell, ndvol,                       &
    !$omp grad_flow_mids, grad_flow_inc_mids,                         &
    !$omp grad_locs, grad_weights,                                    &
    !$omp flux_flow_hls_corr, grad_flow_hls_loc,                          &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc,                       &
#endif
    !$omp i1, icon, idiag, iend, istart, isym, ivol, jvol,            &
    !$omp ivol_gbl, dvsstor, totvsflux, dtotvsflux, dvsflux,          &
    !$omp vsflux, vsfluxinc, vsstor, vsstorinc)

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 

#endif
      do ivol = 1,nngl               !loop over control volumes
        
        istart = iavs(ivol)          !pointer - start of row
        iend = iavs(ivol+1)-1        !pointer - end of row
        idiag = iavs(ivol)           !pointer - diagonal

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

!c  calculate storage and flux terms for current control volume
        vsstor=r0
        totvsflux = r0               !initialize total influx
        icon = 0                     !counter (connections)

        do i1=istart,iend            !loop over connections

          jvol = javs(i1)            !column pointer
          isym = isymvs(i1)          !symmetry pointer

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

!c  compute storage term (lumped) for current control volume,
!c  only for transient conditions

          if (ivol.eq.jvol) then
            if (transient_flow) then

              vsstor = cvol(ivol)*                                     &
                       storfs(delt,uvsnew(ivol),uvsold(ivol),          &
                              mpropvs(ivol),stor(ivol))

            end if                   !(transient_flow)

!c  compute fluxes between current control volume and adjacent
!c  control volumes

          elseif (ivol.ne.jvol) then

            icon = icon+1            !counter (row entries)

            if (b_use_fixed_flow_vel) then
              
              if (b_use_zero_flow_vel) then
                vsflux(icon) = r0
              else
                !c TBD
              end if
            
            else

#ifdef USG
              if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                grad_flow_mids = vector_zero
                flux_flow_hls_corr = r0

                if (b_use_cross_diffusion_flow) then
                  call gradient_cross_diff(i1,ivol,jvol,uvsnew,        &
                                grad_locs,grad_flow_mids,              &
                                grad_weights,flux_flow_hls_corr,       &
                                grad_flow_hls_loc)
                end if

!cdsu calculate influence coefficient for variable saturated flow
                call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                                             cinfvs_usg_cross_loc)

                vsflux(icon) = -fluxfs_usg(uvsnew(ivol),uvsnew(jvol),                    &
                                  num_edge_dvols,janumcell(i1),                          &
                                  grad_flow_mids(1:num_edge_dvols,1:janumcell(i1)),      &
                                  flux_flow_hls_corr(1:num_edge_dvols,1:janumcell(i1)),       &
                                  cinfvs_usg_loc(1:num_edge_dvols,1:janumcell(i1)),      &
                                  cinfvs_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1)))

#ifdef DEBUG
                if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
                    ivol_track == 0)) then
                  write(idbg,'((a,1x,1pe15.6e3,1x),4(a,1x,i6,1x),2(a,1x,1pe15.6e3,1x))')  &
                         "-->jacfs->vsflux",vsflux(icon),                      &
#ifdef PETSC
                         "ivol",node_idx_lg2g(ivol),"jvol",node_idx_lg2g(jvol),&
#else
                         "ivol",ivol,"jvol",jvol,                              &
#endif
                         "num_edge_dvols",num_edge_dvols,                      &
                         "janumcell(i1)",janumcell(i1),                        &
                         "uvsnew(ivol)",uvsnew(ivol),                          &
                         "uvsnew(jvol)",uvsnew(jvol)
                  do icell = 1, janumcell(i1)
                    do idvol = 1, num_edge_dvols
                      write(idbg,*)                                           &
                            "idvol",idvol,"icell",icell,"grad",               &
                            grad_flow_mids(idvol,icell)%x,                    &
                            grad_flow_mids(idvol,icell)%y,                    &
                            grad_flow_mids(idvol,icell)%z,                    &
                            "flux_flow_hls_corr",flux_flow_hls_corr(idvol,icell),       &
                            "cinfvs_usg",cinfvs_usg_loc(idvol,icell),         &
                            "cinfvs_usg_cross",                               &
                            cinfvs_usg_cross_loc(idvol,icell)%x,              &
                            cinfvs_usg_cross_loc(idvol,icell)%y,              &
                            cinfvs_usg_cross_loc(idvol,icell)%z
                    end do
                  end do

                end if
#endif

              else
#endif
                vsflux(icon) = - fluxfs(uvsnew(ivol),uvsnew(jvol),       &
                                        cinfvs_a(i1))
#ifdef USG
              end if
#endif
            end if


            
!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx   no fluid flux between them
!cdsu fix bug
            !if (pore_clogging) then
            !    if (pornew(ivol) <= por_thresh_min   .or.            &
            !       pornew(jvol) <= por_thresh_min)  then
            !       vsflux(icon) = r0
            !    end if        
            !end if   
       
            totvsflux = totvsflux + vsflux(icon)

          end if                     !(ivol.eq.jvol)/(ivol.ne.jvol)
          
        end do                       !loop over connections
        
!c  assembly of storage and flux terms in rhs vector
!c Anna Harrison added qh2o term Jan 24 2014
        if(water_removal) then
          totvsflux = totvsflux+qh2o(ivol)/delt  
        end if
        call rhsvs(vsstor,totvsflux,bvs(ivol))

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
           write(idbg,'(3(a,1x,1pe15.6e3,1x))')                        &
                 "-->jacfs->rhsvs vsstor", vsstor, "totvsflux",        &
                 totvsflux, "bvs", bvs(ivol)
        end if
#endif

!c  calculate derivatives of storage and flux terms for current
!c  control volume (assembly columnwise)

        uvsinc(ivol) = uvsnew(ivol)+dinc_vs   !increment hydraulic head
        dtotvsflux = r0              !zero derivative (total influx)
        vsstorinc = r0
        icon = 0                     !counter (connections)

        do i1=istart,iend            !loop over connections

          jvol = javs(i1)            !column pointer
          isym = isymvs(i1)          !symmetry pointer

!c  compute storage term with incremented variables (lumped)
!c  for current control volume, only for transient conditions

          if (ivol.eq.jvol) then
            if (transient_flow) then

!c  storage term for current control volume with incremented variables

              vsstorinc = cvol(ivol)*                                  &
                          storfs(delt,uvsinc(ivol),uvsold(ivol),       &
                                 mpropvs(ivol),stor(ivol))

            end if                   !(transient_flow)

!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions

          elseif (ivol.ne.jvol) then

!c  flux with incremented variables and derivative of flux
            icon = icon+1

            if (b_use_fixed_flow_vel) then
              
              if (b_use_zero_flow_vel) then
                vsfluxinc = r0
              else
                !c TBD
              end if
            
            else

#ifdef USG
              if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                grad_flow_inc_mids = vector_zero
                flux_flow_hls_corr = r0

                if (b_use_cross_diffusion_flow) then
                  call gradient_cross_diff_inc(i1,ivol,jvol,dinc_vs,       &
                       uvsnew,grad_locs,grad_flow_inc_mids,grad_weights,   &
                       flux_flow_hls_corr,grad_flow_hls_loc)                  
                end if

!cdsu calculate influence coefficient for variable saturated flow
                call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                                             cinfvs_usg_cross_loc)

                vsfluxinc = -fluxfs_usg(uvsinc(ivol),uvsnew(jvol),                     &
                               num_edge_dvols,janumcell(i1),                           &
                               grad_flow_inc_mids(1:num_edge_dvols,1:janumcell(i1)),   &
                               flux_flow_hls_corr(1:num_edge_dvols,1:janumcell(i1)),   &
                               cinfvs_usg_loc(1:num_edge_dvols,1:janumcell(i1)),       &
                               cinfvs_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1)))

              else
#endif
                vsfluxinc = - fluxfs(uvsinc(ivol),uvsnew(jvol),cinfvs_a(i1))
#ifdef USG
              end if
#endif
            end if


            dvsflux = (vsfluxinc-vsflux(icon))/dinc_vs

!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no fluid flux between them
!cdsu fix bug, comment to avoid setting matrix diag entry to zero
            !if (pore_clogging) then
            !    if (pornew(ivol) <= por_thresh_min   .or.            &
            ! &     pornew(jvol) <= por_thresh_min)  then
            !       dvsflux = r0
            !       vsfluxinc = r0
            !    end if        
            !end if              

            dtotvsflux = dtotvsflux+vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
            
            avs(isym) = avs(isym) - dvsflux      !off-diagonal entries
            
          end if                    !(ivol.eq.jvol)/(ivol.ne.jvol)
        end do                      !loop over connections

!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs       !derivatives
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs

        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  !diagonal entry

      end do                        !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!cdbg
!c     do ivol=1,nngl
!c       istart = iavs(ivol)
!c       iend = iavs(ivol+1)-1
!c       write(idbg,'(8(1pe15.6e3))')(avs(i1),i1=istart,iend),bvs(ivol)
!c     end do
!c     stop
!cdbg

      return
      end
