!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updatedd_energybalance.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updatedd_energybalance
!c -------------------
!c
!c update fluid pressure and check for convergence
!c (density dependent variably saturated flow)
!c compute underrelaxation factor for variably saturated flow
!c update solution vector and secondary variables - check for convergence
!c if relaxation factor is less than one, updates are scaled and the
!c convergence check is based on the scaled updates
!c
!c modified from Sergio Andres Bea Jofre
!c
!c written by:     Sergio Andres Bea Jofre 
!c
!c last modified:   Sergio Andres Bea Jofre 
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   - 
!c
!c common:   
!c gen.f:    real*8:
!c           ------- 
!c           relfacold          = underrelaxation factor              + +
!c                                (old time level)
!c           srelfac_vs         = user specified underrelaxation      + -
!c                                factor
!c           uvs(nn)            = update towards solution-vector      + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           uvslim             = user specified upper limit for      + -
!c                                magnitude of solution update        + -
!c           uvsmaxold          = maximum solution update             + +
!c                                (old time level)
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           ilog               = unit number, log file               + -
!c           nn                 = total number of control volumes     + -
!c           iter_vs            = iteration counter                   + -
!c                                (variably saturated flow)
!c           itsolv             = actual number of solver iterations
!c           idetail_vs         = solver information level            + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   + -
!c                                           factor
!c           not_converged      = .true.  -> continue Newton          + +
!c                                           iteration
!c           under_relax        = .true.  -> underrelaxation          + -
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + -  
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c           r3                 = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c           relfac             = underrelaxation factor
!c           sfac               = intermediate value for 
!c                                computation of relaxation factor
!c           ufac               = intermediate dampening factor
!c           uvsmax             = maximum solution update
!c           uvsabs             = absolute value of solution update
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           maxvol             = control volume with maximum 
!c                                solution update
!c           nexvol             = number of control volumes 
!c                                exceeding update tolerance
!c
!c external: -
!c ----------------------------------------------------------------------

subroutine updatedd_energybalance 

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use dens
      use phys
      use chem
#ifdef USG
      use usg_mesh_data, only : num_cells, cells, num_nodes_per_cell
#endif
#ifdef OPENMP
      use omp_lib
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      real*8 :: uvsmax_gbl,utempmax_gbl
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer*4 :: nexvol_gbl, mpireduce_irank
      PetscErrorCode :: ierrcode
#endif
      
      real*8, parameter :: rhalf = 0.5d0, &
                           r0 = 0.0d0, &
                           r1 = 1.0d0, &
                           r3 = 3.0d0, &
                           r10=10.0d0, &
                           enat = 2.71828182845904509d0, &
                           rkelvin = 273.15d0
      integer, parameter :: iscreen=6
      
      integer :: ivol, izn, tid, i1, ibvs, ibheat, ioutunit
      real*8 :: actw, dummy1, dummy2, dummy3, uabs
      integer :: nexvolpa, nexvoltemp, maxvolpa, maxvoltemp,           &
                 nexvolpa2, nexvoltemp2, tempcorr_it
      real*8 :: uvsmax, utempmax, uheatlim_ln, relfac, sfac, ufac,     &
                relfactemp, sfactemp, ufactemp,                        &
                uvs_updt_max, uvs_updt_delta,                          &
                temp_updt_max, temp_updt_delta, uheatlim_ln_temp
      real*8 :: swr_loc,aentry_loc,spalpha_loc,spbeta_loc,expn_loc,spgamma_loc

      real*8, external :: rhonew, visconew, porosity_flow

      logical :: bflag_goto

#ifdef USG
      integer :: icell
      real*8 :: uvsnew_cell, sanew_cell, sgnew_cell, snnew_cell
#endif


#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      relfac = r0
      relfactemp = r0

      tempcorr_it = 0
      
      if (islogunk_energybal) then
        uheatlim_ln = uheatlim_log * dlog(r10)             
      else
        uheatlim_ln = enat**(uheatlim_log * dlog(r10))
      end if
      
#ifdef STANDARD_FORTRAN
      !By definition, NAN is not equal to anything, even itself.
      if (rnorm /= rnorm .or. over_flow_vs) then
#else
      !isnan is not fortran standard, this is gnu extension.
      if (isnan(rnorm) .or. over_flow_vs) then
#endif
         if(rank == 0 .and. b_enable_output)  then 
           write(ilog,*) 'NAN or over_flow obtained in updatedd_energybalance'
           write(*,*) 'NAN or over_flow obtained in updatedd_energybalance'
         end if
         reduce_timestep=.true.
         return
      end if
      
      uvsmax  = r0
      utempmax = r0 
      if (under_relax) then          !underrelaxation

        if (comp_relax .or. under_relax_range_vs) then
!c  find maximum update to calculate relaxation factor
!c  according to Cooley's method (1983)

#ifdef OPENMP
         maxval_omp = uvsmax
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_updatedd_ener_1)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, tid)                                              
    !$omp do schedule(static)
#endif   

#ifdef OPENMP   
          do ivol = 1,nngl 
       
            tid = omp_get_thread_num()+1  
            if (dabs(uglob(ivol)).gt.dabs(maxval_omp(tid))) then
                maxval_omp(tid) = uglob(ivol)
            end if
          end do
#else
          do ivol = 1,nngl 

            if (dabs(uglob(ivol)).gt.dabs(uvsmax)) then
                uvsmax = uglob(ivol)
            end if
          end do
#endif
 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
          i1 = maxloc(abs(maxval_omp), 1)
          uvsmax = maxval_omp(i1)    
#endif

#ifdef PETSC
          call MPI_Allreduce(uvsmax,uvsmax_gbl,1,MPI_REAL8,MPI_MAX,    &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          uvsmax = uvsmax_gbl
#endif
        end if

        if (comp_relax) then         !compute underelaxation factor

!c  compute underrelaxation factor

          if (iter_glob==1) then                 !first iteration

            relfac = r1

          else                                   !following iterations

            sfac = uvsmax/(uvsmaxold*relfacold)            !step 1

            if (sfac<-r1) then                          !step 2
              relfac = rhalf/dabs(sfac)
            else
              relfac = (r3 + sfac)/(r3 + dabs(sfac))
            endif

          end if

!c  limit to maximum allowed update

          ufac = relfac*dabs(uvsmax)/uvslim                !step 3
          if (ufac>r1) then
            relfac = relfac/ufac
          end if

!c  assign old max. update and relaxation factor for next time step

          uvsmaxold = uvsmax
          relfacold = relfac

        else                      !user specified underelaxtion factor

          if (under_relax_range_vs) then
            if (uvsmax >= srelrange_vs_min .and. uvsmax <= srelrange_vs_max) then
              relfac = srelfac_vs
            else
              relfac = r1
            end if
          else
            relfac = srelfac_vs
          end if

        end if       !comp_relax
      end if         !under_relax
      
      
      if (under_relax_temp) then          !underrelaxation

        if (comp_relax_temp .or. under_relax_range_temp) then
!c  find maximum update to calculate relaxation factor
!c  according to Cooley's method (1983)

#ifdef OPENMP
         maxval_omp2 = utempmax
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_updatedd_ener_1)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, tid)                                              
    !$omp do schedule(static)
#endif   

#ifdef OPENMP   
          do ivol = 1,nngl
            tid = omp_get_thread_num()+1  
            if (dabs(uglob(ivol+nngl)).gt.dabs(maxval_omp2(tid))) then
                maxval_omp2(tid) = uglob(ivol+nngl)
            end if
          end do
#else
          do ivol = 1,nngl 

            if (dabs(uglob(ivol+nngl)).gt.dabs(utempmax)) then
                utempmax = uglob(ivol+nngl)
            end if
          end do
#endif

#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
          i1 = maxloc(abs(maxval_omp2), 1)
          utempmax = maxval_omp2(i1)         
#endif

#ifdef PETSC          
          call MPI_Allreduce(utempmax,utempmax_gbl,1,MPI_REAL8,MPI_MAX,&
                             Petsc_Comm_World,ierrcode) 
          CHKERRQ(ierrcode)
          utempmax = utempmax_gbl
#endif
        end if

        if (comp_relax_temp) then         !compute underelaxation factor

!c  compute underrelaxation factor

          if (iter_glob==1) then                 !first iteration

            relfactemp = r1

          else                                   !following iterations

            sfactemp = utempmax/(utempmaxold*relfactempold)            !step 1

            if (sfactemp<-r1) then                          !step 2
              relfactemp = rhalf/dabs(sfactemp)
            else
              relfactemp = (r3 + sfactemp)/(r3 + dabs(sfactemp))
            endif

          end if

!c  limit to maximum allowed update
          
          ufactemp = relfactemp*dabs(utempmax)/utemplim                !step 3
          if (ufactemp>r1) then
            relfactemp = relfactemp/ufactemp
          end if

!c  assign old max. update and relaxation factor for next time step
          
          utempmaxold = utempmax
          relfactempold = relfactemp

        else                      !user specified underelaxtion factor

          if (under_relax_range_temp) then
            if (utempmax >= srelrange_temp_min .and. utempmax <= srelrange_temp_max) then
              relfactemp = srelfac_temp
            else
              relfactemp = r1
            end if
          else
            relfactemp = srelfac_temp
          end if

        end if       !comp_relax
        
      end if         !under_relax

      
!dsu start of maximum log cycles control
1000  continue  

!c  check size of updates (relaxed/un-relaxed) to determine convergence

    
      nexvolpa=0
      nexvoltemp=0
      nexvolpa2=0
      nexvoltemp2=0
      uvsmax=r0
      utempmax=r0
      maxvolpa=1
      maxvoltemp=1
#ifdef OPENMP
      bflag_omp1 = .false.
      bflag_omp2 = .false.
      bflag_omp3 = .false.  
      maxval_omp = uvsmax
      maxval_omp2 = utempmax
      maxvol_omp = maxvolpa
      maxvol_omp2 = maxvoltemp
#endif 

      bflag_goto = .false.  

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_updatedd_ener_2)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, izn, i1, tid, actw, dummy3, dummy1, dummy2,  &
#ifdef USG
    !$omp icell, uvsnew_cell, sanew_cell, sgnew_cell, snnew_cell,     &
#endif
    !$omp uabs, uheatlim_ln_temp, swr_loc,aentry_loc,spalpha_loc,     &
    !$omp spbeta_loc,expn_loc,spgamma_loc)                            &
    !$omp reduction(+:nexvolpa,nexvoltemp,nexvolpa2,nexvoltemp2)
#endif

#ifdef OPENMP
    !$omp do schedule(static)
#endif 
      do ivol = 1,nngl  
!#ifdef PETSC
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#endif
          
#ifdef OPENMP    
        tid = omp_get_thread_num()+1
#else
        tid = 1
#endif         

#ifdef OPENMP
        if (bflag_omp1(tid).or.bflag_omp2(tid).or.bflag_omp3(tid)) then
          cycle
        end if
#endif
        
        if (under_relax) then                    !underrelaxation
          uglob(ivol) = relfac*uglob(ivol)
        end if
        
        if (under_relax_temp) then                    !underrelaxation
          uglob(ivol+nngl) = relfactemp*uglob(ivol+nngl)
        end if

        ! Update the solution for Pa
        
        if (islogunk_energybal) then          
          uvsnew(ivol) = dlog(uvsnew(ivol)) + uglob(ivol) 
          uvsnew(ivol) = enat**uvsnew(ivol)             
          uabs  = dabs(uglob(ivol)/dlog(r10))            
        else 
          uvsnew(ivol) = uvsnew(ivol) + uglob(ivol) 
          uabs  = dabs(uglob(ivol))        
        end if
        
#ifdef OPENMP
        if (uabs>maxval_omp(tid)) then
          maxval_omp(tid) = uabs                    !max solution update
          maxvol_omp(tid) = ivol                    !location of max update
        endif   
#else
        if (uabs>uvsmax) then
          uvsmax = uabs                             !max solution update
          maxvolpa = ivol                           !location of max update
        endif
#endif
        
        if (uabs>tol_vs) then                       !number of volumes
#ifdef PETSC
          if(node_idx_lg2l(ivol) > 0) then
            nexvolpa = nexvolpa + 1
          end if
#else
          nexvolpa = nexvolpa + 1                   !exceeding convergence
#endif
        end if                                      !tolerance

        if (tran_steady_flow) then
          uvs_updt_max = max(abs(uvsnew(ivol)),abs(uvsold(ivol)))
          if (uvs_updt_max > r0) then
            uvs_updt_delta = abs(uvsnew(ivol)-uvsold(ivol))/delt
            if (uvs_updt_delta > atol_tran_steady_flow .and.           &
                uvs_updt_delta/uvs_updt_max > rtol_tran_steady_flow) then
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
                nexvolpa2 = nexvolpa2 + 1
              end if
#else
              nexvolpa2 = nexvolpa2 + 1             !exceeding convergence
#endif
            end if
          end if
        end if
        
        if (uglob(ivol+nngl)>uheatlim_ln) then
           uglob(ivol+nngl) = uheatlim_ln
        elseif (uglob(ivol+nngl)<-uheatlim_ln) then
           uglob(ivol+nngl) = -uheatlim_ln
        end if
        
        if (islogunk_energybal) then      
            tempnew(ivol) = dlog(tempnew(ivol)) + uglob(ivol+nngl)
            tempnew(ivol) = enat**tempnew(ivol)
            uabs  = dabs(uglob(ivol+nngl)/dlog(r10))              
        else  
            tempnew(ivol) = tempnew(ivol) + uglob(ivol+nngl) 
            uabs  = dabs(uglob(ivol+nngl))        
        end if

        if (tempnew(ivol) < tempcorr_min .or. tempnew(ivol) > tempcorr_max) then

          if (islogunk_energybal) then
            uheatlim_ln_temp = uheatlim_ln*0.5 
          else  
            uheatlim_ln_temp = sqrt(uheatlim_ln)
          end if
          
          if(uheatlim_ln_temp < 1.0d-8) then
#ifdef OPENMP
            bflag_omp1(tid) = .true.
#else
            not_converged = .true.
#endif              
            if (tempnew(ivol) < tempcorr_min) then  
              write(*,*) "reduce timestep: temperature is below correction range, ivol", ivol  
              write(ilog,*) "reduce timestep: temperature is below correction range, ivol", ivol
            else
              write(*,*) "reduce timestep: temperature is above correction range, ivol", ivol  
              write(ilog,*) "reduce timestep: temperature is above correction range, ivol", ivol    
            end if
            
            if(iter_glob >= maxit_glob) then
#ifdef OPENMP
             bflag_omp2(tid) = .true.
#else
             reduce_timestep=.true. 
#ifndef PETSC
             return
#endif
#endif
            end if
           
          else
#ifdef OPENMP
            bflag_omp3(tid) = .true.
#else
            bflag_goto = .true.
#endif
          end if
        end if
       
#ifdef OPENMP
        if (uabs>maxval_omp2(tid)) then
          maxval_omp2(tid) = uabs                 !max solution update
          maxvol_omp2(tid) = ivol                 !location of max update
        endif
#else        
        if (uabs>utempmax) then
          utempmax = uabs                         !max solution update
          maxvoltemp = ivol                       !location of max update
        endif
#endif     
        if (uabs>tol_glob) then                    !number of volumes
#ifdef PETSC
          if(node_idx_lg2l(ivol) > 0) then
            nexvoltemp = nexvoltemp + 1
          end if
#else
          nexvoltemp = nexvoltemp + 1             !exceeding convergence
#endif
        end if

        if (tran_steady_flow) then
          temp_updt_max = max(abs(tempnew(ivol)),abs(tempold(ivol)))
          if (temp_updt_max > r0) then
            temp_updt_delta = abs(tempnew(ivol)-tempold(ivol))/delt
            if (temp_updt_delta > atol_tran_steady_heat .and.          &
                temp_updt_delta/temp_updt_max > rtol_tran_steady_heat) then
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
                nexvoltemp2 = nexvoltemp2 + 1
              end if
#else
              nexvoltemp2 = nexvoltemp2 + 1         !exceeding convergence
#endif
            end if
          end if
        end if

!cprovi----------------------------------------------------------------------------------
!cprovi Update the density according to linear expression or based on Pitzer equations
!cprovi----------------------------------------------------------------------------------        
        if (ispitzerdens) then 
          density(ivol) = rhonew(ref_dens,density_pitzer(ivol),ref_dens,  &
                                 tempnew(ivol),tempref_dens,r1,drho_dt,nonlindens_heat, &
                                 cdens1,cdens2,cdens3,cdens4)
        else
          density(ivol) = rhonew(ref_dens,tds_new(ivol),ref_tds, &
                                 tempnew(ivol),tempref_dens,drho_dc,drho_dt,nonlindens_heat, &
                                 cdens1,cdens2,cdens3,cdens4)
        end if
        
        if (update_viscosity_temp.or.update_viscosity) then
             viscosity(ivol) = visconew(density(ivol),tds_new(ivol),tempnew(ivol),update_viscosity, &
                               update_viscosity_temp,cvisco1,cvisco2,cvisco3,cvisco4,cvisco5, &
                               tempref_dens,iviscomodel,ref_visco,ref_tds,ref_dens) 
        end if  

!cprovi----------------------------------------------------------------------------------
!cprovi Update the porosity as a function of Pa
!cprovi----------------------------------------------------------------------------------        
        if (modify_por(ivol)) then
            pornew(ivol)=porosity_flow(porold(ivol),uvsnew(ivol),uvsold(ivol),stor(ivol), &
                         por_stress_dt(ivol),por_init(ivol),facpormin)   
        end if
       
!cprovi----------------------------------------------------------------------------------
!cprovi Update the soil properties as a function of water pressure
!cprovi Only of variable saturated medium 
!cprovi----------------------------------------------------------------------------------        
        if (variably_saturated) then       
          izn = mpropvs(ivol)
          if (.not. b_disable_sat_updt) then
            if (is_cell_based_relp) then
              if (soilhydrfunc_field) then
                call soilprdd(uvsnew(ivol),sanew(ivol),sgnew(ivol),&
                              dummy1,dummy2,snnew(ivol),&
                              swr_vol(ivol),aentry_vol(ivol),spalpha_vol(ivol), &
                              spbeta_vol(ivol),expn_vol(ivol),spgamma_vol(ivol), &
                              napl_permeability,napl_kfunction,sgr, &
                              isovendrying(izn),beta_ovendry(izn),hm_ovendry(izn), &
                              w0_ovendry(izn),cp0_ovendry(izn),ref_dens,gacc)
              else
                call soilprdd(uvsnew(ivol),sanew(ivol),sgnew(ivol),&
                              dummy1,dummy2,snnew(ivol),&
                              swr(izn),aentry(izn),spalpha(izn), &
                              spbeta(izn),expn(izn),spgamma(izn), &
                              napl_permeability,napl_kfunction,sgr, &
                              isovendrying(izn),beta_ovendry(izn),hm_ovendry(izn), &
                              w0_ovendry(izn),cp0_ovendry(izn),ref_dens,gacc)
              end if
            else
              if (soilhydrfunc_field) then
                call soilprdd(uvsnew(ivol),sanew(ivol),sgnew(ivol),&
                              relperm(ivol),relpermg(ivol),snnew(ivol),&
                              swr_vol(ivol),aentry_vol(ivol),spalpha_vol(ivol), &
                              spbeta_vol(ivol),expn_vol(ivol),spgamma_vol(ivol), &
                              napl_permeability,napl_kfunction,sgr, &
                              isovendrying(izn),beta_ovendry(izn),hm_ovendry(izn), &
                              w0_ovendry(izn),cp0_ovendry(izn),ref_dens,gacc)
              else
                call soilprdd(uvsnew(ivol),sanew(ivol),sgnew(ivol),&
                              relperm(ivol),relpermg(ivol),snnew(ivol),&
                              swr(izn),aentry(izn),spalpha(izn), &
                              spbeta(izn),expn(izn),spgamma(izn), &
                              napl_permeability,napl_kfunction,sgr, &
                              isovendrying(izn),beta_ovendry(izn),hm_ovendry(izn), &
                              w0_ovendry(izn),cp0_ovendry(izn),ref_dens,gacc)
              end if
            end if
          end if
          !cprovi--------------------------------------------------------------------------
          !cprovi Compute the saturated vapour density 
          !cprovi (see Saito et al. (2006) and RETRASO manual
          !cprovi--------------------------------------------------------------------------
          if (evaporation) then             
             if (reactive_transport) then   
                actw = gamma(nc,ivol) 
             else
                actw = r1
             end if
  
  
             if (soilhydrfunc_field) then
               aentry_loc = aentry_vol(ivol)
             else
               aentry_loc = aentry(izn)
             end if
  
             call vapor_prop (densvnew(ivol),dummy1,dummy2,dummy3,latvapnew(ivol), &
                                tempnew(ivol),aentry_loc,uvsnew(ivol), &
                                actw,density(ivol),ivol)
  
          end if 
        end if                       
      
      end do        !loop over control volumes     
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_relp .and.       &
          variably_saturated) then
#ifdef OPENMP
    !$omp do schedule(static)
#endif
        do icell = 1, num_cells
          izn = mpropvs_cell(icell)
          uvsnew_cell = 0.0d0
          sanew_cell = 0.0d0
          sgnew_cell = 0.0d0
          snnew_cell = 0.0d0

          if (soilhydrfunc_field) then
            swr_loc = 0.0d0
            aentry_loc = 0.0d0
            spalpha_loc = 0.0d0
            spbeta_loc = 0.0d0
            expn_loc = 0.0d0
            spgamma_loc = 0.0d0
          end if

          do i1 = 1, num_nodes_per_cell
            ivol = cells(i1,icell)
            uvsnew_cell = uvsnew_cell + uvsnew(ivol)
            sanew_cell = sanew_cell + sanew(ivol)
            sgnew_cell = sgnew_cell + sgnew(ivol)
            snnew_cell = snnew_cell + snnew(ivol)

            if (soilhydrfunc_field) then
              swr_loc = swr_loc + swr_vol(ivol)
              aentry_loc = aentry_loc + aentry_vol(ivol)
              spalpha_loc = spalpha_loc + spalpha_vol(ivol)
              spbeta_loc = spbeta_loc + spbeta_vol(ivol)
              expn_loc = expn_loc + expn_vol(ivol)
              spgamma_loc = spgamma_loc + spgamma_vol(ivol)
            end if
          end do
          uvsnew_cell = uvsnew_cell/num_nodes_per_cell
          sanew_cell = sanew_cell/num_nodes_per_cell
          sgnew_cell = sgnew_cell/num_nodes_per_cell
          snnew_cell = snnew_cell/num_nodes_per_cell

          if (soilhydrfunc_field) then
            swr_loc = swr_loc/num_nodes_per_cell
            aentry_loc = aentry_loc/num_nodes_per_cell
            spalpha_loc = spalpha_loc/num_nodes_per_cell
            spbeta_loc = spbeta_loc/num_nodes_per_cell
            expn_loc = expn_loc/num_nodes_per_cell
            spgamma_loc = spgamma_loc/num_nodes_per_cell
          else
            swr_loc = swr(izn)
            aentry_loc = aentry(izn)
            spalpha_loc = spalpha(izn)
            spbeta_loc = spbeta(izn)
            expn_loc = expn(izn)
            spgamma_loc = spgamma(izn)
          end if

          if (.not. b_disable_sat_updt) then
            call soilprdd(uvsnew_cell,sanew_cell,sgnew_cell,&
                          relperm(icell),relpermg(icell),snnew_cell,&
                          swr_loc,aentry_loc,spalpha_loc, &
                          spbeta_loc,expn_loc,spgamma_loc, &
                          napl_permeability,napl_kfunction,sgr, &
                          isovendrying(izn),beta_ovendry(izn),hm_ovendry(izn), &
                          w0_ovendry(izn),cp0_ovendry(izn),ref_dens,gacc)
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
      end if
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

#ifdef OPENMP
      if (any(bflag_omp1,1) .eqv. .true.) then
        not_converged = .true.
        if (any(bflag_omp2,1) .eqv. .true.) then
          reduce_timestep = .true.  
        end if
      end if
#endif

#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(not_converged, b_mpi_process_flag,1,          &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      not_converged = b_mpi_process_flag
      
      b_mpi_process_flag = .false.
      call MPI_Allreduce(reduce_timestep, b_mpi_process_flag,1,        &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      reduce_timestep = b_mpi_process_flag
#endif

      if (reduce_timestep) then
        return
      end if

#ifdef OPENMP 
      if (any(bflag_omp3,1) .eqv. .true.) then
        bflag_goto = .true.
      end if
#endif


#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(bflag_goto, b_mpi_process_flag,1,             &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      bflag_goto = b_mpi_process_flag    
#endif

      if (bflag_goto) then        
        if (islogunk_energybal) then
          uheatlim_ln = uheatlim_ln*0.5 
        else  
          uheatlim_ln = sqrt(uheatlim_ln)
        end if      

        tempcorr_it = tempcorr_it + 1
        if (tempcorr_it <= tempcorr_maxit) then
          goto 1000
        else
          if (rank == 0 .and. b_enable_output) then
            write(*,'(a,1x,2(a,1x,i6,1x))')                                  &
                  "reduce timestep: temperature correction is out of range", &
                  "current correction",tempcorr_it,                          &
                  "max correction",tempcorr_maxit
            write(ilog,'(a,1x,2(a,1x,i6,1x))')                               &
                  "reduce timestep: temperature correction is out of range", &
                  "current correction",tempcorr_it,                          &
                  "max correction",tempcorr_maxit
          end if
          reduce_timestep = .true.
          return
        end if
      end if

!dsu end of maximum log cycles control

#ifdef OPENMP
    i1 = maxloc(maxval_omp, 1)
    uvsmax = maxval_omp(i1)
    maxvolpa = maxvol_omp(i1)
    
    i1 = maxloc(maxval_omp2, 1)
    utempmax = maxval_omp2(i1)
    maxvoltemp = maxvol_omp2(i1)    
#endif

#ifdef PETSC
      mpireduce_in(1) = uvsmax      !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      uvsmax = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvolpa, 1, MPI_INTEGER4, mpireduce_irank,       &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
      
      
      mpireduce_in(1) = utempmax    !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      utempmax = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvoltemp, 1, MPI_INTEGER4, mpireduce_irank,     &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)

      call MPI_Allreduce(nexvolpa, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,  &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvolpa = nexvol_gbl

      call MPI_Allreduce(nexvoltemp, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,&
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvoltemp = nexvol_gbl

      call MPI_Allreduce(nexvolpa2, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM, &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvolpa2 = nexvol_gbl

      call MPI_Allreduce(nexvoltemp2, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,&
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvoltemp2 = nexvol_gbl
#endif

      if (nexvolpa2 == 0 .and. nexvoltemp2 == 0) then
        tran_steady_flow_converged = .true.
      else
        tran_steady_flow_converged = .false.
      end if
      
      
!cprovi----------------------------------------------------------------------------------
!cprovi If evaporation is solved, update the atmospheric parameters for flow and 
!cprovi energy transport equations 
!cprovi---------------------------------------------------------------------------------- 
!cdsu   confusion here, jacbevap sounds like doing nothing that is necessary,
!cdsu   comment by DSU, 2018-01-28
 

!cprovi----------------------------------------------------------------------------------
!cprovi Write convergence history to screen or log file
!cprovi----------------------------------------------------------------------------------
      
      if (idetail_glob>0) then
       
        if(rank == 0 .and. b_enable_output .and. .not.                 &
           ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
            
          ioutunit = iscreen
            
2000      continue  
       
          if (iter_glob==1.or.idetail_glob==2) then
            if (ioutunit==ilog .or. iter_glob==1) then
              write(ioutunit,*)'------------------------------------------------'
              write(ioutunit,'(a)') ' Newton Iteration Convergence Summary For Flow and Heat Transport:'
              write(ioutunit,*)'------------------------------------------------'
!c disable output of coordinates here since for parallel version, we save local and
!c global node id index instead of coordinates.
!c this part can also be commented because the solver output already includes 
!c the control volume index of maximum update 
!c #ifndef PETSC
!c             write(ioutunit,'(a30)') 'Coordenates maximum update Pa'
!c             write(ioutunit,'(a2,1pe15.6e3,2x,a2,1pe15.6e3,2x,a2,1pe15.6e3)')     &
!c                   'x=',xg(maxvolpa),'y=',yg(maxvolpa),'z=',zg(maxvolpa)
!c             write(ioutunit,*)'------------------------------------------------'
!c             write(ioutunit,'(a32)') 'Coordenates maximum update Temp'
!c             write(ioutunit,'(a2,1pe15.6e3,2x,a2,1pe15.6e3,2x,a2,1pe15.6e3)')     &
!c                   'x=',xg(maxvoltemp),'y=',yg(maxvoltemp),'z=',zg(maxvoltemp)
!c             write(ioutunit,*)                                                &
!c                   '------------------------------------------------'  
!c #endif
              write(ioutunit,'(2a)')                                           &
                    ' Newton      maximum    maximum       ',' solver'
              if (tran_steady_flow) then
                write(ioutunit,'(3a)')                                         &
                      ' iteration   updatePa   updateTemp    residual   ',     &
                      ' iterations   maxvolpa maxvoltemp',                     &
                      '   nexvolpa nexvoltemp  nexvolpa2 nexvoltemp2'
              else
                write(ioutunit,'(3a)')                                         &
                      ' iteration   updatePa   updateTemp    residual   ',     &
                      ' iterations   maxvolpa maxvoltemp',                     &
                      '   nexvolpa nexvoltemp'
              end if
               
            end if
          end if
          
          if (tran_steady_flow) then
            write(ioutunit,'(i6,6x,2(1pe11.4),2x,1e11.4,2x,7(2x,i9))') &
                  iter_glob,uvsmax,utempmax,rnorm,itsolv,maxvolpa,     &
                  maxvoltemp,nexvolpa,nexvoltemp,nexvolpa2,nexvoltemp2
          else
            write(ioutunit,'(i6,6x,2(1pe11.4),2x,1e11.4,2x,5(2x,i9))') &
                  iter_glob,uvsmax,utempmax,rnorm,itsolv,maxvolpa,     &
                  maxvoltemp,nexvolpa,nexvoltemp
          end if          
          
          if(ioutunit == iscreen .and. ioutunit /= ilog) then
            ioutunit = ilog
            goto 2000
          end if
      
        end if
        
      end if

!cdsu  ------------------------------------------------------------------------
!cdsu  save maximum update value in newton iteration to check if iteration is diverged
!cdsu  ------------------------------------------------------------------------
      if (b_check_div_vs) then
        i1 = mod(iter_glob,5)
        if (i1 == 0) then
          i1 = 5
        end if
        div_vs(i1) = abs(uvsmax)
      end if

!cprovi-----------------------------------------------------------------------------------
!cprovi Final convergence check
!cprovi-----------------------------------------------------------------------------------
      if (uvsmax<tol_vs.and.utempmax<tol_glob) then
        not_converged = .false.
      end if

      return
      end
