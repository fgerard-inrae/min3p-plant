!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/mbalrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mbalrt
!c -----------------
!c mass balance (reactive transport)
!c
!c modified for density dependent flow
!c
!c written by:      Uli Mayer - September 5, 96
!c
!c last modified:   Uli Mayer - July 26, 01
!c                  Uli Mayer - November 12, 01
!c                  added new database format
!c                  for dissolution-precipitation reactions
!c
!c                  Tom Henderson - October 24, 2002
!c                  Sergi Molins - May 2, 2006
!c                  added gas advection and multi-component diffusion
!c                  still to add multi-comp diff for individual gas species
!c                  Sergi Molins - May 24,2006
!c                  press+temp dependence of diff coeff
!c                  Sergi Molins - June 12, 2006
!c                  fixed bug: rverysmall
!c
!c                  Danyang Su - March 27, 2014
!c                  Add gas advection, modified from Sergi Molins's codes.
!c                  Need further check on some variables, e.g., totgflux,
!c                  different index, ig and/or ic, has been passed to the same array
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   - 
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third and mixed 
!c                                type b.c.       -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (gaseous phase)
!c                                third and mixed 
!c                                type b.c.       -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for + -
!c                                diffusive mass fluxes across
!c                                boundary (excluding diffusion 
!c                                coefficient)
!c           cinfrt_da(njavs)   = influence coefficients              + -
!c                                (dispersion - aqueous phase)
!c           cinfrt_va(njavs)   = influence coefficients              + -
!c                                (advection - aqueous phase)
!c           hhead(nn)          = hydraulic head                      + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species
!c           gbrt(ng,nbrt)      = gas concentrations in boundary      + -
!c                                control volumes
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           gold(ng,nn)        = gas concentrations                  + -
!c                                - old time level [moles / l air]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           cmold(nm,nn)       = mineral concentrations              + -
!c                                - old time level [moles/l bulk]]
!c           cculabsbal(n)      = accumulative absolute mass balance  + +
!c                                error for dissolved species 
!c                                [moles/elapsed time]
!c           cmculabsbal(n)     = accumulative absolute mass balance  + +
!c                                error for minerals 
!c                                [moles/elapsed time]
!c           cculrelbal(n)      = accumulative relative mass balance  + +
!c                                error for dissolved species [%]
!c           cmculrelbal(n)     = accumulative relative mass balance  + +
!c                                for minerals [%]
!c           gculabsbal(ng)     = accumulative absolute mass balance  + +
!c                                error for gaseous species
!c                                [moles/elapsed time]
!c           gculrelbal(ng)     = accumulative relative mass balance  + +
!c                                error for gaseous species [%]
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = current time step                   + -
!c           dpdiff(nc+nm-1)    = source-sink term due to phase       * * 
!c                                exchange with minerals 
!c           dpdiffp(ndr*nm)    = individual source-sink terms due    * *
!c                                to parallel dissolution-
!c                                precipitation reactions
!c           cfluxin(n)         = mass gain due to inflow in water    * *
!c                                phase in terms of total aqueous
!c                                component concentrations
!c           cfluxout(n)        = mass loss due to outflow in water   * *
!c                                phase in terms of total aqueous
!c                                component concentrations
!c           contaqtot(naq)     = contribution of intra-aqueous       + +
!c                                kinetic reactions to mass balance
!c                                [moles/elapsed time]
!c           contmintot(nm)     = contribution of dissolution-        + +
!c                                precipitation reactions to mass
!c                                balance [moles/elapsed time]
!c           gfluxtbdy(ng)      = mass flux across boundary           * *
!c                                (gaseous phase)
!c           gfluxin(n)         = mass gain due to inflow in air      * *
!c                                phase in terms of total gaseous
!c                                component concentrations
!c           gfluxout(n)        = mass loss due to outflow in air     * *
!c                                phase in terms of total gaseous
!c                                component concentrations
!c           ordiff(n)          = global source-sink term due to      * *
!c                                oxidation-reduction reactions
!c           intradiff(n)       = global source-sink term due to      * *
!c                                intra-aqueous kinetic reactions
!c           pornew(nn)         = porosity                            + -
!c           ratemdp(nm,nn)     = absolute dissolution-precipitation  + -
!c                                rates of minerals
!c           cstordiff(nc+nm-1) = change in storage in terms of total * *
!c                                aqueous component concentrations
!c           gdegas(n)          = mass loss from aqueous phase due to * *
!c                                degassing 
!c           gstordiff(n)       = change in storage in terms of total * *
!c                                gaseous component concentrations
!c           phi(nm,nn)         = volume fractions of minerals        + -
!c           phiold(nm,nn)      = volume fractions of minerals        + -
!c                                (old time level)
!c           rateaqtot(naq)     = total rate of intra-aqueous kinetic * * 
!c                                reaction in solution domain
!c                                [moles/day]
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           sbdiff(n)          = source-sink term due to phase       * *
!c                                exchange with sorbed phase
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            + -
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             + +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c
!c           totcnew(nc-1,nn)   = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totcold(nc-1,nn)   = total aqueous component             + -
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgnew(nc-1,nn)   = total gaseous component             + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totgold(nc,nn)      = total gaseous component            + -
!c                                concentrations
!c                                - old time level [moles/l air]
!c           tmass(n)           = total mass in aqueous and gaseous   + -
!c                                phase in terms of total component
!c                                concentrations [moles] 
!c           time_io            = current solution time (I/O units)   + -
!c           totmdp(nc-1,nn)    = total source/sink term towards      + -
!c                                total aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c           totcflux(n)        = total mass fluxes (aqueous phase)   * *
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * *
!c           totsold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              + -
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              + -
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           totcfluxin(nc)     = total mass gain due to inflow in    + +
!c                                auqueous phase in terms of total
!c                                aqueous component concentrations
!c           totcfluxout(nc)    = total mass loss due to inflow in    + +
!c                                aqueous phase in terms of total
!c                                aqueous component concentrations
!c           totcstordiff(nc)   = total change in storage in          + +
!c                                aqueous phase in terms of total
!c                                aqueous component concentrations
!c           totordiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to oxidation/reduction
!c                                reactions
!c           totintradiff(nc)   = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to intra-aqueous kinetic 
!c                                reactions
!c           totdpdiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to dissolution-precipitation 
!c                                reactions
!c           totdpdiffp(ndr*nm) = individual contribution of parallel + +
!c                                reaction pathways of dissolution-
!c                                precipitation reactions to mass
!c                                balance [moles/elapsed time]
!c           totgdegas(nc)      = total mass loss from aquoeus phase  + +
!c                                due to degassing
!c           totgdiff(nc)       = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to gas dissolution-esolution
!c                                reactions
!c           totgfluxin(nc)     = total mass gain due to inflow in    + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totgfluxout(nc)    = total mass loss due to inflow in    + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totgstordiff(nc)   = total change in storage in          + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totsbdiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to sorption or ion-exchange
!c                                reactions
!c
!c           added for gas advection and multi-component diffusion
!c
!c           deltaij(njavs)     = distance between i-j                + -
!c           gmfrac(1,ivol)     = gas molar fractions at c.v. i       * +
!c           gporij(njavs)      = gas filled porosity                 + -
!c           relpermg(ivol)     = relative permeability (gas phase)   * +
!c           tauij(njavs)       = tortuosity (gas phase)              + -
!c
!c           character:
!c           ----------
!c           iupsg(i1)          = upstream node for weighting         + -
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        + -
!c
!c           integer*4:
!c           ----------
!c           i2up(nn)           = pointer array to second upstream    + -
!c                                point
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           idbg               = unit number - debugging file        + -
!c           imrt               = unit number, mass balance -         + -
!c                                             reactive transport
!c           jabrt(nbrt)        = pointer array - boundary conditions + -
!c                                (reactive transport)
!c           l_time_unit        = length of time unit for output      + -
!c           m_time             = current time step                   + -
!c           nbrt               = number of specified boundary        + -
!c                                control volumes
!c           nn                 = total number of control volumes     + -
!c
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (specified dispersive flux, 
!c                                            free mass outflux for aqueous
!c                                            phase, free exit)
!c                                'third'  = Cauchy
!c                                           (specified dispersive and advective flux, 
!c                                            for aqueous phase)
!c                                'third-evap'
!c                                         = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase, for outflux,
!c                                            use closed boundary for transport,
!c                                            like evaporation)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c                            'mixed-evap' = mixed-evap
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and gaseous phase,
!c                                            for outflux, use closed boundary
!c                                            for transport for aqueous phase,
!c                                            like evaporation)
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c
!c chem.f:   real*8:
!c           -------
!c           acth2omin          = min. activity for h2o               + -
!c           adav               = coefficient for Davies equation     + -
!c           bdav               = coefficient for Davies equation     + -
!c           dhac(nc)           = debye-huckel a for free species     + -
!c           dhad(nthreads)     = Debye Huckel constant a_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhax(nx)           = debye-huckel a for secondary        + -
!c                                aqueous species
!c           dhbc(nc)           = debye-huckel b for free species     + -
!c           dhbd(nthreads)     = Debye Huckel constant b_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhbx(nx)           = debye-huckel b for secondary        + -
!c                                aqueous species
!c           rateaq(naq,nthreads)
!c                              = reaction rates of intra-aqueous     * *
!c                                kinetic reaction
!c           rateg(ng,nthreads) = degassing rates                     * *
!c           rateor(nr,nthreads)= oxidation-reduction rate for        * *
!c                                redox couple [moles/(l h2o*day)
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           totaq(nc-1,nthreads)
!c                              = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           totor(nc-1)        = total source/sink term towards      * *
!c                                aqueous component concentrations
!c                                due to oxidation-reduction
!c                                reactions [moles/(l bulk*day)]
!c           totrateg(nc-1)     = total rate for removal of aqueous   * *
!c                                components due to degassing
!c                                [mol L^-1 s^-1]
!c
!c           logical:
!c           --------
!c           gas_removal        = .true.  -> degassing of dissolved   + -
!c                                           gases, if confining
!c                                           pressure exceeded
!c           new_database       = .true.  -> use new database format  + -
!c           noncompetitive_sorption = logical array for activation   + -  
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           integer*4:
!c           ----------
!c           l_namec(nc)        = length of component names           + -
!c           naq                = number of intra-aqueous kinetic     + -
!c                                reactions
!c           nc                 = number of components                + -
!c           nx                 = number of secondary species         + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           nameaq(naq)        = names of intra-aqueous kinetic      + -
!c                                reactions
!c           namec(nc)          = component names                     + -
!c           namem(nm)          = mineral names                       + -
!c           sorption_group     = 'ion-exchange'
!c                                'surface-complexation'
!c                                'undefined'
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c dens.f:   logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c           absbalance         = absolute mass balance in 
!c                                [moles/timestep]
!c           bdyinfrt_da        = boundary influence coefficient 
!c                                for diffusive mass flux (aqueous
!c                                phase)
!c           bdyinfrt_dg        = boundary influence coefficient 
!c                                for diffusive mass flux (gaseous
!c                                phase)
!c           conv3              = conversion factor [l/m^3]
!c           diff_eff           = effective diffusion coefficient
!c           r0                 = constant
!c           r100               = constant
!c           relbalance         = relative mass balance in %
!c           totvsflux          = total water flux across boundary
!c
!c           added for gas transport:
!c
!c           densgij            = gas density at interface i-j
!c           dgm_gflux(nc)      = diffusive gas flux of total         * +
!c                                components (as computed w/ DGM) 
!c           dgm_gflux_s(ng)    = diffusive gas flux of gas species   * +
!c                                (as computed w/ DGM) 
!c           fmat(ng,ncon)      = right hand side DGM system          * +
!c           gacc               = gravity                             + -
!c           gafluxin(nc)       = advective in-flux                   * +
!c           gafluxout(nc)      = advective out-flux                  * +
!c           gdens(nn)          = gas density at control volume i     * +
!c           gij                = gas concentration at i-j            * +
!c           gmfracij           = gas molar fractions at i-j          * +
!c           gpivol(nn)         = gas pressure at control volume i    * +
!c           gvisc(ivol)        = gas viscosity at control vol i      * +
!c           ludecomp(ng,ng,ncon) = LU decomp of matrix of DGM system * +
!c           ms_gflux(nc)       = total diffusive flux                * +
!c                                (as computed with Stefan-Maxwell)
!c           ms_gflux_s(ng)     = diffusive flux of gas species       * +
!c                                (as computed with Stefan-Maxwell)
!c           neflux(nc)         = non-equimolar flux for multi-comp   * +
!c                                diffusion
!c           neflux_s(ng)       = non-equimolar flux of gas species   * +
!c                                in multi-comp diffusion 
!c           relpgij            = relative perm (gas) at i-j          * +
!c           totgafluxin(nc)    = total advective in-flux             * + 
!c           totgafluxout(nc)   = total advective out-flux            * + 
!c           totgij             = total gas concentrations of         * +
!c                                components at interface i-j         * +
!c           viscgij            = gas viscosity at interface i-j      * +
!c
!c           character:
!c           ----------
!c           spt_weight         = spatial weighting for gas transp    * +
!c
!c
!c           integer*4:
!c           ----------
!c           iaq                = counter (intra-aqueous kinetic
!c                                         reactions)
!c           ibrt               = counter (source control volumes)
!c           ic                 = counter (components)
!c           im                 = counter (minerals)
!c           ir                 = counter (redox couples)
!c           ivol               = counter (control volumes)
!c
!c external: acoff     = compute activity coefficient
!c           bdryflux  = compute water flux across boundary control 
!c                       volumes
!c           ddbdflux  = compute water flux across boundary control 
!c                       volumes - density dependent flow
!c           bulkconc  = convert from [moles/l water] to
!c                       [moles/l bulk]
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           diffcoff  = compute effective diffusion coefficient
!c           fluxv     = advective flux
!c           fluxd     = diffusive/dispersive flux
!c           molconc   = compute average molar concentration for
!c                       organic mixture
!c           msysrt    = compute total system mass (reactive 
!c                       transport) 
!c           rategas   = compute degassing rates
!c           rategasd  = compute degassing rates for density
!c                       dependent flow
!c           rateint   = compute rate for intra-aqueous kinetic
!c                       reactions
!c           rateint_new   = compute rate for intra-aqueous kinetic
!c                       reactions (new database format)
!c           ratemin   = compute dissolution-precipitation
!c                       rate for mineral phase
!c           ratemin_new   = compute dissolution-precipitation
!c                       rate for mineral phase (new database format)
!c           rateredx  = compute total oxidation-reduction rates 
!c                       for redox couples 
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totint    = compute total source-sink terms towards
!c                       total aqueous component concentrations
!c                       due to intra-aqueous reactions
!c           totredx   = compute total source/sink term towards total 
!c                       aqueous component concentrations due to
!c                       oxidation-reduction reactions or derivative 
!c                       thereof
!c           zero_r8   = clear real*8 array
!c
!c           dgm_fluxdg   = compute total gas diffusive fluxes using
!c                          the Dusty Gas Model
!c           dgm_fluxdg_s = compute diffusive fluxes of gas species 
!c                          using the Dusty Gas Model        
!c           gasdiff2     = compute gas diffusion coeff for components 
!c                          with LeBlanc's approx
!c           gasdiff2_s   = compute gas diffusion coeff for species
!c                          with LeBlanc's approx
!c           ms_fluxdg    = compute total gas diffusive fluxes using
!c                          the Stefan-Maxwell equations
!c           ms_fluxdg_s  = compute diffusive fluxes of gas species 
!c                          using the Stefan-Maxwell equations
!c           wgprop    = weighting for gas transport properties
!c
!c ----------------------------------------------------------------------
  
      subroutine mbalrt
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use phys
      use chem
      use dens
      use bbls
      use dgml
      use writeversion 
      use file_utility, only : reposition_file
      use mod_diffcoff, only : diffcoff
      use multidiff, only: cinfrt_mcd
      use nobleGasIngrowth
      use biol

#ifdef USG
      use math_common
      use geometry
      use mod_fluxd_usg
      use usg_mesh_data, only : num_edge_dvols,num_edge_maxcells,      &
                                node_cells, node_num_cells,            &
                                num_nodes_per_cell
      use gradient_usg, only : gradient_cross_diff_rt,                 &
                               gradient_cross_diff_md,                 &
                               gradient_cross_diff_rt_average
      use usg_face_utility, only : usg_face_utility_cinfvs,            &
                                   usg_face_utility_cinfrt_da,         &
                                   usg_face_utility_cinfrt_da_ic,      &
                                   usg_face_utility_cinfrt_dg,         &
                                   usg_face_utility_cinfrt_mcd
#endif

#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize, petsc_mpi_barrier
#endif

      use module_binary_mpiio, only : binary_write_data
      
      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif
      
      integer :: ierr, ivol, ibrt, istart ,iend, ic, i1, i2, ibvs, izn,&
                 ix, ir, iaq, imb, ig, im, istop, ireac, jvol, irecord,&
                 idim, ivar, ircm, ntemp, im2, izn_c, ingi
      
      real*8 :: absbalance, area_ivol, totvsflux, diff_eff, diff_loc,  &
                bdyinfrt_da, bdyinfrt_dg, fluxvg, gasp_m, gasd_m,      &
                gasv, relbalance, totwflux_atm, tothflux_atm

      real*8, external :: acoff, bulkconc, bdryflux, ddbdflux,         &
              fluxv_vl, fluxd, diffcoff_g, gasdiff2, gasdiff2_s

      !c local variables to store mass through specified boundary
      !c note, assume n > ng so that tmsb_g* variables are shared for
      !c both aqueous phase and gas phase
      integer :: itmsb
      real*8 :: tmsb_cfluxin(n,ntmsb),  tmsb_cfluxout(n,ntmsb),        &
                tmsb_gfluxin(n,ntmsb),  tmsb_gfluxout(n,ntmsb),        &
                tmsb_gafluxin(n,ntmsb), tmsb_gafluxout(n,ntmsb)

      real*8 :: rdummys(200)
      real*8, allocatable :: rdummys_alloc(:)
      
      integer :: tid

      !c root uptake variables HG
      real*8 :: qrootloc
      real*8, external :: rootwat

      real*8, external :: pressure_melt_k
     
      
#ifdef USG
      integer :: icell, idvol, kvol, ncell, ndvol
      real*8 :: gasdiff_loc, grad_weights(num_crossdifficv_max),               &
                flux_totcnew_hls_corr(num_edge_dvols,num_edge_maxcells),       &
                flux_totviscnew_hls_corr(num_edge_dvols,num_edge_maxcells),    &
                flux_electro_hls_corr(num_edge_dvols,num_edge_maxcells),       &
                flux_totgnew_hls_corr(num_edge_dvols,num_edge_maxcells),       &
                flux_gnew_hls_corr(num_edge_dvols,num_edge_maxcells),          &
                cinfrt_usg(num_edge_dvols,num_edge_maxcells)

      type(point) :: grad_totcnew_locs(num_crossdifficv_max),                  &
                     grad_totviscnew_locs(num_crossdifficv_max),               &
                     grad_electro_locs(num_crossdifficv_max),                  &
                     grad_totgnew_locs(num_crossdifficv_max),                  &
                     grad_gnew_locs(num_crossdifficv_max),                     &
                     grad_totcnew_ivol(n), grad_totcnew_jvol(n),               &
                     grad_totgnew_ivol(n), grad_totgnew_jvol(n),               &
                     grad_totviscnew_ivol(n), grad_totviscnew_jvol(n),         &
                     grad_electro_ivol(n), grad_electro_jvol(n),               &
                     grad_gnew_ivol(ng), grad_gnew_jvol(ng),                   &
                     grad_totcnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_totgnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_totviscnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_electro_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_gnew_kvol(ng,num_nodes_per_cell,num_edge_maxcells),  &
                     grad_totcnew_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_totviscnew_mids(num_edge_dvols,num_edge_maxcells),   &
                     grad_electro_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_totgnew_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_gnew_mids(num_edge_dvols,num_edge_maxcells),         &
                     cinfrt_usg_cross(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_totcnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_totgnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_totviscnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_electro_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_gnew_hls_loc(ng,num_edge_dvols,num_edge_maxcells)

      real*8 :: permij_usg_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_da_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_da_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_da_ic_usg_loc(nc,num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_da_ic_usg_cross_loc(nc,num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_dg_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_dg_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_mcd_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_mcd_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      type(point) :: grad_cgg_totcnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_totviscnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_electro(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_totgnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_gnew(ng,num_edge_dvols,num_edge_maxcells) 
#endif

!c  root respiration variables:
      real*8 :: rootdiff(n), rootresp(n), rootuptake(n)
      real*8 :: rootdiff_zn(n,nzn), rootresp_zn(n,nzn),                &
                rootuptake_zn(n,nzn), totrcm_temp(nm,nzn)

!c  dilution index
      real*8 :: p_dix, totcstor_dix(n), tot_dix(n)

!c  spatial moment
      real*8 :: cstor_loc
      real*8 :: totcstor_spm(n), totcstor_spm_x_1st(n),                &
                totcstor_spm_y_1st(n), totcstor_spm_z_1st(n),          &
                totcstor_spm_x_2nd(n), totcstor_spm_y_2nd(n),          &
                totcstor_spm_z_2nd(n),                                 &
                plume_x(n), plume_y(n), plume_z(n),                    &
                spread_x(n), spread_y(n), spread_z(n)

#ifdef PETSC
      real*8 :: totrcm_temp_gbl(nm,nzn)
#endif

      real*8 :: rootresp_current, rootresp_max, rootresp_allowed,      &
                rootdens, delt_rcm, valid_rup

      external comptotc, msysrt, rateredx, totconcg, zero_r8      
     
      logical :: compute_diff

      real*8, parameter :: r0 = 0.0d0,r1=1.0d0,r100 = 100.0d0,         &
                           conv3 = 1.0d3,rverysmall = 1.0d-30,         &
                           rsmallarea = 1.0d-8,                        &
                           enat = 2.71828182845904509d0

!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------
      real*8   :: dpdt
      !real*8   :: area_ivol, totvsflux, diff_eff, bdyinfrt_da
      
      real (type_r8), allocatable :: bdyinfrt_da_ic(:)
      
!cdsu-------------------------------------------------------------------
!cdsu---------------------Gas transport variables-----------------------
!cdsu-------------------------------------------------------------------
      character*12 :: spt_weight
    
      real*8    relpgij,          &
                densgij,          &
                viscgij,          &
                gpij,             &
                gpivol_ivol,      &
                gdens_ivol,       &
                gvisc_ivol,       &
                gpivol_jvol,      &
                gdens_jvol,       &
                gvisc_jvol,       &
                relpgi,           &
                relpgj
      
     
!cdsu  added for dgm model
!c dgm and s-m variables and initialization
      real*8 :: dgm_gflux(nc), dgm_gflux_s(ng)

      real*8 :: ms_gflux(nc), ms_gflux_s(ng)

      real*8 :: ludecomp(ng,ng), fmat(ng), neflux(nc), neflux_s(ng)

      integer*4 :: ipvt(ng)
      real*8 :: so_av, gflux_ic, gflux_ig, cinfrt
      
      integer :: nvarsimrt, nvarsiresp, nvarsirup, nvarsirupcm,        &
                 nvarsidix, nvarsispm
      
      external molconc, rategas, rategasd, rateint, rateint_new,       &
               ratemin, ratemin_new, tcorr, totint, totredx,           &
               modrate, jacbevap

      real*8 :: rcvt

#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      rcvt = visc_h2o/dens_h2o/gacc
      spt_weight      = spatial_weighting            ! spatial weighting

      allocate (bdyinfrt_da_ic(nc), stat = ierr)
      bdyinfrt_da_ic(1:nc)=0.0d0 
      call checkerr(ierr,'bdyinfrt_da_ic',ilog)
      call memory_monitor(sizeof(bdyinfrt_da_ic),'bdyinfrt_da_ic',.true.)

!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------      

!c  zero arrays 
      cfluxin = r0
      cfluxout = r0
      cstordiff = r0
  
      if (ng.gt.0) then
        gfluxin = r0
        gfluxout = r0
        gafluxin = r0
        gafluxout = r0
        gstordiff = r0
        gdegas = r0
        totgasdecay = r0
      end if      
  
      if (naq.gt.0.or.nr.gt.0) then
        ordiff = r0
        intradiff = r0
      end if 
      
      if (nsb_ion.gt.0.or.nsb_surf.gt.0.or.noncompetitive_sorption) then
        sbdiff = r0
      end if 

      rootdiff = r0
      rootdiff_zn = r0
  
      if (nm.gt.0) then
        dpdiff = r0
      end if 

!c  noble gas ingrowth
      if (b_use_ngi) then
        ngidiff = r0
      end if

!c  initialize variables for total mass through specified boundary
      tmsb_cfluxin = r0
      tmsb_cfluxout = r0

      if (ng > 0) then
        tmsb_gfluxin = r0
        tmsb_gfluxout = r0
        tmsb_gafluxin = r0
        tmsb_gafluxout = r0
      end if

!c  compute total system mass at current time step

      call msysrt
 
!c  compress total aqueous component concentration vector and
!c  total gaseous component concentration vector for mass 
!c  balance calculations
      if (redox_equil.and.nr.gt.0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_1)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)
    !$omp do schedule(static)
#endif
        do ivol = 1,nngl
          call comptotc(totcnew(1,ivol))
          if (ng.gt.0) then
            call comptotc(totgnew(1,ivol))
          end if
          if (noncompetitive_sorption) then
            call comptotc(totanew(1,ivol))            
          end if
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif        
      end if

!c  calculate mass balance for water phase in terms of total 
!c  aqueous component concentrations [moles/unit time]

!c  flux contributions
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mbalrt_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(                                                    &
#ifdef USG
    !$omp icell, idvol, kvol, ncell, ndvol, grad_weights,             &
    !$omp grad_totcnew_mids, grad_gnew_mids,                          &
    !$omp grad_totgnew_mids, grad_totviscnew_mids, grad_electro_mids, &
    !$omp grad_totcnew_locs, grad_gnew_locs,                          &
    !$omp grad_totgnew_locs, grad_totviscnew_locs, grad_electro_locs, &
    !$omp grad_totcnew_ivol, grad_totcnew_jvol, grad_totcnew_kvol,    &
    !$omp grad_totgnew_ivol, grad_totgnew_jvol, grad_totgnew_kvol,    &
    !$omp grad_totviscnew_ivol, grad_totviscnew_jvol,                 &
    !$omp grad_totviscnew_kvol,                                       &
    !$omp grad_electro_ivol, grad_electro_jvol, grad_electro_kvol,    &
    !$omp grad_gnew_ivol, grad_gnew_jvol, grad_gnew_kvol,             &
    !$omp flux_totcnew_hls_corr, flux_gnew_hls_corr,                  &
    !$omp flux_totgnew_hls_corr, flux_totviscnew_hls_corr,            &
    !$omp flux_electro_hls_corr,                                      &
    !$omp grad_totcnew_hls_loc, grad_totgnew_hls_loc,                 &
    !$omp grad_totviscnew_hls_loc, grad_electro_hls_loc,              &
    !$omp grad_gnew_hls_loc,                                          &
    !$omp cinfrt_da_usg_loc, cinfrt_da_usg_cross_loc,                 &
    !$omp cinfrt_da_ic_usg_loc, cinfrt_da_ic_usg_cross_loc,           &
    !$omp cinfrt_mcd_usg_loc, cinfrt_mcd_usg_cross_loc,               &
    !$omp grad_cgg_totcnew, grad_cgg_totviscnew, grad_cgg_electro,    &
#endif
    !$omp i1, ibrt, ibvs, ic, iend, istart, ivol, idim, jvol, itmsb,  &
    !$omp tid, delta_totviscnew, delta_electromignew,                 &
    !$omp so_av, totwflux_atm, tothflux_atm, area_ivol, bdyinfrt_da,  &
    !$omp bdyinfrt_da_ic, diff_eff, diff_loc, totcflux, totvsflux,    &
    !$omp compute_diff)                                               &
    !$omp reduction(+:cfluxin, cfluxout,tmsb_cfluxin, tmsb_cfluxout)
    !$omp do schedule(static)
#endif
      do ibrt = 1,nbrt                 !boundary control volumes
          
        ivol = jabrt(ibrt)             !pointer to control volume
        if (ivol < 0) then
          cycle
        end if

        if (compute_ice_sheet_loading) then
          if (.not. b_jabrt_ice(ibrt)) then
            cycle
          end if
        end if

#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif

#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif

!c  Dirichlet type boundary conditions

        if (btypert(ivol).eq.'first') then

          istart = iavs(ivol)+1 
          iend = iavs(ivol+1)-1

          totcflux(:) = r0

          do i1 = istart,iend         !loop over local connections

            jvol = javs(i1)

#ifdef USG
            if (discretization_type > 0) then
              ncell = janumcell(i1)
            end if
#endif

#ifdef USG
            if (discretization_type > 0) then
              if (b_use_cross_diffusion_react) then
                if (multi_diff) then
                  call gradient_cross_diff_md(i1,ivol,jvol,            &
                       grad_totviscnew_ivol,grad_totviscnew_jvol,      &
                       grad_totviscnew_kvol,grad_electro_ivol,         &
                       grad_electro_jvol,grad_electro_kvol,            &
                       grad_totviscnew_hls_loc,grad_electro_hls_loc,   &
                       grad_cgg_totviscnew,grad_cgg_electro)
                else
                  call gradient_cross_diff_rt(i1,ivol,jvol,n,totcnew,  &
                       grad_totcnew_ivol,grad_totcnew_jvol,            &
                       grad_totcnew_kvol,grad_totcnew_hls_loc,         &
                       grad_cgg_totcnew)
                end if                
              end if

!cdsu
!cdsu calculate influence coefficient
!cdsu
              if (diff_coff) then
                call usg_face_utility_cinfrt_da_ic(ivol,jvol,i1,       &
                         cinfrt_da_ic_usg_loc,cinfrt_da_ic_usg_cross_loc)
              else
                call usg_face_utility_cinfrt_da(ivol,jvol,i1,          &
                         cinfrt_da_usg_loc,cinfrt_da_usg_cross_loc)
              end if

              if (multi_diff) then
                call usg_face_utility_cinfrt_mcd(ivol,jvol,i1,         &
                         cinfrt_mcd_usg_loc,cinfrt_mcd_usg_cross_loc)
              end if

            end if

#endif

            if (multi_diff) then
              call totdyvisc(ivol,jvol,cnew(:,ivol),cx(:,ivol),        &
                             cnew(:,jvol),cx(:,jvol),                  &
                             delta_totviscnew(:,tid))

              call elecmigration(ivol,jvol,cnew(:,ivol),cx(:,ivol),    &
                                 cnew(:,jvol),cx(:,jvol),              &
                                 delta_electromignew(:,tid))
            end if

            do ic = 1, n              !loop over components

              if (component_type(ic).eq.'aqueous') then
              
!cprovi----------------------------------------------------------------------
!cprovi Component dependent influence coefficient if specified
!cprovi----------------------------------------------------------------------
                if (diff_coff) then
                   cinfrt_da(i1) = cinfrt_da_ic(ic,i1)
#ifdef USG
                   if (discretization_type > 0) then
                     do idvol = 1, num_edge_dvols
                       do icell = 1, janumcell(i1)
                         cinfrt_da_usg_loc(idvol,icell) =              &
                                cinfrt_da_ic_usg_loc(ic,idvol,icell)
                         cinfrt_da_usg_cross_loc(idvol,icell) =        &
                                cinfrt_da_ic_usg_cross_loc(ic,idvol,icell)
                       end do
                     end do
                   end if
#endif
                end if
!cprovi----------------------------------------------------------------------              
!cprovi----------------------------------------------------------------------              
!cprovi----------------------------------------------------------------------
                if (multi_diff) then 
         
#ifdef USG
                  if (discretization_type > 0) then
                    grad_totcnew_mids = vector_zero
                    grad_totviscnew_mids = vector_zero
                    grad_electro_mids = vector_zero
                    flux_totcnew_hls_corr = r0
                    flux_totviscnew_hls_corr = r0
                    flux_electro_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_totviscnew_ivol,grad_totviscnew_jvol, &
                           grad_totviscnew_kvol,grad_totviscnew_hls_loc,   &
                           grad_weights,grad_totviscnew_locs,              &
                           grad_totviscnew_mids,flux_totviscnew_hls_corr,  &
                           grad_cgg_totviscnew)
      
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_electro_ivol,grad_electro_jvol,       &
                           grad_electro_kvol,grad_electro_hls_loc,         &
                           grad_weights,grad_electro_locs,                 &
                           grad_electro_mids,flux_electro_hls_corr,        &
                           grad_cgg_electro)
                    end if

                    totcflux(ic) = totcflux(ic) + conv3 *                              &
                       (fluxv_vl(totcnew(ic,ivol),totcnew(ic,jvol),ivol,jvol,          & !advective term
                                 cinfrt_va_usg(i1),ic)                                 &
                      - fluxd_usg(r0,delta_totviscnew(ic,tid),                         & !diffusive term
                           num_edge_dvols,janumcell(i1),                               &
                           grad_totviscnew_mids(1:num_edge_dvols,1:janumcell(i1)),     &
                           flux_totviscnew_hls_corr(1:num_edge_dvols,1:janumcell(i1)), &
                           cinfrt_mcd_usg_loc(1:num_edge_dvols,1:janumcell(i1)),       &
                           cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1))) &
                      - fluxd_usg(r0,delta_electromignew(ic,tid),                      & !electromigration term
                           num_edge_dvols,janumcell(i1),                               &
                           grad_electro_mids(1:num_edge_dvols,1:janumcell(i1)),        &
                           flux_electro_hls_corr(1:num_edge_dvols,1:janumcell(i1)),    &
                           cinfrt_mcd_usg_loc(1:num_edge_dvols,1:janumcell(i1)),     &
                           cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1))))
                  else
#endif
                    totcflux(ic) = totcflux(ic) + conv3 *              &
                                 (fluxv_vl(totcnew(ic,ivol),           & !advective term
                                           totcnew(ic,jvol),           &
                                           ivol,jvol,                  &
                                           cinfrt_va(i1),ic)           &
                                 -fluxd(r0,delta_totviscnew(ic,tid),   & !diffusive term
                                        cinfrt_mcd(i1))                &
                                 -fluxd(r0,delta_electromignew(ic,tid),& !electromigration term
                                        cinfrt_mcd(i1)))
#ifdef USG
                  end if
#endif
                else 

#ifdef USG
                  if (discretization_type > 0) then
                    grad_totcnew_mids = vector_zero
                    flux_totcnew_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_totcnew_ivol,grad_totcnew_jvol,       &
                           grad_totcnew_kvol,grad_totcnew_hls_loc,         &
                           grad_weights,grad_totcnew_locs,                 &
                           grad_totcnew_mids,flux_totcnew_hls_corr,        &
                           grad_cgg_totcnew)
                    end if

                    totcflux(ic) = totcflux(ic) + conv3 *                              &
                       (fluxv_vl(totcnew(ic,ivol),totcnew(ic,jvol),ivol,jvol,          &
                                 cinfrt_va_usg(i1),ic)                                 &
                      - fluxd_usg(totcnew(ic,ivol),totcnew(ic,jvol),                   &
                              num_edge_dvols,janumcell(i1),                            &
                              grad_totcnew_mids(1:num_edge_dvols,1:janumcell(i1)),     &
                              flux_totcnew_hls_corr(1:num_edge_dvols,1:janumcell(i1)), &
                              cinfrt_da_usg_loc(1:num_edge_dvols,1:janumcell(i1)),     &
                              cinfrt_da_usg_cross_loc(1:num_edge_dvols,1:janumcell(i1))))
                  else
#endif
                    totcflux(ic) = totcflux(ic) + conv3 *              &
                                    (fluxv_vl(totcnew(ic,ivol),        &
                                            totcnew(ic,jvol),          &
                                            ivol,jvol,                 &
                                            cinfrt_va(i1),ic)          &
                                - fluxd(totcnew(ic,ivol),              &
                                        totcnew(ic,jvol),              &
                                        cinfrt_da(i1)))
#ifdef USG
                  end if
#endif
                end if

              end if

            end do                   !loop over local connections

          end do                     !loop over components

!c  Neumann, Cauchy or mixed type boundary conditions

        else

!c  compute water flux across boundary [volume, not mass!]
          totvsflux = r0

!c  DSU, bug fixed here. Before 2020-03-11, totvsflux does not properly set
!c  It was placed inside evaporation condition. For density dependent flow
!c  without evaporation, totvsflux is not initialized or calculated.

          if (evaporation) then
            ibvs = ivol2bvs(ivol)
            if(ibvs > 0) then
              if (btypevs(ibvs)=='atmospheric') then 
                area_ivol=bcondvs(ibvs)
                !cprovi---------------------------------------------------
                !cprovi Change the inflow/for m3/day
                !cprovi---------------------------------------------------
                call jacbevap(ivol,' ',totwflux_atm,tothflux_atm) 
                totvsflux = totwflux_atm*area_ivol/ref_dens
                if (totvsflux<r0) then
                  compute_diff = .false. 
                  totvsflux =r0
                end if
              else
                if (density_dependence) then
                  totvsflux = ddbdflux(ivol)          
                else
                  totvsflux = bdryflux(ivol)          
                end if
              end if
            end if
          else
            if (density_dependence) then
              totvsflux = ddbdflux(ivol)          
            else
              totvsflux = bdryflux(ivol)
            end if
          end if

!c  total mass fluxes across Neumann type boundary control volumes
 
          if (btypert(ivol).eq.'second') then

            do ic = 1,n
              if (component_type(ic).eq.'aqueous') then
                totcflux(ic) = conv3 * totvsflux              & !advective flux
                             * totcnew(ic,ivol)
              end if
            end do

!c  total mass fluxes across Cauchy type boundary control volumes or 
!c  injection points

          elseif ((btypert(ivol).eq.'third') .or.             &
     &            (btypert(ivol).eq.'third-evap') .or.        &
     &            (btypert(ivol).eq.'point')) then
!cprovi--------------------------------------------------------------------            
!cprovi Use component dependent diff coefficient if speciifed
!cprovi--------------------------------------------------------------------
            if (b_fluxd_bcond(ivol)) then      
              so_av=dmin1(r1, sonew(ivol))  
              if (.not.diff_coff) then
                diff_eff = r0
                diff_loc = r0
                if (type_diff_ic_coeff == 0) then
                  diff_loc = diff_a
                else if (type_diff_ic_coeff > 0) then
                  idim = diff_brt_dim(ibrt)
                  if (idim == 1) then
                    diff_loc = diff_a_tensor%xx
                  else if (idim == 2) then
                    diff_loc = diff_a_tensor%yy
                  else if (idim == 3) then
                    diff_loc = diff_a_tensor%zz
                  end if
                end if
                diff_eff = diffcoff(diff_loc, sanew(ivol),pornew(ivol),  &
                                    tortuosity_corr,assigned_tau,        &
                                    tau(ivol)*tau_fac(ivol),             &
                                    type_tortuosity,marchies(ivol),so_av,&
                                    tor_corr_a_mq, tor_corr_b_mq)
                bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
                if (b_water_freezing) then
                  if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                    bdyinfrt_da = bdyinfrt_da*frozen_diff_a
                  end if
                end if 
              else
                do ic = 1,nc
                  diff_eff = r0
                  diff_loc = r0
                  if (type_diff_ic_coeff == 0) then
                    diff_loc = diff_ic(ic)
                  else if (type_diff_ic_coeff > 0) then
                    idim = diff_brt_dim(ibrt)
                    if (idim == 1) then
                      diff_loc = diff_ic_tensor(ic)%xx
                    else if (idim == 2) then
                      diff_loc = diff_ic_tensor(ic)%yy
                    else if (idim == 3) then
                      diff_loc = diff_ic_tensor(ic)%zz
                    end if
                  end if
                  diff_eff = diffcoff(diff_loc, sanew(ivol),               &
                                      pornew(ivol),tortuosity_corr,        &
                                      assigned_tau,tau(ivol)*tau_fac(ivol),&
                                      type_tortuosity,marchies(ivol),so_av,&
                                      tor_corr_a_mq, tor_corr_b_mq)
                  
                  bdyinfrt_da_ic(ic) = diff_eff * bdycrt_d(ibrt)
                  if (b_water_freezing) then
                    if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                      bdyinfrt_da_ic(ic) = bdyinfrt_da_ic(ic)*frozen_diff_a
                    end if
                  end if 
                end do
              end if
            else
              if (diff_coff) then
                bdyinfrt_da_ic(1:nc) = r0
              else
                bdyinfrt_da = r0
              end if 
            end if

!cbdy-start
            if (totvsflux.gt.0) then
!cbdy-end
!cbdy - flux enters domain
            
              do ic = 1,n

                if (component_type(ic).eq.'aqueous') then
                  if (b_fluxd_bcond(ivol)) then
                    if (diff_coff) then
                      bdyinfrt_da = bdyinfrt_da_ic(ic)
                    end if
                    totcflux(ic) = conv3 *                             & 
                                   (totvsflux * bcondrt_a(ic,ibrt) +   &   !advective flux
                                    fluxd(totcnew(ic,ivol),            & ! diffusive flux
                                          bcondrt_a(ic,ibrt),          &
                                          bdyinfrt_da))
                  else
                    totcflux(ic) = conv3 *                             & 
                                   totvsflux * bcondrt_a(ic,ibrt)          !advective flux
                  end if
                end if
              end do
!cbdy-start
!cbdy - flux leaves domain

            else
            
              do ic = 1,n
                if (component_type(ic).eq.'aqueous') then
                  if (btypert(ivol).eq.'third-evap') then                !evaporation type, mass is retained
                    totcflux(ic) = conv3 * totvsflux * r0                !advective flux
                  else
                    if (b_fluxd_bcond(ivol)) then
                      if (diff_coff) then
                        bdyinfrt_da = bdyinfrt_da_ic(ic)
                      end if
                      totcflux(ic) = conv3 *                           &
                                     (totvsflux * totcnew(ic,ivol) +   & !advective flux
                                      fluxd(totcnew(ic,ivol),          & ! diffusive flux
                                            bcondrt_a(ic,ibrt),        &
                                            bdyinfrt_da))
                    else
                      totcflux(ic) = conv3 *                           &
                                     totvsflux * totcnew(ic,ivol)        !advective flux
                    end if
                  end if
                end if
              end do

            end if

!cbdy-end

!c  total mass fluxes across mixed type boundary control volumes

          elseif (btypert(ivol).eq.'mixed' .or. btypert(ivol).eq.'mixed-evap') then

!cprovi--------------------------------------------------------------------            
!cprovi Use component dependent diff coefficient if speciifed
!cprovi--------------------------------------------------------------------  
            compute_diff = b_fluxd_bcond(ivol)  

            if (compute_diff) then 
              so_av=dmin1(r1, sonew(ivol))  
              if (.not.diff_coff) then
                diff_eff = r0
                diff_loc = r0
                if (type_diff_ic_coeff == 0) then
                  diff_loc = diff_a
                else if (type_diff_ic_coeff > 0) then
                  idim = diff_brt_dim(ibrt)
                  if (idim == 1) then
                    diff_loc = diff_a_tensor%xx
                  else if (idim == 2) then
                    diff_loc = diff_a_tensor%yy
                  else if (idim == 3) then
                    diff_loc = diff_a_tensor%zz
                  end if
                end if
                diff_eff = diffcoff(diff_loc, sanew(ivol),pornew(ivol),  &
                                    tortuosity_corr,assigned_tau,        &
                                    tau(ivol)*tau_fac(ivol),             &
                                    type_tortuosity,marchies(ivol),so_av,&
                                    tor_corr_a_mq, tor_corr_b_mq)
                bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
                if (b_water_freezing) then
                  if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                    bdyinfrt_da = bdyinfrt_da*frozen_diff_a
                  end if
                end if 
              else
                do ic = 1,nc
                  diff_eff = r0
                  diff_loc = r0
                  if (type_diff_ic_coeff == 0) then
                    diff_loc = diff_ic(ic)
                  else if (type_diff_ic_coeff > 0) then
                    idim = diff_brt_dim(ibrt)
                    if (idim == 1) then
                      diff_loc = diff_ic_tensor(ic)%xx
                    else if (idim == 2) then
                      diff_loc = diff_ic_tensor(ic)%yy
                    else if (idim == 3) then
                      diff_loc = diff_ic_tensor(ic)%zz
                    end if
                  end if
                  diff_eff = diffcoff(diff_loc, sanew(ivol),               &
                                      pornew(ivol),tortuosity_corr,        &
                                      assigned_tau,tau(ivol)*tau_fac(ivol),&
                                      type_tortuosity,marchies(ivol),so_av,&
                                      tor_corr_a_mq, tor_corr_b_mq)
                  
                  bdyinfrt_da_ic(ic) = diff_eff * bdycrt_d(ibrt)
                  if (b_water_freezing) then
                    if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                      bdyinfrt_da_ic(ic) = bdyinfrt_da_ic(ic)*frozen_diff_a
                    end if
                  end if 
                end do
              end if
            else 
              if (diff_coff) then
                 bdyinfrt_da_ic(1:nc) = r0
              else
                 bdyinfrt_da = r0
              end if       
            end if 
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------            
            
            do ic = 1,n
!cprovi--------------------------------------------------------------------         
!cprovi Bubbles use component dependent diff coefficient if 
!cprovi speciifed
!cprovi--------------------------------------------------------------------
     
              if (diff_coff) then
                bdyinfrt_da = bdyinfrt_da_ic(ic)
              end if
!cprovi--------------------------------------------------------------------            
!cprovi  aqueous phase - compute advective and diffusive 
!cprovi flux across boundary         
!cprovi--------------------------------------------------------------------                        
              if (component_type(ic).eq.'aqueous') then
                if (totvsflux > r0) then                                 ! influx
                  if (b_fluxd_bcond(ivol)) then
                    totcflux(ic) = conv3 *                             &
                                   (totvsflux*bcondrt_a(ic,ibrt) +     & ! advective flux
                                    fluxd(totcnew(ic,ivol),            & ! diffusive flux
                                          bcondrt_a(ic,ibrt),          &
                                          bdyinfrt_da))
                  else
                    totcflux(ic) = conv3 *                             &
                                   (totvsflux*bcondrt_a(ic,ibrt))        ! advective flux only
                  end if
                else if (totvsflux <= r0) then                           ! outflux
                  if (btypert(ivol).eq.'mixed-evap') then
                    totcflux(ic) = conv3 * totvsflux * r0
                  else
                    if (b_fluxd_bcond(ivol)) then
                      totcflux(ic) = conv3 *                           &
                                     (totvsflux*totcnew(ic,ivol) +     & ! advective flux
                                      fluxd(totcnew(ic,ivol),          & ! diffusive flux
                                            bcondrt_a(ic,ibrt),        &
                                            bdyinfrt_da))
                    else
                      totcflux(ic) = conv3 *                           &
                                     (totvsflux*totcnew(ic,ivol))        ! advective flux only
                    end if
                  end if
                end if
              end if
            end do

          end if

        end if                !boundary type (transport) 

!c  assign flux contributions

        do ic = 1,n
          if (component_type(ic).eq.'aqueous') then
            if (totcflux(ic).gt.r0 ) then
              cfluxin(ic) = cfluxin(ic) + totcflux(ic)      !mass in
            else
              if (btypert(ivol).eq.'mixed-evap') then
                !c 'mixed-evap' boundary, no mass out for aqueous phase
              else
                cfluxout(ic) = cfluxout(ic) - totcflux(ic)  !mass out
              end if
            end if
          end if
        end do

!c  sum up total mass through specified boundary
        if (ntmsb > 0) then
          do itmsb = 1, ntmsb
            if (btest(mproptmsb(ivol),itmsb-1)) then
              do ic = 1,n
                if (component_type(ic).eq.'aqueous') then
                  if (totcflux(ic).gt.r0 ) then
                    tmsb_cfluxin(ic,itmsb) = tmsb_cfluxin(ic,itmsb) + totcflux(ic)      !mass in
                  else
                    if (btypert(ivol).eq.'mixed-evap') then
                      !c 'mixed-evap' boundary, no mass out for aqueous phase
                    else
                      tmsb_cfluxout(ic,itmsb) = tmsb_cfluxout(ic,itmsb) - totcflux(ic)  !mass out
                    end if
                  end if
                end if
              end do
            end if
          end do
        end if

      end do                  !loop over boundary control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(cfluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxin(1:n) = mpireduce_n(1:n)
      
      call MPI_Allreduce(cfluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxout(1:n) = mpireduce_n(1:n)

      if (ntmsb > 0) then
        do itmsb = 1, ntmsb
          call MPI_Allreduce(tmsb_cfluxin(1:n,itmsb), mpireduce_n,n,   &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_cfluxin(1:n,itmsb) = mpireduce_n(1:n)

          call MPI_Allreduce(tmsb_cfluxout(1:n,itmsb), mpireduce_n,n,  &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_cfluxout(1:n,itmsb) = mpireduce_n(1:n)
        end do
      end if
#endif

 
!c  change in storage [moles/unit time]
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol)                                          &
    !$omp reduction (+:cstordiff)
    !$omp do schedule(static) 
#endif
      do ivol = 1,nngl
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif
        do ic = 1,n
          cstordiff(ic) = cstordiff(ic)                       &
                        + conv3 * cvol(ivol)/delt             &
                        * (bulkconc(totcnew(ic,ivol),         &
                                    sanew(ivol),              &
                                    pornew(ivol))             &
                        -  bulkconc(totcold(ic,ivol),         &
                                    saold(ivol),              &
                                    porold(ivol)))
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(cstordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cstordiff(1:n) = mpireduce_n(1:n)  
#endif

!c  Dilution index, accordingly to Ditanidis 1994.
!c  Modified dilution index by including saturation and porosity terms.
!c  This change is required since MIN3P allow porosity > 1
      if (b_dilution_index) then
        totcstor_dix = r0  
        tot_dix = r0      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol)                                          &
    !$omp reduction (+:totcstor_dix)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          do ic = 1,n
            totcstor_dix(ic) = totcstor_dix(ic) + totcnew(ic,ivol)*    &
                               cvol(ivol)*sanew(ivol)*pornew(ivol)
          end do
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
        call MPI_Allreduce(totcstor_dix, mpireduce_n,n,MPI_REAL8,      &
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_dix(1:n) = mpireduce_n(1:n)
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol, p_dix)                                   &
    !$omp reduction (+:tot_dix)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          do ic = 1,n
            p_dix = totcnew(ic,ivol)/totcstor_dix(ic)
            tot_dix(ic) = tot_dix(ic) + p_dix*log(p_dix)*              &
                          cvol(ivol)*sanew(ivol)*pornew(ivol)
          end do
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
        call MPI_Allreduce(tot_dix, mpireduce_n,n,MPI_REAL8,          &
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        tot_dix(1:n) = mpireduce_n(1:n)  
#endif

        do ic = 1,n
          tot_dix(ic) = exp(-tot_dix(ic))
        end do
      end if

!c  spatial moment, accordingly to Goltz and Huang, 1987, WRR; Oware and Moysey 2014, Journal of Hydrology
!c  Modified spatial moment by including saturation and porosity terms.
!c  This change is required since MIN3P allow porosity > 1
      if (b_spatial_moment) then
        totcstor_spm = r0  
        totcstor_spm_x_1st = r0
        totcstor_spm_y_1st = r0
        totcstor_spm_z_1st = r0 
        totcstor_spm_x_2nd = r0
        totcstor_spm_y_2nd = r0
        totcstor_spm_z_2nd = r0
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol, cstor_loc)                               &
    !$omp reduction (+:totcstor_spm, totcstor_spm_x_1st,              &
    !$omp totcstor_spm_y_1st, totcstor_spm_z_1st, totcstor_spm_x_2nd, &
    !$omp totcstor_spm_y_2nd, totcstor_spm_z_2nd)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          do ic = 1,n
            cstor_loc = totcnew(ic,ivol)*cvol(ivol)*sanew(ivol)*pornew(ivol)

            totcstor_spm(ic) = totcstor_spm(ic) + cstor_loc
            
            totcstor_spm_x_1st(ic) = totcstor_spm_x_1st(ic) + cstor_loc*xg(ivol)
            totcstor_spm_y_1st(ic) = totcstor_spm_y_1st(ic) + cstor_loc*yg(ivol)
            totcstor_spm_z_1st(ic) = totcstor_spm_z_1st(ic) + cstor_loc*zg(ivol)

            totcstor_spm_x_2nd(ic) = totcstor_spm_x_2nd(ic) + cstor_loc*xg(ivol)**2
            totcstor_spm_y_2nd(ic) = totcstor_spm_y_2nd(ic) + cstor_loc*yg(ivol)**2
            totcstor_spm_z_2nd(ic) = totcstor_spm_z_2nd(ic) + cstor_loc*zg(ivol)**2
          end do
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
        call MPI_Allreduce(totcstor_spm, mpireduce_n,n,MPI_REAL8,      &
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm(1:n) = mpireduce_n(1:n)

        call MPI_Allreduce(totcstor_spm_x_1st, mpireduce_n,n,MPI_REAL8,&
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm_x_1st(1:n) = mpireduce_n(1:n)

        call MPI_Allreduce(totcstor_spm_y_1st, mpireduce_n,n,MPI_REAL8,&
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm_y_1st(1:n) = mpireduce_n(1:n)

        call MPI_Allreduce(totcstor_spm_z_1st, mpireduce_n,n,MPI_REAL8,&
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm_z_1st(1:n) = mpireduce_n(1:n)

        call MPI_Allreduce(totcstor_spm_x_2nd, mpireduce_n,n,MPI_REAL8,&
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm_x_2nd(1:n) = mpireduce_n(1:n)

        call MPI_Allreduce(totcstor_spm_y_2nd, mpireduce_n,n,MPI_REAL8,&
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm_y_2nd(1:n) = mpireduce_n(1:n)

        call MPI_Allreduce(totcstor_spm_z_2nd, mpireduce_n,n,MPI_REAL8,&
                           MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totcstor_spm_z_2nd(1:n) = mpireduce_n(1:n)        
#endif

!c  calculate coordinates of the center of mass of the plume from first order spatial moment
        do ic = 1,n
          plume_x(ic) = totcstor_spm_x_1st(ic)/totcstor_spm(ic)
          plume_y(ic) = totcstor_spm_y_1st(ic)/totcstor_spm(ic)
          plume_z(ic) = totcstor_spm_z_1st(ic)/totcstor_spm(ic)
        end do

!c  calculate longitudinal and transverse dispersive spreading of the plume from the second order spatial moment        
        do ic = 1,n
          spread_x(ic) = sqrt(totcstor_spm_x_2nd(ic)/totcstor_spm(ic) -    &
                             (totcstor_spm_x_1st(ic)/totcstor_spm(ic))**2)
          spread_y(ic) = sqrt(totcstor_spm_y_2nd(ic)/totcstor_spm(ic) -    &
                             (totcstor_spm_y_1st(ic)/totcstor_spm(ic))**2)
          spread_z(ic) = sqrt(totcstor_spm_z_2nd(ic)/totcstor_spm(ic) -    &
                             (totcstor_spm_z_1st(ic)/totcstor_spm(ic))**2)
        end do

      end if

!c  contributions from exchange with air phase
!c  Q_ex = inflow - outflow - change in storage
!c
!c  flux contributions 
      if (ng.gt.0) then

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mbalrt_4)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, idvol, kvol, ncell, ndvol, grad_weights,             &
    !$omp grad_totcnew_mids, grad_totgnew_mids, grad_gnew_mids,       &
    !$omp grad_totcnew_locs, grad_totgnew_locs, grad_gnew_locs,       &
    !$omp grad_totcnew_ivol, grad_totcnew_jvol, grad_totcnew_kvol,    &
    !$omp grad_totgnew_ivol, grad_totgnew_jvol, grad_totgnew_kvol,    &
    !$omp grad_gnew_ivol, grad_gnew_jvol, grad_gnew_kvol,             &
    !$omp flux_totcnew_hls_corr, flux_gnew_hls_corr,                  &
    !$omp flux_totgnew_hls_corr, grad_totcnew_hls_loc,                &
    !$omp grad_totgnew_hls_loc, grad_gnew_hls_loc,                    &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc, permij_usg_loc,       &
    !$omp cinfrt_usg, cinfrt_usg_cross, cinfrt_dg_usg_loc,            &
    !$omp cinfrt_dg_usg_cross_loc, grad_cgg_totgnew,                  &                          
#endif
    !$omp i1, ibrt, ic, iend, istart, ivol, jvol, itmsb,              &
    !$omp densgij, gij, gpij, gmfracij, relpgij, relpgi, relpgj,      &
    !$omp totgij, totgflux, totgaflux, viscgij, so_av,                &
    !$omp gpivol_ivol, gdens_ivol, gvisc_ivol,                        &
    !$omp gpivol_jvol, gdens_jvol, gvisc_jvol,                        &
    !$omp diff_eff, diff_loc, bdyinfrt_dg, fmat, ipvt, ludecomp,      &
    !$omp cinfrt, dgm_gflux, gflux_ic, ms_gflux, neflux)              &
    !$omp reduction (+:gfluxin, gfluxout, gafluxin, gafluxout,        &
    !$omp tmsb_gfluxin, tmsb_gfluxout, tmsb_gafluxin, tmsb_gafluxout)
    !$omp do schedule(static)
#endif
        do ibrt = 1,nbrt                 !boundary control volumes
            
          ivol = jabrt(ibrt)             !pointer to control volume
          if (ivol < 0) then
            cycle
          end if

#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif

          if (compute_ice_sheet_loading) then
            if (.not. b_jabrt_ice(ibrt)) then
              cycle
            end if
          end if

          call zero_r8 (totgflux,n,1,1)  !zero flux array
          call zero_r8 (totgaflux,n,1,1) !zero flux array
          call zero_r8 (totgij,nc,1,1)
          
          
!c  Dirichlet type boundary conditions

          if (btypert(ivol).eq.'first') then

            istart = iavs(ivol)+1
            iend = iavs(ivol+1)-1

!c          gas advection variables
            if (gas_advection) then
              !gpivol_ivol = gasp_m(mdens_g(ivol),ivol)           ! pressure
              !gdens_ivol  = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! density
              !gvisc_ivol  = gasv(gmfrac(:,ivol))                 ! viscosity
              gpivol_ivol = gpivol(ivol)                          ! pressure
              gdens_ivol  = gdens(ivol)                           ! density
              gvisc_ivol  = gvisc(ivol)                           ! viscosity
            else
              gpivol_ivol = 0.0d0
              gdens_ivol  = 0.0d0
              gvisc_ivol  = 0.0d0
            end if


            do i1 = istart,iend            !loop over local connections

              jvol = javs(i1)

!c            gas advection variables
              if (gas_advection) then
                !gpivol_jvol = gasp_m(mdens_g(jvol),jvol)           ! pressure
                !gdens_jvol  = gasd_m(mdens_g(jvol),gmfrac(:,jvol)) ! density
                !gvisc_jvol  = gasv(gmfrac(:,jvol))                 ! viscosity
                gpivol_jvol = gpivol(jvol)                          ! gas pressure
                gdens_jvol  = gdens(jvol)                           ! gas density
                gvisc_jvol  = gvisc(jvol)                           ! gas viscosity
              else
                gpivol_jvol = 0.0d0
                gdens_jvol  = 0.0d0
                gvisc_jvol  = 0.0d0
              end if

#ifdef USG
              if (discretization_type > 0) then
                ncell = janumcell(i1)
              end if
#endif

#ifdef USG
              if (discretization_type > 0) then
                if (b_use_cross_diffusion_react) then
                  call gradient_cross_diff_rt(i1,ivol,jvol,n,totgnew,  &
                       grad_totgnew_ivol,grad_totgnew_jvol,            &
                       grad_totgnew_kvol,grad_totgnew_hls_loc,         &
                       grad_cgg_totgnew)
                end if

!cdsu
!cdsu calculate influence coefficient
!cdsu
                if (ng > 0) then
                  call usg_face_utility_cinfrt_dg(ivol,jvol,i1,        &
                           cinfrt_dg_usg_loc,cinfrt_dg_usg_cross_loc)

                  call usg_face_utility_cinfvs(ivol,jvol,i1,           &
                           cinfvs_usg_loc,cinfvs_usg_cross_loc,        &
                           permij_usg_loc)
                end if
              end if
#endif

              do ic = 1, n                 !loop over components

                if (blanc_diff_g .or. gas_advection) then
                    !gpivol_jvol  = gasp_m(mdens_g(jvol),jvol)          ! pressure
                    !gdens_jvol   = gasd_m(mdens_g(jvol),gmfrac(:,jvol))! density
                    !gvisc_jvol   = gasv(gmfrac(:,jvol))                ! viscosity
                    gpivol_jvol = gpivol(jvol)                          ! gas pressure
                    gdens_jvol  = gdens(jvol)                           ! gas density
                    gvisc_jvol  = gvisc(jvol)                           ! gas viscosity
                else
                    gpivol_jvol = 0.0d0
                    gdens_jvol  = 0.0d0
                    gvisc_jvol  = 0.0d0
                endif

!c              calculate gas properties at interface according to weighting scheme
#ifdef USG
                if (discretization_type > 0 .and. is_cell_based_relp) then

                  !c modify relpgij externally
                  relpgij = 0.0d0
                  do icell = 1, node_num_cells(ivol)
                    relpgij = relpgij + relpermg(node_cells(icell,ivol))
                  end do
                  relpgij = relpgij / node_num_cells(ivol)

                  relpgi = relpgij
                  relpgj = relpgij

                else
#endif
                  relpgi = relpermg(ivol)
                  relpgj = relpermg(jvol)
#ifdef USG
                end if
#endif

                call wgprop(totgnew(1,ivol),totgnew(1,jvol),totgij   , &
                            gnew(1,ivol)   ,gnew(1,jvol)   ,gij      , &
                            gmfrac(1,ivol) ,gmfrac(1,jvol) ,gmfracij , &
                            relpgi         ,relpgj         ,relpgij  , &
                            gdens_ivol     ,gdens_jvol     ,densgij  , &
                            gvisc_ivol     ,gvisc_jvol     ,viscgij  , &
                            gpivol_ivol    ,gpivol_jvol    ,gpij     , &
                            zg(ivol)       ,zg(jvol)       ,           &
                            spt_weight     ,iupsg(i1)      ,           &
                            nc             ,ng             ,gacc     )
                
                
!c -------------- DGM module ----------------------------------------------------
!c               solve A F = B
!c               computes fluxes F of all gas components at current c.v. interphase

                gflux_ic = 0.0d0
          
                if (dgm) then
                
#ifdef USG
                  if (discretization_type > 0) then
                    call dgm_fluxdg (gnew(1,ivol)    ,gnew(1,jvol) ,   &
                                     gij             ,gmfracij     ,   &
                                     zg(ivol)        ,zg(jvol)     ,   &
                                     densgij         ,gpij         ,   &
                                     tkel(ivol)      ,                 &
                                     sum(permij_usg_loc(               &
                                                1:num_edge_dvols   ,   &
                                                1:janumcell(i1)))  ,   &
                                     relpgij         ,tauij(i1)    ,   &
                                     gporij(i1)      ,deltaij(i1)  ,   &
                                     rverysmall      ,                 &
                                     ludecomp        ,                 &
                                     fmat            ,ipvt         ,   &
                                     dgm_gflux       ,neflux       )
                  else
#endif
                    call dgm_fluxdg (gnew(1,ivol)    ,gnew(1,jvol) ,   &
                                     gij             ,gmfracij     ,   &
                                     zg(ivol)        ,zg(jvol)     ,   &
                                     densgij         ,gpij         ,   &
                                     tkel(ivol)      ,permij(i1)   ,   &
                                     relpgij         ,tauij(i1)    ,   &
                                     gporij(i1)      ,deltaij(i1)  ,   &
                                     rverysmall      ,                 &
                                     ludecomp        ,                 &
                                     fmat            ,ipvt         ,   &
                                     dgm_gflux       ,neflux       )
#ifdef USG
                  end if
#endif

!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else

#ifdef USG
                    if (discretization_type > 0) then
                      gflux_ic =                                       &
                               + sum(cinfrt_dg_usg_loc(                &
                                     1:num_edge_dvols,                 &
                                     1:janumcell(i1)))                 &
                               * deltaij(i1)                           &
                               * dgm_gflux(ic)                         &
                               / tauij(i1)                             &
                               / gporij(i1)
                    else
#endif
                      gflux_ic =                                       &
                               + cinfrt_dg(i1)                         &
                               * deltaij(i1)                           &
                               * dgm_gflux(ic)                         &
                               / tauij(i1)                             &
                               / gporij(i1)
#ifdef USG
                    end if
#endif
                  endif
                
!c --------------- Maxwell Stefan module ----------------------------------------

                else if (maxwell) then
                
                  call ms_fluxdg (gnew(1,ivol)    ,gnew(1,jvol) ,      &
     &                            gij             ,gmfracij     ,      &
     &                            zg(ivol)        ,zg(jvol)     ,      &
     &                            densgij         ,gpij         ,      &
     &                            tkel(ivol)      ,tauij(i1)    ,      &
     &                            gporij(i1)      ,deltaij(i1)  ,      &
     &                            rverysmall      ,                    &
     &                            ludecomp        ,fmat         ,      &
     &                            ipvt            ,equimolar    ,      &
     &                            ms_gflux        ,neflux       )
                
!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else

#ifdef USG
                    if (discretization_type > 0) then
                      gflux_ic =                                       &
                               + sum(cinfrt_dg_usg_loc(                &
                                     1:num_edge_dvols,                 &
                                     1:janumcell(i1)))                 &
                               * deltaij(i1)                           &
                               * ms_gflux(ic)                          &
                               / tauij(i1)                             &
                               / gporij(i1)
                    else
#endif
                      gflux_ic =                                       &
                               + cinfrt_dg(i1)                         &
                               * deltaij(i1)                           &
                               * ms_gflux(ic)                          &
                               / tauij(i1)                             &
                               / gporij(i1)
#ifdef USG
                    end if
#endif
                  endif
                
!c--------ficks law, business as usual------------------------------------

                else if ((.not.dgm).and.(.not.maxwell)) then
                
                  if (blanc_diff_g) then
#ifdef USG
                    if (discretization_type > 0) then
                      gasdiff_loc = gasdiff2(gmfrac(1,ivol),gmfrac(1,jvol),  &
                                         gpivol_ivol   ,gpivol_jvol   ,      &
                                         zg(ivol)      ,zg(jvol)      ,      &
                                         gdens_ivol    ,gdens_jvol    ,      &
                                         ic            ,                     &
                                         iupsg(i1)     ,spt_weight    )
                      cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)*gasdiff_loc
                      cinfrt_usg_cross(:,:) = cinfrt_dg_usg_cross_loc(:,:) * &
                                               gasdiff_loc

                    else
#endif
!c                    diffusion coefficient calc'd with LeBlanc's law
                      cinfrt = cinfrt_dg(i1) * gasdiff2                &
                                      (gmfrac(1,ivol), gmfrac(1,jvol), &
                                       gpivol_ivol   , gpivol_jvol   , &
                                       zg(ivol)      , zg(jvol)      , &
                                       gdens_ivol    , gdens_jvol    , &
                                       ic            ,                 &
                                       iupsg(i1)     , spt_weight    )
#ifdef USG
                    end if
#endif
                  else
!c                  single constant diffusion
#ifdef USG
                    if (discretization_type > 0) then
                      cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)
                      cinfrt_usg_cross(:,:) =cinfrt_dg_usg_cross_loc(:,:)
                    else
#endif
                      cinfrt = cinfrt_dg(i1)
#ifdef USG
                    end if
#endif
                  endif


                
!c new - diffusion expressed in terms of concentration gradients
#ifdef USG
                  if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                    grad_totgnew_mids = vector_zero
                    flux_totgnew_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                           jvol,grad_totgnew_ivol,grad_totgnew_jvol,       &
                           grad_totgnew_kvol,grad_totgnew_hls_loc,         &
                           grad_weights,grad_totgnew_locs,                 &
                           grad_totgnew_mids,flux_totgnew_hls_corr,        &
                           grad_cgg_totgnew)
                    end if

                    gflux_ic = - fluxd_usg(totgnew(ic,ivol),totgnew(ic,jvol),          & !diffusive flux
                              num_edge_dvols,janumcell(i1),                            &
                              grad_totgnew_mids(1:num_edge_dvols,1:janumcell(i1)),     &
                              flux_totgnew_hls_corr(1:num_edge_dvols,1:janumcell(i1)), &
                              cinfrt_usg(1:num_edge_dvols,1:janumcell(i1)),            &
                              cinfrt_usg_cross(1:num_edge_dvols,1:janumcell(i1)))
                  else
#endif
                    gflux_ic = - fluxd(totgnew(ic,ivol),                        & !diffusive flux
                                       totgnew(ic,jvol),                        &
                                       cinfrt)
#ifdef USG
                  end if
#endif

                endif
!c  -----------> diffusion component 
                totgflux(ic) = totgflux(ic) + conv3 * gflux_ic


!c  -----------> advection component 
                if (gas_advection) then
#ifdef USG
                  if (discretization_type > 0) then
                    totgaflux(ic) = totgaflux(ic) + conv3 *            &
                                    (fluxvg(gpivol_ivol, gpivol_jvol,  &
                                           zg(ivol)    ,zg(jvol)    ,  &
                                           totgij(ic)  ,relpgij     ,  &
                                           densgij     ,viscgij     ,  &
                                           rcvt*sum(cinfvs_usg_loc(    &
                                               1:num_edge_dvols,       &
                                               1:janumcell(i1))),      &
                                           gas_gravity ,gacc))
                  else
#endif
                    totgaflux(ic) = totgaflux(ic) + conv3 *            &
                                    (fluxvg(gpivol_ivol, gpivol_jvol,  &
                                           zg(ivol)    ,zg(jvol)    ,  &
                                           totgij(ic)  ,relpgij     ,  &
                                           densgij     ,viscgij     ,  &
                                           cinfvs_g(i1),               &
                                           gas_gravity ,gacc))
#ifdef USG
                  end if
#endif
                endif 
 
              end do                     !loop over components

            end do                       !loop over local connections

!c  total mass fluxes across mixed type boundary control volumes

          elseif (btypert(ivol).eq.'mixed' .or. btypert(ivol).eq.'mixed-evap') then
              
            so_av=dmin1(r1, sonew(ivol))  

            diff_eff = diffcoff_g(diff_g,sgnew(ivol),pornew(ivol),     &
                                  tortuosity_corr,assigned_tau_gas,    &
                                  taugas(ivol)*tau_fac(ivol),          &
                                  type_tortuosity,marchies(ivol),      &
                                  gas_tortuosity,so_av,                &
                                  tor_corr_a_mq,tor_corr_b_mq)
            bdyinfrt_dg = diff_eff * bdycrt_d(ibrt)

            if (b_water_freezing) then
              if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                bdyinfrt_dg = bdyinfrt_dg*frozen_diff_g
              end if
            end if  

            do ic = 1,n
              totgflux(ic) = conv3 *                                   &
                           ( + fluxd(totgnew(ic,ivol),                 & !diffusive flux
                                     bcondrt_g(ic,ibrt),               &
                                     bdyinfrt_dg))
            end do

          end if                         !boundary type

          do ic = 1,n

            if (totgflux(ic).gt.r0) then
              gfluxin(ic) = gfluxin(ic) + totgflux(ic)    !influx
            else
              gfluxout(ic) = gfluxout(ic) - totgflux(ic)  !outflux
            end if

            if (gas_advection) then
            
              if (totgaflux(ic).gt.r0) then
                  gafluxin(ic) = gafluxin(ic) + totgaflux(ic)    !influx
              else
                  gafluxout(ic) = gafluxout(ic) - totgaflux(ic)  !outflux
              end if
            
            endif

          end do

!c  sum up total mass through specified boundary
          if (ntmsb > 0) then
            do itmsb = 1, ntmsb
              if (btest(mproptmsb(ivol),itmsb-1)) then
                do ic = 1,n
                  if (totgflux(ic).gt.r0) then
                    tmsb_gfluxin(ic,itmsb) = tmsb_gfluxin(ic,itmsb) + totgflux(ic)    !influx
                  else
                    tmsb_gfluxout(ic,itmsb) = tmsb_gfluxout(ic,itmsb) - totgflux(ic)  !outflux
                  end if

                  if (gas_advection) then
                    if (totgaflux(ic).gt.r0) then
                      tmsb_gafluxin(ic,itmsb) = tmsb_gafluxin(ic,itmsb) + totgaflux(ic)    !influx
                    else
                      tmsb_gafluxout(ic,itmsb) = tmsb_gafluxout(ic,itmsb) - totgaflux(ic)  !outflux
                    end if
                  endif
                end do
              end if
            end do
          end if

        end do                           !boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(gfluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxin(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(gfluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxout(1:n) = mpireduce_n(1:n)
      
      if (ng .gt. 0 .and. gas_advection) then
        call MPI_Allreduce(gafluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gafluxin(1:n) = mpireduce_n(1:n)
      
        call MPI_Allreduce(gafluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM, &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gafluxout(1:n) = mpireduce_n(1:n)
      end if

!c  sum up total mass through specified boundary
      if (ntmsb > 0) then
        do itmsb = 1, ntmsb
          call MPI_Allreduce(tmsb_gfluxin(1:n,itmsb),mpireduce_n,n,    &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_gfluxin(1:n,itmsb) = mpireduce_n(1:n)

          call MPI_Allreduce(tmsb_gfluxout(1:n,itmsb),mpireduce_n,n,   &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_gfluxout(1:n,itmsb) = mpireduce_n(1:n)

          if (ng .gt. 0 .and. gas_advection) then
            call MPI_Allreduce(tmsb_gafluxin(1:n,itmsb),mpireduce_n,n, &
                     MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            tmsb_gafluxin(1:n,itmsb) = mpireduce_n(1:n)

            call MPI_Allreduce(tmsb_gafluxout(1:n,itmsb),mpireduce_n,n,&
                     MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            tmsb_gafluxout(1:n,itmsb) = mpireduce_n(1:n)
          end if
        end do
      end if
#endif

!c  change in storage [moles/unit time]
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_5)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, ic)                                          &
    !$omp reduction (+:gstordiff)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
#ifdef PETSC 
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if 
#endif
            
          do ic = 1,n
            gstordiff(ic) = gstordiff(ic)                             &
     &                    + conv3 * cvol(ivol)/delt                   &
     &                    * (bulkconc(totgnew(ic,ivol),               &
     &                                sgnew(ivol),                    &
     &                                pornew(ivol))                   &
     &                    -  bulkconc(totgold(ic,ivol),               &
     &                                sgold(ivol),                    &
     &                                porold(ivol)))
          end do
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
        call MPI_Allreduce(gstordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM, &
                         Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gstordiff(1:n) = mpireduce_n(1:n) 
#endif


!c  mass loss due to degassing

        if (gas_removal) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_6)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ic, ivol, totrateg)                           &
    !$omp reduction (+:gdegas)
    !$omp do schedule(static) 
#endif
          do ivol = 1,nngl 
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
              
#ifdef OPENMP    
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif

            if (density_dependence) then
              call rategasd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),      &
                            sgnew(ivol),tid)
            else
              call rategas(gnew(1,ivol),tkel(ivol),hhead(ivol),        &
                           zg(ivol),sgnew(ivol),tid)
            end if

            call totconcg(rateg(:,tid),totrateg)

!c  scale total rates for removal af aqueous components due to
!c  degassing [mol L^-1 bulk s^-1]
            do ic = 1,n
              gdegas(ic) = gdegas(ic) + conv3 * cvol(ivol)             &
     &                   * bulkconc(totrateg(ic),sanew(ivol),          &
     &                              pornew(ivol))
            end do

          end do               !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif      

#ifdef PETSC
          call MPI_Allreduce(gdegas, mpireduce_n,n,MPI_REAL8,MPI_SUM,  &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          gdegas(1:n) = mpireduce_n(1:n) 
#endif

!c  compress total rates for removal of aqueous components
!c  due to degassing in case of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(gdegas)
          end if

        end if                 !(gas_removal)

!c  mass loss due to first order gas decay
        if (b_use_gas_decay) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_6)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ic, ig, ivol, gasdecayrate, gasdecayratetot)  &
    !$omp reduction (+:totgasdecay)
    !$omp do schedule(static) 
#endif
          do ivol = 1,nngl 
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
              
#ifdef OPENMP    
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif

            do ig = 1, ng
              gasdecayrate(ig) = gnew(ig,ivol)/delt*                   &
                                 (1.0d0-enat**(-gasdecayconst(ig)*delt))
            end do
         
!c  compute gaseous components concentration 
!c  due to gas decay [mol L^-1 bulk s^-1]

            call totconcg(gasdecayrate,gasdecayratetot)

            do ic = 1,n
              totgasdecay(ic) = totgasdecay(ic) + cvol(ivol) *         &
                                bulkconc(gasdecayratetot(ic),          &
                                         sgnew(ivol),pornew(ivol))
            end do

          end do               !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif      

#ifdef PETSC
          call MPI_Allreduce(totgasdecay, mpireduce_n,n,MPI_REAL8,MPI_SUM,  &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          totgasdecay(1:n) = mpireduce_n(1:n) 
#endif
        end if

!c  total contributions due to exchange with gaseous phase

        do ic = 1,n
          gdiff(ic) = gfluxin(ic) - gfluxout(ic) - gstordiff(ic)      &
     &              - gdegas(ic) - totgasdecay(ic)
          
          if (ng .gt. 0 .and. gas_advection) then
            gdiff(ic) = gdiff(ic) + gafluxin(ic) - gafluxout(ic)
          endif        
        end do

      end if                                             !(ng.gt.0)
 
!c  total source-sink term due to intra-aqueous kinetic reactions
!c  [moles/unit time]

      if (naq.gt.0.or.nr.gt.0.and..not.redox_equil) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_7)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, iaq, ic, ir, ivol, ix, totor)                 &
    !$omp reduction (+:ordiff,intradiff)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
            
#ifdef OPENMP
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif

!c  exclude first type boundary control volumes

          if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

            if (temp_corr.or.heat_transport) then
              call tcorr(tkel(ivol),ivol,tid)
            end if

!c  recompute activity coefficients

            if (update_activity(tid).eq.'double_update') then
               if (ispitzer) then 
                     call pitzer (phase,gamma(1:nc,ivol),             &
                                  gamma(nc+1:nc+nx,ivol),             &
                                  cnew(1:nc,ivol),cx(1:nx,ivol),      &
                                  nc,nx,ilog)
               else
!c  --> for free species

                  do ic=1,nc
                     gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),  &
                                      sionnew(ivol),chargec(ic),      &
                                      dhac(ic),dhbc(ic),              &
                                      dhad(tid),dhbd(tid),            &
                                      adav,bdav,acth2omin,nc,         &
                                      nx,namec(ic),namec,ic,          &
     &                                issit,asit,basit,coepsil,       &
     &                                iasit,jasit)
                  end do

!c  --> for secondary aqueous species

                  do ix=1,nx
                    gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
                                        sionnew(ivol),chargex(ix),    &
                                        dhax(ix),dhbx(ix),            &
                                        dhad(tid),dhbd(tid),          &
                                        adav,bdav,acth2omin,nc,       &
                                        nx,namex(ix),namec,           &
     &                                  nc+ix,issit,asit,basit,       &
     &                                  coepsil,iasit,jasit)
                  end do
                end if 
            end if

!c  overall oxidation-reduction rates for redox couples

            if (nr.gt.0) then

              do ir = 1,nr
                call rateredx(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),  &
     &                        gamma(nc+1,ivol),rateor(ir,tid),        &
     &                        totcnew(1,ivol),ir,tid)
              end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to oxidation-reduction reactions

              call totredx(totor,tid,idbg)

!c  scale total source-sink term due to oxidation-reduction reactions
!c  and sum up over control volumes
              do ic = 1,n
                totor(ic) = conv3 * cvol(ivol) * bulkconc(totor(ic),   &
                            sanew(ivol),pornew(ivol))
                ordiff(ic) = ordiff(ic) - totor(ic)
              end do
           end if          !(nr.gt.0)

!c  reaction rates of intra-aqueous kinetic reactions

            if (naq.gt.0) then

              do iaq = 1,naq
                if (new_database) then
                  call rateint_new(rateaq(iaq,tid),totcnew(1,ivol),   &
                                   cnew(1,ivol),cx(1,ivol),           &
                                   gamma(1,ivol),gamma(nc+1,ivol),    &
                                   phi(1,ivol),iaq,                   &
                                   scalfac_aq_ivol(iaq,ivol),         &
                                   sanew(ivol),pornew(ivol),tid)             
                else
                  call rateint(rateaq(iaq,tid),totcnew(1,ivol),       &
                               cnew(1,ivol),gamma(1,ivol),            &
                               phi(1,ivol),iaq,                       &
                               scalfac_aq_ivol(iaq,ivol),tid)
                end if
              end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions

              call totint(totaq(:,tid),tid,idbg)

!c  scale total source-sink term due to intra-aqueous kinetic
!c  reactions and sum up over control volumes
              do ic = 1,n
                totaq(ic,tid) = conv3 * cvol(ivol) *                   &
                                bulkconc(totaq(ic,tid), sanew(ivol),   &
                                pornew(ivol))
                !cdsu 2019-06-26
                !separate this term from oxidation/reduction term
                !ordiff(ic) = ordiff(ic) - totaq(ic,tid)
                intradiff(ic) = intradiff(ic) - totaq(ic,tid)
              end do

            end if         !(naq.gt.0)

          end if           !exclude first type boundary control volumes

        end do             !number of control volumes
#ifdef OPENMP        
      !$omp end do
      !$omp end parallel  
#endif

#ifdef PETSC
        if (nr.gt.0) then
          call MPI_Allreduce(ordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,  &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          ordiff(1:n) = mpireduce_n(1:n)
        end if

        if (naq.gt.0) then
          call MPI_Allreduce(intradiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,&
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          intradiff(1:n) = mpireduce_n(1:n)
        end if
#endif

      end if               !(nr.gt.0)
      
!c root respiration related code
!c DO NOT put this initialization inside parallel loop
      rootresp = r0
      rootresp_zn = r0

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_8)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol, izn,                                     &
    !$omp qrootloc, rootresp_current, rootresp_max, rootresp_allowed)
#endif
      
!c  total source-sink term due to sorption reactions
!c  non-competitive sorption
!c  [moles/unit time]

      if (noncompetitive_sorption) then
#ifdef OPENMP
    !$omp do schedule(static) reduction (+:sbdiff)
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
!c  exclude first type boundary control volumes

          if (btypert(ivol).ne.'first') then
            
            do ic = 1,n
              sbdiff(ic) = sbdiff(ic) - conv3 * cvol(ivol)/delt       &
                         * (totanew(ic,ivol) -  totaold(ic,ivol))
            end do

          end if           !exclude first type boundary control volumes

        end do             !loop over control volumes
#ifdef OPENMP        
    !$omp end do
#endif  

#ifdef OPENMP
    !$omp barrier
#endif

      end if

!c  total source-sink term due to sorption reactions
!c  competitive sorption
!c  [moles/unit time]

      if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
        
        if (sorption_group.eq.'surface-complexation'.or.(nsb_surf.gt.0 &
            .and.sorption_group.eq.'surface-complex and ion-exchange')) then  
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:sbdiff)
#endif             
            do ivol = 1,nngl
#ifdef PETSC  
              if(node_idx_lg2l(ivol) < 0) then
                  cycle
              end if
#endif
!c  exclude first type boundary control volumes

              if (btypert(ivol).ne.'first') then
                do ic = 1,n
                    sbdiff(ic) = sbdiff(ic) - conv3 * cvol(ivol)/delt           &
                              * (sanew(ivol)*pornew(ivol)*totsnew_surf(ic,ivol) &
                              -  saold(ivol)*porold(ivol)*totsold_surf(ic,ivol))
                end do

              end if           !exclude first type boundary control volumes

            end do             !loop over control volumes 
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif
        end if
            
        if (sorption_group.eq.'ion-exchange'.or.(nsb_ion.gt.0 &
            .and.sorption_group.eq.'surface-complex and ion-exchange')) then  
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:sbdiff)
#endif         
            do ivol = 1,nngl
#ifdef PETSC
              if(node_idx_lg2l(ivol) < 0) then
                  cycle
              end if
#endif
!c  exclude first type boundary control volumes

              if (btypert(ivol).ne.'first') then
                do ic = 1,n
                    sbdiff(ic) = sbdiff(ic) - conv3 * cvol(ivol)/delt        &
                               * (totsnew_ion(ic,ivol)-totsold_ion(ic,ivol))
                end do

              end if           !exclude first type boundary control volumes

            end do             !loop over control volumes 
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
        end if  

      end if               !(nsb.gt.0)  

!c  total source-sink term due to dissolution-precipitation
!c  reactions [moles/unit time]
 
      if (nm.gt.0) then
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:dpdiff)
#endif   
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
!c  exclude first type boundary control volumes

          if (btypert(ivol).ne.'first') then

            do ic = 1,n
              dpdiff(ic) = dpdiff(ic)                                 &
     &                   - conv3 * cvol(ivol) * totmdp(ic,ivol)
            end do

          end if           !exclude first type boundary control volumes
 
        end do             !loop over control volumes
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
      end if               !(nm.gt.0)

!croot - passive solute uptake !HG
      if (passive_uptake) then
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:rootdiff, rootdiff_zn)
#endif 
        do ivol = 1,nngl 
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
          izn = mpropvs(ivol)
          if (btypert(ivol).ne.'first' .and. rld(ivol) >rverysmall) then 
            !c root uptake, positive means source and negative means sink here
            qrootloc = - cvol(ivol)*rootwat(sanew,ivol,rsum_vprop)*conv3
            if (rootwateruptake_field) then
              qrootloc = qrootloc*uptakefactor_vol(ivol)
            else
              qrootloc = qrootloc*uptakefactor(mpropvs(ivol))
            end if            

            do ic = 1,n     
              rootdiff(ic) = rootdiff(ic) + qrootloc*totcnew(ic,ivol) 
              rootdiff_zn(ic,izn) = rootdiff_zn(ic,izn) + qrootloc*totcnew(ic,ivol)
            end do 
          end if   
        end do 
#ifdef OPENMP
    !$omp end do
#endif  
      end if

      if (root_uptake) then 
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:rootresp,rootresp_zn)
#endif 
        do ivol = 1,nngl 
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
          if (rld(ivol) >rverysmall) then
            izn = mpropvs(ivol)
            do ic = 1,n    
              !c absorption or exudation by root
              !c convert rld(ivol)*resprate(ic,izn) from mol/m^3 to mol/L bulk             
              if (resprate(ic,izn) < 0) then        !exudation by root
                rootresp_allowed = - cvol(ivol)*rld(ivol)*resprate(ic,izn)
                rootresp(ic) = rootresp(ic) + rootresp_allowed
                rootresp_zn(ic,izn) = rootresp_zn(ic,izn) + rootresp_allowed
              else                              !respiration by root 
                rootresp_current = cvol(ivol)*rld(ivol)*resprate(ic,izn)             !mol/day
                rootresp_max = (totcnew(ic,ivol)-                          &
                                max(rverysmall,totc_uptake_min(ic,izn)))*  &
                                conv3*cvol(ivol)*pornew(ivol)*sanew(ivol)/delt   !mol/day
                rootresp_allowed = - min(rootresp_current,max(rootresp_max,r0))

                rootresp(ic) = rootresp(ic) + rootresp_allowed   !mol/day
                rootresp_zn(ic,izn) = rootresp_zn(ic,izn) + rootresp_allowed
              end if
            end do 
          end if   
        end do  
#ifdef OPENMP
    !$omp end do
#endif
      end if

#ifdef OPENMP
    !$omp end parallel
#endif   

#ifdef PETSC
      call MPI_Allreduce(sbdiff,mpireduce_n,n,MPI_REAL8,MPI_SUM,       &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      sbdiff(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(dpdiff,mpireduce_n,n,MPI_REAL8,MPI_SUM,       &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      dpdiff(1:n) = mpireduce_n(1:n)  

      if (passive_uptake) then
        call MPI_Allreduce(rootdiff,mpireduce_n,n,MPI_REAL8,MPI_SUM,   &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rootdiff(1:n) = mpireduce_n(1:n) 

        do izn = 1, nzn
          call MPI_Allreduce(rootdiff_zn(:,izn),mpireduce_n,n,         &
                            MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          rootdiff_zn(1:n,izn) = mpireduce_n(1:n)
        end do
      end if

      if (root_uptake) then
        call MPI_Allreduce(rootresp,mpireduce_n,n,MPI_REAL8,MPI_SUM,   &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rootresp(1:n) = mpireduce_n(1:n)
        
        do izn = 1, nzn
          call MPI_Allreduce(rootresp_zn(:,izn),mpireduce_n,n,         &
                             MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          rootresp_zn(1:n,izn) = mpireduce_n(1:n)
        end do
      end if
#endif

!c  total root respiration uptake over time
      if (root_uptake) then
        totrootresp(1:nc-1) = totrootresp(1:nc-1) + rootresp(1:nc-1)*delt
      end if

!c root respiration and uptake
      if (root_uptake) then
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
          if (b_output_trans_binary) then
            nvarsiresp = 2*(nc-1)+1
            realbuffer_gb(1:nvarsiresp) = (/time_io,rootresp(1:nc-1),  &
                                            totrootresp(1:nc-1)/)

            call binary_write_data(iresp_mpi, 1,                       &
                         (/mtime/),offset_iresp_ijk,.true.)
            call binary_write_data(iresp_mpi, nvarsiresp,              &
                         realbuffer_gb,offset_iresp,.true.) 

            offset_iresp = offset_iresp + nvarsiresp*nfloatbit

          else
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(iresp,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(iresp,irecord,time_io_rs)
                read(iresp,*,end=10,err=10) rdummys(1:2*nc-1)
                !c reposition to the line to append results
                call reposition_file(iresp,irecord)

                !c summation for accumulative root respiration uptke
                totrootresp(1:nc-1) = totrootresp(1:nc-1) + rdummys(nc+1:2*nc-1)
              end if
10            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(iresp,ascii_fmt) time_io,rootresp(1:nc-1),         &
                                     totrootresp(1:nc-1)
            end if
          end if
        end if
      end if

!c  total solute uptake by passive uptake and respiration
      if (root_uptake .or. passive_uptake) then
        rootuptake(1:nc-1) = -(rootdiff(1:nc-1) + rootresp(1:nc-1))

        totrootuptake(1:nc-1) = totrootuptake(1:nc-1) + rootuptake(1:nc-1)*delt

        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
          if (b_output_trans_binary) then
            nvarsirup = 2*(nc-1)+1
            realbuffer_gb(1:nvarsirup) = (/time_io,rootuptake(1:nc-1), &
                                          totrootuptake(1:nc-1)/)

            call binary_write_data(irup_mpi, 1,                        &
                         (/mtime/),offset_irup_ijk,.true.)
            call binary_write_data(irup_mpi, nvarsirup,                &
                         realbuffer_gb,offset_irup,.true.) 

            offset_irup = offset_irup + nvarsirup*nfloatbit

          else
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(irup,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(irup,irecord,time_io_rs)
                read(irup,*,end=12,err=12) rdummys(1:2*nc-1)
                !c reposition to the line to append results
                call reposition_file(irup,irecord)

                !c summation for accumulative total root uptake
                totrootuptake(1:nc-1) = totrootuptake(1:nc-1) +        &
                                        rdummys(nc+1:2*nc-1)
              end if
12            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(irup,ascii_fmt) time_io,rootuptake(1:nc-1),        &
                                    totrootuptake(1:nc-1)
            end if
          end if
        end if

!cdsu recyclable component-mineral uptake and return
        totrcm_temp = r0

        if (ircm_tz >= 1 .and. ircm_tz <= nrcm_tz .and.                &
            (ircm_stage == 1 .or. ircm_stage == 2)) then
          do izn = 1, nzn    
            ivar = 0
            do ic = 1, nc
              if (rcmpair_c(ic)) then
                ivar = ivar + 1
                if (exclude_return_uptake .and. ircm_stage == 2) then
                  valid_rup = r0
                else
                  valid_rup = -(rootdiff_zn(ic,izn) + rootresp_zn(ic,izn))
                end if

                totrcm_c_tz(ivar) = totrcm_c_tz(ivar) + valid_rup*delt
                totrcm_c(ivar) = totrcm_c(ivar) + valid_rup*delt

                totrcm_c_nz(ivar,izn) = totrcm_c_nz(ivar,izn) + valid_rup*delt

                if (ircm_stage == 1) then
                  delt_rcm = rcm_time(3,ircm_tz)- rcm_time(2,ircm_tz)
                  if (delt_rcm >= deltmin) then
                    totrcm_c_ave1st(ivar,izn) = totrcm_c_nz(ivar,izn)/delt_rcm
                  else
                    totrcm_c_ave1st(ivar,izn) = r0
                  end if

                else if (ircm_stage == 2) then
                  istart = iarcm(ic)+1
                  iend = iarcm(ic+1)
                  do ircm = istart, iend
                    im = jarcm(ircm)

                    if (rcm_xnum_coeff(ircm) > r0) then
                      totrcm_temp(im,izn) =                            &
                        (valid_rup+totrcm_c_ave1st(ivar,izn))*delt*    &
                        rcm_distri_coeff(ircm,izn)/rcm_xnum_coeff(ircm)
                    end if
                  end do
                end if
              end if              
            end do

            !c calculate component uptake and mineral return in the current cycle and elapsed cycles
            ivar = 0
            do im = 1, nm
              if (rcmpair_m(im)) then
                ivar = ivar + 1
                totrcm_m_tz(ivar) = totrcm_m_tz(ivar) + totrcm_temp(im,izn)
                totrcm_m(ivar) = totrcm_m(ivar) + totrcm_temp(im,izn)
              end if
            end do
          end do

          !c calculate mineral return rate to the specified recycle location
          do izn = 1, nzn
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, im)
    !$omp do schedule(static)
#endif 
            do ivol = 1, nngl
              if (ibits(rcm_flag_cvol(ivol),izn-1,1) > 0) then
                do im = 1, nm
                  if (totrcm_temp(im,izn) > r0) then
                    cmnew(im,ivol) = cmnew(im,ivol) +                    &
                          totrcm_temp(im,izn)/(rcm_totcvol(izn)*conv3)
                    phi(im,ivol) = cmnew(im,ivol)*gfwm(im)/(densm(im)*conv3)
                  end if              
                end do
              end if
            end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
          end do
        end if

        if(nrcm_tz > 0 .and. rank == 0 .and. b_enable_output .and.     &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
          if (b_output_trans_binary) then
            nvarsirupcm = 2*(nrcm_nc+nrcm_nm)+1
            realbuffer_gb(1:nvarsirupcm) = (/time_io,                  &
                       totrcm_c_tz(1:nrcm_nc),totrcm_c(1:nrcm_nc),     &
                       totrcm_m_tz(1:nrcm_nm),totrcm_m(1:nrcm_nm)/)

            call binary_write_data(irupcm_mpi, 1,                      &
                         (/mtime/),offset_irupcm_ijk,.true.)
            call binary_write_data(irupcm_mpi, nvarsirupcm,            &
                         realbuffer_gb,offset_irupcm,.true.) 

            offset_irupcm = offset_irupcm + nvarsirupcm*nfloatbit

          else
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(irupcm,irecord)

              if (irecord > 0) then
                nvarsirupcm = 2*(nrcm_nc+nrcm_nm)+1
                !c locate to the restart time and get previous results
                call reposition_file(irupcm,irecord,time_io_rs)
                read(irupcm,*,end=14,err=14) rdummys(1:nvarsirupcm)
                !c reposition to the line to append results
                call reposition_file(irupcm,irecord)

                !c summation for accumulative total root uptake is read from restart append data.
              end if
14            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(irupcm,ascii_fmt) time_io,totrcm_c_tz(1:nrcm_nc),  &
                                      totrcm_c(1:nrcm_nc),             &
                                      totrcm_m_tz(1:nrcm_nm),          &
                                      totrcm_m(1:nrcm_nm)
            end if
          end if
        end if
        
      end if 

!c  noble gas ingrowth
      if (b_use_ngi) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ic, ingi, ivol, totaq_ngi)                    &
    !$omp reduction (+:ngidiff)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl 
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif

#ifdef OPENMP
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif

          do ingi = 1, ngi
            ic = noble_gas_ingrowth(ingi)%idx_namec
            !totaq_ngi(ic,tid) = -conv3*cvol(ivol) * bulkconc(          &
            !                    totRateNobleGas(ingi,ivol),r1,         &
            !                    r1-pornew(ivol))
            totaq_ngi(ic,tid) = -conv3*cvol(ivol) * totRateNobleGas(ingi,ivol)
            ngidiff(ic) = ngidiff(ic) - totaq_ngi(ic,tid)
          end do
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
        call MPI_Allreduce(ngidiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        ngidiff(1:n) = mpireduce_n(1:n)
#endif
      end if


      do ic = 1,n

!c compute accumulative changes over time
        totcfluxin(ic) = totcfluxin(ic) + cfluxin(ic)*delt
        totcfluxout(ic) = totcfluxout(ic) + cfluxout(ic)*delt
        totcstordiff(ic) = totcstordiff(ic) + cstordiff(ic)*delt
        totordiff(ic) = totordiff(ic) + ordiff(ic)*delt
        totintradiff(ic) = totintradiff(ic) + intradiff(ic)*delt
        totdpdiff(ic) = totdpdiff(ic) + dpdiff(ic)*delt
        totsbdiff(ic) = totsbdiff(ic) + sbdiff(ic)*delt
        totngidiff(ic) = totngidiff(ic) + ngidiff(ic)*delt

        if(passive_uptake) then
          ! passive uptake change HG
          totrootdiff(ic) = totrootdiff(ic) + rootdiff(ic)*delt
        end if
        
        if (ng.gt.0) then ! for lattice run time error thh 4/12/05
          totgdiff(ic) = totgdiff(ic) + gdiff(ic)*delt
          totgfluxin(ic) = totgfluxin(ic) + gfluxin(ic)*delt
          totgfluxout(ic) = totgfluxout(ic) + gfluxout(ic)*delt
          totgafluxin(ic) = totgafluxin(ic) + gafluxin(ic)*delt
          totgafluxout(ic) = totgafluxout(ic) + gafluxout(ic)*delt
          totgstordiff(ic) = totgstordiff(ic) + gstordiff(ic)*delt
          totgdegas(ic) = totgdegas(ic) + gdegas(ic)*delt
        else
          totgdiff(ic) = r0
          totgfluxin(ic) = r0
          totgfluxout(ic) = r0
          totgafluxin(ic) = r0
          totgafluxout(ic) = r0
          totgstordiff(ic) = r0
          totgdegas(ic) = r0
          gdiff(ic)= r0
          gfluxin(ic)= r0
          gfluxout(ic)= r0
          gstordiff(ic)= r0
          gdegas(ic)= r0
        end if

!c compute accumulative mass through sepcified boundary

!c  write results
 
        imrt = imrt+1
      
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
        if (b_output_trans_binary) then
          if (ng .gt. 0 .and. gas_advection) then
            nvarsimrt = 33
            realbuffer_gb(1:nvarsimrt) = (/time_io,cfluxin(ic),         &
                                      cfluxout(ic),cstordiff(ic),       &
                                      ordiff(ic),intradiff(ic),         &
                                      dpdiff(ic),gdiff(ic),             &
                                      gfluxin(ic),gfluxout(ic),         &
                                      gafluxin(ic),gafluxout(ic),       &
                                      gstordiff(ic),gdegas(ic),         &
                                      sbdiff(ic),rootdiff(ic),          &
                                      ngidiff(ic),                      &
                                      totcfluxin(ic),totcfluxout(ic),   &
                                      totcstordiff(ic),totordiff(ic),   &
                                      totintradiff(ic),totdpdiff(ic),   &
                                      totgdiff(ic),totgfluxin(ic),      &
                                      totgfluxout(ic),totgafluxin(ic),  &
                                      totgafluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic),      &
                                      totrootdiff(ic),totngidiff(ic)/)
          else
            nvarsimrt = 29
            realbuffer_gb(1:nvarsimrt) = (/time_io,cfluxin(ic),        &
                                      cfluxout(ic),cstordiff(ic),      &
                                      ordiff(ic),intradiff(ic),        &
                                      dpdiff(ic),gdiff(ic),            &
                                      gfluxin(ic),gfluxout(ic),        &
                                      gstordiff(ic),gdegas(ic),        &
                                      sbdiff(ic),rootdiff(ic),         &
                                      ngidiff(ic),                     &
                                      totcfluxin(ic),totcfluxout(ic),  &
                                      totcstordiff(ic),totordiff(ic),  &
                                      totintradiff(ic),totdpdiff(ic),  &
                                      totgdiff(ic),totgfluxin(ic),     &
                                      totgfluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic),     &
                                      totrootdiff(ic),totngidiff(ic)/)

          end if

          call binary_write_data(imrt_mpi(imrt), 1,            &
                       (/mtime/),offset_imrt_ijk(imrt),.true.)
          call binary_write_data(imrt_mpi(imrt), nvarsimrt,    &
                       realbuffer_gb,offset_imrt(imrt),.true.) 

          offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

        else
          if (ng .gt. 0 .and. gas_advection) then
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(imrt,irecord,time_io_rs)
                read(imrt,*,end=18,err=18) rdummys(1:33)
                !c reposition to the line to append results
                call reposition_file(imrt,irecord)

                totcfluxin(ic) = totcfluxin(ic) + rdummys(18)
                totcfluxout(ic) = totcfluxout(ic) + rdummys(19)
                totcstordiff(ic) = totcstordiff(ic) + rdummys(20)
                totordiff(ic) = totordiff(ic) + rdummys(21)
                totintradiff(ic) = totintradiff(ic) + rdummys(22)
                totdpdiff(ic) = totdpdiff(ic) + rdummys(23)
                totgdiff(ic) = totgdiff(ic) + rdummys(24)
                totgfluxin(ic) = totgfluxin(ic) + rdummys(25)
                totgfluxout(ic) = totgfluxout(ic) + rdummys(26)
                totgafluxin(ic) = totgafluxin(ic) + rdummys(27)
                totgafluxout(ic) = totgafluxout(ic) + rdummys(28)
                totgstordiff(ic) = totgstordiff(ic) + rdummys(29)
                totgdegas(ic) = totgdegas(ic) + rdummys(30)
                totsbdiff(ic) = totsbdiff(ic) + rdummys(31)
                totrootdiff(ic) = totrootdiff(ic) + rdummys(32)
                totngidiff(ic) = totngidiff(ic) + rdummys(33)
              end if
18            continue
            end if

            if (i_append_sim < 1 .or.                                   &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,cfluxin(ic),                &
                                      cfluxout(ic),cstordiff(ic),       &
                                      ordiff(ic),intradiff(ic),         &
                                      dpdiff(ic),gdiff(ic),             &
                                      gfluxin(ic),gfluxout(ic),         &
                                      gafluxin(ic),gafluxout(ic),       &
                                      gstordiff(ic),gdegas(ic),         &
                                      sbdiff(ic),rootdiff(ic),          &
                                      ngidiff(ic),                      &
                                      totcfluxin(ic),totcfluxout(ic),   &
                                      totcstordiff(ic),totordiff(ic),   &
                                      totintradiff(ic),totdpdiff(ic),   &
                                      totgdiff(ic),totgfluxin(ic),      &
                                      totgfluxout(ic),totgafluxin(ic),  &
                                      totgafluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic),      &
                                      totrootdiff(ic),totngidiff(ic)
            end if
          else
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(imrt,irecord,time_io_rs)
                read(imrt,*,end=20,err=20) rdummys(1:29)
                !c reposition to the line to append results
                call reposition_file(imrt,irecord)

                totcfluxin(ic) = totcfluxin(ic) + rdummys(16)
                totcfluxout(ic) = totcfluxout(ic) + rdummys(17)
                totcstordiff(ic) = totcstordiff(ic) + rdummys(18)
                totordiff(ic) = totordiff(ic) + rdummys(19)
                totintradiff(ic) = totintradiff(ic) + rdummys(20)
                totdpdiff(ic) = totdpdiff(ic) + rdummys(21)
                totgdiff(ic) = totgdiff(ic) + rdummys(22)
                totgfluxin(ic) = totgfluxin(ic) + rdummys(23)
                totgfluxout(ic) = totgfluxout(ic) + rdummys(24)
                totgstordiff(ic) = totgstordiff(ic) + rdummys(25)
                totgdegas(ic) = totgdegas(ic) + rdummys(26)
                totsbdiff(ic) = totsbdiff(ic) + rdummys(27)
                totrootdiff(ic) = totrootdiff(ic) + rdummys(28)
                totngidiff(ic) = totngidiff(ic) + rdummys(29)
              end if
20            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,cfluxin(ic),               &
                                      cfluxout(ic),cstordiff(ic),      &
                                      ordiff(ic),intradiff(ic),        &
                                      dpdiff(ic),gdiff(ic),            &
                                      gfluxin(ic),gfluxout(ic),        &
                                      gstordiff(ic),gdegas(ic),        &
                                      sbdiff(ic),rootdiff(ic),         &
                                      ngidiff(ic),                     &                                      
                                      totcfluxin(ic),totcfluxout(ic),  &
                                      totcstordiff(ic),totordiff(ic),  &
                                      totintradiff(ic),totdpdiff(ic),  &
                                      totgdiff(ic),totgfluxin(ic),     &
                                      totgfluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic),     &
                                      totrootdiff(ic),totngidiff(ic)
            end if
          end if
        end if
        end if
      
      end do

!c  absolute mass balance error [moles/time unit]
!c  relative mass balance error in [%] = [moles/moles in system] x 100
!c  accumulative mass balance error [moles]
!c  relative accumulative mass balance error in [%] = 
!c  [moles/moles in system] x 100
 
      do ic = 1,n
        absbalance = (cfluxin(ic) - cfluxout(ic)                      &
                   - cstordiff(ic) + dpdiff(ic) + ordiff(ic)          &
                   + intradiff(ic) + gdiff(ic) + sbdiff(ic)           &
                   + rootdiff(ic)  + rootresp(ic)                     &
                   + ngidiff(ic)) * delt
        relbalance = dabs(absbalance)/tmass(ic)*r100
        cculabsbal(ic) = cculabsbal(ic) + absbalance
        cculrelbal(ic) = cculabsbal(ic)/tmass(ic)*r100
        imrt = imrt+1

        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        
        !Note: There is round-error in cstordiff in parallel version.
        !The different may be a little different in the following output. DSU
        
          if (b_output_trans_binary) then
            nvarsimrt = 5
            realbuffer_gb(1:nvarsimrt) = (/time_io,absbalance,         &
                                          relbalance,cculabsbal(ic),   &
                                          cculrelbal(ic)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)       
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
          else

            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(imrt,irecord,time_io_rs)

                read(imrt,*,end=30,err=30) rdummys(1:5)
                !c reposition to the line to append results
                call reposition_file(imrt,irecord)

                cculabsbal(ic) = cculabsbal(ic) + rdummys(4)
                cculrelbal(ic) = cculabsbal(ic)/tmass(ic)*r100
              end if
30            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,absbalance,                &
                                    relbalance,cculabsbal(ic),         &
                                    cculrelbal(ic)
            end if
          end if
        
        end if
        
      end do

!c  dilution index, accordingly to Ditanidis 1994
      if (b_dilution_index) then
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
          if (b_output_trans_binary) then
            nvarsidix = nc
            realbuffer_gb(1:nvarsidix) = (/time_io,tot_dix(1:nc-1)/)

            call binary_write_data(idix_mpi, 1,                        &
                         (/mtime/),offset_idix_ijk,.true.)
            call binary_write_data(idix_mpi, nvarsidix,                &
                         realbuffer_gb,offset_idix,.true.) 

            offset_idix = offset_idix + nvarsidix*nfloatbit

          else
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(idix,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(idix,irecord,time_io_rs)
                read(idix,*,end=32,err=32) rdummys(1:nc)
                !c reposition to the line to append results
                call reposition_file(idix,irecord)
              end if
32            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(idix,ascii_fmt) time_io,tot_dix(1:nc-1)
            end if
          end if
        end if
      end if

!c  spatial moment, accordingly to Goltz and Huang, 1987, WRR; Oware and Moysey 2014, Journal of Hydrology
      if (b_spatial_moment) then
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
          if (b_output_trans_binary) then
            nvarsispm = 1+(nc-1)*6
            realbuffer_gb(1) = time_io
            do ic = 1, nc-1
              realbuffer_gb((ic-1)*3+2) = plume_x(ic)
              realbuffer_gb((ic-1)*3+3) = plume_y(ic)
              realbuffer_gb((ic-1)*3+4) = plume_z(ic)
            end do

            do ic = 1, nc-1
              realbuffer_gb((nc-1)*3+(ic-1)*3+2) = spread_x(ic)
              realbuffer_gb((nc-1)*3+(ic-1)*3+3) = spread_y(ic)
              realbuffer_gb((nc-1)*3+(ic-1)*3+4) = spread_z(ic)
            end do

            call binary_write_data(ispm_mpi, 1,                        &
                         (/mtime/),offset_ispm_ijk,.true.)
            call binary_write_data(ispm_mpi, nvarsispm,                &
                         realbuffer_gb,offset_ispm,.true.) 

            offset_ispm = offset_ispm + nvarsispm*nfloatbit

          else
            !c read accumulative absolute mass balance error at the restart point
            !c For legacy mode, previous mass balance is read at restart point but
            !c will not output until the second restart point is reached

            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(ispm,irecord)

              if (irecord > 0) then
                !c locate to the restart time and get previous results
                call reposition_file(ispm,irecord,time_io_rs)
                read(ispm,*,end=34,err=34) rdummys(1:nc)
                !c reposition to the line to append results
                call reposition_file(ispm,irecord)
              end if
34            continue
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(ispm,ascii_fmt) time_io,                           &
                   (plume_x(ic),plume_y(ic),plume_z(ic),ic = 1,nc-1),  &
                   (spread_x(ic),spread_y(ic),spread_z(ic),ic = 1,nc-1)
            end if
          end if
        end if
      end if      

!c  total mass through specified boundary
      if (ntmsb > 0) then

        !c allocate memory since ntmsb is not available in mem_rt
        if (.not. allocated(tmsb_totcfluxin)) then
          allocate(tmsb_totcfluxin(n,ntmsb), stat = ierr)
          call checkerr(ierr,'tmsb_totcfluxin',ilog)
          tmsb_totcfluxin = r0
          call memory_monitor(sizeof(tmsb_totcfluxin),'tmsb_totcfluxin',.true.)
        end if

        if (.not. allocated(tmsb_totcfluxout)) then
          allocate(tmsb_totcfluxout(n,ntmsb), stat = ierr)
          call checkerr(ierr,'tmsb_totcfluxout',ilog)
          tmsb_totcfluxout = r0
          call memory_monitor(sizeof(tmsb_totcfluxout),'tmsb_totcfluxout',.true.)
        end if

        if (.not. allocated(tmsb_totgfluxin)) then
          allocate(tmsb_totgfluxin(n,ntmsb), stat = ierr)
          call checkerr(ierr,'tmsb_totgfluxin',ilog)
          tmsb_totgfluxin = r0
          call memory_monitor(sizeof(tmsb_totgfluxin),'tmsb_totgfluxin',.true.)
        end if

        if (.not. allocated(tmsb_totgfluxout)) then
          allocate(tmsb_totgfluxout(n,ntmsb), stat = ierr)
          call checkerr(ierr,'tmsb_totgfluxout',ilog)
          tmsb_totgfluxout = r0
          call memory_monitor(sizeof(tmsb_totgfluxout),'tmsb_totgfluxout',.true.)
        end if

        if (.not. allocated(tmsb_totgafluxin)) then
          allocate(tmsb_totgafluxin(n,ntmsb), stat = ierr)
          call checkerr(ierr,'tmsb_totgafluxin',ilog)
          tmsb_totgafluxin = r0
          call memory_monitor(sizeof(tmsb_totgafluxin),'tmsb_totgafluxin',.true.)
        end if

        if (.not. allocated(tmsb_totgafluxout)) then
          allocate(tmsb_totgafluxout(n,ntmsb), stat = ierr)
          call checkerr(ierr,'tmsb_totgafluxout',ilog)
          tmsb_totgafluxout = r0
          call memory_monitor(sizeof(tmsb_totgafluxout),'tmsb_totgafluxout',.true.)
        end if

        do itmsb = 1, ntmsb
          do ic = 1,n

!c compute accumulative changes over time
            tmsb_totcfluxin(ic,itmsb) = tmsb_totcfluxin(ic,itmsb) +        &
                                        tmsb_cfluxin(ic,itmsb)*delt
            tmsb_totcfluxout(ic,itmsb) = tmsb_totcfluxout(ic,itmsb) +      &
                                         tmsb_cfluxout(ic,itmsb)*delt

            if (ng.gt.0) then ! for lattice run time error thh 4/12/05
              tmsb_totgfluxin(ic,itmsb) = tmsb_totgfluxin(ic,itmsb) +      &
                                          tmsb_gfluxin(ic,itmsb)*delt
              tmsb_totgfluxout(ic,itmsb) = tmsb_totgfluxout(ic,itmsb) +    &
                                           tmsb_gfluxout(ic,itmsb)*delt
              tmsb_totgafluxin(ic,itmsb) = tmsb_totgafluxin(ic,itmsb) +    &
                                           tmsb_gafluxin(ic,itmsb)*delt
              tmsb_totgafluxout(ic,itmsb) = tmsb_totgafluxout(ic,itmsb) +  &
                                            tmsb_gafluxout(ic,itmsb)*delt
            else
              tmsb_gfluxin(ic,itmsb) = r0
              tmsb_gfluxout(ic,itmsb) = r0
              tmsb_gafluxin(ic,itmsb) = r0
              tmsb_gafluxout(ic,itmsb) = r0
              tmsb_totgfluxin(ic,itmsb) = r0
              tmsb_totgfluxout(ic,itmsb) = r0
              tmsb_totgafluxin(ic,itmsb) = r0
              tmsb_totgafluxout(ic,itmsb) = r0
            end if

!c compute accumulative mass through sepcified boundary

!c  write results

            imrt = imrt+1

            if(rank == 0 .and. b_enable_output .and.                       &
               .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then

              if (b_output_trans_binary) then
                if (ng .gt. 0 .and. gas_advection) then
                  nvarsimrt = 13
                  realbuffer_gb(1:nvarsimrt) = (/time_io,                  &
                                            tmsb_cfluxin(ic,itmsb),        &
                                            tmsb_cfluxout(ic,itmsb),       &
                                            tmsb_gfluxin(ic,itmsb),        &
                                            tmsb_gfluxout(ic,itmsb),       &
                                            tmsb_gafluxin(ic,itmsb),       &
                                            tmsb_gafluxout(ic,itmsb),      &
                                            tmsb_totcfluxin(ic,itmsb),     &
                                            tmsb_totcfluxout(ic,itmsb),    &
                                            tmsb_totgfluxin(ic,itmsb),     &
                                            tmsb_totgfluxout(ic,itmsb),    &
                                            tmsb_totgafluxin(ic,itmsb),    &
                                            tmsb_totgafluxout(ic,itmsb)/)
                else
                  nvarsimrt = 9
                  realbuffer_gb(1:nvarsimrt) = (/time_io,                  &
                                            tmsb_cfluxin(ic,itmsb),        &
                                            tmsb_cfluxout(ic,itmsb),       &
                                            tmsb_gfluxin(ic,itmsb),        &
                                            tmsb_gfluxout(ic,itmsb),       &
                                            tmsb_totcfluxin(ic,itmsb),     &
                                            tmsb_totcfluxout(ic,itmsb),    &
                                            tmsb_totgfluxin(ic,itmsb),     &
                                            tmsb_totgfluxout(ic,itmsb)/)

                end if

                call binary_write_data(imrt_mpi(imrt), 1,            &
                             (/mtime/),offset_imrt_ijk(imrt),.true.)
                call binary_write_data(imrt_mpi(imrt), nvarsimrt,    &
                             realbuffer_gb,offset_imrt(imrt),.true.)

                offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

              else
                if (ng .gt. 0 .and. gas_advection) then
                  !c read accumulative absolute mass balance error at the restart point
                  !c For legacy mode, previous mass balance is read at restart point but
                  !c will not output until the second restart point is reached
                  if (mtime == mtime_append .and. i_append_sim >= 1) then
                    call reposition_file(imrt,irecord)

                    if (irecord > 0) then
                      !c locate to the restart time and get previous results
                      call reposition_file(imrt,irecord,time_io_rs)
                      read(imrt,*,end=40,err=40) rdummys(1:13)
                      !c reposition to the line to append results
                      call reposition_file(imrt,irecord)

                      tmsb_totcfluxin(ic,itmsb) = tmsb_totcfluxin(ic,itmsb) + rdummys(8)
                      tmsb_totcfluxout(ic,itmsb) = tmsb_totcfluxout(ic,itmsb) + rdummys(9)
                      tmsb_totgfluxin(ic,itmsb) = tmsb_totgfluxin(ic,itmsb) + rdummys(10)
                      tmsb_totgfluxout(ic,itmsb) = tmsb_totgfluxout(ic,itmsb) + rdummys(11)
                      tmsb_totgafluxin(ic,itmsb) = tmsb_totgafluxin(ic,itmsb) + rdummys(12)
                      tmsb_totgafluxout(ic,itmsb) = tmsb_totgafluxout(ic,itmsb) + rdummys(13)
                    end if
40                  continue
                  end if

                  if (i_append_sim < 1 .or.                                  &
                     (mtime >= mtime_append .and. i_append_sim >= 1)) then
                    write(imrt,ascii_fmt) time_io,                           &
                                              tmsb_cfluxin(ic,itmsb),        &
                                              tmsb_cfluxout(ic,itmsb),       &
                                              tmsb_gfluxin(ic,itmsb),        &
                                              tmsb_gfluxout(ic,itmsb),       &
                                              tmsb_gafluxin(ic,itmsb),       &
                                              tmsb_gafluxout(ic,itmsb),      &
                                              tmsb_totcfluxin(ic,itmsb),     &
                                              tmsb_totcfluxout(ic,itmsb),    &
                                              tmsb_totgfluxin(ic,itmsb),     &
                                              tmsb_totgfluxout(ic,itmsb),    &
                                              tmsb_totgafluxin(ic,itmsb),    &
                                              tmsb_totgafluxout(ic,itmsb)
                  end if
                else
                  !c read accumulative absolute mass balance error at the restart point
                  !c For legacy mode, previous mass balance is read at restart point but
                  !c will not output until the second restart point is reached

                  if (mtime == mtime_append .and. i_append_sim >= 1) then
                    call reposition_file(imrt,irecord)

                    if (irecord > 0) then
                      !c locate to the restart time and get previous results
                      call reposition_file(imrt,irecord,time_io_rs)
                      read(imrt,*,end=50,err=50) rdummys(1:9)
                      !c reposition to the line to append results
                      call reposition_file(imrt,irecord)

                      tmsb_totcfluxin(ic,itmsb) = tmsb_totcfluxin(ic,itmsb) + rdummys(6)
                      tmsb_totcfluxout(ic,itmsb) = tmsb_totcfluxout(ic,itmsb) + rdummys(7)
                      tmsb_totgfluxin(ic,itmsb) = tmsb_totgfluxin(ic,itmsb) + rdummys(8)
                      tmsb_totgfluxout(ic,itmsb) = tmsb_totgfluxout(ic,itmsb) + rdummys(9)
                    end if
50                  continue
                  end if

                  if (i_append_sim < 1 .or.                                &
                     (mtime >= mtime_append .and. i_append_sim >= 1)) then
                    write(imrt,ascii_fmt)  time_io,                        &
                                              tmsb_cfluxin(ic,itmsb),      &
                                              tmsb_cfluxout(ic,itmsb),     &
                                              tmsb_gfluxin(ic,itmsb),      &
                                              tmsb_gfluxout(ic,itmsb),     &
                                              tmsb_totcfluxin(ic,itmsb),   &
                                              tmsb_totcfluxout(ic,itmsb),  &
                                              tmsb_totgfluxin(ic,itmsb),   &
                                              tmsb_totgfluxout(ic,itmsb)
                  end if
                end if
              end if
            end if

          end do
        end do
      end if
   
!c ----------------------------------------------------------------------
!c  compute mass balance for selected species in aqueous phase
!c  only if selected species are specified
!c ----------------------------------------------------------------------

      if (nmb.gt.0) then
    
        do imb = 1,nmb
          imrt = imrt + 1
        end do

      end if

!c ----------------------------------------------------------------------
!c  mass balance contributions - intra-aqueous kinetic reactions
!c ----------------------------------------------------------------------
  
      if (naq.gt.0) then

        call zero_r8 (rateaqtot,naq,1,1)

!c  reaction rates of intra-aqueous kinetic reactions
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_9)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol)                                          
#endif
        do iaq = 1,naq
          
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:rateaqtot)
#endif
          do ivol=1,nngl
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif

#ifdef OPENMP
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif  
          
!c  exclude first type boundary control volumes

            if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

              if (temp_corr.or.heat_transport) then
                call tcorr(tkel(ivol),ivol,tid)
              end if

!c  recompute reactions rates

              if (new_database) then
                call rateint_new(rateaq(iaq,tid),totcnew(1,ivol),      &
                                 cnew(1,ivol),cx(1,ivol),              &
                                 gamma(1,ivol),gamma(nc+1,ivol),       &
                                 phi(1,ivol),iaq,                      &
                                 scalfac_aq_ivol(iaq,ivol),            &
                                 sanew(ivol),pornew(ivol),tid)
              else
                call rateint(rateaq(iaq,tid),totcnew(1,ivol),          &
                             cnew(1,ivol),gamma(1,ivol),phi(1,ivol),   &
                             iaq,scalfac_aq_ivol(iaq,ivol),tid)
              end if

!c  sum up total reaction rate
              rateaqtot(iaq) = rateaqtot(iaq)                          &
                             - conv3 * cvol(ivol)                      &
                             * bulkconc(rateaq(iaq,tid),sanew(ivol),   &
                                      pornew(ivol))

            end if          !exclude first type boundary conditions    

          end do            !loop over control volumes
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
        end do              !iaq = 1,naq        
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
        call MPI_Allreduce(rateaqtot, mpireduce_naq,naq,MPI_REAL8,     &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rateaqtot(1:naq) = mpireduce_naq(1:naq) 
#endif

!c  sum up total accumulative contribution
        do iaq = 1,naq
          contaqtot(iaq) = contaqtot(iaq) + rateaqtot(iaq)*delt
        end do

        do iaq = 1,naq
          imrt = imrt+1 
          if(rank == 0 .and. b_enable_output .and.                     &
             .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
            if (b_output_trans_binary) then
              nvarsimrt = 3
              realbuffer_gb(1:nvarsimrt) = (/time_io, rateaqtot(iaq),  &
                                         contaqtot(iaq)/)
              call binary_write_data(imrt_mpi(imrt), 1,        &
                           (/mtime/),offset_imrt_ijk(imrt),.true.)
              call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                           realbuffer_gb,offset_imrt(imrt),.true.) 

              offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
            else 
              !c read accumulative absolute mass balance error at the restart point
              !c For legacy mode, previous mass balance is read at restart point but
              !c will not output until the second restart point is reached
              if (mtime == mtime_append .and. i_append_sim >= 1) then
                call reposition_file(imrt,irecord)
                if (irecord > 0) then
                  !c locate to the restart time and get previous results
                  call reposition_file(imrt,irecord,time_io_rs)
                  read(imrt,*,end=60,err=60) rdummys(1:3)
                  !c reposition to the line to append results
                  call reposition_file(imrt,irecord)

                  contaqtot(iaq) = contaqtot(iaq) + rdummys(3)
                end if
60              continue
              end if

              if (i_append_sim < 1 .or.                                &
                 (mtime >= mtime_append .and. i_append_sim >= 1)) then
                write(imrt,ascii_fmt) time_io,rateaqtot(iaq),          &
                                         contaqtot(iaq)
              end if
            end if
          end if
        end do  

      end if                !(naq.gt.0) 

!c ----------------------------------------------------------------------
!c  compute mass balance for gaseous phase
!c  only if gases are specified
!c ----------------------------------------------------------------------

      if (ng.gt.0) then

!c  clear arrays

        call zero_r8(gfluxin,ng,1,1)
        call zero_r8(gfluxout,ng,1,1)
        call zero_r8(gafluxin,ng,1,1)
        call zero_r8(gafluxout,ng,1,1)
        call zero_r8(gfluxtbdy,ng,1,1)      !This variable is never used
        call zero_r8(gstordiff,ng,1,1)
        call zero_r8(gdegas,ng,1,1)

        if (ntmsb > 0) then
          tmsb_gfluxin = r0
          tmsb_gfluxout = r0
          tmsb_gafluxin = r0
          tmsb_gafluxout = r0
        end if

!c  flux contributions [moles/time unit]
!c  (for now: advective flow components are negligible)
!c  (inflow/outflow occurs only where first type boundary is specified)
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mbalrt_10)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, idvol, kvol, ncell, ndvol, grad_gnew_hls_loc,        &
    !$omp grad_gnew_ivol, grad_gnew_jvol, grad_gnew_kvol,             &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc, permij_usg_loc,       &
    !$omp cinfrt_usg, cinfrt_usg_cross, grad_gnew_locs, grad_weights, &
    !$omp cinfrt_dg_usg_loc, cinfrt_dg_usg_cross_loc, grad_cgg_gnew,  &
#endif
    !$omp i1, ibrt, istart, iend, ig, ivol, jvol, tid, itmsb,         &
    !$omp densgij, gij, gmfracij, gpij, relpgij, relpgi, relpgj,      &
    !$omp totgflux, totgaflux, totgij, viscgij, so_av,                &
    !$omp gpivol_ivol, gdens_ivol, gvisc_ivol,                        &
    !$omp gpivol_jvol, gdens_jvol, gvisc_jvol,                        &
    !$omp cinfrt, dgm_gflux_s, ms_gflux_s, fmat, gflux_ig, ipvt,      &
    !$omp ludecomp, neflux, neflux_s, bdyinfrt_dg, diff_eff, diff_loc)
#endif

#ifdef OPENMP
    !$omp do schedule(static) reduction(+: gfluxtbdy,                 &
    !$omp gfluxin, gfluxout, gafluxin, gafluxout,                     &
    !$omp tmsb_gfluxin, tmsb_gfluxout, tmsb_gafluxin, tmsb_gafluxout)
#endif
        do ibrt = 1,nbrt                 !boundary control volumes
            
          ivol = jabrt(ibrt)             !pointer to control volume
          if (ivol < 0) then
            cycle
          end if

#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif

          if (compute_ice_sheet_loading) then
            if (.not. b_jabrt_ice(ibrt)) then
              cycle
            end if
          end if
          
          call zero_r8(totgflux,n,1,1)   !zero flux vector
          call zero_r8(totgaflux,n,1,1)  !zero flux vector

!c  Dirichlet type boundary conditions

          if (btypert(ivol).eq.'first') then

            istart = iavs(ivol)+1
            iend = iavs(ivol+1)-1

!c          gas advection variables
            if (gas_advection) then                
              !gpivol_ivol = gasp_m(mdens_g(ivol),ivol)           ! pressure
              !gdens_ivol  = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! density
              !gvisc_ivol  = gasv(gmfrac(:,ivol))                 ! viscosity
              gpivol_ivol = gpivol(ivol)                          ! pressure
              gdens_ivol  = gdens(ivol)                           ! density
              gvisc_ivol  = gvisc(ivol)                           ! viscosity
            else
              gpivol_ivol = 0.0d0
              gdens_ivol  = 0.0d0
              gvisc_ivol  = 0.0d0
            end if

            do i1 = istart,iend        !loop over local connections

              jvol = javs(i1)

!c            gas advection variables
              if (gas_advection) then
                !gpivol_jvol = gasp_m(mdens_g(jvol),jvol)           ! pressure
                !gdens_jvol  = gasd_m(mdens_g(jvol),gmfrac(:,jvol)) ! density
                !gvisc_jvol  = gasv(gmfrac(:,jvol))                 ! viscosity
                gpivol_jvol = gpivol(jvol)                          ! gas pressure
                gdens_jvol  = gdens(jvol)                           ! gas density
                gvisc_jvol  = gvisc(jvol)                           ! gas viscosity
              else
                gpivol_jvol = 0.0d0
                gdens_jvol  = 0.0d0
                gvisc_jvol  = 0.0d0
              end if

#ifdef USG
              if (discretization_type > 0) then
                ncell = janumcell(i1)
              end if
#endif

#ifdef USG
              if (discretization_type > 0) then
                if (b_use_cross_diffusion_react) then
                  call gradient_cross_diff_rt(i1,ivol,jvol,ng,gnew,    &
                       grad_gnew_ivol,grad_gnew_jvol,grad_gnew_kvol,   &
                       grad_gnew_hls_loc,grad_cgg_gnew)                  
                end if
!cdsu
!cdsu calculate influence coefficient
!cdsu
                if (ng > 0) then
                  call usg_face_utility_cinfrt_dg(ivol,jvol,i1,        &
                           cinfrt_dg_usg_loc,cinfrt_dg_usg_cross_loc)

                  call usg_face_utility_cinfvs(ivol,jvol,i1,           &
                           cinfvs_usg_loc,cinfvs_usg_cross_loc,        &
                           permij_usg_loc)

                end if

              end if
#endif

              do ig=1,ng               !loop over gaseous species

                if (blanc_diff_g .or. gas_advection) then
                  !gpivol_jvol  = gasp_m(mdens_g(jvol),jvol)          ! pressure
                  !gdens_jvol   = gasd_m(mdens_g(jvol),gmfrac(:,jvol))! density
                  !gvisc_jvol   = gasv(gmfrac(:,jvol))                ! viscosity
                  gpivol_jvol = gpivol(jvol)                          ! gas pressure
                  gdens_jvol  = gdens(jvol)                           ! gas density
                  gvisc_jvol  = gvisc(jvol)                           ! gas viscosity
                else                    
                  gpivol_jvol  = 0.0d0
                  gdens_jvol   = 0.0d0
                  gvisc_jvol   = 0.0d0
                endif

!               calculate gas properties at interface according to weighting scheme
#ifdef USG
                if (discretization_type > 0 .and. is_cell_based_relp) then

                  !c modify relpgij externally
                  relpgij = 0.0d0
                  do icell = 1, node_num_cells(ivol)
                    relpgij = relpgij + relpermg(node_cells(icell,ivol))
                  end do
                  relpgij = relpgij / node_num_cells(ivol)

                  relpgi = relpgij
                  relpgj = relpgij

                else
#endif
                  relpgi = relpermg(ivol)
                  relpgj = relpermg(jvol)
#ifdef USG
                end if
#endif

                call wgprop(totgnew(1,ivol),totgnew(1,jvol),totgij   ,&
     &                      gnew(1,ivol)   ,gnew(1,jvol)   ,gij      ,&
     &                      gmfrac(1,ivol) ,gmfrac(1,jvol) ,gmfracij ,&
     &                      relpgi         ,relpgj         ,relpgij  ,&
     &                      gdens_ivol     ,gdens_jvol     ,densgij  ,&
     &                      gvisc_ivol     ,gvisc_jvol     ,viscgij  ,&
     &                      gpivol_ivol    ,gpivol_jvol    ,gpij     ,&
     &                      zg(ivol)       ,zg(jvol)       ,          &
     &                      spt_weight     ,iupsg(i1)      ,          &
     &                      nc             ,ng             ,gacc     )
                
!c -------------- DGM module ----------------------------------------------------
!c               solve A F = B
!c               computes fluxes F of all gas components at current c.v. interphase

                gflux_ig = 0.0d0
          
                if ((ng.gt.0).and.dgm) then
                
#ifdef USG
                  if (discretization_type > 0) then
                    call dgm_fluxdg_s (gnew(1,ivol)    ,gnew(1,jvol) , &
                                       gij             ,gmfracij     , &
                                       zg(ivol)        ,zg(jvol)     , &
                                       densgij         ,gpij         , &
                                       tkel(ivol)      ,               &
                                       sum(permij_usg_loc(             &
                                                  1:num_edge_dvols   , &
                                                  1:janumcell(i1)))  , &
                                       relpgij         ,tauij(i1)    , &
                                       gporij(i1)      ,deltaij(i1)  , &
                                       rverysmall      ,               &
                                       ludecomp        ,               &
                                       fmat            ,ipvt         , &
                                       dgm_gflux_s     ,neflux       )
                  else
#endif
                    call dgm_fluxdg_s (gnew(1,ivol)    ,gnew(1,jvol) , &
                                       gij             ,gmfracij     , &
                                       zg(ivol)        ,zg(jvol)     , &
                                       densgij         ,gpij         , &
                                       tkel(ivol)      ,permij(i1)   , &
                                       relpgij         ,tauij(i1)    , &
                                       gporij(i1)      ,deltaij(i1)  , &
                                       rverysmall      ,               &
                                       ludecomp        ,               &
                                       fmat            ,ipvt         , &
                                       dgm_gflux_s     ,neflux       )
#ifdef USG
                  end if
#endif

!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else
                
                    gflux_ig =                                         &
     &                         + cinfrt_dg(i1)                         &
     &                         * deltaij(i1)                           &
     &                         * dgm_gflux_s(ig)                       &
     &                         / tauij(i1)                             &
     &                         / gporij(i1)


                
                  endif
                
!c --------------- Maxwell Stefan module ----------------------------------------

                else if ((ng.gt.0).and.maxwell) then
                
                  call ms_fluxdg_s (gnew(1,ivol)     ,gnew(1,jvol)  ,  &
     &                              gij              ,gmfracij      ,  &
     &                              zg(ivol)         ,zg(jvol)      ,  &
     &                              densgij          ,gpij          ,  &
     &                              tkel(ivol)       ,tauij(i1)     ,  &
     &                              gporij(i1)       ,deltaij(i1)   ,  &
     &                              rverysmall       ,                 &
     &                              ludecomp         ,                 &
     &                              ipvt             ,equimolar     ,  &
     &                              ms_gflux_s       ,neflux_s      )

!c               bug fix in ms_fluxdg_s, should pass ms_gflux_s instead of dgm_gflux_s here
!c               DSU, 2018-09-06
                
!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else
                    gflux_ig =                                         & 
     &                         + cinfrt_dg(i1)                         &
     &                         * deltaij(i1)                           &
     &                         * ms_gflux_s(ig)                        &
     &                         / tauij(i1)                             &
     &                         / gporij(i1)
                  endif
                
                else if ((.not.dgm).and.(.not.maxwell)) then

                  if (blanc_diff_g) then
#ifdef USG
                    if (discretization_type > 0) then

                      gasdiff_loc = gasdiff2_s(gmfrac(1,ivol),gmfrac(1,jvol),&
                                       gpivol_ivol   ,gpivol_jvol  ,         &
                                       zg(ivol)      ,zg(jvol)      ,        &
                                       gdens_ivol    ,gdens_jvol    ,        &
                                       ig            ,                       &
                                       iupsg(i1)     ,spt_weight    )
                      cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)*gasdiff_loc
                      cinfrt_usg_cross(:,:) = cinfrt_dg_usg_cross_loc(:,:) * &
                                                        gasdiff_loc
                    else
#endif
!c                  diffusion coefficient calc'd with LeBlanc's law
                      cinfrt = cinfrt_dg(i1) * gasdiff2_s                &
                                      (gmfrac(1,ivol),gmfrac(1,jvol),    &
                                       gpivol_ivol   ,gpivol_jvol  ,     &
                                       zg(ivol)      ,zg(jvol)      ,    &
                                       gdens_ivol    ,gdens_jvol    ,    &
                                       ig            ,                   &
                                       iupsg(i1)     ,spt_weight    )
#ifdef USG
                    end if
#endif
                  else
!c                  single constant diffusion
#ifdef USG
                    if (discretization_type > 0) then
                      cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)
                      cinfrt_usg_cross(:,:) =cinfrt_dg_usg_cross_loc(:,:)
                    else
#endif
                      cinfrt = cinfrt_dg(i1)
#ifdef USG
                    end if
#endif
                  endif

#ifdef USG
                  if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                    grad_gnew_mids = vector_zero
                    flux_gnew_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ig,ng,i1,    &
                           ivol,jvol,grad_gnew_ivol,grad_gnew_jvol,    &
                           grad_gnew_kvol,grad_gnew_hls_loc,           &
                           grad_weights,grad_gnew_locs,                &
                           grad_gnew_mids,flux_gnew_hls_corr,          &
                           grad_cgg_gnew)
                    end if

                    gflux_ig = -fluxd_usg(gnew(ig,ivol),gnew(ig,jvol),                 &
                                  num_edge_dvols,janumcell(i1),                        &
                                  grad_gnew_mids(1:num_edge_dvols,1:janumcell(i1)),    &
                                  flux_gnew_hls_corr(1:num_edge_dvols,1:janumcell(i1)),&
                                  cinfrt_usg(1:num_edge_dvols,1:janumcell(i1)),        &
                                  cinfrt_usg_cross(1:num_edge_dvols,1:janumcell(i1)))
                  else
#endif
                    gflux_ig = - fluxd(gnew(ig,ivol),                  &
                                       gnew(ig,jvol),                  &
                                       cinfrt)                           ! cinfrt_dg(i1) -> cinfrt

#ifdef USG
                  end if
#endif

                endif
                
!c ------------> diffusion component
                totgflux(ig) = totgflux(ig) + conv3 * gflux_ig

!c ----------- advection component
                if (gas_advection) then
#ifdef USG
                  if (discretization_type > 0) then
                    totgaflux(ig) = totgaflux(ig) + conv3 *            &
                                ( + fluxvg(gpivol_ivol ,gpivol_jvol ,  &
                                           zg(ivol)    ,zg(jvol)    ,  &
                                           gij(ig)     ,relpgij     ,  &
                                           densgij     ,viscgij     ,  &
                                           rcvt*sum(cinfvs_usg_loc(    &
                                               1:num_edge_dvols,       &
                                               1:janumcell(i1))),      &
                                           gas_gravity ,gacc)       )
                  else
#endif
                    totgaflux(ig) = totgaflux(ig) + conv3 *            &
                                ( + fluxvg(gpivol_ivol ,gpivol_jvol ,  &
                                           zg(ivol)    ,zg(jvol)    ,  &
                                           gij(ig)     ,relpgij     ,  &
                                           densgij     ,viscgij     ,  &
                                           cinfvs_g(i1),               &
                                           gas_gravity ,gacc)       )
#ifdef USG
                  end if
#endif

                endif

              end do                     !loop over gaseous species

            end do                       !loop over local connections

!c  mixed type boundary conditions

          elseif (btypert(ivol).eq.'mixed' .or. btypert(ivol).eq.'mixed-evap') then

!c  compute boundary influence coefficient
            so_av=dmin1(r1, sonew(ivol)) 
            diff_eff = diffcoff_g(diff_g, sgnew(ivol),pornew(ivol),    &
                                  tortuosity_corr,assigned_tau_gas,    &
                                  taugas(ivol)*tau_fac(ivol),          &
                                  type_tortuosity,marchies(ivol),      &
                                  gas_tortuosity,so_av,                &
                                  tor_corr_a_mq,tor_corr_b_mq)
            bdyinfrt_dg = diff_eff * bdycrt_d(ibrt)

            if (b_water_freezing) then
              if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                bdyinfrt_dg = bdyinfrt_dg*frozen_diff_g
              end if
            end if  
            
            do ig = 1,ng
              totgflux(ig) = conv3 *                                   &
                           ( fluxd(gnew(ig,ivol),                      & !diffusive flux
                                   gbrt(ig,ibrt),                      &
                                   bdyinfrt_dg))
            end do
          end if                         !boundary type

          do ig = 1,ng

            if (totgflux(ig).gt.r0) then
              gfluxin(ig) = gfluxin(ig) + totgflux(ig)     !influx
            else
              gfluxout(ig) = gfluxout(ig) - totgflux(ig)   !outflux
            end if

            if (gas_advection) then
            
              if (totgaflux(ig).gt.r0) then
                  gafluxin(ig) = gafluxin(ig) + totgaflux(ig)     !influx
              else
                  gafluxout(ig) = gafluxout(ig) - totgaflux(ig)   !outflux
              end if
            
            endif

          end do                         !loop over components

!c  sum up total mass through specified boundary
          if (ntmsb > 0) then
            do itmsb = 1, ntmsb
              if (btest(mproptmsb(ivol),itmsb-1)) then
                do ig = 1,ng
                  if (totgflux(ig).gt.r0) then
                    tmsb_gfluxin(ig,itmsb) = tmsb_gfluxin(ig,itmsb) + totgflux(ig)     !influx
                  else
                    tmsb_gfluxout(ig,itmsb) = tmsb_gfluxout(ig,itmsb) - totgflux(ig)   !outflux
                  end if

                  if (gas_advection) then
                    if (totgaflux(ig).gt.r0) then
                      tmsb_gafluxin(ig,itmsb) = tmsb_gafluxin(ig,itmsb) + totgaflux(ig)     !influx
                    else
                      tmsb_gafluxout(ig,itmsb) = tmsb_gafluxout(ig,itmsb) - totgaflux(ig)   !outflux
                    end if
                  endif
                end do                         !loop over components
              end if
            end do
          end if

        end do                           !boundary control volumes
#ifdef OPENMP
    !$omp end do
#endif   

#ifdef OPENMP
    !$omp barrier
#endif

!c  contributions due to changes in storage [moles/time unit]
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:gstordiff)
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          do ig = 1,ng
            gstordiff(ig) = gstordiff(ig)                             &
     &                    + conv3 * cvol(ivol)/delt                   &
     &                    * (bulkconc(gnew(ig,ivol),                  &
     &                                sgnew(ivol),                    &
     &                                pornew(ivol))                   &
     &                    -  bulkconc(gold(ig,ivol),                  &
     &                                sgold(ivol),                    &
     &                                porold(ivol)))
          end do
        end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

!!c  total contributions due to exchange with water phase 
!!c  [moles/unit time]
!
!#ifdef OPENMP
!    !$omp single
!#endif
!        do ig = 1,ng
!          gdiff(ig) = gfluxin(ig) - gfluxout(ig) - gstordiff(ig)
!        end do
!#ifdef OPENMP
!    !$omp end single
!#endif

!c  mass loss due to degassing

        if (gas_removal) then
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:gdegas)
#endif
          do ivol = 1,nngl
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif

#ifdef OPENMP
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif  

!c  compute degassing rates

            if (density_dependence) then     
              call rategasd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),      &
                            sgnew(ivol),tid)
            else      
              call rategas(gnew(1,ivol),tkel(ivol),hhead(ivol),        &
                           zg(ivol),sgnew(ivol),tid)        
            end if

!c  scale total degassing rates to [mol L^-1 bulk s^-1]
            do ig = 1,ng
              gdegas(ig) = gdegas(ig) + conv3 * cvol(ivol)             &
                         * bulkconc(rateg(ig,tid),sanew(ivol),         &
                                    pornew(ivol))
            end do
                                                                      
          end do               !loop over control volumes  
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif
                                                                      
        end if                 !(gas_removal)
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
      call MPI_Allreduce(gfluxtbdy,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,  &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxtbdy(1:ng) = mpireduce_ng(1:ng) 
      
      
      call MPI_Allreduce(gfluxin,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxin(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gfluxout,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,   &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxout(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gafluxin,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,   &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gafluxin(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gafluxout,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,  &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gafluxout(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gstordiff,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,  &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gstordiff(1:ng) = mpireduce_ng(1:ng) 
      
      if (gas_removal) then
        call MPI_Allreduce(gdegas,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,   &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gdegas(1:ng) = mpireduce_ng(1:ng) 
      end if

!c  sum up total mass through specified boundary
      if (ntmsb > 0) then
        do itmsb = 1, ntmsb
          call MPI_Allreduce(tmsb_gfluxin(1:ng,itmsb),mpireduce_ng,ng,   &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_gfluxin(1:ng,itmsb) = mpireduce_ng(1:ng)

          call MPI_Allreduce(tmsb_gfluxout(1:ng,itmsb),mpireduce_ng,ng,  &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_gfluxout(1:ng,itmsb) = mpireduce_ng(1:ng)

          call MPI_Allreduce(tmsb_gafluxin(1:ng,itmsb),mpireduce_ng,ng,  &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_gafluxin(1:ng,itmsb) = mpireduce_ng(1:ng)

          call MPI_Allreduce(tmsb_gafluxout(1:ng,itmsb),mpireduce_ng,ng, &
                   MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          tmsb_gafluxout(1:ng,itmsb) = mpireduce_ng(1:ng)
        end do
      end if
#endif


!c  total contributions due to exchange with water phase 
!c  [moles/unit time]
       do ig = 1,ng
         gdiff(ig) = gfluxin(ig) - gfluxout(ig) - gstordiff(ig)
       end do


!c  write results to output files [moles/unit time]
        do ig = 1,ng
          imrt = imrt+1
          if(rank == 0 .and. b_enable_output .and.                     &
             .not.(skip_time.gt.0 .and. nskip_time.lt.skip_time)) then
            if (b_output_trans_binary) then
              nvarsimrt = 9
              realbuffer_gb(1:nvarsimrt) = (/time_io,                  &
                                         gfluxin(ig),                  &
                                         gfluxout(ig),                 &
                                         gafluxin(ig),                 &
                                         gafluxout(ig),                &
                                         gfluxtbdy(ig),                &
                                         gstordiff(ig),                &
                                         gdiff(ig),                    &
                                         gdegas(ig)/)
              call binary_write_data(imrt_mpi(imrt), 1,        &
                           (/mtime/),offset_imrt_ijk(imrt),.true.)
              call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                           realbuffer_gb,offset_imrt(imrt),.true.) 

              offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
     
            else 
              if (mtime == mtime_append .and. i_append_sim >= 1) then
                call reposition_file(imrt,irecord)
              end if

              if (i_append_sim < 1 .or.                                &
                 (mtime >= mtime_append .and. i_append_sim >= 1)) then
                write(imrt,ascii_fmt) time_io,                         &
                                         gfluxin(ig),                  &
                                         gfluxout(ig),                 &
                                         gafluxin(ig),                 &
                                         gafluxout(ig),                &
                                         gfluxtbdy(ig),                &
                                         gstordiff(ig),                &
                                         gdiff(ig),                    &
                                         gdegas(ig)
              end if
            end if  
          
          end if
        end do
        
!c total mass through specified boundary
        if (ntmsb > 0) then
          do itmsb = 1, ntmsb
            do ig = 1,ng
              imrt = imrt+1
              if(rank == 0 .and. b_enable_output .and.                     &
                 .not.(skip_time.gt.0 .and. nskip_time.lt.skip_time)) then
                if (b_output_trans_binary) then
                  nvarsimrt = 5
                  realbuffer_gb(1:nvarsimrt) = (/time_io,                  &
                                                 tmsb_gfluxin(ig,itmsb),   &
                                                 tmsb_gfluxout(ig,itmsb),  &
                                                 tmsb_gafluxin(ig,itmsb),  &
                                                 tmsb_gafluxout(ig,itmsb)/)
                  call binary_write_data(imrt_mpi(imrt), 1,        &
                               (/mtime/),offset_imrt_ijk(imrt),.true.)
                  call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                               realbuffer_gb,offset_imrt(imrt),.true.)

                  offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

                else
                  if (mtime == mtime_append .and. i_append_sim >= 1) then
                    call reposition_file(imrt,irecord)
                  end if

                  if (i_append_sim < 1 .or.                            &
                     (mtime >= mtime_append .and. i_append_sim >= 1)) then
                    write(imrt,ascii_fmt) time_io,                     &
                                             tmsb_gfluxin(ig,itmsb),   &
                                             tmsb_gfluxout(ig,itmsb),  &
                                             tmsb_gafluxin(ig,itmsb),  &
                                             tmsb_gafluxout(ig,itmsb)
                  end if
                end if

              end if
            end do
          end do
        end if

      end if                                             !(ng.gt.0)


!c ----------------------------------------------------------------------
!c  compute mass balance for minerals
!c  only if minerals are specified
!c ----------------------------------------------------------------------
 
      if (nm.gt.0) then
 
!c  clear arrays

        cstordiff = r0
        dpdiff = r0
        dpdiffp = r0
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_11)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ireac, istart, istop, ivol, i1, im2, izn_c,   &
    !$omp rootdens)                                                   &
    !$omp reduction(+: contmintot, cstordiff,                         &
    !$omp dpdiff, dpdiffp, totdpdiffp)                     
#endif

!c  change in storage and total dissolved/precipitated mass
!c  [moles/unit time]
 
        do im = 1,nm
#ifdef OPENMP
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl
              
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
              
#ifdef OPENMP
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif   

            izn_c = mpropc(ivol)

!c  exclude first type boundary control volumes

            if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

              if (temp_corr.or.heat_transport) then
                call tcorr(tkel(ivol),ivol,tid)
              end if

!c  compute average molar concentrations for organic mixture
!c  in solid phase
              call molconc(phiold(1,ivol),tid)     

!c  recompute rates for output of mass balance contributions of 
!c  parallel reaction pathways

              if (new_database) then
                if (root_uptake) then
                  rootdens = rld(ivol)
                else
                  rootdens = r1
                end if
                call ratemin_new(totcnew(1,ivol),cnew(1,ivol),        &
                                 cx(1,ivol),gamma(1,ivol),            &
                                 gamma(nc+1,ivol),sanew(ivol),        &
                                 ratemdp(im,ivol),                    &
                                 phi(1,ivol),phiold(im,ivol),         &
                                 area(im,ivol),rootdens,im,tid)  
              else
                call ratemin(totcnew(1,ivol),cnew(1,ivol),cx(1,ivol), &
                             gamma(1,ivol),gamma(nc+1,ivol),          &
                             ratemdp(im,ivol),phi(im,ivol),           &
                             phiold(im,ivol),area(im,ivol),im,tid)        
              end if

!cdsu  Adjust mineral rate for intermittent reactions
              if (flag_intermittent_react) then
                if (imizn2jairm(im,izn_c) > 0) then
                  ratemdp(im,ivol) = ratemdp(im,ivol)*imizn2irc(im,izn_c)
                end if
              end if
            
!cdsu  Assign mineral rate for frozen water
              if(b_water_freezing_ratemin) then
                if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                  ratemdp(im,ivol) = water_freezing_ratemin
                end if
              end if

!c  modify computed rates in the same manner as done in the residual
!c  assembly
              call modrate(ratemdp(im,ivol),cmnew(im,ivol),            &
                           pornew(ivol),delt,im,tid)

!c  combine reaction rates to update mineralogical parameters
              istart = iamp(im)
              istop = iamp(im+1)-1
              totratem(im,tid) = r0
              do i1 = istart,istop
                im2 = jamp(i1)
                totratem(im,tid) = totratem(im,tid) + ratemdp(im2,ivol)
              end do   
   
!c  calculate change in storage
              cstordiff(im) = cstordiff(im)                            &
                            + conv3 * cvol(ivol)/delt                  &
                            * (cmnew(im,ivol)-cmold(im,ivol))

!cdsu  use combine reaction rates since cmnew is the parameter based on combined reaction
              dpdiff(im) = dpdiff(im) + conv3 * cvol(ivol)             &
                         * totratem(im,tid)

              ! dpdiff(im) = dpdiff(im) + conv3 * cvol(ivol)             &
              !            * ratemdp(im,ivol)

              istart = iamd(im)
              istop = iamd(im+1)-1

              do ireac = istart,istop
                dpdiffp(ireac) = dpdiffp(ireac) + conv3 * cvol(ivol)   &
                               * ratemp(ireac,tid)
              end do

            end if       !exclude first type control volumes

          end do         !number of control volumes
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
          contmintot(im) = contmintot(im) + dpdiff(im)*delt
          
          istart = iamd(im)
          istop = iamd(im+1)-1
          
          do ireac = istart,istop
            totdpdiffp(ireac) = totdpdiffp(ireac) + dpdiffp(ireac)*delt
          end do
         
        end do
#ifdef OPENMP
    !$omp end parallel
#endif  

#ifdef PETSC
        call MPI_Allreduce(contmintot, mpireduce_nm,nm,MPI_REAL8,      &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        contmintot_mpi(1:nm) = mpireduce_nm(1:nm) 
        
        call MPI_Allreduce(cstordiff, mpireduce_nm,nm,MPI_REAL8,       &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        cstordiff(1:nm) = mpireduce_nm(1:nm) 
        
        call MPI_Allreduce(dpdiff, mpireduce_nm,nm,MPI_REAL8,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        dpdiff(1:nm) = mpireduce_nm(1:nm) 
#endif

        do im = 1,nm

          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop
              
#ifdef PETSC
            call MPI_Allreduce(dpdiffp(ireac), mpireduce_gbl,1,MPI_REAL8,MPI_SUM,     &
                               Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            dpdiffp(ireac) = mpireduce_gbl 
            
            call MPI_Allreduce(totdpdiffp(ireac), mpireduce_gbl,1,MPI_REAL8,MPI_SUM,     &
                               Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            totdpdiffp_mpi(ireac) = mpireduce_gbl
#endif              
          end do
       
        end do        
        
!c  write results to output file
 
        do im = 1,nm

          imrt = imrt + 1
          istart = iamd(im)
          istop = iamd(im+1)-1

          if(rank == 0 .and. b_enable_output .and.                     &
             .not.(skip_time.gt.0 .and. nskip_time.lt.skip_time)) then
              
            if (b_output_trans_binary) then
              nvarsimrt = 2*(istop-istart+1)+4
#ifdef PETSC
              realbuffer_gb(1:nvarsimrt) = (/                          &
                   time_io,cstordiff(im),dpdiff(im),contmintot_mpi(im),&
                   (dpdiffp(ireac),totdpdiffp_mpi(ireac),              &
                   ireac=istart,istop)/)
#else
              realbuffer_gb(1:nvarsimrt) = (/                          &
                   time_io,cstordiff(im),dpdiff(im),contmintot(im),    &
                   (dpdiffp(ireac),totdpdiffp(ireac),                  &
                   ireac=istart,istop)/)
#endif
              call binary_write_data(imrt_mpi(imrt), 1,        &
                           (/mtime/),offset_imrt_ijk(imrt),.true.)
              call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                           realbuffer_gb,offset_imrt(imrt),.true.) 

              offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
  
            else
              !c read accumulative absolute mass balance error at the restart point
              !c For legacy mode, previous mass balance is read at restart point but
              !c will not output until the second restart point is reached
              if (mtime == mtime_append .and. i_append_sim >= 1) then
                call reposition_file(imrt,irecord)
                if (irecord > 0) then

                  allocate(rdummys_alloc(4+(istop-istart+1)*2), stat = ierr)
                  call checkerr(ierr,'rdummys_alloc',ilog)
                  call memory_monitor(sizeof(rdummys_alloc),'rdummys_alloc',.false.)

                  !c locate to the restart time and get previous results
                  call reposition_file(imrt,irecord,time_io_rs)
                  read(imrt,*,end=70,err=70) rdummys_alloc(:)
                  !c reposition to the line to append results
                  call reposition_file(imrt,irecord)

                  do ireac = istart, istop
#ifdef PETSC
                    totdpdiffp_mpi(ireac) = totdpdiffp_mpi(ireac) +      &
                               rdummys_alloc(6+(ireac-istart)*2)
#else
                    totdpdiffp(ireac) = totdpdiffp(ireac) +              &
                               rdummys_alloc(6+(ireac-istart)*2)
#endif
                  end do
                  call memory_monitor(-sizeof(rdummys_alloc),'rdummys_alloc',.false.)
                  deallocate(rdummys_alloc)
                end if
70              continue
              end if

              if (i_append_sim < 1 .or.                                &
                 (mtime >= mtime_append .and. i_append_sim >= 1)) then
#ifdef PETSC
                write(imrt,ascii_fmt)                                  &
                  time_io,cstordiff(im),dpdiff(im),contmintot_mpi(im), &
                  (dpdiffp(ireac),totdpdiffp_mpi(ireac),               &
                  ireac=istart,istop)
#else
                write(imrt,ascii_fmt)                                  &
                  time_io,cstordiff(im),dpdiff(im),contmintot(im),     &
                  (dpdiffp(ireac),totdpdiffp(ireac),                   &
                  ireac=istart,istop)
#endif      
              end if
            end if
          end if
        end do
 
      end if      !(nm.gt.0)
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
      call memory_monitor(-sizeof(bdyinfrt_da_ic),'bdyinfrt_da_ic',.true.)
      deallocate(bdyinfrt_da_ic)
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi-------------------------------------------------------------------------- 

      return
      end
