!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/energy_bal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine energy_bal
!c -----------------
!c
!c Compute the energy balance
!c
!c 
!c
!c last modified:   -
!c
!c                  Danyang Su    - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           relperm(nn)        = relative permeability               + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           time_io            = current solution time (I/O units)   + -
!c           totvsmass          = total system mass                   + +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c
!c           integer*4:
!c           ----------
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           imvs               = unit number, mass balance -         + *
!c                                             variably saturated
!c                                             flow
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           mtime              = current time step                   + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> calculate root water     + -
!c                                           uptake
!c           steady_flow        = .true.  -> steady state flow        + -
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c                                'free-drainage' = free-drainage
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + - 
!c           dcoef(ncon-1)      = coefficient including density,      + -
!c                                viscosity, and relative 
!c                                permeability
!c           psi_i              = total pressure potential in control + -
!c                                volume i currently considered
!c           psi_j              = total pressure potential in control + -
!c                                volume j currently considered
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c local:    real*8:
!c           -------
!c           qroot              = root water uptake for current 
!c                                control volume
!c           qroot_tot_act      = total actual root water uptake
!c           r0                 = constant
!c           r100               = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c           totinflux          = total flux into domain
!c           totoutflux         = total flux out of domain
!c           totvsflux          = total flux into control volume
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control 
!c                                         volumes)
!c           icon               = pointer (connections - local)
!c           iend               = pointer (end of row)
!c           istart             = pointer (start of row)
!c           jvol               = row-column pointer
!c           ivol               = counter (control volumes)
!c
!c external: fluxdd   = flux function for density dependent 
!c                      flow 
!c           msysdd   = compute total system mass
!c                      (density dependent flow)
!c ----------------------------------------------------------------------
      subroutine energy_bal    

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use chem
      use gen
      use phys
      use dens
      use writeversion
      use file_utility, only : reposition_file
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols, num_edge_maxcells
      use gradient_usg, only : gradient_cross_diff,                    &
                               gradient_cross_diff_dd
      use diff_vapour_usg_mod, only : diff_vapour_usg
      use usg_face_utility, only : usg_face_utility_cinfvs,            &
                                   usg_face_utility_cinfevap_t,        &
                                   usg_face_utility_cinfevap_pa,       &
                                   usg_face_utility_cinfheat_c,        &
                                   usg_face_utility_cinfheat_d
      use mod_fluxdd_usg, only : fluxdd_usg
      use mod_darcy_energybal_usg, only : darcy_energybal_usg
#endif

      use module_binary_mpiio, only : binary_write_data
      
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: i1, i2, ibheat, ibvs, icon, ivol, istart, iend, jvol,im
      real*8 :: area_ivol, coeff, ddbdflux_energybal, densloc,         &
                diff_vapour, heatflux, totheatstor, rpor, heatstor,    &
                temploc, totheatflux, totinflux, totoutflux,           &
                absbalance, relbalance, totwflux_atm,tothflux_atm,     &
                totsinksource

#ifdef PETSC
      real*8 :: totheatstor_gbl, totinflux_gbl, totoutflux_gbl, totsinksource_gbl
      PetscErrorCode :: ierrcode
#endif
      
      real(type_r8) :: rho_av_loc

      real*8, external :: fluxdd, storheat, storevap, porosity_flow,  &
                          darcy_energybal, fluxheat, relheat_freezing
      external :: msysdd
      
      character(len=100)  typebc 
      
     
      real*8 :: latvap_av, relheat_iw

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,         &
                           r3 = 3.0d0, r100 = 100.0d0, r1d3 = 1.0d3
      real*8, parameter :: rhalf = 0.5d0
      
      integer :: nvarsimheat, irecord
      
#ifdef USG
      integer :: icell, idvol, kvol, ndvol, ncell, nrelp
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells), &
                flux_temp_hls_corr(num_edge_dvols,num_edge_maxcells),   &
                flux_flow_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_locs(num_crossdifficv_max)
      type(point) :: grad_ddflow_mids(num_edge_dvols,num_edge_maxcells),&
                     grad_temp_mids(num_edge_dvols,num_edge_maxcells),  &
                     grad_flow_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols),       &
                             grad_ddflow_hls_loc(num_edge_dvols),     &
                             grad_temp_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfevap_pa_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfevap_pa_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfevap_t_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfevap_t_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfheat_c_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfheat_c_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfheat_d_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfheat_d_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

#endif

!cprovi----------------------------------------------------
!cprovi  compute total energy in the energy
!cprovi  Parallelized, OpenMP, DSU
!cprovi----------------------------------------------------
      call energysys 
!cprovi----------------------------------------------------
!cprovi for transient conditions -> compute changes 
!cprovi in storage 
!cprovi----------------------------------------------------
      totheatstor = r0
      
      if (isstorheat) then
        
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_energy_bal_1)                   &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, heatstor, rpor, totsinksource, relheat_iw)    &
    !$omp reduction(+:totheatstor)
    !$omp do schedule(static)
#endif
        
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
        
          if (modify_por(ivol)) then
            rpor=porosity_flow(porold(ivol), &
                 uvsnew(ivol),uvsold(ivol),stor(ivol),  &
                 por_stress_dt(ivol),por_init(ivol),facpormin)   
          else
            rpor=pornew(ivol)
          end if 
        
          if (b_icewater_heat) then
            relheat_iw = r1
          else
            relheat_iw = relheat_freezing(tempnew(ivol),heatcapw,heatcapi, &
                                          uvsnew(ivol))
          end if
        
          heatstor = cvol(ivol)*storheat(delt,delt,tempnew(ivol),  & 
                     tempold(ivol),sanew(ivol),saold(ivol), &
                     density(ivol),densold(ivol),density(ivol),densold(ivol), &
                     r0,r0,r0,r0,denssolid(ivol), & 
                     rpor,porold(ivol),heatcapw*relheat_iw,  &
                     heatcaps(ivol),.true.,.false., &
                     cdens1,cdens2,cdens3,cdens4)  
                     
                     
          if (evaporation) then
             
              heatstor = heatstor + cvol(ivol)*storevap(delt,tempnew(ivol),&
                                    tempold(ivol),sgnew(ivol),sgold(ivol), &
                                    densvnew(ivol),densvold(ivol), &
                                    rpor,porold(ivol),heatcapv)
              heatstor = heatstor + cvol(ivol)*storevap(delt,latvapnew(ivol),&
                                    latvapold(ivol),sgnew(ivol),sgold(ivol), &
                                    densvnew(ivol),densvold(ivol), &
                                    rpor,porold(ivol),r1)
          end if   
       
          totsinksource = r0
          if (reaction_heat) then
            do im = 1, nm
              if (cmnew(im,ivol).gt.1.0d-10) then
                if (reaction_type(im).eq.'dissolution_far_from_equilibrium' .or. &
                    reaction_type(im).eq.'reversible') then
                  totsinksource = totsinksource + r1d3*cvol(ivol)*     &
                                  cal2jou*ratemdp(im,ivol)*dscm(im) 
                end if 
              end if      
            end do
            heatstor = heatstor + totsinksource
          end if                      
                     
                 
          totheatstor = totheatstor + heatstor
         
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
      
#ifdef PETSC
        call MPI_Allreduce(totheatstor, totheatstor_gbl,1,MPI_REAL8,           & 
                   MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totheatstor = totheatstor_gbl
#endif

      end if 

!c  compute fluxes across boundary

      totinflux = r0               
      totoutflux = r0
!cprovi--------------------------------------------------------------------------------------
!cprovi Boundary conditions for energy balance
!cprovi--------------------------------------------------------------------------------------    
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbheat > numofloops_thred_energy_bal_2)                 &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(                                                    &
#ifdef USG
    !$omp icell, idvol, kvol, ndvol, ncell, nrelp, relps_loc,         &
    !$omp grad_ddflow_mids, grad_temp_mids,                           &
    !$omp grad_flow_mids, grad_locs, grad_weights,                    &
    !$omp grad_flow_hls_loc, grad_ddflow_hls_loc,                   &
    !$omp grad_temp_hls_loc,                                         &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc,                       &
    !$omp cinfevap_t_usg_loc, cinfevap_t_usg_cross_loc,               &
    !$omp cinfevap_pa_usg_loc, cinfevap_pa_usg_cross_loc,             &
    !$omp cinfheat_c_usg_loc, cinfheat_c_usg_cross_loc,               &
    !$omp cinfheat_d_usg_loc, cinfheat_d_usg_cross_loc,               &
#endif
    !$omp i1, i2, ibheat, ibvs, icon, iend, istart, ivol, jvol,       &
    !$omp area_ivol, coeff, del_p, del_z, del_temp, densloc,          &
    !$omp heatflux, heatflux_a, heatflux_c, heatflux_d, heatflux_v,   &
    !$omp latvap_av, rho_av_loc, temploc, relheat_iw, totheatflux,    &
    !$omp vapfluxheat, vsfluxheat, totwflux_atm, tothflux_atm)        &
    !$omp reduction(+:totinflux, totoutflux)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif


      do ibheat = 1,nbheat
        
        ivol = iabheat(ibheat)
        
        if (ivol < 0) then
          cycle  
        end if
        
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif        
        totheatflux = r0

        if (b_icewater_heat) then
          relheat_iw = r1
        else
          relheat_iw = relheat_freezing(tempnew(ivol),heatcapw,heatcapi,   &
                                        uvsnew(ivol))
        end if

!c  modify for second type flow boundary condition and
!c  point source boundary
!c  calculate mass flux
        if (btypeheat(ibheat)=='free') then

          totheatflux=ddbdflux_energybal(ivol,density(ivol),&
                                         viscosity(ivol))
          
          if (totheatflux<r0) then
            temploc=tempnew(ivol)           
            if (isboussinesq) then  
              densloc=r1
            else
              densloc=density(ivol)
            end if
          else
            temploc=bcondheat(ibheat)
            if (isboussinesq) then  
              densloc=ssdens(ivol)/density(ivol)
            else
              densloc=ssdens(ivol)*heatcapw*relheat_iw
            end if
          end if
          
          if (massflux_second) then  
             totheatflux=totheatflux*temploc
          else
             totheatflux=totheatflux*densloc*temploc
          end if
          
          
        elseif (btypeheat(ibheat)=='fluxw+') then
          
          totheatflux=ddbdflux_energybal(ivol,density(ivol),&
                                         viscosity(ivol))
          
          if (totheatflux<r0) then
            heatflux = r0
            temploc=r0
            densloc=r0
          else
            temploc=bcondheat(ibheat)
            if (isboussinesq) then  
              densloc=ssdens(ivol)/density(ivol)
            else
              densloc=ssdens(ivol)*heatcapw*relheat_iw
            end if
          end if
          
          if (massflux_second) then  
            totheatflux=totheatflux*temploc
          else
            totheatflux=totheatflux*densloc*temploc 
          end if
          
            
        else if ((btypeheat(ibheat)=='second') .or.  &
                 (btypeheat(ibheat).eq.'point')) then
 
          totheatflux = bcondheat(ibheat) 
          
        else if (btypeheat(ibheat)=='atmospheric'.and.evaporation) then  
  
          ibvs = ivol2bvs(ivol)
          if(ibvs > 0) then
            area_ivol = bcondvs(ibvs)
            call jacbevap(ivol,' ',totwflux_atm,tothflux_atm) 
            totheatflux = tothflux_atm*area_ivol
          end if
 
        elseif ((btypeheat(ibheat)=='first').or.   &
                (btypeheat(ibheat)=='seepage'.and. &
                 bcondheat(ibheat)<r0)) then

          icon=0  
          istart = iavs(ivol)+1                                       
          iend = iavs(ivol+1)-1

!cprovi---------------------------------------------------------------
!cprovi Loop on connected control volumes
!cprovi---------------------------------------------------------------             
          do i1=istart,iend          !loop over connected control volumes 
          
            icon = icon + 1
            jvol = javs(i1)

#ifdef USG
            if (discretization_type > 0) then
              ncell = janumcell(i1)
            end if
#endif

            heatflux_a(icon)=r0
            heatflux_c(icon)=r0
            heatflux_d(icon)=r0
            vsfluxheat(icon)=r0
            if (evaporation) then
              vapfluxheat(icon)=r0
              heatflux_v(icon)=r0
            end if

            del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
            del_z(icon) = zg(jvol) - zg(ivol)
!cprovi---------------------------------------------------------------             
!cprovi     
!cprovi---------------------------------------------------------------  
            if (del_z(icon)/=r0) then
!cprovi---------------------------------------------------------------  
!cprovi Compute the average density
!cprovi---------------------------------------------------------------             
              rho_av_loc = rhalf * (density(ivol) + density(jvol))
              if (av_dens_z) then
                del_p(icon)=rho_av_loc*(uvsnew(jvol)/density(jvol)-uvsnew(ivol)/density(ivol))
              end if
!cprovi---------------------------------------------------------------  
!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
!cprovi---------------------------------------------------------------   

              del_z(icon) = del_z(icon) * rho_av_loc * gacc
              del_p(icon) = del_p(icon) + del_z(icon)
            end if

            if (b_use_fixed_flow_vel) then
              
              if (b_use_zero_flow_vel) then
                vsfluxheat(icon) = r0
                heatflux_a(icon) = r0
              else
                !c TBD
              end if
            
            else

#ifdef USG
!c calculate gradient for jvol
              if (discretization_type > 0) then

                grad_ddflow_mids = vector_zero
                flux_ddflow_hls_corr = r0

                if (isadvective) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                  if (b_use_cross_diffusion_flow) then
                    call gradient_cross_diff_dd(i1,ivol,jvol,          &
                                  grad_locs,grad_ddflow_mids,          &
                                  grad_weights,flux_ddflow_hls_corr,   &
                                  grad_ddflow_hls_loc)                    
                  end if

                end if


                grad_temp_mids = vector_zero
                flux_temp_hls_corr = r0
                if (isconductive .or. isdispersive .or. evaporation) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                  if (b_use_cross_diffusion_heat) then
                    call gradient_cross_diff(i1,ivol,jvol,tempnew,     &
                                  grad_locs,grad_temp_mids,            &
                                  grad_weights,flux_temp_hls_corr,     &
                                  grad_temp_hls_loc)   
                  end if

                end if


                grad_flow_mids = vector_zero
                flux_flow_hls_corr = r0
                if (evaporation) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                  if (b_use_cross_diffusion_flow) then
                    call gradient_cross_diff(i1,ivol,jvol,uvsnew,      &
                                  grad_locs,grad_flow_mids,            &
                                  grad_weights,flux_flow_hls_corr,     &
                                  grad_flow_hls_loc)
                  end if

                end if

!cdsu calculate influence coefficient for variable saturated flow
                call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                                            cinfvs_usg_cross_loc)

                if (evaporation) then
                  if (split_divdensv) then
                    call usg_face_utility_cinfevap_t(ivol,jvol,i1,       &
                             cinfevap_t_usg_loc,cinfevap_t_usg_cross_loc)
                    call usg_face_utility_cinfevap_pa(ivol,jvol,i1,      &
                             cinfevap_pa_usg_loc,cinfevap_pa_usg_cross_loc)
                  else
                    call usg_face_utility_cinfevap_pa(ivol,jvol,i1,      &
                             cinfevap_pa_usg_loc,cinfevap_pa_usg_cross_loc)
                  end if
                end if

                if (isconductive) then
                  call usg_face_utility_cinfheat_c(ivol,jvol,i1,         &
                           cinfheat_c_usg_loc,cinfheat_c_usg_cross_loc)
                end if

                if (isdispersive) then
                  call usg_face_utility_cinfheat_d(ivol,jvol,i1,         &
                           cinfheat_d_usg_loc,cinfheat_d_usg_cross_loc)
                end if

              end if
#endif

!cprovi--------------------------------------------------------------------------
!cprovi Advective term
!cprovi--------------------------------------------------------------------------
              if (isadvective) then

                if (b_icewater_heat) then
                  relheat_iw = r1
                else
                  relheat_iw = relheat_freezing((tempnew(ivol)+tempnew(jvol))*0.5d0, &
                                                 heatcapw,heatcapi,                  &
                                                 (uvsnew(ivol)+uvsnew(jvol))*0.5d0)
                end if
#ifdef USG
                if (discretization_type > 0) then

                  relps_loc = 0.0d0
                  if (is_cell_based_relp) then
                    nrelp = ncell
                    do icell = 1, ncell
                      i2 = jacell(icell,i1)
                      if (i2 >0) then
                        relps_loc(icell) = relperm(i2)
                      end if
                    end do
                  else
                    nrelp = 2
                    relps_loc(1:2) = (/relperm(ivol),relperm(jvol)/)
                  end if

                  vsfluxheat(icon) = darcy_energybal_usg(del_p(icon),del_p(icon),      &
                                        num_edge_dvols,ncell,                          &
                                        grad_ddflow_mids(1:num_edge_dvols,1:ncell),    &
                                        flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell),&
                                        density(ivol),density(jvol),                   &
                                        viscosity(ivol),viscosity(jvol),               &
                                        is_cell_based_relp,nrelp,relps_loc(1:nrelp),   &
                                        cinfvs_usg_loc(1:num_edge_dvols,1:ncell),      &
                                        cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell),&
                                        ups_heat,isboussinesq)

                  if (isboussinesq) then
                    heatflux_a(icon)=fluxheat(tempnew(ivol),tempnew(jvol),ivol,jvol,   &
                                              vsfluxheat(icon),nngl,tempold,i2up,      &
                                              sp_weight_heat,r1,r1)
                  else
                    heatflux_a(icon)=heatcapw*relheat_iw*                              &
                                     fluxheat(tempnew(ivol),tempnew(jvol),ivol,jvol,   &
                                              vsfluxheat(icon),nngl,tempold,i2up,      &
                                              sp_weight_heat,r1,r1)
                  end if

                else
#endif

                  vsfluxheat(icon) = darcy_energybal(del_p(icon),del_p(icon),          &
                                                     density(ivol),density(jvol),      &
                                                     viscosity(ivol),viscosity(jvol),  &
                                                     relperm(ivol),relperm(jvol),      &
                                                     cinfvs_a(i1),ups_heat,isboussinesq)


                  if (isboussinesq) then
                    heatflux_a(icon)=fluxheat(tempnew(ivol),tempnew(jvol),ivol,jvol,   &
                                              vsfluxheat(icon),nngl,tempold,           &
                                              i2up,sp_weight_heat,                     &
                                              distcells(i1,1),distcells(i1,2))
                  else
                    heatflux_a(icon)=heatcapw*relheat_iw*                              &
                                     fluxheat(tempnew(ivol),tempnew(jvol),ivol,jvol,   &
                                              vsfluxheat(icon),nngl,tempold,i2up,      &
                                              sp_weight_heat,distcells(i1,1),          &
                                              distcells(i1,2))
                  end if

#ifdef USG
                end if
#endif
              end if 
            end if


!cprovi--------------------------------------------------------------------------
!cprovi Conductive fluxes
!cprovi--------------------------------------------------------------------------
            del_temp(icon) = tempnew(jvol) - tempnew(ivol)

            if (isconductive) then

              if (b_icewater_heat) then
                relheat_iw = r1
              else
                relheat_iw = relheat_freezing(tempnew(ivol),heatcapw,heatcapi, &
                                              uvsnew(ivol))
              end if

              if (isboussinesq) then
                 coeff = r1/(heatcapw*relheat_iw*density(ivol))
              else
                 coeff = r1
              end if

#ifdef USG
              if (discretization_type > 0) then
                heatflux_c(icon) = - fluxdd_usg(                               &
                         del_temp(icon),num_edge_dvols,ncell,                  &
                         grad_temp_mids(1:num_edge_dvols,1:ncell),             &
                         flux_temp_hls_corr(1:num_edge_dvols,1:ncell),         &
                         cinfheat_c_usg_loc(1:num_edge_dvols,1:ncell),         &
                         cinfheat_c_usg_cross_loc(1:num_edge_dvols,1:ncell),   &
                         .false.,1,(/coeff/))
              else
#endif
                heatflux_c(icon) = - fluxdd(del_temp(icon),cinfheat_c(i1),coeff)
#ifdef USG
              end if
#endif

            end if
!cprovi--------------------------------------------------------------------------
!cprovi Dispersive fluxes 
!cprovi--------------------------------------------------------------------------                
            if (isdispersive) then

              if (b_icewater_heat) then
                relheat_iw = r1
              else
                relheat_iw = relheat_freezing((tempnew(ivol)+tempnew(jvol))*0.5d0,       &
                                               heatcapw,heatcapi,                        &
                                              (uvsnew(ivol)+uvsnew(jvol))*0.5d0)
              end if

#ifdef USG
              if (discretization_type > 0) then
                heatflux_d(icon) = diff_vapour_usg(tempnew(ivol),tempnew(jvol),           &
                                       num_edge_dvols,ncell,                              &
                                       grad_temp_mids(1:num_edge_dvols,1:ncell),          &
                                       flux_temp_hls_corr(1:num_edge_dvols,1:ncell),      &
                                       density(ivol),density(jvol),                       &
                                       pornew(ivol),pornew(jvol),                         &
                                       sanew(ivol),sanew(jvol),                           &
                                       cinfheat_d_usg_loc(1:num_edge_dvols,1:ncell),      &
                                       cinfheat_d_usg_cross_loc(1:num_edge_dvols,1:ncell),&
                                       r1,r1,heatcapw*relheat_iw,ups_heat,isboussinesq)
              else
#endif
                heatflux_d(icon) = diff_vapour(tempnew(ivol),tempnew(jvol),               &
                                        density(ivol),density(jvol),                      &
                                        pornew(ivol),pornew(jvol),                        &
                                        sanew(ivol),sanew(jvol),cinfheat_d(i1),           &
                                        r1,r1,heatcapw*relheat_iw,ups_heat,isboussinesq)
#ifdef USG
              end if
#endif
            end if
!cprovi--------------------------------------------------------------------------
!cprovi Vapour fluxes 
!cprovi--------------------------------------------------------------------------           
            if (evaporation) then

#ifdef USG
              if (discretization_type > 0) then

                if (split_divdensv) then
                  vapfluxheat(icon)  = diff_vapour_usg(uvsnew(ivol),uvsnew(jvol),              &
                                           num_edge_dvols,ncell,                               &
                                           grad_flow_mids(1:num_edge_dvols,1:ncell),           &
                                           flux_flow_hls_corr(1:num_edge_dvols,1:ncell),       &
                                           r1,r1,pornew(ivol),pornew(jvol),                    &
                                           sgnew(ivol),sgnew(jvol),                            &
                                           cinfevap_pa_usg_loc(1:num_edge_dvols,1:ncell),      &
                                           cinfevap_pa_usg_cross_loc(1:num_edge_dvols,1:ncell),&
                                           r1,r1,r1,ups_heat,.false.)


                  vapfluxheat(icon)  = vapfluxheat(icon) + diff_vapour_usg(tempnew(ivol),      &
                                          tempnew(jvol),num_edge_dvols,ncell,                  &
                                          grad_temp_mids(1:num_edge_dvols,1:ncell),            &
                                          flux_temp_hls_corr(1:num_edge_dvols,1:ncell),        &
                                          r1,r1,pornew(ivol),pornew(jvol),                     &
                                          sgnew(ivol),sgnew(jvol),                             &
                                          cinfevap_t_usg_loc(1:num_edge_dvols,1:ncell),        &
                                          cinfevap_t_usg_cross_loc(1:num_edge_dvols,1:ncell),  &
                                          r1,r1,r1,ups_heat,.false.)

                else
                  vapfluxheat(icon)  = diff_vapour_usg(densvnew(ivol),densvnew(jvol),          &
                                           num_edge_dvols,ncell,                               &
                                           grad_flow_mids(1:num_edge_dvols,1:ncell),           &
                                           flux_flow_hls_corr(1:num_edge_dvols,1:ncell),       &
                                           r1,r1,pornew(ivol),pornew(jvol),                    &
                                           sgnew(ivol),sgnew(jvol),                            &
                                           cinfevap_pa_usg_loc(1:num_edge_dvols,1:ncell),      &
                                           cinfevap_pa_usg_cross_loc(1:num_edge_dvols,1:ncell),&
                                           r1,r1,r1,ups_heat,.false.)
                end if

                heatflux_v(icon)   = heatcapv*fluxheat(tempnew(ivol),                          &
                                        tempnew(jvol),ivol,jvol,vapfluxheat(icon),nngl,tempold,&
                                        i2up,sp_weight_heat,r1,r1)

              else
#endif

                if (split_divdensv) then
                  vapfluxheat(icon)  = diff_vapour(uvsnew(ivol),uvsnew(jvol),r1,               &
                                            r1,pornew(ivol),pornew(jvol),                      &
                                            sgnew(ivol),sgnew(jvol),cinfevap_pa(i1),           &
                                            r1,r1,r1,ups_heat,.false.)
              
              
                  vapfluxheat(icon)  = vapfluxheat(icon) + diff_vapour(tempnew(ivol),          &
                                          tempnew(jvol),r1,r1,pornew(ivol),                    &
                                          pornew(jvol),sgnew(ivol),sgnew(jvol),cinfevap_t(i1), &
                                          r1,r1,r1,ups_heat,.false.)
                                      
                else
                  vapfluxheat(icon)  = diff_vapour(densvnew(ivol),densvnew(jvol),r1,           &
                                            r1,pornew(ivol),pornew(jvol),                      &
                                            sgnew(ivol),sgnew(jvol),cinfevap_pa(i1),           &
                                            r1,r1,r1,ups_heat,.false.)
                end if

                heatflux_v(icon)   = heatcapv*fluxheat(tempnew(ivol),                          &
                                        tempnew(jvol),ivol,jvol,vapfluxheat(icon),nngl,tempold,&
                                        i2up,sp_weight_heat,distcells(i1,1),distcells(i1,2))
#ifdef USG
              end if
#endif

              latvap_av = rhalf*(latvapnew(ivol)+latvapnew(jvol))
                                    
              heatflux_v(icon)   = heatflux_v(icon) + latvap_av*vapfluxheat(icon)                      
                              
              totheatflux = totheatflux +  heatflux_v(icon)                                                        
            end if
!cprovi--------------------------------------------------------------------------
!cprovi Add the total fluxes
!cprovi--------------------------------------------------------------------------     
            totheatflux = totheatflux + heatflux_a(icon) + heatflux_c(icon) + heatflux_d(icon)
      
      
          end do                          !loop - boundary control volumes

      end if
      
      if (totheatflux>r0) then   
          totinflux = totinflux + totheatflux
      else
          totoutflux = totoutflux - totheatflux
      end if

    end do                        !loop over boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
    call MPI_Allreduce(totinflux, totinflux_gbl,1,MPI_REAL8,           & 
               MPI_SUM, Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    totinflux = totinflux_gbl
    
    call MPI_Allreduce(totoutflux, totoutflux_gbl,1,MPI_REAL8,         & 
               MPI_SUM, Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    totoutflux = totoutflux_gbl    
#endif

!cprovi----------------------------------------------------------------
!cprovi  write total contributions to file   
!cprovi----------------------------------------------------------------
    imheat = imheat + 1
    
    if(rank == 0 .and. b_enable_output) then    
      if (b_output_trans_binary) then
        nvarsimheat = 4
        realbuffer_gb(1:nvarsimheat)=(/time_io,totinflux,totoutflux,   &
                                     totheatstor/)
        call binary_write_data(imheat_mpi(imheat), 1,          &
                     (/mtime/),offset_imheat_ijk(imheat),.true.)
        call binary_write_data(imheat_mpi(imheat), nvarsimheat,&
                     realbuffer_gb,offset_imheat(imheat),.true.) 

        offset_imheat(imheat) = offset_imheat(imheat) +                &
                                nvarsimheat*nfloatbit

      else
        if (mtime == mtime_append .and. i_append_sim >= 1) then
          call reposition_file(imheat,irecord)
        end if

        if (i_append_sim < 1 .or.                                      &
           (mtime >= mtime_append .and. i_append_sim >= 1)) then
          write(imheat,ascii_fmt) time_io,totinflux,totoutflux,        &
                                       totheatstor
        end if
      end if
    end if
    
!cprovi---------------------------------------------------------------
!cprovi  compute absolute and relative mass balance error 
!cprovi---------------------------------------------------------------
      absbalance = (totinflux-totoutflux-totheatstor)*delt
      relbalance = absbalance/totenergy*r100
!cprovi--------------------------------------------------------------- 
!cprovi  compute accumulative absolute and relative mass balance error 
!cprovi---------------------------------------------------------------
      culabsbalheat = culabsbalheat + absbalance
      culrelbalheat = culabsbalheat/totenergy*r100

      imheat = imheat + 1
      
      if(rank == 0 .and. b_enable_output) then
        if (b_output_trans_binary) then
          nvarsimheat = 5
          realbuffer_gb(1:nvarsimheat)=(/time_io,absbalance,relbalance,  &
                                   culabsbalheat,culrelbalheat/)
          call binary_write_data(imheat_mpi(imheat), 1,          &
                       (/mtime/),offset_imheat_ijk(imheat),.true.)
          call binary_write_data(imheat_mpi(imheat), nvarsimheat,&
                       realbuffer_gb,offset_imheat(imheat),.true.) 

          offset_imheat(imheat) = offset_imheat(imheat) +              &
                                  nvarsimheat*nfloatbit

        else
          if (mtime == mtime_append .and. i_append_sim >= 1) then
            call reposition_file(imheat,irecord)
          end if

          if (i_append_sim < 1 .or.                                    &
             (mtime >= mtime_append .and. i_append_sim >= 1)) then
            write(imheat,ascii_fmt) time_io,absbalance,                &
                  relbalance,culabsbalheat,culrelbalheat
          end if
        end if
    
      end if

      return
  
  end subroutine   
