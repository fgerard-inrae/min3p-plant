!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/seepfdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine seepfdd
!c -------------------
!c
!c seepage face iteration control
!c
!c written by:      Uli Mayer - July 10, 1996
!c
!c last modified:   Tom Henderson - October 7, 2002
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + +
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           relperm(nn)        = relative permeability               + -
!c           uvsold(nn)         = solution vector (old time level)    + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           vsflux(ncon-1)     = interfacial fluxes                  * +
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ---------- 
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           javs(njavs)        = connectivity list                   + - 
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary
!c                                control volumes
!c                                (variably saturated flow)
!c           nseep_first        = number of seepage face nodes        + -
!c
!c           logical:
!c           --------
!c           seep_iter          = .true.  -> continue seepage face    + +
!c                                           iteration 
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c           iups(ncon-1)       = upstream pointer array              * +
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + - 
!c           dcoef(ncon-1)      = coefficient including density,      + -
!c                                viscosity, and relative 
!c                                permeability
!c
!c local:    real*8:
!c           -------
!c           totvsflux          = total flux 
!c           r0                 = constant
!c           r1                 = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control volumes)
!c           icon               = pointer (connections - local)
!c           iend               = pointer (end of row)
!c           istart             = pointer (start of row)
!c           ivol               = counter (control volumes)
!c           jvol               = pointer
!c           not_matched        = number of nonconforming seepage 
!c                                face nodes
!c
!c external: fluxdd   = flux function for variably saturated 
!c                      density dependent flow       
!c ----------------------------------------------------------------------

      subroutine seepfdd

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use dens
      use phys, only : is_cell_based_relp
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols,num_edge_maxcells
      use gradient_usg, only : gradient_cross_diff_dd
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxdd_usg, only : fluxdd_usg
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: i1, i2, ibvs, ivol, istart, iend, icon, jvol, not_matched
      
      real(type_r8) :: rho_av_loc, dcoef_loc, totvsflux

      real(type_r8), external :: fluxdd

#ifdef PETSC 
      integer :: not_matched_gbl, nseep_first_gbl
      PetscErrorCode :: ierrcode
#endif        

#ifdef USG
      integer :: icell, idvol, kvol, ncell, ndvol, nrelp
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_ddflow_locs(num_crossdifficv_max),           &
                     grad_ddflow_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rhalf = 0.5d0,      &
                           r2 = 2.0d0, r3 = 3.0d0

!c  reassign seepage face boundary condition
 
      not_matched = 0
      nseep_first = 0
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbvs > numofloops_thred_seepfdd_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, idvol, kvol, ncell, ndvol, nrelp, relps_loc,         &
    !$omp grad_weights,                                               &
    !$omp grad_ddflow_mids, flux_ddflow_hls_corr,                     &
    !$omp grad_ddflow_locs, grad_ddflow_hls_loc,                     &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc,                       &
#endif
    !$omp i1, i2, ibvs, icon, iend, istart, ivol, jvol,               &
    !$omp dcoef_loc, del_p, del_z, rho_av_loc, totvsflux, vsflux)     &
    !$omp reduction(+:not_matched, nseep_first)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif

      do ibvs = 1,nbvs             !loop over boundary control volumes

        if (compute_ice_sheet_loading) then
          if (.not. b_iabvs_ice(ibvs)) then
            cycle
          end if
        end if

!c  check only on seepage face boundary

        if (btypevs(ibvs).eq.'seepage' .or. &
            btypevs(ibvs).eq.'seepage-second') then  
          
          ivol = iabvs(ibvs)         !pointer to control volume
          if (ivol < 0) then
            cycle  
          end if

!c  check, if seepage face too low and reassign if p>0

          if ((seepage_bits(ibvs).ge.2).and.(uvsnew(ivol).gt.r0)) then  
            !bcondvs(ibvs) = -r1
            seepage_bits(ibvs) = 1
            uvsnew(ivol) = r0
            uvsold(ivol) = r0
!c            pressure(ivol) = r0 * density(ivol) * gacc 
            not_matched = not_matched+1
            nseep_first = nseep_first+1    !sum up seepage face nodes

!c  check, if seepage face too high and reassign if necessary,
!c  this is done by doing a mass balance on all seepage face 
!c  control volume with p=0, the zero pressure boundary condition
!c  is correct, if the change in mass is negative, i.e. outflow
!c  occurs over the boundary, if the change in mass is positive
!c  a zero flux boundary has to be assigned 
 
          elseif (seepage_bits(ibvs).eq.1) then

!c  calculate total flux

            istart = iavs(ivol)       !pointer - start of row 
            iend = iavs(ivol+1)-1     !pointer - end of row
            icon = 0                  !counter (connections)
            totvsflux = r0            !initialize total influx

            do i1=istart,iend         !loop over connections

#ifdef USG
              if (discretization_type > 0) then
                ncell = janumcell(i1)
              end if
#endif

              jvol = javs(i1)         !column pointer


              if (jvol.ne.ivol) then
                icon = icon+1         !counter (connections)

                del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
                del_z(icon) = zg(jvol) - zg(ivol)

                if (del_z(icon) .ne. r0) then
                  rho_av_loc = rhalf * (density(ivol) + density(jvol))

                  if (av_dens_z) then
                    del_p(icon) = rho_av_loc*(uvsnew(jvol)/density(jvol)-&
                                              uvsnew(ivol)/density(ivol))
                  end if

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential

                  del_z(icon) = del_z(icon) * rho_av_loc * gacc
                  del_p(icon) = del_p(icon) + del_z(icon)
                end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
 
                if (.not.is_cell_based_relp) then
                  if (upstream) then                  
                    if (del_p(icon) .gt. r0) then
                      dcoef_loc = relperm(jvol) * density(jvol)/viscosity(jvol)
                    else
                      dcoef_loc = relperm(ivol) * density(ivol)/viscosity(ivol)   !upstream kr, density & visc
                    end if
                  else
                    dcoef_loc = (relperm(ivol)+relperm(jvol))*rhalf*   &
                                (density(ivol)+density(jvol))/         &
                                (viscosity(ivol)+viscosity(jvol))
                  end if
                end if
#ifdef USG
                if (discretization_type > 0 .and. is_cell_based_relp) then
                  !c apply relative permeability later for cell based relative permeability
                  dcoef_loc = (density(ivol)+density(jvol))/           &
                              (viscosity(ivol)+viscosity(jvol))
                end if
#endif

                if (b_use_fixed_flow_vel) then
                              
                  if (b_use_zero_flow_vel) then
                    vsflux(icon) = r0
                  else
                    !c TBD
                  end if
                
                else
#ifdef USG
                  if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                    grad_ddflow_mids = vector_zero
                    flux_ddflow_hls_corr = r0

                    if (b_use_cross_diffusion_flow) then
                      call gradient_cross_diff_dd(i1,ivol,jvol,        &
                           grad_ddflow_locs,grad_ddflow_mids,          &
                           grad_weights,flux_ddflow_hls_corr,          &
                           grad_ddflow_hls_loc)
                    end if

!cdsu calculate influence coefficient for variable saturated flow
                    call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,    &
                                                 cinfvs_usg_cross_loc)

                    relps_loc = 0.0d0
                    if (is_cell_based_relp) then
                      nrelp = ncell
                      do icell = 1, ncell
                        i2 = jacell(icell,i1)
                        if (i2 >0) then
                          relps_loc(icell) = relperm(i2)
                        end if
                      end do
                    else
                      nrelp = 2
                      relps_loc(1:2) = 1.0d0
                    end if

                    vsflux(icon) = -fluxdd_usg(del_p(icon),num_edge_dvols,ncell,      &
                                      grad_ddflow_mids(1:num_edge_dvols,1:ncell),     &
                                      flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell), &
                                      cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                                      cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell), &
                                      is_cell_based_relp,nrelp,                       &
                                      relps_loc(1:nrelp)*dcoef_loc)
                  else
#endif

!c  compute fluxes between current control volume and adjacent 
!c  control volumes
       
                    vsflux(icon) = - fluxdd(del_p(icon),                 &
                                            cinfvs_a(i1), dcoef_loc)

#ifdef USG
                  end if
#endif
                end if
              
                totvsflux = totvsflux + vsflux(icon)

              end if                  !(ivol.eq.jvol)
            end do                    !loop over connections

            if (btypevs(ibvs).eq.'seepage') then
              if (totvsflux.gt.r0) then
                !bcondvs(ibvs) = r1             !set to zero flux
                seepage_bits(ibvs) = 2
                not_matched = not_matched+1
              else    
                nseep_first = nseep_first + 1  !sum up seepage face nodes
              end if
            else if (btypevs(ibvs).eq.'seepage-second') then
              if (totvsflux.gt.bcondvs(ibvs)) then
                !bcondvs(ibvs) = r1             !set to zero flux
                !c set bit position 2 to pause influx to avoid seepage fluctuation
                seepage_bits(ibvs) = 5
                not_matched = not_matched+1
              else    
                nseep_first = nseep_first + 1  !sum up seepage face nodes
              end if
            end if
            
          else if (ibits(seepage_bits(ibvs),2,1).eq.1) then
            nseep_first = nseep_first + 1      !sum up seepage face nodes
          end if                   !(p>0/p=0)
        end if                     !(seepage)
      end do                       !loop over boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif   

#ifdef PETSC
      call MPI_Allreduce(not_matched, not_matched_gbl,1,               &
                MPI_INTEGER4,MPI_SUM, Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      not_matched = not_matched_gbl

      call MPI_Allreduce(nseep_first, nseep_first_gbl,1,               &
                MPI_INTEGER4,MPI_SUM, Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nseep_first = nseep_first_gbl
          
#endif

!c  check for convergence of seepage face iteration

      if (not_matched.eq.0) then
        seep_iter = .false.
      end if
 
      return
      end 
