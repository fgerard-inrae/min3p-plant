!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacbvs_energybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacbvs
!c -----------------
!c
!c incorporate dirichlet and neumann type boundary condition in 
!c jacobian matrix and rhs vector for variably saturated flow 
!c
!c written by:      Uli Mayer - May 6, 96
!c
!c last modified:   Tom Henderson - March 20, 2003
!c                  added point source
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = Jacobian matrix                     + +
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           bvs(nn)            = rhs vector                          + +
!c           
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           njavs              = number of global connections        + -
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c dens.f:   real*8:
!c           -------
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density 
!c                                           dependent flow
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           ibvs               = counter (boundary control volumes)
!c           istart             = pointer (start of row) 
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal entry)
!c           i1                 = counter (row entries)
!c
!c           logical
!c           -------
!c           isdebug            = debugging information level
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine jacbvs_energybal 
 
      use parm
      use gen
      use dens
      use phys 
      use chem
      
#ifdef OPENMP
      use omp_lib 
#endif 

#ifdef USG
      use usg_mesh_data, only : node_cells, node_num_cells
#endif

      implicit none
      
      character(len=100) :: typebc
      logical            :: isdebug
     
      integer :: i1, ibheat, ibvs, ivol, istart, iend, idiag , izn
#ifdef USG
      integer :: icell, ncell, cindex
#endif

      real*8 :: waterflux, densloc, densinc_ivol, dheatflux, heatflux, &
                tempinc_ivol, temploc, dtemp_ivol, &
                viscoinc_ivol, heatflux_temp,        &
                condz_free, relp_loc, relheat_iw,&
                rdummy1, rdummy2
      
      real*8, external :: ddbdflux_energybal, rhonew, visconew,        &
              fluxvs_free_drainage, relheat_freezing

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
  
!c  debug toggle
 
      isdebug = .false. 

!c  loop over boundary control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, ncell, cindex,                                       &
#endif
    !$omp i1, izn, ibheat, ibvs, idiag, iend, istart, ivol,  relp_loc,&
    !$omp densinc_ivol, densloc, dheatflux, dtemp_ivol, condz_free,   &
    !$omp heatflux, heatflux_temp, tempinc_ivol, temploc, relheat_iw, &
    !$omp typebc, viscoinc_ivol, waterflux, rdummy1, rdummy2)

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif  

#endif
      do ibvs = 1,nbvs
          
        ivol = iabvs(ibvs)
        if (ivol < 0) then
          cycle  
        end if
        
        if (compute_ice_sheet_loading) then
          if (.not. b_iabvs_ice(ibvs)) then
            cycle
          end if
        end if
 
!c  modify for second type flow boundary condition and
!c  point source boundary
!c  calculate mass flux
 
        if ((btypevs(ibvs).eq.'second') .or.                           &
            (btypevs(ibvs).eq.'seepage-second' .and.                   &
            ibits(seepage_bits(ibvs),1,1).eq.1) .or.                   &
            (btypevs(ibvs).eq.'free-drainage') .or.                    &
            (btypevs(ibvs).eq.'point') .or.                            &
            (btypevs(ibvs).eq.'evaporation'.and.evaporation)) then

          if (btypevs(ibvs).eq.'free-drainage') then
            if (permeability_field) then
#ifdef USG
              if (discretization_type > 0 .and. is_cell_based_perm_cond) then
                ncell = node_num_cells(ivol)
                condz_free = r0
                do icell = 1, ncell
                  cindex = node_cells(icell,ivol)
                  condz_free = condz_free + permz(cindex)
                end do
                condz_free = condz_free / ncell
              else
#endif
                condz_free = permz(ivol)
#ifdef USG
              end if
#endif

#ifdef USG
              if (discretization_type > 0 .and. is_cell_based_relp) then
                ncell = node_num_cells(ivol)
                relp_loc = r0
                do icell = 1, ncell
                  cindex = node_cells(icell,ivol)
                  relp_loc = relp_loc + relperm(cindex)
                end do
                relp_loc = relp_loc / ncell
              else
#endif
                relp_loc = relperm(ivol)
#ifdef USG
              end if
#endif

            else
              izn = mpropvs(ivol)
              condz_free = condzz(izn)*k_depth_ratio(ivol)
            end if

            if (density_dependence) then
              !c for density dependent flow, permeability is stored in permz and condzz
              condz_free = condz_free*density(ivol)*gacc/viscosity(ivol)
            end if

            bcondvs(ibvs) =  - fluxvs_free_drainage(relp_loc,          &
                                      condz_free,perm_fac(ivol),       &
                                      gradf_bvs(ibvs),areaf_bvs(ibvs))
          end if

          if ((density_dependence).and.(.not.flow_verification)) then
             waterflux = bcondvs(ibvs)
             if (isboussinesq) then
                if (waterflux>r0) then
                     densloc=ssdens(ivol)/density(ivol)
                else
                     densloc=r1
                end if
                                
                bglob(ivol) = bglob(ivol) + densloc*waterflux
             else   
                if (massflux_second) then  
                 bglob(ivol) = bglob(ivol) + waterflux 
                else
                   if (waterflux>r0) then
                     densloc=ssdens(ivol)
                   else
                     densloc=density(ivol)
                   end if  
                   bglob(ivol) = bglob(ivol) + waterflux * densloc 
                end if     
             end if   
          else 
            bglob(ivol) = bglob(ivol) + bcondvs(ibvs)
          end if

          
!c  modify for first type boundary and zero pressure seepage face
!c  boundary conditions
 
        elseif ((btypevs(ibvs).eq.'first').or.                        &
                ((btypevs(ibvs).eq.'seepage'.or.                      &
                  btypevs(ibvs).eq.'seepage-second').and.             &
                  ibits(seepage_bits(ibvs),0,1).eq.1)) then

          istart = iaglob(ivol)          !pointer - start of row
          iend = iaglob(ivol+1)-1        !pointer - end of row
          idiag = iaglob(ivol)           !pointer - diagonal

          do i1=istart,iend            !modify matrix and rhs
            aglob(i1) = r0
          end do          
      
          aglob(idiag) = r1
 
          bglob(ivol) = r0 
          
        elseif (btypevs(ibvs).eq.'atmospheric'.and.evaporation) then
  
          call jacbevap(ivol,'flow',rdummy1,rdummy2) 
             
        end if                        !(btypevs(ibvs).eq......)

      end do                          !loop - boundary control volumes 
      
#ifdef OPENMP
    !$omp end do
#endif
    
#ifdef OPENMP
    !$omp barrier
#endif
      
!cprovi--------------------------------------------------------------------------------------
!cprovi Boundary conditions for heat equation 
!cprovi-------------------------------------------------------------------------------------- 
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
      do ibheat = 1,nbheat
          
        !if(.not.bvalid_iabheat(ibheat)) then
        !    cycle
        !end if
        
        ivol = iabheat(ibheat)
        
        if (ivol < 0) then
          cycle  
        end if
 
        if (b_icewater_heat) then
          relheat_iw = r1
        else
          relheat_iw = relheat_freezing(tempnew(ivol),heatcapw,heatcapi,uvsnew(ivol))
        end if

!c  modify for second type flow boundary condition and
!c  point source boundary
!c  calculate mass flux
        if (btypeheat(ibheat)=='free') then
          
          heatflux=ddbdflux_energybal(ivol,density(ivol),    &
                                      viscosity(ivol))

          if (heatflux<r0) then
          
              temploc=tempnew(ivol)
              dtemp_ivol = dinc_heat
              tempinc_ivol = tempnew(ivol) + dtemp_ivol
              idiag = iaglob(ivol+nngl)
              
              if (isboussinesq) then
              
                densloc=r1
                dheatflux=heatflux*(tempinc_ivol-temploc)/dtemp_ivol
              
              else !boussinesq
              
                densloc=density(ivol)

                if (ispitzerdens) then
                  densinc_ivol =rhonew (ref_dens,            &
                         density_pitzer(ivol),               &
                         ref_dens,tempinc_ivol,tempref_dens, &
                         r1,drho_dt,nonlindens_heat,cdens1,  &
                         cdens2,cdens3,cdens4)
                else
                  densinc_ivol = rhonew (ref_dens,           &
                         tds_new(ivol),                      &
                         ref_tds,tempinc_ivol,tempref_dens,  &
                         drho_dc,drho_dt,nonlindens_heat,    &
                         cdens1,cdens2,cdens3,cdens4)
                end if

                if (update_viscosity_temp) then
                  viscoinc_ivol = visconew(densinc_ivol,     &
                                  tds_new(ivol),tempinc_ivol,&
                                  update_viscosity,          &
                                  update_viscosity_temp,     &
                                  cvisco1,cvisco2,cvisco3,   &
                                  cvisco4,cvisco5,           &
                                  tempref_dens,iviscomodel,  &
                                  ref_visco,ref_tds,ref_dens)
                else
                  viscoinc_ivol = viscosity(ivol)
                end if

                heatflux_temp=ddbdflux_energybal(ivol,       &
                              densinc_ivol,viscoinc_ivol)
              
                dheatflux = heatcapw*relheat_iw*             &
                   (heatflux_temp*densinc_ivol*tempinc_ivol- &
                    heatflux*densloc*temploc)/dtemp_ivol

              end if !boussinesq
            
              aglob(idiag)=aglob(idiag) - dheatflux
            
          else  !heatflux
          
            temploc=bcondheat(ibheat)
            if (isboussinesq) then
              densloc=ssdens(ivol)/density(ivol)
            else
              densloc=ssdens(ivol)
            end if
             
          end if !heatflux
          
          if (massflux_second) then
            heatflux=heatflux*heatcapw*relheat_iw*temploc
          else
            heatflux=heatflux*densloc*heatcapw*relheat_iw*temploc
          end if !massflux_second
           
          bglob(ivol+nngl) = bglob(ivol+nngl) + heatflux
          
        elseif (btypeheat(ibheat)=='fluxw+') then
          heatflux=ddbdflux_energybal(ivol,density(ivol),             & 
                                      viscosity(ivol))
          if (heatflux<r0) then
            heatflux = r0
            temploc=r0
            densloc=r0
          else
            temploc=bcondheat(ibheat)
            if (isboussinesq) then  
              densloc=ssdens(ivol)/density(ivol)
            else
              densloc=ssdens(ivol)*heatcapw*relheat_iw
            end if
          end if
          
          if (massflux_second) then  
            heatflux=heatflux*temploc
          else
            heatflux=heatflux*densloc*temploc 
          end if
       
         bglob(ivol+nngl) = bglob(ivol+nngl) + heatflux 
           
       
            
        else if ((btypeheat(ibheat)=='second') .or.                   &
                  (btypeheat(ibheat).eq.'point')) then
 
          bglob(ivol+nngl) = bglob(ivol+nngl) + bcondheat(ibheat) 
 
        elseif ((btypeheat(ibheat)=='first').or.                      &
                (btypeheat(ibheat)=='seepage'.and.                    &
                 bcondheat(ibheat)<r0)) then

          istart = iaglob(ivol+nngl)          !pointer - start of row
          iend = iaglob(ivol+nngl+1)-1        !pointer - end of row
          idiag = iaglob(ivol+nngl)           !pointer - diagonal

          do i1=istart,iend            !modify matrix and rhs
            aglob(i1) = r0
          end do          
        
          aglob(idiag) = r1

          bglob(ivol+nngl) = r0 
        
       elseif (btypeheat(ibheat)=='atmospheric') then 
    
          call jacbevap(ivol,'heat',rdummy1,rdummy2)
            
       end if 
        
      end do                          !loop - boundary control volumes
      
#ifdef OPENMP
    !$omp end do
#endif  

#ifdef OPENMP
    !$omp barrier
#endif
      
#ifdef OPENMP
    !$omp end parallel
#endif  
        
!cprovi-------------------------------------------------------------                    
!cprovi-------------------------------------------------------------                    
!cprovi-------------------------------------------------------------   
#ifdef DEBUG
      if (isdebug) then
        write(idbg,*) '---------------------------------------------------'
        write(idbg,*) 'jabobian and residual'
        write(idbg,*) '---------------------------------------------------'
        write(idbg,*) aglob,bglob
      end if
#endif
!cprovi-------------------------------------------------------------                    
!cprovi-------------------------------------------------------------                    
!cprovi-------------------------------------------------------------

      return
      end
