!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initppsn.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initppsn
!c -------------------
!c
!c physical parameters for the surface nodes and cells of simulation domain, 
!c required by ice loading/unloading
!c
!c written by:      Danyang Su - April 03, 20
!c
!c last modified:   
!c
!c ----------------------------------------------------------------------
 
      subroutine initppsn
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use gen
      use file_unit, only : lun_get, lun_free
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize, PETSc_Comm_Group
#endif

#ifdef USG
      use geometry
      use usg_ice_sheet
      use usg_mesh_surface
      use usg_mesh_data, only :                                        &
#ifdef PETSC
                                num_cells_loc,                         &
#endif
                                is_boundary_node, is_boundary_cell,    &
                                node_to_layer_node, cell_to_layer_cell,&
                                CellCenter, num_nodes, num_cells,      &
                                cell_type, num_nodes_per_cell,         &
                                cell_projection, num_nodes_per_layer,  &
                                num_cells_per_layer
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      PetscErrorCode :: ierrcode
      PetscInt :: irank
#endif

      integer :: i, ic, izn, ivol, ivol_ln, icell, ibice, nbicep,      &
                 ibasal, igroup, nbasal_nodes, nbasal_cells, nzice,    &
                 l_string, ierr, ierrcd

      integer, allocatable :: isn_to_sg_send(:), isn_to_sg_recv(:)
                 
      real*8 :: xbmin, xbmax, ybmin, ybmax, zbmin, zbmax ,factiny

      character*72 :: subsection

      external readbloc
 
      logical found_section, found_subsection, iserror

      real*8, parameter :: r0 = 0.0d0, tiny = 1.0d-8 

!c  read numerical data and write to temporary file

      ierrcd = 0

      section_header = 'physical parameters - ice sheet loading/unloading' 
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header
      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

  !c  write section header to generic output file                          
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72) 
        write(igen,'(a)') section_header(:l_string) 
        write(igen,'(72a/)')('-',i=1,72)         
      end if

      if (.not. found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section ',trim(section_header),' is missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  define surface cell type
#ifdef USG      
      if (cell_type == cell_type_prism) then    
        cell_type_sn = cell_type_tri
      else if (cell_type == cell_type_hexa) then
        cell_type_sn = cell_type_quad
      else if (cell_type == cell_type_quad) then
        cell_type_sn = cell_type_line
      end if
      
      num_nodes_sn_per_cell = num_nodes_per_cell/2
#endif

!c  read number of material property zones
      ierrcd = 1
      read(itmp,*,err=999,end=999) nzice                !number of zones
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
          'number of zones for ice sheet basal             = ',nzice
      end if

!c  initialize indices of ice sheet basal nodes and cells
#ifdef USG
      allocate (node_idx_sn2lg(nngl), stat = ierr) 
      node_idx_sn2lg=0 
      call checkerr(ierr,'node_idx_sn2lg',ilog) 
      call memory_monitor(sizeof(node_idx_sn2lg),'node_idx_sn2lg',.true.)

      allocate (node_idx_lg2sn(nngl), stat = ierr) 
      node_idx_lg2sn=0 
      call checkerr(ierr,'node_idx_lg2sn',ilog)
      call memory_monitor(sizeof(node_idx_lg2sn),'node_idx_lg2sn',.true.)

      allocate (node_idx_ln2sn(num_nodes_per_layer), stat = ierr) 
      node_idx_ln2sn=0 
      call checkerr(ierr,'node_idx_ln2sn',ilog)
      call memory_monitor(sizeof(node_idx_ln2sn),'node_idx_ln2sn',.true.)  

      allocate (cell_idx_sn2lg(num_cells), stat = ierr) 
      cell_idx_sn2lg=0 
      call checkerr(ierr,'cell_idx_sn2lg',ilog) 
      call memory_monitor(sizeof(cell_idx_sn2lg),'cell_idx_sn2lg',.true.)

!c  initialize number of ice sheet basal nodes and cells
      num_nodes_sn = 0
      num_cells_sn = 0
      num_nodes_sn_loc = 0
      num_cells_sn_loc = 0
#endif

!c  loop over ice basal zones      
      do izn = 1, nzice
!c  read physical parameters for ice sheet basal
        subsection = 'number and name of zone'
        call findzone(subsection,itmp,found_subsection,izn,zone_name)

        if (found_subsection) then
          call readzone(itmp,icnv,ilog,zone_name,found_subsection)
        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error in input file'
            write(ilog,*) 'section "',trim(subsection),'"'
            write(ilog,*) 'zone number "',izn, '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if  
        
!c  define length of zone name
        l_zone_name = index(zone_name,'  ')-1
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
          l_zone_name = 72
        end if 

!c  read coordiantes defining boundary zone,
        type_extent_zone = -1
        type_extent_zone_box = -1
  
        subsection = 'extent of zone'
        call findstrg(subsection,icnv,found_subsection)
  
        if (found_subsection) then  
          type_extent_zone = 0  
          ierrcd = 2
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
                                       zbmin,zbmax  
        end if
  
#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 3
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
                                       zbmin,zbmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xbmin = -1.0d300
          xbmax = 1.0d300
        end if
      
        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ybmin = -1.0d300
          ybmax = 1.0d300
        end if
      
        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zbmin = -1.0d300
          zbmax = 1.0d300
        end if
  
!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then  
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "', section_header(:l_string),'"'
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
            l_string = index(subsection,' ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
               l_string=72
            end if
            write(ilog,*) 'subsection "'//subsection(:l_string)//'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
  
        end if  

!c  increment boundary coordinates                                       
                                                                        
        factiny=dabs(xbmax-xbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        xbmin = xbmin-factiny 
        xbmax = xbmax+factiny 
        factiny=dabs(ybmax-ybmin)*tiny 
        if (factiny==r0) factiny=tiny 
        ybmin = ybmin-factiny 
        ybmax = ybmax+factiny 
        factiny=dabs(zbmax-zbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        zbmin = zbmin-factiny 
        zbmax = zbmax+factiny  
        
!c  store related nodes that served as ice sheet basal              
!c  for global system in compressed storage
        nbasal_nodes = 0
        do ivol = 1,nngl 

!c  check limits of boundary zone                                              
          if (((type_extent_zone==0.or.type_extent_zone_box>0) .and. &
            (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.        &
            (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.        &
            (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.        &
            (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
             ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
            if (discretization_type > 0 .and. type_extent_zone_box > 0) then
              if ((btest(type_extent_zone_box,1) .and.               &
                   .not. is_boundary_node(ivol)) .or.                &
                  (btest(type_extent_zone_box,2) .and.               &
                   is_boundary_node(ivol))) then
                cycle
              end if
            end if
                                                                        
!c  assign boundary type and boundary condition                       
            nbasal_nodes = nbasal_nodes + 1
            num_nodes_sn = num_nodes_sn + 1
!c  skip ghost nodes
#ifdef PETSC
            if (node_idx_lg2l(ivol) > 0) then
#endif
              num_nodes_sn_loc = num_nodes_sn_loc + 1
#ifdef PETSC
            end if
#endif
                                                                        
!c  assign pointer and type                                                                          
            node_idx_sn2lg(num_nodes_sn) = ivol
            node_idx_lg2sn(ivol) = num_nodes_sn
            node_idx_ln2sn(node_to_layer_node(ivol)) = num_nodes_sn
#endif            
          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes  

!c  store related nodes that served as ice sheet basal              
!c  for global system in compressed storage
#ifdef USG
        nbasal_cells = 0
        do icell = 1,num_cells                  !loop over control volumes
          if (((type_extent_zone==0.or.type_extent_zone_box>0) .and.   &
              (CellCenter(icell)%x.gt.xbmin).and.                      &
              (CellCenter(icell)%x.lt.xbmax) .and.                     &
              (CellCenter(icell)%y.gt.ybmin).and.                      &
              (CellCenter(icell)%y.lt.ybmax) .and.                     &
              (CellCenter(icell)%z.gt.zbmin).and.                      &
              (CellCenter(icell)%z.lt.zbmax)) .or.                     &
              (type_extent_zone>0 .and. cell_iflags(icell)>=0 .and.    &
              ibits(type_extent_zone,0,1) == 1)) then

              if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                if ((btest(type_extent_zone_box,1) .and.               &
                     .not. is_boundary_cell(icell)) .or.               &
                    (btest(type_extent_zone_box,2) .and.               &
                     is_boundary_cell(icell))) then
                  cycle
                end if
              end if

!c  assign boundary type and boundary condition                       
            nbasal_cells = nbasal_cells + 1
            num_cells_sn = num_cells_sn + 1
!c  skip ghost cells
#ifdef PETSC
          if (icell <= num_cells_loc) then
#endif
            num_cells_sn_loc = num_cells_sn_loc + 1
#ifdef PETSC
          end if
#endif
                                                                        
!c  assign pointer and type                                                                          
            cell_idx_sn2lg(num_cells_sn) = icell
          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over cells 
#endif
      end do           !loop over zones

#ifdef USG
!c  reallocate ice sheet basal related arrays to the required size
      allocate (iwork(num_nodes_sn), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initcpice-iwork',.true.)

      !c node_idx_sn2lg
      do ibasal = 1,num_nodes_sn
        iwork(ibasal) = node_idx_sn2lg(ibasal)
      end do

      call memory_monitor(-sizeof(node_idx_sn2lg),'node_idx_sn2lg',.true.)
      deallocate (node_idx_sn2lg, stat = ierr)
      call checkerr(ierr,'node_idx_sn2lg',ilog)

      allocate (node_idx_sn2lg(num_nodes_sn), stat = ierr)
      call checkerr(ierr,'node_idx_sn2lg',ilog)
      call memory_monitor(sizeof(node_idx_sn2lg),'node_idx_sn2lg',.true.)

      do ibasal = 1,num_nodes_sn
        node_idx_sn2lg(ibasal) = iwork(ibasal)
      end do

      call memory_monitor(-sizeof(iwork),'initcpice-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)  

!c  initialize surface icethickness with negative inifinity
      allocate (ice_thickness_old(num_nodes_sn), stat = ierr)
      ice_thickness_old = r0
      call checkerr(ierr,'ice_thickness_old',ilog)
      call memory_monitor(sizeof(ice_thickness_old),                   &
                          'ice_thickness_old',.true.)  

      allocate (ice_thickness_new(num_nodes_sn), stat = ierr)
      ice_thickness_new = r0
      call checkerr(ierr,'ice_thickness_new',ilog)
      call memory_monitor(sizeof(ice_thickness_new),                   &
                          'ice_thickness_new',.true.)

      allocate (ice_thickness_new_prev(num_nodes_sn), stat = ierr)
      ice_thickness_new_prev = r0
      call checkerr(ierr,'ice_thickness_new_prev',ilog)
      call memory_monitor(sizeof(ice_thickness_new_prev),              &
                          'ice_thickness_new_prev',.true.)

      allocate (ice_thickness_new_next(num_nodes_sn), stat = ierr)
      ice_thickness_new_next = r0
      call checkerr(ierr,'ice_thickness_new_next',ilog)
      call memory_monitor(sizeof(ice_thickness_new_next),              &
                          'ice_thickness_new_next',.true.)

      allocate (ice_thickness_phw2ice_new(num_nodes_sn), stat = ierr)
      ice_thickness_phw2ice_new = r0
      call checkerr(ierr,'ice_thickness_phw2ice_new',ilog)
      call memory_monitor(sizeof(ice_thickness_phw2ice_new),           &
                          'ice_thickness_phw2ice_new',.true.)      

      allocate (ice_thickness_phw2ice_old(num_nodes_sn), stat = ierr)
      ice_thickness_phw2ice_old = r0
      call checkerr(ierr,'ice_thickness_phw2ice_old',ilog)
      call memory_monitor(sizeof(ice_thickness_phw2ice_old),           &
                          'ice_thickness_phw2ice_old',.true.)   

!c  initialize global ice thickness, used for pore stress calculation
#ifdef PETSC
      allocate (ice_thickness_gbl_old(num_nodes_per_layer), stat = ierr)
      ice_thickness_gbl_old = r0
      call checkerr(ierr,'ice_thickness_gbl_old',ilog)
      call memory_monitor(sizeof(ice_thickness_gbl_old),               &
                          'ice_thickness_gbl_old',.true.)  

      allocate (ice_thickness_gbl_new(num_nodes_per_layer), stat = ierr)
      ice_thickness_gbl_new = r0
      call checkerr(ierr,'ice_thickness_gbl_new',ilog)
      call memory_monitor(sizeof(ice_thickness_gbl_new),               &
                          'ice_thickness_gbl_new',.true.)

      allocate (ice_thickness_gbl_tmp(num_nodes_per_layer), stat = ierr)
      ice_thickness_gbl_tmp = r0
      call checkerr(ierr,'ice_thickness_gbl_tmp',ilog)
      call memory_monitor(sizeof(ice_thickness_gbl_tmp),               &
                          'ice_thickness_gbl_tmp',.true.)

      allocate (ice_thickness_phw2ice_gbl_old(num_nodes_per_layer), stat = ierr)
      ice_thickness_phw2ice_gbl_old = r0
      call checkerr(ierr,'ice_thickness_phw2ice_gbl_old',ilog)
      call memory_monitor(sizeof(ice_thickness_phw2ice_gbl_old),       &
                          'ice_thickness_phw2ice_gbl_old',.true.)  

      allocate (ice_thickness_phw2ice_gbl_new(num_nodes_per_layer), stat = ierr)
      ice_thickness_phw2ice_gbl_new = r0
      call checkerr(ierr,'ice_thickness_phw2ice_gbl_new',ilog)
      call memory_monitor(sizeof(ice_thickness_phw2ice_gbl_new),       &
                          'ice_thickness_phw2ice_gbl_new',.true.)
#endif

!c  initialize surface node index to ice sheet zone
      allocate (node_idx_sn2bz(num_nodes_sn), stat = ierr)
      node_idx_sn2bz=0
      call checkerr(ierr,'node_idx_sn2bz',ilog)
      call memory_monitor(sizeof(node_idx_sn2bz),                      &
                          'node_idx_sn2bz',.true.)

!c  save the number of ice sheet basal nodes (surface nodes)
      num_nodes_sn_gbl = num_nodes_sn

#ifdef PETSC
      if (nprcs > 1) then
        call MPI_Allreduce(num_nodes_sn_loc,num_nodes_sn_gbl,1,        &
                           MPI_INTEGER4,MPI_SUM,Petsc_Comm_World,      &
                           ierrcode)
        CHKERRQ(ierrcode)
      end if
#endif

!c  write ice sheet basal information to gen file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
              'total number of ice sheet basal nodes           = ',    &
              num_nodes_sn_gbl                              
      end if

      allocate (iwork(num_cells_sn), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initcpice-iwork',.true.)

      !c cell_idx_sn2lg
      do ibasal = 1,num_cells_sn
        iwork(ibasal) = cell_idx_sn2lg(ibasal)
      end do

      call memory_monitor(-sizeof(cell_idx_sn2lg),'cell_idx_sn2lg',.true.)
      deallocate (cell_idx_sn2lg, stat = ierr)
      call checkerr(ierr,'cell_idx_sn2lg',ilog)

      allocate (cell_idx_sn2lg(num_cells_sn), stat = ierr)
      call checkerr(ierr,'cell_idx_sn2lg',ilog)
      call memory_monitor(sizeof(cell_idx_sn2lg),'cell_idx_sn2lg',.true.)

      do ibasal = 1,num_cells_sn
        cell_idx_sn2lg(ibasal) = iwork(ibasal)
      end do

      call memory_monitor(-sizeof(iwork),'initcpice-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)  

!c  save the number of ice sheet basal nodes (surface nodes)
      num_cells_sn_gbl = num_cells_sn

#ifdef PETSC
      if (nprcs > 1) then
        call MPI_Allreduce(num_cells_sn_loc,num_cells_sn_gbl,1,        &
                           MPI_INTEGER4,MPI_SUM,Petsc_Comm_World,      &
                           ierrcode)
        CHKERRQ(ierrcode)
      end if
#endif

!c  write ice sheet basal information to gen file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
              'total number of ice sheet basal nodes           = ',    &
              num_cells_sn_gbl                                     
      end if

!c  double check if number of surface nodes and cells is with the mesh.
!c  when material id is not consecutive and identical for each layer,
!c  the automatically calculated number of nodes/cells per layer is not 
!c  correct, user needs to specify the number of nodes per layer or use
!c  alternative method

#ifdef PETSC
!c  renumber the index of surface nodes when domain decomposition is used
      offset_nodes_sn = 0
      offset_cells_sn = 0
!c  set number of local owned nodes to each rank, make it public for all processors
      if (b_output_binary .and. nprcs > 1) then
        allocate(num_nodes_sn_rank(nprcs), stat = ierr)
        call checkerr(ierr,'num_nodes_sn_rank',ilog)
        num_nodes_sn_rank = 0
        call memory_monitor(sizeof(num_nodes_sn_rank),                 &
                            'num_nodes_sn_rank',.true.)

        call MPI_Allgather(num_nodes_sn_loc, 1, MPI_INTEGER4,          &
                           num_nodes_sn_rank, 1, MPI_INTEGER4,         &
                           Petsc_Comm_World, ierrcode)
        CHKERRQ(ierrcode)

!c  set number of local owned cells to each rank, make it public for all processors
        allocate(num_cells_sn_rank(nprcs), stat = ierr)
        call checkerr(ierr,'num_cells_sn_rank',ilog)
        num_cells_sn_rank = 0
        call memory_monitor(sizeof(num_cells_sn_rank),                 &
                            'num_cells_sn_rank',.true.)

        call MPI_Allgather(num_cells_sn_loc, 1, MPI_INTEGER4,          &
                           num_cells_sn_rank, 1, MPI_INTEGER4,         &
                           Petsc_Comm_World, ierrcode)
        CHKERRQ(ierrcode)

!c set offset value for surface nodes and cells
        if (rank > 0) then
          do irank = 1, rank
            offset_nodes_sn = offset_nodes_sn + num_nodes_sn_rank(irank)
            offset_cells_sn = offset_cells_sn + num_cells_sn_rank(irank)
          end do
        end if        
      end if
#else
      offset_nodes_sn = 0
      offset_cells_sn = 0      
#endif

!c  set local surface node to global surface node for domain decomposition method
#ifdef PETSC
      allocate (isn_to_sg_send(num_nodes_per_layer), stat = ierr)
      isn_to_sg_send = -1
      call checkerr(ierr,'isn_to_sg_send',ilog)
      call memory_monitor(sizeof(isn_to_sg_send),'isn_to_sg_send',.true.)

      allocate (isn_to_sg_recv(num_nodes_per_layer), stat = ierr)
      isn_to_sg_recv = -1
      call checkerr(ierr,'isn_to_sg_recv',ilog)
      call memory_monitor(sizeof(isn_to_sg_recv),'isn_to_sg_recv',.true.)

      do ibasal = 1, num_nodes_sn 
        ivol = node_idx_sn2lg(ibasal)
        if (node_idx_lg2l(ivol) > 0) then
          ivol_ln = node_to_layer_node(ivol)
          isn_to_sg_send(ivol_ln) = ibasal+offset_nodes_sn
        end if
      end do

      call MPI_Allreduce(isn_to_sg_send, isn_to_sg_recv,               &
                         num_nodes_per_layer, MPI_INTEGER4, MPI_MAX,   &
                         Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)

      call memory_monitor(-sizeof(isn_to_sg_send),'isn_to_sg_send',.true.)
      deallocate (isn_to_sg_send, stat = ierr)
      call checkerr(ierr,'isn_to_sg_send',ilog)

      allocate (node_idx_sn2sg(num_nodes_sn), stat = ierr)
      call checkerr(ierr,'node_idx_sn2sg',ilog)
      call memory_monitor(sizeof(node_idx_sn2sg),'node_idx_sn2sg',.true.)

      do ibasal = 1, num_nodes_sn
        ivol_ln = node_to_layer_node(node_idx_sn2lg(ibasal))
        node_idx_sn2sg(ibasal) = isn_to_sg_recv(ivol_ln)
      end do

      call memory_monitor(-sizeof(isn_to_sg_recv),'isn_to_sg_recv',.true.)
      deallocate (isn_to_sg_recv, stat = ierr)
      call checkerr(ierr,'isn_to_sg_recv',ilog)
#endif

#ifdef PETSC
!c create separated group with and without top surface domain.
      if (num_nodes_sn_loc > 0) then
        igroup = 1
      else
        igroup = 0
      end if
      call MPI_Comm_split(Petsc_Comm_World, igroup, rank,              &
                          Petsc_Comm_Group, ierrcode)
#endif

!c end of USG part
#endif
      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
