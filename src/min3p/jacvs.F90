!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacvs
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (variably saturated flow)
!c
!c written by:      Uli Mayer - May 29, 96
!c
!c last modified:   Uli Mayer - May 25, 01 
!c                  Sergi Molins - January 18,2003
!c                  added new var -> passed to soilparm
!c                  Sergi Molins - May 15, 2006
!c                  added new var -> passed to soilparm 
!c                  Sergi Molins - June 7, 2006
!c                  added chemical_water, qwater
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c                    Celine Blitz Frayret (CBF) for Frederic Gerard, December 14, 2018
!c                    (DSU Comment) Added computation of root water uptake (qroot(ivol)), physical evaporation,
!c                    (DSU Comment) and root water uptake derivatives (dqroot(ivol), qrootinc(ivol)).
!c
!c                  Danyang Su - Only qroot is necessary to be declared global variable
!c                               qrootinc and dqroot is always locally calculated and used, not necessary to used as global variable
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common: 
!c bbls.f    logical
!c           -------
!c           gas_bubbles         =.true. -> gas phase saturation is calculated      
!c                                below the water table   
!c 
!c phys.f    real*8
!c           -------
!c           aentry(nzn)        = air entry pressure 
!c           rewm               = mean reserve of extractible water  CBF   
!c
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     - +
!c           bvs(nn)            = rhs vector                          - +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation
!c           hhead(nn)          = hydraulic head                      + -
!c           pornew(nn)         = porosity (new time level)           + -
!c           qwater(nn)         = rate of water production/consumpt.  + -
!c                                due to geochemical reactions 
!c           relperm(nn)        = relative permeability               * +
!c           relpinc(nn)        = relative permeability (incremented) * *
!c           sainc(nn)          = aqueous phase saturation            * *
!c                                - incremented
!c           sanew(nn)          = aqueous phase saturation            * +
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           uvsinc(nn)         = solution vector (incremented)       * *
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c added for gas transport:
!c
!c           relpermg(nn)       = relative gas permeability           + -
!c ------------------------
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        + -
!c
!c           logical:
!c           --------
!c           chemical_water     = .true.  -> account for production   + -
!c                                           or consumption of water
!c                                           due to geochemical 
!c                                           reactions in flow eq.
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c biol.F90: real*8:
!c           -------           
!c           qroot(nn)          = root water uptake for current ! CBF
!c                                control volume
!c         dqroot(nn)         = derivative of root water uptake ! CBF
!c           qrootinc(nn)       = root water uptake for current ! CBF
!c                                control volume (incremented)
!c         logical:
!c           --------
!c           pure_evap   = .true.  -> physical evaporation only ! CBF
!c
!c local:    real*8:
!c           -------
!c           dqroot             = derivative of root water uptake
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsstor            = derivative of storage term
!c           dvsflux            = derivative of flux term
!c           hhinc              = hydraulic head (incremented)
!c           qroot              = root water uptake for current
!c                                control volume
!c           qrootinc           = root water uptake for current 
!c                                control volume (incremented)
!c           totvsflux          = total flux into current control 
!c                                volume
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           r0                 = constant
!c           r1                 = constant
!c           rew                = reserve of extractible water ! CBF
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ivol               = counter (control volumes)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           isym               = symmetry pointer
!c           jvol               = row-column pointer
!c
!c external: rhsvs     = assembly of rhs vector
!c           rootwat   = function for computing root water uptake
!c           evapo     = function for computing soil water evaporation ! CBF
!c           storvs    = storage function for variably saturated 
!c                       flow 
!c           fluxvs    = flux function for variably saturated flow
!c           soilparm  = soil hydraulic parameters
!c ----------------------------------------------------------------------
 
      subroutine jacvs
 
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use phys
      use bbls
      use mip_bubble, only : mip_mt_enable,mip_update_relperm,mip_g
      use biol
      
#ifdef OPENMP
      use omp_lib 
#endif 
#ifdef USG
      use math_common
      use geometry
      use gradient_usg, only : gradient_cross_diff,                    &
                               gradient_cross_diff_inc

      use usg_mesh_data, only : num_edge_dvols,cells,nodes, num_cells, &
                                num_nodes_per_cell,num_nodes_per_cell, &
                                num_edge_maxcells
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxvs_usg
#endif
      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      real(kind=8) :: rewm_gbl, rsum_vprop_gbl, rsum_vprop_inc_gbl
      PetscErrorCode :: ierrcode
#endif

!c Small round-off error in OpenMP reduction operation (:sum) causes 
!c significant difference in the final results. The code looks very sensitive
!c to the value of rsum_vprop. Use quadratic precision here.
      real(kind=16) :: rewm_quad, rsum_vprop_quad, rsum_vprop_inc_quad

      integer :: i1, icon, ivol, idiag, istart, iend, isym, izn, jvol ! CBF
      
      real*8 :: dvsflux, dvsstor, totvsflux,  qrootinc, dqroot,        &
                vsstor, vsstorinc, vsfluxinc, hhinc, dtotvsflux,       &
                sa_eff_old, qroot, transp, soilevapo,                  &
                rsum_vprop_inc, rew                                   ! CBF

      real*8, external :: storvs, fluxvs, rootwat, evapo              ! CBF

      integer :: info_debug, chunk, ivol_track, ivol_gbl, mip_g_loc

      real*8 :: rdummy, sa_min_loc,sgt_loc,sgt_old_loc,                &
                sa_app_loc,sa_eff_loc,sg_eff_loc,sgr_imbi_loc,         &
                aentry_loc
      logical :: unsaturated_loc,drainage_loc,main_drain_loc,          &
                 big_bubble_loc,solvegb_loc

#ifdef USG
      integer :: i2, icell, icell2, idvol, kvol, ncell, ndvol, nrelp
      logical :: bflag
      real*8 :: uvsnew_cell,sanew_cell,sonew_cell
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_locs(num_crossdifficv_max),                  &
                     grad_flow_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_flow_inc_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif

      external rhsvs, soilparm, soilparm_perm

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0, r3 = 3.0d0
      
      if(ittot_vs == 1) then
        info_debug = 0
        ivol_track = -1
      else
        info_debug = 0
        ivol_track = -1
      end if

      totvsflux = r0 
      
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
        chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
        if(mod(chunk, i_chunksize_factor_flow) > 0) then
            chunk = chunk/i_chunksize_factor_flow + 1
        else
            chunk = chunk/i_chunksize_factor_flow
        end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif 


!c_trap determine if imbibition is occuring
      
      if (trap_bubbles) then
        drainage = .false.
        main_drain = .false.
        
        if (soilhydrfunc_field) then
          do ivol = 1,nngl
            if (uvsnew(ivol).lt.aentry_vol(ivol)) then
              if (uvsnew(ivol).le.uvsold(ivol)) then
                drainage(ivol) = .true.
              end if
!c_trap set minimum effective saturation for trapped gas calculation
              sa_eff_old = (saold(ivol)-swr_vol(ivol))/(r1-swr_vol(ivol))
              if (sa_eff_old.le.sa_min(ivol)) then
                 main_drain(ivol) = .true.
                 sa_min(ivol) = sa_eff_old
              end if
            end if
          end do
        else
          do ivol = 1,nngl
            izn = mpropvs(ivol)
            if (uvsnew(ivol).lt.aentry(izn)) then
              if (uvsnew(ivol).le.uvsold(ivol)) then
                drainage(ivol) = .true.
              end if
!c_trap set minimum effective saturation for trapped gas calculation
              sa_eff_old = (saold(ivol)-swr(izn))/(r1-swr(izn))
              if (sa_eff_old.le.sa_min(ivol)) then
                 main_drain(ivol) = .true.
                 sa_min(ivol) = sa_eff_old
              end if
            end if
          end do
        end if
      end if


!c  compute soil hydraulic parameters

#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_relp) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,izn,rdummy,ivol_gbl,                          &
    !$omp sa_min_loc,solvegb_loc,sgt_loc,sgt_old_loc,sa_app_loc,      &
    !$omp sa_eff_loc,sg_eff_loc,unsaturated_loc,drainage_loc,         &
    !$omp main_drain_loc,big_bubble_loc,sgr_imbi_loc,mip_g_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        izn = mpropvs(ivol)

        if (gas_bubbles) then
          sa_min_loc = sa_min(ivol)
          solvegb_loc = solvegb(ivol)
          sgt_loc = sgt(ivol)
          sgt_old_loc = sgt_old(ivol)
        end if

        if (trap_bubbles) then
          sa_app_loc = sa_app(ivol)
          sa_eff_loc = sa_eff(ivol)
          sg_eff_loc = sg_eff(ivol)
          unsaturated_loc = unsaturated(ivol)
          drainage_loc = drainage(ivol)
          main_drain_loc = main_drain(ivol)
          big_bubble_loc = big_bubble(ivol)
          if (soilhydrfunc_field) then
            sgr_imbi_loc = sgr_imbi_vol(ivol)
          else
            sgr_imbi_loc = sgr_imbi(izn)
          end if
        end if

        if (mip_mt_enable) then
          mip_g_loc = mip_g(ivol)
        else
          mip_g_loc = 0
        end if

        !c here local variables *_loc were used as these variables may not be
        !c allocated if gas_bubbles or trap_bubbles are not set.
        if (.not.b_disable_sat_updt) then
          if (soilhydrfunc_field) then
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry_vol(ivol),swr_vol(ivol),              &
                          spalpha_vol(ivol),spbeta_vol(ivol),          &
                          spgamma_vol(ivol),expn_vol(ivol),            &
                          rdummy,rdummy,                               &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          else
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry(izn),swr(izn),                        &
                          spalpha(izn),spbeta(izn),                    &
                          spgamma(izn),expn(izn),                      &
                          rdummy,rdummy,                               &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          end if
        end if

        if (gas_bubbles) then
          sa_min(ivol) = sa_min_loc
          sgt(ivol) = sgt_loc
        end if

        if (trap_bubbles) then
          sa_app(ivol) = sa_app_loc
          sa_eff(ivol) = sa_eff_loc
          sg_eff(ivol) = sg_eff_loc
          big_bubble(ivol) = big_bubble_loc
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (icell,ivol,izn,i2,uvsnew_cell,sanew_cell,sonew_cell)
    !$omp do schedule(static)
#endif
      do icell = 1, num_cells
        izn = mpropvs_cell(ivol)
        uvsnew_cell = 0.0d0
        sanew_cell = 0.0d0
        sonew_cell = 0.0d0
        do i2 = 1, num_nodes_per_cell
          ivol = cells(i2,icell)
          uvsnew_cell = uvsnew_cell + uvsnew(ivol)
          sanew_cell = sanew_cell + sanew(ivol)
          sonew_cell = sonew_cell + sonew(ivol)
        end do
        uvsnew_cell = uvsnew_cell/num_nodes_per_cell
        sanew_cell = sanew_cell/num_nodes_per_cell
        sonew_cell = sonew_cell/num_nodes_per_cell

        if (.not.b_disable_sat_updt) then
          call soilparm_perm(uvsnew_cell,sanew_cell,sonew_cell,        &
                        aentry(izn),swr(izn),spgamma(izn),expn(izn),   &
                        relperm(icell),relpermg(icell),bubble_perm,    &
                        gas_bubbles,oil_saturation,                    &
                        mip_mt_enable,mip_update_relperm)
        end if
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

      else
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,izn, ivol_gbl,                                &
    !$omp sa_min_loc,solvegb_loc,sgt_loc,sgt_old_loc,sa_app_loc,      &
    !$omp sa_eff_loc,sg_eff_loc,unsaturated_loc,drainage_loc,         &
    !$omp main_drain_loc,big_bubble_loc,sgr_imbi_loc,mip_g_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        izn = mpropvs(ivol)

        if (gas_bubbles) then
          sa_min_loc = sa_min(ivol)
          solvegb_loc = solvegb(ivol)
          sgt_loc = sgt(ivol)
          sgt_old_loc = sgt_old(ivol)
        end if

        if (trap_bubbles) then
          sa_app_loc = sa_app(ivol)
          sa_eff_loc = sa_eff(ivol)
          sg_eff_loc = sg_eff(ivol)
          unsaturated_loc = unsaturated(ivol)
          drainage_loc = drainage(ivol)
          main_drain_loc = main_drain(ivol)
          big_bubble_loc = big_bubble(ivol)
          if (soilhydrfunc_field) then
            sgr_imbi_loc = sgr_imbi_vol(ivol)
          else
            sgr_imbi_loc = sgr_imbi(izn)
          end if
        end if

        if (mip_mt_enable) then
          mip_g_loc = mip_g(ivol)
        else
          mip_g_loc = 0
        end if

        !c here local variables *_loc were used as these variables may not be
        !c allocated if gas_bubbles or trap_bubbles are not set.
        if (.not.b_disable_sat_updt) then
          if (soilhydrfunc_field) then
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry_vol(ivol),swr_vol(ivol),              &
                          spalpha_vol(ivol),spbeta_vol(ivol),          &
                          spgamma_vol(ivol),expn_vol(ivol),            &
                          relperm(ivol),relpermg(ivol),                &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          else
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry(izn),swr(izn),                        &
                          spalpha(izn),spbeta(izn),                    &
                          spgamma(izn),expn(izn),                      &
                          relperm(ivol),relpermg(ivol),                &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          end if
        end if

        if (gas_bubbles) then
          sa_min(ivol) = sa_min_loc
          sgt(ivol) = sgt_loc
        end if

        if (trap_bubbles) then
          sa_app(ivol) = sa_app_loc
          sa_eff(ivol) = sa_eff_loc
          sg_eff(ivol) = sg_eff_loc
          big_bubble(ivol) = big_bubble_loc
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef USG
      end if
#endif

!c  compute total potential root uptake and estimate 
!c  scaling factor

!c  increment primary unknown
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)                  
    !$omp do schedule(static)
#endif
      do ivol=1,nngl
        uvsinc(ivol) = uvsnew(ivol) + dinc_vs
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  compute incremented soil hydraulic parameters

#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_relp) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,izn,rdummy,ivol_gbl,                          &
    !$omp sa_min_loc,solvegb_loc,sgt_loc,sgt_old_loc,sa_app_loc,      &
    !$omp sa_eff_loc,sg_eff_loc,unsaturated_loc,drainage_loc,         &
    !$omp main_drain_loc,big_bubble_loc,sgr_imbi_loc,mip_g_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        izn = mpropvs(ivol)

        if (gas_bubbles) then
          sa_min_loc = sa_min(ivol)
          solvegb_loc = solvegb(ivol)
          sgt_loc = sgt(ivol)
          sgt_old_loc = sgt_old(ivol)
        end if

        if (trap_bubbles) then
          sa_app_loc = sa_app(ivol)
          sa_eff_loc = sa_eff(ivol)
          sg_eff_loc = sg_eff(ivol)
          unsaturated_loc = unsaturated(ivol)
          drainage_loc = drainage(ivol)
          main_drain_loc = main_drain(ivol)
          big_bubble_loc = big_bubble(ivol)
          if (soilhydrfunc_field) then
            sgr_imbi_loc = sgr_imbi_vol(ivol)
          else
            sgr_imbi_loc = sgr_imbi(izn)
          end if
        end if

        if (mip_mt_enable) then
          mip_g_loc = mip_g(ivol)
        else
          mip_g_loc = 0
        end if

        !c here local variables *_loc were used as these variables may not be
        !c allocated if gas_bubbles or trap_bubbles are not set.
        if (.not.b_disable_sat_updt) then
          if (soilhydrfunc_field) then
            call soilparm(uvsinc(ivol),uvsold(ivol),                   &
                          sainc(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry_vol(ivol),swr_vol(ivol),              &
                          spalpha_vol(ivol),spbeta_vol(ivol),          &
                          spgamma_vol(ivol),expn_vol(ivol),            &
                          rdummy,rdummy,                               &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          else
            call soilparm(uvsinc(ivol),uvsold(ivol),                   &
                          sainc(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry(izn),swr(izn),                        &
                          spalpha(izn),spbeta(izn),                    &
                          spgamma(izn),expn(izn),                      &
                          rdummy,rdummy,                               &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          end if
        end if

        if (gas_bubbles) then
          sa_min(ivol) = sa_min_loc
          sgt(ivol) = sgt_loc
        end if

        if (trap_bubbles) then
          sa_app(ivol) = sa_app_loc
          sa_eff(ivol) = sa_eff_loc
          sg_eff(ivol) = sg_eff_loc
          big_bubble(ivol) = big_bubble_loc
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (num_cells > numofloops_thred_global)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (icell,ivol,izn,i2,uvsnew_cell,sanew_cell,sonew_cell)
    !$omp do schedule(static)
#endif
      do icell = 1, num_cells
        izn = mpropvs_cell(ivol)
        uvsnew_cell = 0.0d0
        sanew_cell = 0.0d0
        sonew_cell = 0.0d0
        do i2 = 1, num_nodes_per_cell
          ivol = cells(i2,icell)
          uvsnew_cell = uvsnew_cell + uvsinc(ivol)
          sanew_cell = sanew_cell + sainc(ivol)
          sonew_cell = sonew_cell + sonew(ivol)
        end do
        uvsnew_cell = uvsnew_cell/num_nodes_per_cell
        sanew_cell = sanew_cell/num_nodes_per_cell
        sonew_cell = sonew_cell/num_nodes_per_cell

        if (.not.b_disable_sat_updt) then
          call soilparm_perm(uvsnew_cell,sanew_cell,sonew_cell,        &
                        aentry(izn),swr(izn),spgamma(izn),expn(izn),   &
                        relpinc(icell),relpincg(icell),bubble_perm,    &
                        gas_bubbles,oil_saturation,                    &
                        mip_mt_enable,mip_update_relperm)
        end if
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

      else
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,izn,ivol_gbl,                                 &
    !$omp sa_min_loc,solvegb_loc,sgt_loc,sgt_old_loc,sa_app_loc,      &
    !$omp sa_eff_loc,sg_eff_loc,unsaturated_loc,drainage_loc,         &
    !$omp main_drain_loc,big_bubble_loc,sgr_imbi_loc,mip_g_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        izn = mpropvs(ivol)

        if (gas_bubbles) then
          sa_min_loc = sa_min(ivol)
          solvegb_loc = solvegb(ivol)
          sgt_loc = sgt(ivol)
          sgt_old_loc = sgt_old(ivol)
        end if

        if (trap_bubbles) then
          sa_app_loc = sa_app(ivol)
          sa_eff_loc = sa_eff(ivol)
          sg_eff_loc = sg_eff(ivol)
          unsaturated_loc = unsaturated(ivol)
          drainage_loc = drainage(ivol)
          main_drain_loc = main_drain(ivol)
          big_bubble_loc = big_bubble(ivol)
          if (soilhydrfunc_field) then
            sgr_imbi_loc = sgr_imbi_vol(ivol)
          else
            sgr_imbi_loc = sgr_imbi(izn)
          end if
        end if

        if (mip_mt_enable) then
          mip_g_loc = mip_g(ivol)
        else
          mip_g_loc = 0
        end if

        !c here local variables *_loc were used as these variables may not be
        !c allocated if gas_bubbles or trap_bubbles are not set.
        if (.not.b_disable_sat_updt) then
          if (soilhydrfunc_field) then
            call soilparm(uvsinc(ivol),uvsold(ivol),                   &
                          sainc(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry_vol(ivol),swr_vol(ivol),              &
                          spalpha_vol(ivol),spbeta_vol(ivol),          &
                          spgamma_vol(ivol),expn_vol(ivol),            &
                          relpinc(ivol),relpincg(ivol),                &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          else
            call soilparm(uvsinc(ivol),uvsold(ivol),                   &
                          sainc(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry(izn),swr(izn),                        &
                          spalpha(izn),spbeta(izn),                    &
                          spgamma(izn),expn(izn),                      &
                          relpinc(ivol),relpincg(ivol),                &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          end if
        end if

        if (gas_bubbles) then
          sa_min(ivol) = sa_min_loc
          sgt(ivol) = sgt_loc
        end if

        if (trap_bubbles) then
          sa_app(ivol) = sa_app_loc
          sa_eff(ivol) = sa_eff_loc
          sg_eff(ivol) = sg_eff_loc
          big_bubble(ivol) = big_bubble_loc
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef USG
      end if
#endif
       
!c_bubbles if change in permeability is due to gas bubble growth
!c_bubbles then relpinc = relperm, i.e. permeability is not a function of 
!c_bubbles hydraulic head
      if (gas_bubbles .or. mip_mt_enable) then

#ifdef USG
        if (is_cell_based_relp) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (num_cells > numofloops_thred_global)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, icell, i2, izn, bflag, aentry_loc)
    !$omp do schedule(static)
#endif
          do icell = 1, num_cells
            izn = mpropvs_cell(ivol)

            bflag = .true.
            do i2 = 1, num_nodes_per_cell
              ivol = cells(i2,icell)

              if (soilhydrfunc_field) then
                aentry_loc = aentry_vol(ivol)
              else
                aentry_loc = aentry(izn)
              end if

              if (gas_bubbles) then
                if (uvsnew(ivol).lt.aentry_loc.or.unsaturated(ivol)) then
                  bflag = .false.
                  exit
                end if
              end if            
            end do

            if (bflag) then
              relpinc(icell) = relperm(icell)
              do i2 = 1, num_nodes_per_cell
                ivol = cells(i2,icell)
                sainc(ivol)=sanew(ivol)
              end do
            end if
          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
        else
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, izn, aentry_loc)
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl
            if (soilhydrfunc_field) then
              aentry_loc = aentry_vol(ivol)
            else
              izn = mpropvs(ivol)
              aentry_loc = aentry(izn)
            end if

            if (gas_bubbles) then
              if (uvsnew(ivol).ge.aentry_loc .and. .not.unsaturated(ivol)) then
                relpinc(ivol) = relperm(ivol)
                sainc(ivol)=sanew(ivol)
              end if
            else if (mip_mt_enable) then
              if (uvsnew(ivol).ge.aentry_loc) then
                relpinc(ivol) = relperm(ivol)
                sainc(ivol)=sanew(ivol)
              end if
            end if
          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef USG
        end if
#endif
      end if

!c DSU compute mean reserve of extractible water : correction method for water stress = 2
!c DSU move this part output of jacobian matrix assembly. This is only related to sanew variable
!c DSU and the other variables used in rewm calculation remain unchanged.
!c
!c Small round-off error in OpenMP reduction operation (:sum) causes 
!c significant difference in the final results. The code looks very sensitive
!c to the value of rsum_vprop
!c
!      rewm = r0
!      rsum_vprop = r0
!      rsum_vprop_inc = r0
!      if (root_uptake) then
!#ifdef OPENMP
!    !$omp parallel                                                    &
!    !$omp if (nngl > numofloops_thred_cvolume_1)                      &
!    !$omp num_threads(numofthreads_global)                            &
!    !$omp default(shared)                                             &
!    !$omp private(ivol)                                               &
!    !$omp reduction(+:rewm,rsum_vprop,rsum_vprop_inc)
!    !$omp do schedule(static)
!#endif
!        do ivol = 1, nngl
!#ifdef PETSC
!          if(node_idx_lg2l(ivol) < 0) then
!            cycle
!          end if
!#endif
!          rewm = rewm + cvol(ivol)*rew(sanew,ivol)/cvol_tot
!          rsum_vprop = rsum_vprop+rld(ivol)*sanew(ivol)*cvol(ivol)
!          rsum_vprop_inc = rsum_vprop_inc+rld(ivol)*sainc(ivol)*cvol(ivol)          
!        end do
!#ifdef OPENMP
!    !$omp end do
!    !$omp end parallel
!#endif


      rewm_quad = real(r0,kind=16)
      rsum_vprop_quad = real(r0,kind=16)
      rsum_vprop_inc_quad = real(r0,kind=16)

      if (root_uptake) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_cvolume_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                                               &
    !$omp reduction(+:rewm_quad,rsum_vprop_quad,rsum_vprop_inc_quad)
    !$omp do schedule(static)
#endif
        do ivol = 1, nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          rewm_quad = rewm_quad + real(cvol(ivol)*rew(sanew,ivol)/cvol_tot,kind=16)
          rsum_vprop_quad = rsum_vprop_quad + real(rld(ivol)*sanew(ivol)*cvol(ivol),kind=16)
          rsum_vprop_inc_quad = rsum_vprop_inc_quad + real(rld(ivol)*sainc(ivol)*cvol(ivol),kind=16)

!cdsu Note, cvol_tot is calculated from collective operator that this value is
!cdsu slightly different when different number of processors are used. Same as other
!cdsu parameters using collective operator under parallel environment.
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!#ifdef PETSC
!!cdsu MPI_REAL16 works just fine when use Intel Fortran and Intel MPI,
!!cdsu However, it does not return right value when use OpenMPI or MPICH.
!!cdsu For example, OpenMPI 1.6 or MPICH 3.3.

!        call MPI_Allreduce(rewm_quad, rewm_gbl,1,MPI_REAL16,           &
!                           MPI_SUM,Petsc_Comm_World,ierrcode)
!        CHKERRQ(ierrcode)
!        rewm_quad = rewm_gbl
!
!        call MPI_Allreduce(rsum_vprop_quad,rsum_vprop_gbl,1,MPI_REAL16,&
!                           MPI_SUM,Petsc_Comm_World,ierrcode)
!        CHKERRQ(ierrcode)
!        rsum_vprop_quad = rsum_vprop_gbl
!
!        call MPI_Allreduce(rsum_vprop_inc_quad,rsum_vprop_inc_gbl,1,   &
!                           MPI_REAL16,MPI_SUM,Petsc_Comm_World,ierrcode)
!        CHKERRQ(ierrcode)
!        rsum_vprop_inc_quad = rsum_vprop_inc_gbl
!#endif
!
!        rewm = rewm_quad
!        rsum_vprop = rsum_vprop_quad
!        rsum_vprop_inc = rsum_vprop_inc_quad

!!cdsu alternative code

        rewm = real(rewm_quad,kind=8)
        rsum_vprop = real(rsum_vprop_quad,kind=8)
        rsum_vprop_inc = real(rsum_vprop_inc_quad,kind=8)

#ifdef PETSC
!!cdsu MPI_REAL16 works just fine when use Intel Fortran and Intel MPI,
!!cdsu However, it does not return right value when use OpenMPI or MPICH.
!!cdsu For example, OpenMPI 1.6 or MPICH 3.3, 4.1.
        call MPI_Allreduce(rewm, rewm_gbl,1,MPI_REAL8,           &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rewm = rewm_gbl

        call MPI_Allreduce(rsum_vprop,rsum_vprop_gbl,1,MPI_REAL8,&
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rsum_vprop = rsum_vprop_gbl

        call MPI_Allreduce(rsum_vprop_inc,rsum_vprop_inc_gbl,1,   &
                           MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rsum_vprop_inc = rsum_vprop_inc_gbl
#endif
      end if

!c  build jacobian matrix
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, idvol, i2, kvol, ncell, ndvol, nrelp, relps_loc,     &
    !$omp grad_flow_mids, grad_flow_inc_mids, grad_locs,              &
    !$omp grad_weights, flux_hls_corr,                                &
    !$omp grad_flow_hls_loc, cinfvs_usg_loc, cinfvs_usg_cross_loc,   &
#endif
    !$omp i1, icon, idiag, iend, istart, isym, ivol, izn,             &
    !$omp ivol_gbl, jvol, dtotvsflux, dvsflux, dvsstor, hhinc,        &
    !$omp totvsflux, vsflux, vsfluxinc, vsstor, vsstorinc,            &
    !$omp transp, soilevapo, qroot,                                   &
    !$omp qrootinc, dqroot, aentry_loc)                               &
    !$omp firstprivate (iups)

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)    
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif

#endif

      do ivol = 1,nngl           !loop over control volumes

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        izn = mpropvs(ivol)

        idiag = iavs(ivol)       !pointer - diagonal 
        istart = iavs(ivol)+1    !pointer - start (off-diagonal entries)
        iend = iavs(ivol+1)-1    !pointer - end (off-diagonal entries)

!c  calculate storage and flux terms for current control volume

        totvsflux = r0           !initialize total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes 

          jvol = javs(i1)        !column pointer

!c  compute fluxes between current control volume and adjacent 
!c  control volumes

          icon = icon+1          !counter (row entries)

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

!c  assign pointer array for upstream weighting
 
          if (upstream) then
            iups(icon) = 'i'                         !h_i >= h_j
            if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
              iups(icon) = 'j'
            end if
          end if

          if (b_use_fixed_flow_vel) then
              
            if (b_use_zero_flow_vel) then
              vsflux(icon) = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
!c  flux calculations
            if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_flow_mids = vector_zero
              flux_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff(i1,ivol,jvol,hhead,           &
                              grad_locs,grad_flow_mids,                &
                              grad_weights,flux_hls_corr,              &
                              grad_flow_hls_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = (/relperm(ivol),relperm(jvol)/)
              end if

              vsflux(icon) = -fluxvs_usg(upstream,hhead(ivol),hhead(jvol),     &
                               num_edge_dvols,ncell,                           &
                               grad_flow_mids(1:num_edge_dvols,1:ncell),       &
                               flux_hls_corr(1:num_edge_dvols,1:ncell),        &
                               is_cell_based_relp,nrelp,                       &
                               relps_loc(1:nrelp),iups(icon),                  &
                               cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                               cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell))
            else
#endif
              vsflux(icon) = - fluxvs(upstream,hhead(ivol),hhead(jvol),  &
                                      relperm(ivol),relperm(jvol),       &
                                      iups(icon),cinfvs_a(i1))

#ifdef USG
            end if
#endif
          end if        

          
!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx   no fluid flux between them
!cdsu fix bug
          !if (pore_clogging) then
          !  if (pornew(ivol) <= por_thresh_min .or.                    &
          !      pornew(jvol) <= por_thresh_min)  then
          !    vsflux(icon) = r0
          !  end if        
          !end if  
            
          totvsflux = totvsflux + vsflux(icon)
          
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              if (discretization_type > 0) then
                write(idbg,'(3(a,1x,i6,1x),a,1x,l1,1x,2(a,1x),                    &
                      7(a,1x,1pe15.6e3,1x))')                                     &
                      "-->jacvs ivol",ivol,"jvol",jvol,"icon",icon,               &
                      "upstream",upstream,"iups(icon)",iups(icon),                &
                      "hhead(ivol)",hhead(ivol),"hhead(jvol)",hhead(jvol),        &
                      "relperm(ivol)",relperm(ivol),                              &
                      "relperm(jvol)",relperm(jvol),                              &
                      "vsflux(icon)",vsflux(icon),"totvsflux",totvsflux
#ifdef USG
                write(idbg,*) "cinfvs_usg",cinfvs_usg_loc(1:num_edge_dvols,1:ncell)
                write(idbg,*) "cinfvs_usg_cross",cinfvs_usg_cross_loc(            &
                                                 1:num_edge_dvols,1:ncell)
                do idvol = 1, num_edge_dvols
                  do icell = 1, ncell
                    write(idbg,*) "--->grad_flow_mids,idvol",idvol,"icell",icell, &
                                  "cell id",jacell(icell,i1),                     &
                                  "grad",grad_flow_mids(idvol,icell)%x,           &
                                  grad_flow_mids(idvol,icell)%y,                  &
                                  grad_flow_mids(idvol,icell)%z
                  end do
                end do
#endif
              else
                write(idbg,'(4(a,1x,i6,1x),a,1x,l1,1x,2(a,1x),7(a,1x,1pe15.6e3,1x))')&
                      "-->jacvs ivol",ivol,"jvol",jvol,"icon",icon,'jtemp',i1,    &
                      "upstream",upstream,"iups(icon)",iups(icon),                &
                      "hhead(ivol)",hhead(ivol),"hhead(jvol)",hhead(jvol),        &
                      "relperm(ivol)",relperm(ivol),                              &
                      "relperm(jvol)",relperm(jvol),"cinfvs(i1)",cinfvs_a(i1),    &
                      "vsflux(icon)",vsflux(icon),"totvsflux",totvsflux
              end if
            end if
          end if
#endif

        end do                   !loop over connected control volumes

!c  compute storage term (lumped) for current control volume, 
!c  only for transient conditions

        if (transient_flow) then
 
          vsstor = cvol(ivol) *                                       &
                   storvs(delt,uvsnew(ivol),uvsold(ivol),             &
                          sanew(ivol),saold(ivol),                    &
                          pornew(ivol),stor(ivol))
        else
          vsstor = r0
        end if                   !(transient_flow)
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg,'(a,1x,i6,1x,8(a,1x,1pe15.6e3,1x))')            &
                "-->jacvs A ivol", ivol,"vsstor",vsstor,               &
                "cvol(ivol)",cvol(ivol),"uvsnew(ivol)",uvsnew(ivol),   &
                "uvsold(ivol)",uvsold(ivol),"sanew(ivol)",sanew(ivol), &
                "saold(ivol)",saold(ivol),"mpropvs(ivol)",             &
                mpropvs(ivol)*1.0d0,"stor(ivol)",stor(ivol)
          end if
        end if
#endif

!c  compute root water uptake for current control volume
!c  DSU qroot computation here
!c  DSU compute mean reserve of extractible water : correction method for water stress = 2
!c  DSU this part is missing in FG & CBF's version

        if (root_uptake) then
          transp = cvol(ivol)*rootwat(sanew,ivol,rsum_vprop)
        else
          transp = r0
        end if

        soilevapo = r0
        if (root_uptake .or. pure_evap) then
          if (soilhydrfunc_field) then
            if (h1dry_vol(ivol).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sanew,ivol)
            end if
          else
            izn = mpropvs(ivol)
            if (h1dry(izn).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sanew,ivol)
            end if
          end if
        end if
          
        qroot = transp + soilevapo

#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg,*)                                              &
                  "-->jacvs B3 ivol",ivol,"qroot",qroot,               &
                  "qwater",qwater(ivol),"bvs",bvs(ivol),               &
                  "sanew",sanew(ivol),"rsum_vprop",rsum_vprop
          end if
        end if
#endif

!c CBF ---------------------------------------------------
!c CBF end of mean reserve of extractible water computation
!c CBF ---------------------------------------------------- 


!c  assembly of storage and flux terms in rhs vector
!c  Anna Harrison added qh2o term Jan 24 2014
        if(water_removal) then
          totvsflux = totvsflux+qh2o(ivol)/delt  
        end if
        call rhsvs(vsstor,totvsflux,bvs(ivol))

#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg,'(a,1x,i6,1x,3(a,1x,1pe15.6e3,1x))')            &
                  "-->jacvs B ivol",ivol,"vsstor",vsstor,              &
                  "totvsflux",totvsflux,"bvs(ivol)",bvs(ivol)
          end if
        end if
#endif

!c CBF : add root water uptake (including evaporation if considered) or pure evaporation to rhs vector 
        if (root_uptake.or.pure_evap) then    ! CBF 'pure_evap'          
          bvs(ivol) = bvs(ivol)-qroot   
        end if
        
        if (chemical_water) then
          bvs(ivol) = bvs(ivol)-qwater(ivol)
        endif

#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg,'(a,1x,i6,1x,3(a,1x,1pe15.6e3,1x))')            &
                  "-->jacvs B2 ivol",ivol,"qroot",qroot,               &
                  "qwater",qwater(ivol),"bvs",bvs(ivol)
          end if
        end if
#endif

!c  calculate derivatives of storage and flux terms for current 
!c  control volume (assembly columnwise)

        hhinc = hhead(ivol)+dinc_vs  !increment hydraulic head
        dtotvsflux = r0          !initialize derivative of total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes

          jvol = javs(i1)        !column pointer
          isym = isymvs(i1)      !symmetry pointer
 
!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions
!c  flux with incremented variables and derivative of flux
 
          icon = icon+1

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          if (b_use_fixed_flow_vel) then
                        
            if (b_use_zero_flow_vel) then
              vsfluxinc = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
            if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_flow_inc_mids = vector_zero
              flux_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_inc(i1,ivol,jvol,dinc_vs,     &
                     hhead,grad_locs,grad_flow_inc_mids,grad_weights,  &
                     flux_hls_corr,grad_flow_hls_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relpinc(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = (/relpinc(ivol),relperm(jvol)/)
              end if

              vsfluxinc = -fluxvs_usg(upstream,hhinc,hhead(jvol),            &
                             num_edge_dvols,ncell,                           &
                             grad_flow_inc_mids(1:num_edge_dvols,1:ncell),   &
                             flux_hls_corr(1:num_edge_dvols,1:ncell),        &
                             is_cell_based_relp,nrelp,                       &
                             relps_loc(1:nrelp),iups(icon),                  &
                             cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                             cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell))
            else
#endif
              vsfluxinc = -fluxvs(upstream,hhinc,hhead(jvol),          &
                           relpinc(ivol),relperm(jvol),iups(icon),     &
                           cinfvs_a(i1))
#ifdef USG
            end if
#endif
          end if

          dvsflux = (vsfluxinc-vsflux(icon))/dinc_vs
          
!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx   no fluid flux between them
!cdsu fix bug, comment to avoid setting matrix diag entry to zero
          !if (pore_clogging) then
          !  if (pornew(ivol) <= por_thresh_min .or.                    &
          !      pornew(jvol) <= por_thresh_min)  then
          !    dvsflux = r0
          !    vsfluxinc = r0
          !  end if        
          !end if
            
          dtotvsflux = dtotvsflux+vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
 
          avs(isym) = avs(isym) - dvsflux    !off-diagonal entries 

        end do                  !loop over connected control volumes

!c  compute storage term with incremented variables (lumped) 
!c  for current control volume, only for transient conditions

        if (transient_flow) then
          vsstorinc = cvol(ivol) *                                    &
                      storvs(delt,uvsinc(ivol),uvsold(ivol),          &
                             sainc(ivol),saold(ivol),                 &
                             pornew(ivol),stor(ivol))
        else
          vsstorinc = r0
        end if                   !(transient_flow)

!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs          !derivatives
!c_bubbles if change in storage is due to gas bubble growth
!c_bubbles then derivative of the storage is 0
        if (gas_bubbles .or. mip_mt_enable) then

          if (soilhydrfunc_field) then
            aentry_loc = aentry_vol(ivol)
          else
            izn = mpropvs(ivol)
            aentry_loc = aentry(izn)
          end if

          if (gas_bubbles) then
            if (uvsnew(ivol).ge.aentry_loc .and. .not.unsaturated(ivol)) then
              dvsstor = r0
            end if
          else if (mip_mt_enable) then
            if (uvsnew(ivol).ge.aentry_loc) then
              dvsstor = r0
            end if
          end if
        end if
        
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs
        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  !diagonal entry

!c  compute root water uptake for current control volume
!c  DSU qroot computation here
!c  DSU compute mean reserve of extractible water : correction method for water stress = 2
!c  DSU this part is missing in FG & CBF's version

        if (root_uptake) then
          transp = cvol(ivol)*rootwat(sainc,ivol,rsum_vprop_inc)
        else
          transp = r0
        end if

        soilevapo = r0
        if (root_uptake .or. pure_evap) then
          if (soilhydrfunc_field) then
            if (h1dry_vol(ivol).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sainc,ivol)
            end if
          else
            if (h1dry(izn).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sainc,ivol)
            end if
          end if
        end if

        qrootinc = transp + soilevapo

        dqroot = (qrootinc-qroot)/dinc_vs
       
        avs(idiag) = avs(idiag) + dqroot


      end do                        !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
 
!cdbg
!c     do ivol=1,nngl
!c       istart = iavs(ivol)
!c       iend = iavs(ivol+1)-1
!c       write(idbg,ascii_fmt)(avs(i1),i1=istart,iend),bvs(ivol)
!c     end do
!c     stop
!cdbg

      return
      end
