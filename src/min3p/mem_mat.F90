!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/mem_mat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mem_mat
!c ------------------
!c
!c allocate memory for physical parameters in material 
!c property zones
!c
!c written by:      Uli Mayer - Januray 6, 2000
!c
!c last modified:   -
!c
!c last modified:   -
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c last modified:   Celine Blitz Frayret (CBF) for Frederic Gerard, December 14, 2018
!c            removed allocation for canopy_evap_factor (became parameter now),
!c            added allocation for pvol(nzn) and h1dry(nzn)
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    integer*4:
!c           ----------
!c           ilog               = unit number, logbook file           + -
!c           nn                 = number of control volumes           + -
!c
!c phys.f:   real*8:
!c           ------- 
!c           aentry(nzn)        = air entry pressure                  * +
!c           condxx(nzn)        = saturated hydraulic conductivity    * +
!c                                in x-direction
!c           condyy(nzn)        = saturated hydraulic conductivity    * +
!c                                in y-direction
!c           condzz(nzn)        = saturated hydraulic conductivity    * +
!c                                in z-direction
!c           permx(nn)          = saturated permeability in           * +
!c                                x-direction
!c           permy(nn)          = saturated permeability in           * +
!c                                y-direction
!c           permz(nn)          = saturated permeability in           * +
!c                                z-direction
!c           expn(nzn)          = soil hydraulic function parameter   * +
!c           spalpha(nzn)       = soil hydraulic function parameter   * +
!c           spbeta(nzn)        = soil hydraulic function parameter   * +
!c           spgamma(nzn)       = soil hydraulic function parameter   * +
!c           spstor(nzn)        = specific storage coefficient        * +
!c           swr(nzn)           = residual saturation                 * +
!c           disx(nzn)          = longitudinal dispersivity           * +
!c           disy(nzn)          = transverse horizontal dispersivity  * +
!c           disz(nzn)          = transverse vertical dispersivity    * +
!c           satwlim(nzn)       = water saturation at wilting point   * +
!c           satwfield(nzn)     = water saturation at field capacity  * +
!c           h1dry(nzn)         = air-dry aqueous pressure          * + CBF
!c           pvol(nzn)          = volume of property zone (used for evaporation)  * + CBF
!c           rew0(izn)          = relative extractable water at       * +
!c                                50% of maximum extraction capacity 
!c                                (fitting parameter)
!c           rate_root_max(nzn) = maximum root water uptake rate      * +
!c
!c           character:
!c           ----------
!c           mprop_name(nzn)    = name of material property zone
!c
!c biol.F90: real*8:
!c           -------  
!c           p1(nzn)            = fitting parameter for root water    * +
!c                                uptake function CBF
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c
!c external: checkerr  = check for error during memory allocation
!c---------------------------------------------------------------------- 
!c WARNING
!c---------------------------------------------------------------------- 
!c All allocated variables are initialized to some value. This depends  
!c of its type:
!c 
!c real*8      => 0.0d0
!c integer     => 0 
!c character   => ' '    
!c logical     => .false. 
!c 
!c Sergio Andres Bea Jofre (2009)
!c
!c ----------------------------------------------------------------------
  
    subroutine mem_mat
 
      use parm
      use gen
      use phys
      use bbls
      use geometry_definition
      use biol

#ifdef OPENMP
      use omp_lib 
#endif

#ifdef USG
      use usg_mesh_data, only : num_cells, num_nodes
#endif

      implicit none
      
      integer :: ierr
 
      external checkerr

!c  allocate memory for physical material property zones
 
      allocate(porz(nzn), stat = ierr)
      porz = 0.0d0
      call checkerr(ierr,'porz',ilog)
      call memory_monitor(sizeof(porz),'porz',.true.)

      allocate (mprop_name(nzn), stat = ierr)
      mprop_name=' '
      call checkerr(ierr,'mprop_name',ilog)
      call memory_monitor(sizeof(mprop_name),'mprop_name',.true.)
 
      allocate (condxx(nzn), stat = ierr)
      condxx=0.0d0
      call checkerr(ierr,'condxx',ilog)
      call memory_monitor(sizeof(condxx),'condxx',.true.)

      allocate (condyy(nzn), stat = ierr)
      condyy=0.0d0
      call checkerr(ierr,'condyy',ilog)
      call memory_monitor(sizeof(condyy),'condyy',.true.)

      allocate (condzz(nzn), stat = ierr)
      condzz=0.0d0
      call checkerr(ierr,'condzz',ilog)
      call memory_monitor(sizeof(condzz),'condzz',.true.)
     
      allocate (spstor(nzn), stat = ierr)
      spstor=0.0d0
      call checkerr(ierr,'spstor',ilog)
      call memory_monitor(sizeof(spstor),'spstor',.true.)

#ifdef USG
      if (discretization_type > 0 .and. (type_cond_perm == 2 .or.      &
          useAnisoCondCorr)) then
        allocate (cond_tensor(nzn), stat = ierr)
        cond_tensor=tensor_zero
        call checkerr(ierr,'cond_tensor',ilog)
        call memory_monitor(sizeof(cond_tensor),'cond_tensor',.true.)
      end if
#endif

!cdsu  hydraulic conductivity relationship over depth, compared to the K at the surface
!cdsu  here we use a similar permeability relationship over depth reported by 
!cdsu  Stefano Delfino Normani, 2009, Paleoevolution of Pore Fluids in Glaciated Geologic Settings,
!cdsu  PhD thesis presented to the University of Waterloo, pp 71-72.
!cdsu  K(depth)/K(surface) = 10**(a*exp(-b*depth)-c)
      allocate (k_depth_parms(3,nzn), stat = ierr)
      k_depth_parms=0.0d0
      call checkerr(ierr,'k_depth_parms',ilog)
      call memory_monitor(sizeof(k_depth_parms),'k_depth_parms',.true.)

#ifdef USG
      if (is_cell_based_perm_cond) then
        allocate (k_depth_ratio(num_cells), stat = ierr)
        k_depth_ratio=1.0d0
        call checkerr(ierr,'k_depth_ratio',ilog)
        call memory_monitor(sizeof(k_depth_ratio),'k_depth_ratio',.true.)
      else
        allocate (k_depth_ratio(num_nodes), stat = ierr)
        k_depth_ratio=1.0d0
        call checkerr(ierr,'k_depth_ratio',ilog)
        call memory_monitor(sizeof(k_depth_ratio),'k_depth_ratio',.true.)
      end if      
#else
      allocate (k_depth_ratio(nngl), stat = ierr)
      k_depth_ratio=1.0d0
      call checkerr(ierr,'k_depth_ratio',ilog)
      call memory_monitor(sizeof(k_depth_ratio),'k_depth_ratio',.true.)
#endif

!cdsu ----------------------------------------------------------
!cdsu Mechanical parameters
!cdsu ----------------------------------------------------------
      allocate (spskempton(nzn), stat = ierr)
      spskempton=1.0d0
      call checkerr(ierr,'spskempton',ilog)
      call memory_monitor(sizeof(spskempton),'spskempton',.true.)

      allocate (modulus_young(nzn), stat = ierr)
      modulus_young=0.0d0
      call checkerr(ierr,'modulus_young',ilog)
      call memory_monitor(sizeof(modulus_young),'modulus_young',.true.)
      
      allocate (poisson_ratio(nzn), stat = ierr)
      poisson_ratio=0.0d0
      call checkerr(ierr,'poisson_ratio',ilog)
      call memory_monitor(sizeof(poisson_ratio),'poisson_ratio',.true.)

      allocate (modulus_grain(nzn), stat = ierr)
      modulus_grain=0.0d0
      call checkerr(ierr,'modulus_grain',ilog)
      call memory_monitor(sizeof(modulus_grain),'modulus_grain',.true.)

      allocate (modulus_fluid(nzn), stat = ierr)
      modulus_fluid=0.0d0
      call checkerr(ierr,'modulus_fluid',ilog)
      call memory_monitor(sizeof(modulus_fluid),'modulus_fluid',.true.)

      allocate (modulus_bulk(nzn), stat = ierr)
      modulus_bulk=0.0d0
      call checkerr(ierr,'modulus_bulk',ilog)
      call memory_monitor(sizeof(modulus_bulk),'modulus_bulk',.true.)

      allocate (compressibility(nzn), stat = ierr)
      compressibility=0.0d0
      call checkerr(ierr,'compressibility',ilog)
      call memory_monitor(sizeof(compressibility),'compressibility',.true.)

      allocate (density_rock(nzn), stat = ierr)
      density_rock=0.0d0
      call checkerr(ierr,'density_rock',ilog)
      call memory_monitor(sizeof(density_rock),'density_rock',.true.)

      allocate (density_fluid(nzn), stat = ierr)
      density_fluid=0.0d0
      call checkerr(ierr,'density_fluid',ilog)
      call memory_monitor(sizeof(density_fluid),'density_fluid',.true.)

      allocate (loading_factor_zn(nzn), stat = ierr)
      loading_factor_zn=0.0d0
      call checkerr(ierr,'loading_factor_zn',ilog)
      call memory_monitor(sizeof(loading_factor_zn),'loading_factor_zn',.true.)

!cprovi----------------------------------------------------------
!cprovi Allocate vector for oven dry model
!cprovi----------------------------------------------------------
 
      allocate (beta_ovendry(nzn), stat = ierr)
      beta_ovendry=0.0d0
      call checkerr(ierr,'beta_ovendry',ilog)
      call memory_monitor(sizeof(beta_ovendry),'beta_ovendry',.true.)
      
      allocate (cp0_ovendry(nzn), stat = ierr)
      cp0_ovendry=0.0d0
      call checkerr(ierr,'cp0_ovendry',ilog)
      call memory_monitor(sizeof(cp0_ovendry),'cp0_ovendry',.true.)
      
      allocate (hm_ovendry(nzn), stat = ierr)
      hm_ovendry=0.0d0
      call checkerr(ierr,'hm_ovendry',ilog)
      call memory_monitor(sizeof(hm_ovendry),'hm_ovendry',.true.)
      
      allocate (w0_ovendry(nzn), stat = ierr)
      w0_ovendry=0.0d0
      call checkerr(ierr,'w0_ovendry',ilog)
      call memory_monitor(sizeof(w0_ovendry),'w0_ovendry',.true.)
      
      allocate (isovendrying(nzn), stat = ierr)
      isovendrying=.false.
      call checkerr(ierr,'isovendrying',ilog)
      call memory_monitor(sizeof(isovendrying),'isovendrying',.true.)

!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
 
      allocate (swr(nzn), stat = ierr)
      swr=0.0d0
      call checkerr(ierr,'swr',ilog)
      call memory_monitor(sizeof(swr),'swr',.true.)

      allocate (spalpha(nzn), stat = ierr)
      spalpha=0.0d0
      call checkerr(ierr,'spalpha',ilog)
      call memory_monitor(sizeof(spalpha),'spalpha',.true.)

      allocate (spbeta(nzn), stat = ierr)
      spbeta=0.0d0
      call checkerr(ierr,'spbeta',ilog)
      call memory_monitor(sizeof(spbeta),'spbeta',.true.)

      allocate (spgamma(nzn), stat = ierr)
      spgamma=0.0d0
      call checkerr(ierr,'spgamma',ilog)
      call memory_monitor(sizeof(spgamma),'spgamma',.true.)

      allocate (expn(nzn), stat = ierr)
      expn=0.0d0
      call checkerr(ierr,'expn',ilog)
      call memory_monitor(sizeof(expn),'expn',.true.)
      
 
      allocate (aentry(nzn), stat = ierr)
      aentry=0.0d0
      call checkerr(ierr,'aentry',ilog)
      call memory_monitor(sizeof(aentry),'aentry',.true.)

      allocate (disx(nzn), stat = ierr)
      disx=0.0d0
      call checkerr(ierr,'disx',ilog)
      call memory_monitor(sizeof(disx),'disx',.true.)

      allocate (disy(nzn), stat = ierr)
      disy=0.0d0
      call checkerr(ierr,'disy',ilog)
      call memory_monitor(sizeof(disy),'disy',.true.)

      allocate (disz(nzn), stat = ierr)
      disz=0.0d0
      call checkerr(ierr,'disz',ilog)
      call memory_monitor(sizeof(disz),'disz',.true.)

      !c for transient dispersivity
      allocate (disx_prev(nzn), stat = ierr)
      disx_prev=0.0d0
      call checkerr(ierr,'disx_prev',ilog)
      call memory_monitor(sizeof(disx_prev),'disx_prev',.true.)

      allocate (disy_prev(nzn), stat = ierr)
      disy_prev=0.0d0
      call checkerr(ierr,'disy_prev',ilog)
      call memory_monitor(sizeof(disy_prev),'disy_prev',.true.)

      allocate (disz_prev(nzn), stat = ierr)
      disz_prev=0.0d0
      call checkerr(ierr,'disz_prev',ilog)
      call memory_monitor(sizeof(disz_prev),'disz_prev',.true.)

      allocate (disx_next(nzn), stat = ierr)
      disx_next=0.0d0
      call checkerr(ierr,'disx_next',ilog)
      call memory_monitor(sizeof(disx_next),'disx_next',.true.)

      allocate (disy_next(nzn), stat = ierr)
      disy_next=0.0d0
      call checkerr(ierr,'disy_next',ilog)
      call memory_monitor(sizeof(disy_next),'disy_next',.true.)

      allocate (disz_next(nzn), stat = ierr)
      disz_next=0.0d0
      call checkerr(ierr,'disz_next',ilog)
      call memory_monitor(sizeof(disz_next),'disz_next',.true.)

      allocate (satwlim(nzn), stat = ierr)
      satwlim=0.0d0
      call checkerr(ierr,'satwlim',ilog)
      call memory_monitor(sizeof(satwlim),'satwlim',.true.)

 
      allocate (satwfield(nzn), stat = ierr)
      satwfield=0.0d0
      call checkerr(ierr,'satwfield',ilog)
      call memory_monitor(sizeof(satwfield),'satwfield',.true.)

      allocate (satwopt(nzn), stat = ierr)
      satwopt=0.0d0
      call checkerr(ierr,'satwopt',ilog)
      call memory_monitor(sizeof(satwopt),'satwopt',.true.)

      allocate (rew0(nzn), stat = ierr)
      rew0=0.0d0
      call checkerr(ierr,'rew0',ilog)
      call memory_monitor(sizeof(rew0),'rew0',.true.)

      allocate (p1(nzn), stat = ierr)
      p1=0.0d0
      call checkerr(ierr,'p1',ilog)
      call memory_monitor(sizeof(p1),'p1',.true.)

      allocate (rate_root_max(nzn), stat = ierr)
      rate_root_max=0.0d0
      call checkerr(ierr,'rate_root_max',ilog)
      call memory_monitor(sizeof(rate_root_max),'rate_root_max',.true.)

      allocate (satwdry(nzn), stat = ierr)
      satwdry=0.0d0
      call checkerr(ierr,'satwdry',ilog)
      call memory_monitor(sizeof(satwdry),'satwdry',.true.)
      
      allocate (h1dry(nzn), stat = ierr)! CBF
      call checkerr(ierr,'h1dry',ilog)! CBF
      h1dry = 0.0d0
      call memory_monitor(sizeof(h1dry),'h1dry',.true.)

      allocate (pvol(nzn), stat = ierr)! CBF
      call checkerr(ierr,'pvol',ilog)! CBF
      pvol = 0.0d0
      call memory_monitor(sizeof(pvol),'pvol',.true.)

!cdsu allocate memory for mechanical related variables
      allocate (porosity_mech_cal(nzn), stat = ierr)
      porosity_mech_cal=.false.
      call checkerr(ierr,'porosity_mech_cal',ilog)
      call memory_monitor(sizeof(porosity_mech_cal),'porosity_mech_cal',.true.)

      allocate (storcoeff_mech_cal(nzn), stat = ierr)
      storcoeff_mech_cal=.false.
      call checkerr(ierr,'storcoeff_mech_cal',ilog)
      call memory_monitor(sizeof(storcoeff_mech_cal),'storcoeff_mech_cal',.true.)

      allocate (skempton_mech_cal(nzn), stat = ierr)
      skempton_mech_cal=.false.
      call checkerr(ierr,'skempton_mech_cal',ilog)
      call memory_monitor(sizeof(skempton_mech_cal),'skempton_mech_cal',.true.)

      allocate (loadingfactor_mech_cal(nzn), stat = ierr)
      loadingfactor_mech_cal=.false.
      call checkerr(ierr,'loadingfactor_mech_cal',ilog)
      call memory_monitor(sizeof(loadingfactor_mech_cal),'loadingfactor_mech_cal',.true.)

      allocate (loadingfactor_specified(nzn), stat = ierr)
      loadingfactor_specified=.false.
      call checkerr(ierr,'loadingfactor_specified',ilog)
      call memory_monitor(sizeof(loadingfactor_specified),'loadingfactor_specified',.true.)
      
!c_trap allocate memory for variables used for bubble entrapment
      if (trap_bubbles) then
        allocate (sgr_imbi(nzn), stat = ierr)
        sgr_imbi=0.0d0
        call checkerr(ierr,'sgr_imbi',ilog)
        call memory_monitor(sizeof(sgr_imbi),'sgr_imbi',.true.)
      end if      
 
      allocate (root_length_dens(nzn), stat = ierr)
      root_length_dens=0.0d0
      call checkerr(ierr,'root_length_dens',ilog)
      call memory_monitor(sizeof(root_length_dens),'root_length_dens',.true.)

      allocate (tree_trans_factor(nzn), stat = ierr)
      tree_trans_factor=0.0d0
      call checkerr(ierr,'tree_trans_factor',ilog)
      call memory_monitor(sizeof(tree_trans_factor),'tree_trans_factor',.true.)

!cdsu orientation and rotation matrix information
      if (useAnisoCorr) then
        allocate (aca_vol(nngl), stat = ierr)
        aca_vol = vector_zero
        call checkerr(ierr,'aca_vol',ilog)
        call memory_monitor(sizeof(aca_vol),'aca_vol',.true.)

        if (reactive_transport) then
          allocate (atc_zone(nzn), stat = ierr)
          atc_zone = vector_one
          call checkerr(ierr,'atc_zone',ilog)
          call memory_monitor(sizeof(atc_zone),'atc_zone',.true.)
        end if 
      end if

!c allocate memory for material parameters read from file
#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_perm_cond) then
        allocate (permx(num_cells), stat = ierr)
        permx=0.0d0
        call checkerr(ierr,'permx',ilog)
        call memory_monitor(sizeof(permx),'permx',.true.)

        allocate (permy(num_cells), stat = ierr)
        permy=0.0d0
        call checkerr(ierr,'permy',ilog)
        call memory_monitor(sizeof(permy),'permy',.true.)

        allocate (permz(num_cells), stat = ierr)
        permz=0.0d0
        call checkerr(ierr,'permz',ilog)
        call memory_monitor(sizeof(permz),'permz',.true.)

        if (type_cond_perm == 2 .or. useAnisoCondCorr) then
          allocate (perm_tensor(num_cells), stat = ierr)
          perm_tensor=tensor_zero
          call checkerr(ierr,'perm_tensor',ilog)
          call memory_monitor(sizeof(perm_tensor),'perm_tensor',.true.)
        end if
      else
#endif
        allocate (permx(nngl), stat = ierr)
        permx=0.0d0
        call checkerr(ierr,'permx',ilog)
        call memory_monitor(sizeof(permx),'permx',.true.)

        allocate (permy(nngl), stat = ierr)
        permy=0.0d0
        call checkerr(ierr,'permy',ilog)
        call memory_monitor(sizeof(permy),'permy',.true.)

        allocate (permz(nngl), stat = ierr)
        permz=0.0d0
        call checkerr(ierr,'permz',ilog)
        call memory_monitor(sizeof(permz),'permz',.true.)

        if (discretization_type > 0 .and. (type_cond_perm == 2 .or.    &
            useAnisoCondCorr)) then
          allocate (perm_tensor(nngl), stat = ierr)
          perm_tensor=tensor_zero
          call checkerr(ierr,'perm_tensor',ilog)
          call memory_monitor(sizeof(perm_tensor),'perm_tensor',.true.)
        end if
#ifdef USG
      end if
#endif

#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_perm_cond) then
        if (compute_permafrost) then
          allocate (permx0(num_cells), stat = ierr)
          permx0=0.0d0
          call checkerr(ierr,'permx0',ilog)
          call memory_monitor(sizeof(permx0),'permx0',.true.)

          allocate (permy0(num_cells), stat = ierr)
          permy0=0.0d0
          call checkerr(ierr,'permy0',ilog)
          call memory_monitor(sizeof(permy0),'permy0',.true.)

          allocate (permz0(num_cells), stat = ierr)
          permz0=0.0d0
          call checkerr(ierr,'permz0',ilog)
          call memory_monitor(sizeof(permz0),'permz0',.true.)

          if (type_cond_perm == 2 .or. useAnisoCondCorr) then
            allocate (perm0_tensor(num_cells), stat = ierr)
            perm0_tensor=tensor_zero
            call checkerr(ierr,'perm0_tensor',ilog)
            call memory_monitor(sizeof(perm0_tensor),'perm0_tensor',.true.)
          end if
        end if
      else
#endif
        if (compute_permafrost) then
          allocate (permx0(nngl), stat = ierr)
          permx0=0.0d0
          call checkerr(ierr,'permx0',ilog)
          call memory_monitor(sizeof(permx0),'permx0',.true.)

          allocate (permy0(nngl), stat = ierr)
          permy0=0.0d0
          call checkerr(ierr,'permy0',ilog)
          call memory_monitor(sizeof(permy0),'permy0',.true.)

          allocate (permz0(nngl), stat = ierr)
          permz0=0.0d0
          call checkerr(ierr,'permz0',ilog)
          call memory_monitor(sizeof(permz0),'permz0',.true.)

          if (discretization_type > 0 .and. (type_cond_perm == 2 .or.  &
              useAnisoCondCorr)) then
            allocate (perm0_tensor(nngl), stat = ierr)
            perm0_tensor=tensor_zero
            call checkerr(ierr,'perm0_tensor',ilog)
            call memory_monitor(sizeof(perm0_tensor),'perm0_tensor',.true.)
          end if
        end if
#ifdef USG
      end if
#endif

!c fracture related parameters
      allocate (fractureFlowType(nngl), stat = ierr)
      fractureFlowType=0
      call checkerr(ierr,'fractureFlowType',ilog)
      call memory_monitor(sizeof(fractureFlowType),'fractureFlowType',.true.)

      allocate (aperture(nngl), stat = ierr)
      aperture=0.0d0
      call checkerr(ierr,'aperture',ilog)
      call memory_monitor(sizeof(aperture),'aperture',.true.)

    end subroutine 

!cdsu -----------------------------------------------------------------
!cdsu extented material properties
!cdsu -----------------------------------------------------------------
    subroutine mem_mat_ext

      use gen, only : ilog, nngl, root_uptake,                         &
                      mem_cur, mem_max, memory_monitor
      use phys, only : swr_vol, spalpha_vol, spbeta_vol, spgamma_vol,  &
                       expn_vol, aentry_vol, h1dry_vol, satwdry_vol,   &
                       soilhydrfunc_field
      use bbls, only : trap_bubbles, sgr_imbi_vol
      use biol, only : pure_evap

#ifdef USG
      use usg_mesh_data, only : num_cells
#endif

      implicit none

      integer :: ierr

      external checkerr

      allocate (swr_vol(nngl), stat = ierr)
      swr_vol=0.0d0
      call checkerr(ierr,'swr_vol',ilog)
      call memory_monitor(sizeof(swr_vol),'swr_vol',.true.)

      allocate (spalpha_vol(nngl), stat = ierr)
      spalpha_vol=0.0d0
      call checkerr(ierr,'spalpha_vol',ilog)
      call memory_monitor(sizeof(spalpha_vol),'spalpha_vol',.true.)

      allocate (spbeta_vol(nngl), stat = ierr)
      spbeta_vol=0.0d0
      call checkerr(ierr,'spbeta_vol',ilog)
      call memory_monitor(sizeof(spbeta_vol),'spbeta_vol',.true.)

      allocate (spgamma_vol(nngl), stat = ierr)
      spgamma_vol=0.0d0
      call checkerr(ierr,'spgamma_vol',ilog)
      call memory_monitor(sizeof(spgamma_vol),'spgamma_vol',.true.)

      allocate (expn_vol(nngl), stat = ierr)
      expn_vol=0.0d0
      call checkerr(ierr,'expn_vol',ilog)
      call memory_monitor(sizeof(expn_vol),'expn_vol',.true.)

      allocate (aentry_vol(nngl), stat = ierr)
      aentry_vol=0.0d0
      call checkerr(ierr,'aentry_vol',ilog)
      call memory_monitor(sizeof(aentry_vol),'aentry_vol',.true.)

      if (soilhydrfunc_field) then
        allocate (h1dry_vol(nngl), stat = ierr)
        h1dry_vol=0.0d0
        call checkerr(ierr,'h1dry_vol',ilog)
        call memory_monitor(sizeof(h1dry_vol),'h1dry_vol',.true.)

        allocate (satwdry_vol(nngl), stat = ierr)
        satwdry_vol=0.0d0
        call checkerr(ierr,'satwdry_vol',ilog)
        call memory_monitor(sizeof(satwdry_vol),'satwdry_vol',.true.)
      end if

      if (trap_bubbles) then
        allocate (sgr_imbi_vol(nngl), stat = ierr)
        sgr_imbi_vol=0.0d0
        call checkerr(ierr,'sgr_imbi_vol',ilog)
        call memory_monitor(sizeof(sgr_imbi_vol),'sgr_imbi_vol',.true.)

      end if

    end subroutine mem_mat_ext
