!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/fluxd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function fluxd
!c ---------------------
!c
!c compute dispersive/diffusive mass flux
!c
!c written by:      Uli Mayer - August 15, 96
!c
!c last modified:
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           totc_i             = total aqueous component             + -
!c                                concentration in control volume i
!c           totc_j             = total aqueous component             + -
!c                                concentration in control volume j
!c           cinfrt_d           = influence coefficient               + -
!c                                (hydrodynamic dispersion)
!c           fluxd              = dispersive flux                     * +
!c
!c common:   -
!c
!c local:    - 
!c
!c external: -
!c ----------------------------------------------------------------------
 
      real*8 function fluxd(totc_i,totc_j,cinfrt_d)

      implicit none
      
      real*8 :: totc_i,totc_j,cinfrt_d
 
      fluxd = cinfrt_d * (totc_j - totc_i)

      return
      end function fluxd


!      !>
!      !>  Fickian diffusive flux for MCD
!      !>
!      real*8 function fluxd_mcd(ic,cnew_i,cnew_j,cx_i,cx_j,          &
!                                mdiff_c_i,mdiff_c_j,                 &
!                                mdiff_x_i,mdiff_x_j, cinfrt_d,       &
!                                type_ave_De)
!
!      use math_common, only : math_common_harmonic
!      use chem, only : nc, nx, iacx, jacx, xnuxc
!
!      implicit none
!      
!      integer :: ic
!      real*8 :: cnew_i(nc),cnew_j(nc),cx_i(nx),cx_j(nx),               &
!                mdiff_c_i(nc),mdiff_c_j(nc),                           &
!                mdiff_x_i(nx),mdiff_x_j(nx),cinfrt_d
!      character(len=*) :: type_ave_De
!      
!      !c local variables
!      integer :: i, ix, istart, iend, j, istart2, iend2
!      real*8 :: diff_ij, fluxd_c, fluxd_x
!      real*8 :: r0 = 0.0d0, rhalf = 0.5d0
!
!      fluxd_c = r0
!      fluxd_x = r0
!
!      !c free species
!      if (type_ave_De.eq.'harmonic') then
!        diff_ij = math_common_harmonic(mdiff_c_i(ic),mdiff_c_j(ic))
!      else if (type_ave_De.eq.'arithmetic') then
!        diff_ij = rhalf*(mdiff_c_i(ic)+mdiff_c_j(ic))
!      else if (type_ave_De.eq.'no averaging') then
!        diff_ij = mdiff_c_i(ic)
!      end if 
!
!      fluxd_c = cinfrt_d*diff_ij*(cnew_j(ic)-cnew_i(ic))
!
!      !c aqueous complexes
!      if (nx > 0) then
!        istart = iacx(ic)
!        iend = iacx(ic+1)-1
!        do i = istart, iend
!          ix = jacx(i)
!          if (type_ave_De.eq.'harmonic') then
!            diff_ij = math_common_harmonic(mdiff_x_i(ix),mdiff_x_j(ix))
!          else if (type_ave_De.eq.'arithmetic') then
!            diff_ij = rhalf*(mdiff_x_i(ix)+mdiff_x_j(ix))
!          else if (type_ave_De.eq.'no averaging') then
!            diff_ij = mdiff_x_i(ix)
!          end if 
!
!          fluxd_x = fluxd_x + cinfrt_d*xnuxc(i)*diff_ij*(cx_j(ix)-cx_i(ix))
!        end do
!      end if
!
!      fluxd_mcd = fluxd_c + fluxd_x
!
!      end function fluxd_mcd
!
!      !>
!      !>  Electrochemical migration diffusive flux for MCD
!      !>  Note: performance of this function can be improved by 
!      !>        calculating all species together
!      !>
!      real*8 function fluxd_mcd_e(iic,cnew_i,cnew_j,cx_i,cx_j,         &
!                                  mdiff_c_i,mdiff_c_j,                 &
!                                  mdiff_x_i,mdiff_x_j,cinfrt_d,        &
!                                  type_ave_De)
!
!      use math_common, only : math_common_harmonic
!      use chem, only : nc, nx, iax, jax, xnux, namec, chargec, chargex
!
!      implicit none
!
!      
!      integer :: iic
!      real*8 :: cnew_i(nc),cnew_j(nc),cx_i(nx),cx_j(nx),               &
!                mdiff_c_i(nc),mdiff_c_j(nc),                           &
!                mdiff_x_i(nx),mdiff_x_j(nx),cinfrt_d
!      character(len=*) :: type_ave_De
!      
!      !c local variables
!      integer :: i, ic, ix, istart, iend
!      real*8 :: diff_cof_ic(nc), diff_cof_ix(nx), Dzc_loc(nc)
!      real*8 :: Dzdelta_c, Dzdelta_x, Dz2c_tot, Dzc_ii, Dzc_jj,        &
!                diff_ij, Dzdelta_tot
!      real*8 :: r0 = 0.0d0, r2 = 2.0d0, rhalf = 0.5d0
!
!      !c parameters for electrochemical migration term
!      diff_cof_ic = r0
!      diff_cof_ix = r0
!
!      Dzc_loc = r0
!      Dz2c_tot = r0
!
!      if (type_ave_De.eq.'harmonic') then
!        do ic=1,nc-1         ! loop over free species 
!          diff_cof_ic(ic) = math_common_harmonic(mdiff_c_i(ic),mdiff_c_j(ic))     
!        end do
!             
!        do ix=1,nx            ! loop over secondary species 
!          diff_cof_ix(ix) = math_common_harmonic(mdiff_x_i(ix),mdiff_x_j(ix))
!        end do
!      else if (type_ave_De.eq.'arithmetic') then
!        do ic=1,nc-1          ! loop over free species 
!          diff_cof_ic(ic) = rhalf*(mdiff_c_i(ic)+mdiff_c_j(ic))
!        end do
!             
!        do ix=1,nx            ! loop over secondary species
!          diff_cof_ix(ix) = rhalf*(mdiff_x_i(ix)+mdiff_x_j(ix))
!        end do
!      else if (type_ave_De.eq.'no averaging') then
!        do ic=1,nc-1          ! loop over free species 
!          diff_cof_ic(ic) = mdiff_c_i(ic)
!        end do
!             
!        do ix=1,nx            ! loop over secondary species 
!          diff_cof_ix(ix) = mdiff_x_i(ix)
!        end do
!      end if      
!
!      do ic = 1, nc-1           ! loop over free species
!        Dzc_loc(ic) = diff_cof_ic(ic)*chargec(ic)*rhalf*(cnew_i(ic)+cnew_j(ic))
!      end do                  
!
!      do ix=1,nx              ! ix loop over complexes
!        istart = iax(ix)
!        iend = iax(ix+1)-1
!        do i = istart, iend
!          ic = jax(i)             
!          !c skip h2o, h+1 and oh- since electromig considers other sps             
!          if (namec(ic).ne.'h2o') then
!            Dzc_loc(ic) = Dzc_loc(ic) + diff_cof_ix(ix)*xnux(i)*       &
!                          chargex(ix)*rhalf*(cx_i(ix)+cx_j(ix))
!          end if
!        end do              ! i loop
!      end do                ! ix loop over complexes
!
!
!      !c calculate Sigma D_z^2_c
!      do ic=1,nc-1          ! loop over free species
!        Dz2c_tot = Dz2c_tot + chargec(ic)*Dzc_loc(ic)
!      end do   
!    
!      !c calculate electrochemical migration diffusive flux
!      Dzdelta_tot = r0
!
!      !c D_z_delta_c of free species
!      do ic=1,nc-1           ! loop over free species                                                                 
!        Dzdelta_tot = Dzdelta_tot + diff_cof_ic(ic)*chargec(ic)*       &
!                      (cnew_j(ic)-cnew_i(ic))
!      end do                ! loop over free species
!
!      !c D_z_delta_c of secondary species species
!      do ix = 1, nx
!        istart = iax(ix)
!        iend = iax(ix+1)-1
!        do i = istart,iend
!          ic = jax(i)      
!          if (namec(ic).ne.'h2o') then
!            Dzdelta_tot = Dzdelta_tot + xnux(i)*diff_cof_ix(ix)*       &
!                          chargec(ic)*(cx_j(ix)-cx_i(ix))
!          end if
!        end do
!      end do
!
!      fluxd_mcd_e = - cinfrt_d * Dzdelta_tot * Dzc_loc(iic) / Dz2c_tot
!
!      end function fluxd_mcd_e
!
!      !>
!      !>  Electrochemical migration diffusive flux for MCD
!      !>  Note: performance of this function can be improved by 
!      !>        calculating all species together
!      !>
!      real*8 function fluxd_mcd_e_inc(iic,cnew_inc,cnew_i,cnew_j,      &
!                                      cx_inc,cx_i,cx_j,                &
!                                      mdiff_c_i,mdiff_c_j,             &
!                                      mdiff_x_i,mdiff_x_j,cinfrt_d,    &
!                                      type_ave_De)
!
!      use math_common, only : math_common_harmonic
!      use chem, only : nc, nx, iax, jax, xnux, namec, chargec, chargex
!
!      implicit none
!      
!      integer :: iic
!      real*8 :: cnew_inc(nc),cnew_i(nc),cnew_j(nc),                    &
!                cx_inc(nx),cx_i(nx),cx_j(nx),                          &
!                mdiff_c_i(nc),mdiff_c_j(nc),                           &
!                mdiff_x_i(nx),mdiff_x_j(nx),cinfrt_d
!      character(len=*) :: type_ave_De
!      
!      !c local variables
!      integer :: i, ic, ix, istart, iend
!      real*8 :: diff_cof_ic(nc), diff_cof_ix(nx), Dzc_loc(nc),         &
!                Dzc_loc_inc(nc)
!      real*8 :: Dzdelta_c, Dzdelta_x, Dzc_ii, Dzc_jj, diff_ij,         &
!                Dz2c_tot, Dz2c_tot_inc, Dzdelta_tot, Dzdelta_tot_inc
!      real*8 :: r0 = 0.0d0, r2 = 2.0d0, rhalf = 0.5d0
!
!      !c parameters for electrochemical migration term
!      diff_cof_ic = r0
!      diff_cof_ix = r0
!
!      Dzc_loc = r0
!      Dz2c_tot = r0
!      Dzdelta_tot = r0
!
!      Dzc_loc_inc = r0
!      Dz2c_tot_inc = r0
!      Dzdelta_tot_inc = r0
!
!      if (type_ave_De.eq.'harmonic') then
!        do ic=1,nc-1         ! loop over free species 
!          diff_cof_ic(ic) = math_common_harmonic(mdiff_c_i(ic),mdiff_c_j(ic))     
!        end do
!             
!        do ix=1,nx            ! loop over secondary species 
!          diff_cof_ix(ix) = math_common_harmonic(mdiff_x_i(ix),mdiff_x_j(ix))
!        end do
!      else if (type_ave_De.eq.'arithmetic') then
!        do ic=1,nc-1          ! loop over free species 
!          diff_cof_ic(ic) = rhalf*(mdiff_c_i(ic)+mdiff_c_j(ic))
!        end do
!             
!        do ix=1,nx            ! loop over secondary species
!          diff_cof_ix(ix) = rhalf*(mdiff_x_i(ix)+mdiff_x_j(ix))
!        end do
!      else if (type_ave_De.eq.'no averaging') then
!        do ic=1,nc-1          ! loop over free species 
!          diff_cof_ic(ic) = mdiff_c_i(ic)
!        end do
!             
!        do ix=1,nx            ! loop over secondary species 
!          diff_cof_ix(ix) = mdiff_x_i(ix)
!        end do
!      end if      
!
!      do ic = 1, nc-1           ! loop over free species
!        Dzc_loc(ic) = diff_cof_ic(ic)*chargec(ic)*rhalf*(cnew_i(ic)+cnew_j(ic))
!        Dzc_loc_inc(ic) = diff_cof_ic(ic)*chargec(ic)*rhalf*(cnew_inc(ic)+cnew_j(ic))
!      end do                  
!
!      do ix=1,nx              ! ix loop over complexes
!        istart = iax(ix)
!        iend = iax(ix+1)-1
!        do i = istart, iend
!          ic = jax(i)             
!          !c skip h2o, h+1 and oh- since electromig considers other sps             
!          if (namec(ic).ne.'h2o') then
!            Dzc_loc(ic) = Dzc_loc(ic) + diff_cof_ix(ix)*xnux(i)*         &
!                          chargex(ix)*rhalf*(cx_i(ix)+cx_j(ix))
!            Dzc_loc_inc(ic) = Dzc_loc_inc(ic) + diff_cof_ix(ix)*xnux(i)* &
!                          chargex(ix)*rhalf*(cx_inc(ix)+cx_j(ix))
!          end if
!        end do              ! i loop
!      end do                ! ix loop over complexes
!
!      
!      !c calculate Sigma D_z^2_c
!      do ic=1,nc-1          ! loop over free species
!        Dz2c_tot = Dz2c_tot + chargec(ic)*Dzc_loc(ic)
!        Dz2c_tot_inc = Dz2c_tot_inc + chargec(ic)*Dzc_loc_inc(ic)
!      end do   
!    
!      !c calculate electrochemical migration diffusive flux
!
!      !c D_z_delta_c of free species
!      do ic=1,nc-1           ! loop over free species                                                                 
!        Dzdelta_tot = Dzdelta_tot + diff_cof_ic(ic)*chargec(ic)*         &
!                      (cnew_j(ic)-cnew_i(ic))
!        Dzdelta_tot_inc = Dzdelta_tot_inc + diff_cof_ic(ic)*chargec(ic)* &
!                      (cnew_j(ic)-cnew_inc(ic))
!      end do                ! loop over free species
!
!      !c D_z_delta_c of secondary species species
!      do ix = 1, nx
!        istart = iax(ix)
!        iend = iax(ix+1)-1
!        do i = istart,iend
!          ic = jax(i)      
!          if (namec(ic).ne.'h2o') then
!            Dzdelta_tot = Dzdelta_tot + xnux(i)*diff_cof_ix(ix)*         &
!                          chargec(ic)*(cx_j(ix)-cx_i(ix))
!            Dzdelta_tot_inc = Dzdelta_tot_inc + xnux(i)*diff_cof_ix(ix)* &
!                          chargec(ic)*(cx_j(ix)-cx_inc(ix))
!          end if
!        end do
!      end do
!
!      fluxd_mcd_e_inc = - cinfrt_d * (Dzdelta_tot_inc*Dzc_loc_inc(iic)/  &
!                                      Dz2c_tot_inc -                     &
!                                      Dzdelta_tot*Dzc_loc(iic)/          &
!                                      Dz2c_tot)
!      end function fluxd_mcd_e_inc
