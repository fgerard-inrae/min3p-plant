!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initbcice.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initbcice
!c -------------------
!c
!c boundary conditions for ice loading/unloading
!c
!c written by:      Danyang Su - March 29, 20
!c
!c last modified:   
!c
!c ----------------------------------------------------------------------
 
      subroutine initbcice
 
      use gen
      use chem, only : nc, ncorder, component_type, namec
      use file_unit, only : lun_get, lun_free
      use file_utility, only : rewind_first_record
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use geometry
      use usg_ice_sheet
      use usg_mesh_surface
      use usg_mesh_data, only : nodes, is_boundary_node,               &
                                node_to_layer_node, cell_projection
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box
#endif

      implicit none
      
      integer :: i, ic, ibz, ivol, ivol_sn, ibice, nbice, nbicep, ierr,&
                 itemp, l_string, ierrcd

      real*8 :: xbmin, xbmax, ybmin, ybmax, zbmin, zbmax ,factiny

      character*72  :: subsection 
      character*256 :: strbuffer
      integer, allocatable :: iabice(:)

      external readbloc
 
      logical found_section, found_subsection, iserror

      real*8, parameter :: r0 = 0.0d0, tiny = 1.0d-8 

!c  read numerical data and write to temporary file 
      ierrcd = 0  

!c  new ice sheet control parameter for general structured and unstructured mesh
      section_header = 'boundary conditions - ice sheet loading/unloading' 
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  terminate program if section header not found
      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
  
!c  define length of section header                                      
                                                                        
      l_string = index(section_header,'  ')-1 
      if (l_string.eq.-1.or.l_string.gt.72) then 
         l_string=72 
      end if

!c  write section header to generic output file                          
      if (b_enable_output .and. b_enable_output_gen) then                                                                  
        write(igen,'(/72a)')('-',i=1,72) 
        write(igen,'(a)') section_header(:l_string) 
        write(igen,'(72a/)')('-',i=1,72) 
      end if

!c  write section header to screen and log file
      if (b_enable_output .and. rank == 0) then
        write(*,*) section_header(:l_string) 
        write(*,*)('-',i=1,72) 

        write(ilog,'(a)') section_header(:l_string) 
        write(ilog,'(72a/)')('-',i=1,72) 
      end if      

!c  read number of boundary zones                                        
                                                                        
      ierrcd = 1
      read(itmp,*,err=999,end=999) nbzice
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
          'number of boundary zones                        = ',nbzice
      end if   

!c initialize array for ice boundary conditions    
      allocate (iabice(nngl), stat = ierr) 
      iabice=0 
      call checkerr(ierr,'iabice',ilog)
      call memory_monitor(sizeof(iabice),'iabice',.true.)      
      
!c initialize parameters of curve fitting ice sheet model 
#ifdef USG       
      allocate (ice_fitting_parms(nbzice,2), stat = ierr)
      call checkerr(ierr,'ice_fitting_parms',ilog)
      call memory_monitor(sizeof(ice_fitting_parms),                &
                          'ice_fitting_parms',.true.)
#endif

!c initialize array for component concentration input
#ifdef USG
      allocate (ice_totbc(nc-1,nbzice), stat = ierr)
      ice_totbc = r0
      call checkerr(ierr,'ice_totbc',ilog)
      call memory_monitor(sizeof(ice_totbc),'ice_totbc',.true.)

      allocate (ice_typetotbc(nc-1,nbzice), stat = ierr)
      ice_typetotbc = ''
      call checkerr(ierr,'ice_typetotbc',ilog)
      call memory_monitor(sizeof(ice_typetotbc),'ice_typetotbc',.true.)

      allocate (ice_istotbc(nbzice), stat = ierr)
      ice_istotbc = .false.
      call checkerr(ierr,'ice_typetotbc',ilog)
      call memory_monitor(sizeof(ice_typetotbc),'ice_typetotbc',.true.)
#endif

!c initialize array for ice boundary conditions        
      nbice = 0
      iabice(1) = 1 
 
!c  read name of zone 
!c  loop over number of zones 
      do ibz = 1, nbzice                                 !loop over number of zones
!c  temporary pointer for output         
        nbicep = nbice+1 
                                                                        
!c  find current zone in input file and write to temporary file          
                                                                                  
        subsection = 'number and name of zone' 
                                                                                  
        call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                                  
        if (found_subsection) then 
                                                                                
          call readzone(itmp,icnv,ilog,zone_name,found_subsection) 
                                                                                
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error in input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                                  
        end if  

!c  define length of zone name
        l_zone_name = index(zone_name,' ')-1 
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
          l_zone_name = 72 
        end if  

!c  define type and value of boundary condition                          
                                                                        
        subsection = 'boundary type' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 
                                                                          
        if (found_subsection) then 
          ierrcd = 2
          read(icnv,'(a)',err=999,end=999) strbuffer
          strbuffer = adjustl(strbuffer)
  
          if(index(strbuffer,'gradient') == 2) then
#ifdef USG
            if(index(strbuffer,'gradient-top') == 2) then
              ice_fitting_parms(ibz,1)%itype_grad = 2
            else if(index(strbuffer,'gradient-bottom') == 2) then
              ice_fitting_parms(ibz,1)%itype_grad = 1
            else
              ice_fitting_parms(ibz,1)%itype_grad = 0
            end if

            if (.not. b_use_layered_mesh) then
              ice_fitting_parms(ibz,1)%itype_grad = 0
            end if

            ice_fitting_parms(ibz,1)%btypezn = 'gradient'
            ice_fitting_parms(ibz,1)%nparms = 3
  
            ierrcd = 3
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%dir_grad
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%thick_grad
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%thick_slope_grad

            if (ice_fitting_parms(ibz,1)%dir_grad /= 'x' .and. &
                ice_fitting_parms(ibz,1)%dir_grad /= 'y' .and. &
                ice_fitting_parms(ibz,1)%dir_grad /= 'z') then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "',section_header(:l_string),'"'
                write(ilog,*) 'Error in gradient direction'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if
#endif
          else if(index(strbuffer,'curve fitting ice sheet model') == 2) then
#ifdef USG             
            ice_fitting_parms(ibz,1)%btypezn = 'curve-fitting'
            ice_fitting_parms(ibz,1)%nparms = 5
            ierrcd = 4
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%sea_level
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%sea_level_temp_coeff         
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ice_thick_sea_level_coeff
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%sea_level_threshold
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%elevation_threshold
#endif
          else if(index(strbuffer,'ellipsoid fitting ice sheet model') == 2) then
#ifdef USG             
            ice_fitting_parms(ibz,1)%btypezn = 'ellipsoid-fitting'
            ice_fitting_parms(ibz,1)%nparms = 7
            ierrcd = 5
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_x0
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_y0
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_z0
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_a
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_b
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_c
            read(icnv,*,err=999,end=999) ice_fitting_parms(ibz,1)%ellip_alpha
#endif         
          else            
#ifdef USG
            ice_fitting_parms(ibz,1)%nparms = 1
            ierrcd = 6
            read(strbuffer,*,err=999,end=999) ice_fitting_parms(ibz,1)%btypezn,            &
                                              ice_fitting_parms(ibz,1)%ice_thickness
#endif
          end if

#ifdef USG
          ice_fitting_parms(ibz,2) = ice_fitting_parms(ibz,1)
#endif

#ifdef USG
          !c reactive transport boundary conditions during glaciation
          subsection = 'concentration input' 
          call findstrg(subsection,itmp,found_subsection)       
          if (found_subsection) then
            ice_istotbc(ibz) = .true.  
  
            do i = 1, nc-1
              itemp = ncorder(i)                 !internal order
              if (component_type(itemp).eq.'aqueous'.or. &
                  component_type(itemp).eq.'biomass') then
                ierrcd = 7
                read(itmp,*,end=999,err=999) ice_totbc(itemp,ibz),     &
                                             ice_typetotbc(itemp,ibz)
              end if
            end do
          end if
  
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(72a/)') ('-',i=1,72)
            if (ice_istotbc(ibz)) then
              write(igen,'(a/)') "Concentration input: Yes"
              write(igen,'(a)')'component           concentration      type'
              write(igen,'(72a/)') ('-',i=1,72)
              do ic = 1, nc-1
                if (component_type(ic).eq.'aqueous'.or. &
                    component_type(ic).eq.'biomass') then
                  write(igen,'(a12,6x,1pe15.6e3,6x,a12)') namec(ic),     &
                        ice_totbc(ic,ibz),ice_typetotbc(ic,ibz)
                end if
              end do
            else
              write(igen,'(a)') "Concentration input: No"
            end if
          end if
#endif                                                                          
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "',trim(section_header),'"' 
            write(ilog,*) 'zone "', trim(zone_name),'"' 
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                          
        end if 

!c  read coordiantes defining boundary zone,                             
                                                                        
        type_extent_zone = -1
        type_extent_zone_box = -1
  
        subsection = 'extent of zone'
        call findstrg(subsection,icnv,found_subsection)
  
        if (found_subsection) then  
          type_extent_zone = 0  
          ierrcd = 8
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
                                       zbmin,zbmax  
        end if
  
#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 9
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
                                       zbmin,zbmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xbmin = -1.0d300
          xbmax = 1.0d300
        end if

        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ybmin = -1.0d300
          ybmax = 1.0d300
        end if

        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zbmin = -1.0d300
          zbmax = 1.0d300
        end if
  
!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then  
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
  
        end if  

!c  increment boundary coordinates                                       
                                                                        
        factiny=dabs(xbmax-xbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        xbmin = xbmin-factiny 
        xbmax = xbmax+factiny 
        factiny=dabs(ybmax-ybmin)*tiny 
        if (factiny==r0) factiny=tiny 
        ybmin = ybmin-factiny 
        ybmax = ybmax+factiny 
        factiny=dabs(zbmax-zbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        zbmin = zbmin-factiny 
        zbmax = zbmax+factiny 

!c  store type of boundary condition and boundary condition              
!c  for global system in compressed storage

        do ivol = 1,nngl 

!c  skip internal nodes
#ifdef USG
          ivol_sn = node_idx_lg2sn(ivol)
          if (ivol_sn < 1) then
            cycle
          end if          
#endif
!c  check limits of boundary zone                                        
                                                                                    
          if (((type_extent_zone==0.or.type_extent_zone_box>0).and.    &
              (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.        &
              (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.        &
              (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.        &
              (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
              ibits(type_extent_zone,0,1)==0)) then
  
#ifdef USG
            if (discretization_type > 0 .and. type_extent_zone_box > 0) then
              if ((btest(type_extent_zone_box,1) .and.                 &
                   .not. is_boundary_node(ivol)) .or.                  &
                  (btest(type_extent_zone_box,2) .and.                 &
                   is_boundary_node(ivol))) then
                cycle
              end if
            end if

!  assign boundary type and boundary condition                          
                                                                        
            nbice = nbice+1
            iabice(nbice) = ivol

            node_idx_sn2bz(ivol_sn) = ibz
                                                                        
!  exit if nbice > nn                                                    
                                                                        
            if (nbice.gt.nngl) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'nbice > nn ...'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if 
            
            !c calculate ice sheet thickness
            call usg_ice_cal_thickness(ivol_sn)
            if (b_phw2ice) then
              call usg_ice_cal_thickness_phw2ice(ivol_sn)
            end if
#endif                       
          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes 
          
!  write header for boundary zone to generic output file                
        if (b_enable_output .and. b_enable_output_gen) then   
            
          write(igen,'(/a,i0,a,1x,a)') 'zone ',ibz,':',zone_name 
          write(igen,'(72a)')('-',i=1,72)

#ifdef PETSC   
          write(igen,'(3(a,3x),a,21x,a/)') 'local volume',              &
                'global volume', 'boundary type','thickness' 
#else
          write(igen,'(2x,a,3x,a,21x,a/)') 'volume', 'boundary type',   &
                'thickness'
#endif
        end if          

!c  write boundary condition for zone to generic output file            
                                                                        
!c  first and gradient type   
        if (b_enable_output .and. b_enable_output_gen) then                                  
          do ibice=nbicep,nbice
            ivol = iabice(ibice)
#ifdef USG            
            ivol_sn = node_idx_lg2sn(ivol)
#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
              write(igen,'(i10,5x,i10,6x,a32,1pe15.6e3,1x)')           &
                    ivol,node_idx_lg2g(ivol),                          &
                    ice_fitting_parms(ibz,1)%btypezn,                  &
                    ice_thickness_new(ivol_sn)
            end if
#else
            write(igen,'(i8,3x,a32,1pe15.6e3,1x)') ivol,              &
                  ice_fitting_parms(ibz,1)%btypezn,                   &
                  ice_thickness_new(ivol_sn)
#endif
#endif
          end do
        end if 

      end do                                             !end of nbzice zones

!c  define if boundary conditions are to updated
      update_bcice = .false.

      subsection = 'transient boundary conditions'
      call findstrg(subsection,itmp,found_subsection)  
      if (found_subsection) then
        update_bcice = .true.
      else
        subsection = 'transient ice sheet boundary conditions'
        call findstrg(subsection,itmp,found_subsection)    
        if (found_subsection) then
          update_bcice = .true.
        end if        
      end if
  
!cdsu only update the boundary condition values, with boundary type and zone unchanged.
      update_bcice_value_only=.false.

      subsection = 'transient boundary conditions: values only'
      call findstrg(subsection,itmp,found_subsection)  
      if (found_subsection) then
        update_bcice = .true.
        update_bcice_value_only = .true.
      else
        subsection = 'transient ice sheet boundary conditions: values only'
        call findstrg(subsection,itmp,found_subsection) 
        if (found_subsection) then
          update_bcice = .true.
          update_bcice_value_only = .true.
        end if              
      end if

!cdsu linear interpolation for boundary conditions, only if the 
!cdsu boundary condition type remains the same
      b_interpolation_bcice = .false.
      b_first_update_bcice = .false.

      if (update_bcice_value_only) then
        subsection = 'linear interpolation of boundary conditions'
        call findstrg(subsection,itmp,found_subsection) 
        if (found_subsection) then
          b_interpolation_bcice = .true.
          b_first_update_bcice = .true.
        end if 
      end if

  
!c  open file containing boundary conditions for ice loading/unloading
!c  and read first read time
  
      if (update_bcice) then
        ibcice = lun_get()
        open(ibcice,file=prefix(:l_prfx)//'.bcice',err=997, status='old')
        call rewind_first_record(ibcice)
        read(ibcice,*,err=998,end=998) time_bcice
      end if

!c  free space for array not required any more
!c  array iabice
      call memory_monitor(-sizeof(iabice),'iabice',.true.)
      deallocate (iabice, stat = ierr)
      call checkerr(ierr,'iabice',ilog)

      goto 1000

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'file ', prefix(:l_prfx)//'.bcice missing'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcice'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
