!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initicdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initicdd
!c -------------------
!c
!c initial condition (density dependent flow)
!c
!c written by:      Tom Henderson - August 21, 2002
!c
!c last modified:   Tom Henderson - November 12, 2003
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    * +
!c
!c           integer*4:
!c           ----------
!c           icnv               = unit number, data conversion and    + -
!c                                             temporary storage
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging file         + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           itmp               = unit number, temporary storage      + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           pressure_head      = .true.  -> initial condition in     + -
!c                                           terms of pressure head
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           section_header     = section header                      + -
!c           zone_name          = name of zone                        * +
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      * +
!c           density(nn)        = fluid density                       * +
!c           viscosity(nn)      = fluid viscosity                     * +
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures  * +
!c           logical:
!c           --------
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c local:    real*8:
!c           -------
!c           rdummy             = real*8 dummy variable
!c           tiny               = small increment
!c           ximin              = min. limit of zone in 
!c                                x-direction
!c           ximax              = max. limit of zone in 
!c                                x-direction
!c           yimin              = min. limit of zone in 
!c                                y-direction
!c           yimax              = max. limit of zone in 
!c                                y-direction
!c           zimin              = min. limit of zone in 
!c                                z-direction
!c           zimax              = max. limit of zone in 
!c                                z-direction
!c
!c           integer*4:
!c           ----------
!c           icvs               = unit number - initial condition 
!c                                              for variably 
!c                                              saturated flow
!c           iiz                = counter (zones)
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c           niz                = number of zones           
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           initcond_file      = .true.  -> read initial condition 
!c                                           from file
!c
!c           character:
!c           ----------
!c           cdummy             = character dummy variable
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file 
!c           findzone  = find zone in input section
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine initicdd

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use dens
      use file_unit, only : lun_get, lun_free
      use file_utility, only : read_vtk_data_from_file
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use solver_snes_common, only : stencil_width, dmda_flow
      use petsc_mpi_common, only : petsc_mpi_barrier, petsc_mpi_finalize
#endif

#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, is_boundary_node,    &
                                node_to_layer_node, cell_projection,   &
                                layer_nodes_top, layer_nodes_bottom,   &
                                usg_mesh_data_search_build

      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#ifdef PETSC_HDF
      use hdf5
      use hdf5_usg, only: hdf5_usg_read_node_lg2g, hdf5_usg_read_node_var
#endif
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: iskip, nskip
      
      integer :: i, i1, icvs, iiz, ivol, ivolgbl, niz, l_string,       &
                 nerrs, nwarns, nerrs_gbl, nwarns_gbl, ierr, ierrcd
      integer :: itype_grad       !0: normal, 1: bottom, 2: top (layered mesh)
      
#ifdef PETSC
      integer :: ilayer, nlayerxy, nlayerz, nvxys, mpitag, mpisrc,     &
                 mpidest, ivxystart, ivxyend, istart, iend
      integer :: mpistatus(MPI_STATUS_SIZE)
      real*8, allocatable :: uvs_lower(:), uvs_delta(:)
#endif
      
      real*8 :: ximin, ximax, yimin, yimax, zimin, zimax, rdummy,      &
                theta_a, theta_g, pinitial, sginitial,                 &
                h0_grad, slope_grad, pos_grad

      real*8 :: rx0, ry0, rz0     !center of gradient-radius type i.c. or b.c. condition

      external findstrg, findzone, readbloc, readzone

#ifdef USG
#ifdef PETSC_HDF
      integer(HID_T) :: iunit_hdf5, icvs_hdf5
#endif
      integer :: iunit_file, hdf5_ierr
      external hydrostatic_pitzerdens_usg
      logical :: initcond_file_vtk, initcond_file_hdf5, bfound, bexist
      character*72 :: subcommand
      character*2048 :: strbuffer2048
#endif

      logical found_section, found_subsection, initcond_file, bflag,   &
              gassat_initial, gasblock_initial
      character*1 :: cdummy
      character*1  :: dir_grad
      character*32 :: btypezn
      character*72 :: subsection
      character*256 :: strbuffer
      character*256 :: strfilename
      real*8   maxz
      real*8, parameter :: tiny = 1.d-5, visc_h2o = 1.0d-3, r0 = 0.0d0
      
      !c  set mpi process stop flag
#ifdef PETSC 
      logical :: b_mpi_process_flag_gbl
      PetscErrorCode :: ierrcode
#endif  

      ierrcd = 0

      sginitial = r0
      b_mpi_process_flag = .false.
     
      if (ispitzerdens) then
        !maxz=maxval(zg)
        maxz = zlmaxgbl
      end if


!c  default values - initial constants

      do ivol = 1,nngl

!c zero hydraulic heads for passing to subroutines also used for
!c density dependent flow

       hhead(ivol) = r0 
       densold(ivol) = density(ivol)
       !densold1(ivol) = density(ivol)
       !densold2(ivol) = density(ivol)
        
       tds_old(ivol) = tds_new(ivol)
       !tds_old2(ivol) = tds_new(ivol)
       sgnew(ivol) = r0
!c initial viscosity calculated previously in ddtds.for unless
!c viscosity is not updated
         
       if (.not.update_viscosity.and..not.update_viscosity_temp) then        
         viscosity(ivol) = visc_h2o
       end if       
       
       if (update_viscosity_temp) then 
        viscoold(ivol) = viscosity(ivol)
       end if     
       
       
       if (heat_transport.and.ispitzerdens) then
         densold_pitzer(ivol)=density_pitzer(ivol)
         !densold2_pitzer(ivol)=density_pitzer(ivol)
       end if           
    
    end do


!c zero hydraulic heads for passing to subroutines also used for
!c density dependent flow

       hhead(1:nngl) = r0 

       densold(1:nngl) = density(1:nngl)
!       densold1(1:nngl) = density(1:nngl)
!       if (heat_transport.and.ispitzerdens) then
!         densold2(1:nngl)=density_pitzer(1:nngl)
!       else
!         densold2(1:nngl) = density(1:nngl)
!       end if
        
       tds_old(1:nngl) = tds_new(1:nngl)
!       tds_old2(1:nngl) = tds_new(1:nngl)

       sgnew(1:nngl) = r0       

       if (heat_transport.and.ispitzerdens) then
         densold_pitzer(1:nngl)=density_pitzer(1:nngl)
         !densold2_pitzer(1:nngl)=density_pitzer(1:nngl)
       end if 
!c initial viscosity calculated previously in ddtds.for unless
!c viscosity is not updated
   
       if (.not.update_viscosity.and..not.update_viscosity_temp) then        
         viscosity(1:nngl) = visc_h2o
       end if

       if (update_viscosity_temp) then 
        viscoold(1:nngl) = viscosity(1:nngl)
       end if 
       

    hydrostatic_condition = .false.   !hydrostatic condition

    if (flow_verification) then
        do ivol = 1,nngl
          density(ivol) = ref_dens
        end do
    end if           

!c  read section header for initial condition of variably saturated
!c  flow simulation
   
      section_header = 'initial condition - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)
 
!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (found_section) then
        if(rank == 0 .and. b_enable_output) then
          write(*,*) 'initial condition - variably saturated density dependent flow'
          write(*,*) ('-',i=1,72)
          write(*,*)
          write(ilog,'(a)') 'initial condition - variably saturated density dependent flow'
          write(ilog,'(72a/)')('-',i=1,72)
        end if 
      else
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to generic output file  
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  define logical flag to determine if initial condition will be
!c  - read from file (steady state)
!c  - specified in input file

      initcond_file = .false.
#ifdef USG
      initcond_file_vtk = .false.
      initcond_file_hdf5 = .false.
#endif

!c disable reading initial condition when restart is used    
!c      if (.not. restart_sim) then      
        subsection = 'read initial condition from file'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          initcond_file = .true.
        end if

#ifdef USG
        subsection = 'read initial condition from vtk file'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          initcond_file_vtk = .true.
        end if

        subsection = 'read initial condition from hdf5 file'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          initcond_file_hdf5 = .true.
        end if
#endif
!c      end if


!c disable saturation update when zero flow veloicty is specified
      b_disable_sat_updt = .false.
      if (b_use_zero_flow_vel) then
        if (initcond_file) then
          b_disable_sat_updt = .true.
        end if
#ifdef USG
        if (initcond_file_vtk .or. initcond_file_hdf5) then
          b_disable_sat_updt = .true.
        end if
#endif
      end if

!c  read initial condition from file

      if (initcond_file) then
 
!c  open file containing initial condition
!c  *.gsp file format

!c  Initial conditions read from file as fluid pressures

        !icvs  = 13 
        icvs = lun_get()
        open(icvs,file=prefix(:l_prfx)//'.ivs',status='old',  &
     &            form='formatted')

        do i1 = 1,3
          read(icvs,*,err=998,end=998) cdummy       !skip header
        end do

!c  for fully saturated density-dependent flow
!c  uvs(:) contains fluid pressures

        if (fully_saturated) then
#ifdef USG
          if (discretization_type > 0) then
            do ivolgbl = 1,nngbl
#ifdef PETSC
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
              else
                ivol = node_idx_g2lg(ivolgbl)
              end if
#else
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2g_invord(ivolgbl)
              else
                ivol = ivolgbl
              end if
#endif
              if (ivol > 0) then
                read(icvs,*,err=998,end=998) rdummy,rdummy,rdummy,     &
                                             rdummy, uvsnew(ivol)
                uvsold(ivol) = uvsnew(ivol)
              else
                read(icvs,*,err=998,end=998) rdummy
              end if
            end do
          end if
#endif
          if (discretization_type == 0) then
            nskip = 0
            do ivol = 1,nngl
#ifdef PETSC
              do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                ierrcd = 1
                read(icvs,*,end=999,err=999) rdummy
              end do
              nskip = node_idx_lg2g(ivol)
#endif
              ierrcd = 2
              read(icvs,*,err=998,end=998) rdummy,rdummy,rdummy,       &
                                           rdummy, uvsnew(ivol)
              uvsold(ivol) = uvsnew(ivol)
            end do
          end if

        elseif (variably_saturated) then
#ifdef USG
          if (discretization_type > 0) then
            do ivolgbl = 1,nngbl
#ifdef PETSC
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
              else
                ivol = node_idx_g2lg(ivolgbl)
              end if
#else
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2g_invord(ivolgbl)
              else
                ivol = ivolgbl
              end if
#endif
              if (ivol > 0) then
                read(icvs,*,err=998,end=998) rdummy,rdummy,rdummy,       &
                                             rdummy,uvsnew(ivol),        &
                                             sanew(ivol),theta_a,        &
                                             sgnew(ivol),theta_g

                uvsold(ivol) = uvsnew(ivol)
                saold(ivol) = sanew(ivol)
                sgold(ivol) = sgnew(ivol)
              else
                read(icvs,*,err=998,end=998) rdummy
              end if
            end do
          end if
#endif
          if (discretization_type == 0) then
            nskip = 0
            do ivol = 1,nngl
#ifdef PETSC
              do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                ierrcd = 3
                read(icvs,*,end=999,err=999) rdummy
              end do
              nskip = node_idx_lg2g(ivol)
#endif
              ierrcd = 4
              read(icvs,*,err=998,end=998) rdummy,rdummy,rdummy,        &
                                           rdummy,uvsnew(ivol),         &
                                           sanew(ivol),theta_a,         &
                                           sgnew(ivol),theta_g

              uvsold(ivol) = uvsnew(ivol)
              saold(ivol) = sanew(ivol)
              sgold(ivol) = sgnew(ivol)
            end do
          end if

        end if    

!c  close file

        close(icvs)
        call lun_free(icvs)


!c  initial condition specified in input file
#ifdef USG
      else if (initcond_file_vtk) then

!c  open file containing initial condition
!c  *.gsp file format
        icvs = lun_get()
        if ((read_spatial_master_proc .and. rank == 0) .or.            &
            .not.read_spatial_master_proc) then          
          open(icvs,file=prefix(:l_prfx)//'.ivs.vtk',status='old',     &
               form='formatted')
        else
          call lun_free(icvs)
          icvs = 0
        end if

!c  for fully saturated flow

        if (fully_saturated) then

          call read_vtk_data_from_file(icvs,'p_w',bfound,uvsnew)
          if (bfound) then
            uvsold = uvsnew
            if (rank == 0 .and. b_enable_output) then
              write(*,'(a)') 'read pressure head from vtk file: done'
              write(ilog,'(a)') 'read pressure head from vtk file: done'
            end if
          else
            call read_vtk_data_from_file(icvs,'ph_w',bfound,uvsnew)
            if (bfound) then
              uvsnew = uvsnew*(ref_dens*gacc)
              uvsold = uvsnew
              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read pressure head from vtk file: done'
                write(ilog,'(a)') 'read pressure head from vtk file: done'
              end if
            end if
          end if

!c  for variably saturated flow

        elseif (variably_saturated) then

          call read_vtk_data_from_file(icvs,'p_w',bfound,uvsnew)
          if (bfound) then
            uvsold = uvsnew
          else
            call read_vtk_data_from_file(icvs,'ph_w',bfound,uvsnew)
            if (bfound) then
              uvsnew = uvsnew*(ref_dens*gacc)
              uvsold = uvsnew
            end if
          end if

          call read_vtk_data_from_file(icvs,'s_a',bfound,sanew)
          if (bfound) then
            saold = sanew
          end if

          call read_vtk_data_from_file(icvs,'s_g',bfound,sgnew)
          if (bfound) then
            sgold = sgnew
          end if

        end if

!c  close file
        if (icvs > 0) then
          close(icvs)
          call lun_free(icvs)
        end if
#ifdef PETSC_HDF
      else if (initcond_file_hdf5) then

!c  initialize parallel data mapping if not initialized
        if (.not. b_init_hdf5_lg2g) then
          inquire(file=prefix(:l_prfx)//'.domain.h5',exist=bflag)

          if (bflag) then
            iunit_file = lun_get()
            iunit_hdf5 = int(iunit_file,kind(HID_T))
            call hdf5_usg_read_node_lg2g(iunit_hdf5,                   &
                      prefix(:l_prfx)//'.domain.h5',hdf5_ierr)
            call lun_free(iunit_file)

            if (hdf5_ierr < 0) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in reading domain from hdf5 file'
                write(ilog,*) 'file: ',prefix(:l_prfx)//'.domain.h5'
                close(ilog)
              end if
              call petsc_mpi_finalize
              stop
            else
              if (rank == 0) then
                write(*,'(a)') 'read domain from hdf5 file: done'
                write(ilog,'(a)') 'read domain from hdf5 file: done'
              end if
            end if

            b_init_hdf5_lg2g = .true.
          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading domain from hdf5 file'
              write(ilog,*) 'file is missing: ',prefix(:l_prfx)//'.domain.h5'
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop    
          end if

        end if

        icvs = lun_get()
        icvs_hdf5 = int(icvs,kind(HID_T))
        strfilename=prefix(:l_prfx)//'.ivs.h5'

!c  for fully saturated flow

        if (fully_saturated) then

          call hdf5_usg_read_node_var(icvs_hdf5, trim(strfilename),    &
                    "results", "p_w", uvsnew, bexist, hdf5_ierr)
          if (hdf5_ierr < 0) then
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading p_w from hdf5 file'
              write(ilog,*) 'file: ',trim(strfilename)
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop
          else
            if (rank == 0) then
              write(*,'(a)') 'read p_w from hdf5 file: done'
              write(ilog,'(a)') 'read p_w from hdf5 file: done'
            end if
          end if

          if (bexist) then
            uvsold = uvsnew
          else
            !c check if ph_w exists when p_w cannot be found, e.g., reading  
            !c initial condition obtained from variably saturated flow
            call hdf5_usg_read_node_var(icvs_hdf5, trim(strfilename),    &
                      "results", "ph_w", uvsnew, bexist, hdf5_ierr)
            if (.not. bexist .or. hdf5_ierr < 0) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in reading p_w or ph_w from hdf5 file'
                write(ilog,*) 'file: ',trim(strfilename)
                close(ilog)
              end if
              call petsc_mpi_finalize
              stop
            else
              if (rank == 0) then
                write(*,'(a)') 'read p_w or ph_w from hdf5 file: done'
                write(ilog,'(a)') 'read p_w or ph_w from hdf5 file: done'
              end if
            end if
            uvsnew = uvsnew*ref_dens*gacc
            uvsold = uvsnew
          end if

!c  for variably saturated flow

        elseif (variably_saturated) then

          call hdf5_usg_read_node_var(icvs_hdf5, trim(strfilename),    &
                    "results", "p_w", uvsnew, bexist, hdf5_ierr)
          if (hdf5_ierr < 0) then
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading p_w from hdf5 file'
              write(ilog,*) 'file: ',trim(strfilename)
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop
          else
            if (rank == 0) then
              write(*,'(a)') 'read p_w from hdf5 file: done'
              write(ilog,'(a)') 'read p_w from hdf5 file: done'
            end if
          end if

          if (bexist) then
            uvsold = uvsnew
          else
            !c check if ph_w exists when p_w cannot be found, e.g., reading  
            !c initial condition obtained from variably saturated flow
            call hdf5_usg_read_node_var(icvs_hdf5, trim(strfilename),    &
                      "results", "ph_w", uvsnew, bexist, hdf5_ierr)
            if (.not. bexist .or. hdf5_ierr < 0) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in reading p_w or ph_w from hdf5 file'
                write(ilog,*) 'file: ',trim(strfilename)
                close(ilog)
              end if
              call petsc_mpi_finalize
              stop
            else
              if (rank == 0) then
                write(*,'(a)') 'read p_w or ph_w from hdf5 file: done'
                write(ilog,'(a)') 'read p_w or ph_w from hdf5 file: done'
              end if
            end if
            uvsnew = uvsnew*ref_dens*gacc
            uvsold = uvsnew
          end if

          call hdf5_usg_read_node_var(icvs_hdf5, trim(strfilename),    &
                    "results", "s_a", sanew, bexist, hdf5_ierr)
          if (hdf5_ierr < 0) then
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading s_a from hdf5 file'
              write(ilog,*) 'file: ',trim(strfilename)
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop
          else
            if (rank == 0) then
              write(*,'(a)') 'read s_a from hdf5 file: done'
              write(ilog,'(a)') 'read s_a from hdf5 file: done'
            end if
          end if
          saold = sanew

          call hdf5_usg_read_node_var(icvs_hdf5, trim(strfilename),    &
                    "results", "s_g", sgnew, bexist, hdf5_ierr)
          if (hdf5_ierr < 0) then
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading s_g from hdf5 file'
              write(ilog,*) 'file: ',trim(strfilename)
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop
          else
            if (rank == 0) then
              write(*,'(a)') 'read s_g from hdf5 file: done'
              write(ilog,'(a)') 'read s_g from hdf5 file: done'
            end if
          end if
          sgold = sgnew

        end if

        call lun_free(icvs)
#endif

#endif
!c  initial condition specified in input file

      else

!c  read number of zones for initial condition
 
        rewind(itmp)
        ierrcd = 5
        read(itmp,*,err=999,end=999) niz
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(a,i10)')     &
     &    'number of zones for initial condition           = ',niz
        end if

!c  read name of zone

        property_iflag = 0

        do iiz=1,niz                !loop over number of zones

          subsection = 'number and name of zone'

          call findzone(subsection,itmp,found_subsection,iiz, &
     &                  zone_name)

          if (found_subsection) then

            call readzone(itmp,icnv,ilog,zone_name,found_subsection)

          else

            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone number "',iiz, '" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if

!c  define length of zone name

          l_zone_name = index(zone_name,'  ')-1
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
            l_zone_name = 72
          end if

!c  read initial condition (fluid pressure) for current zone
!c  and convert to fluid pressure

          subsection = 'initial condition'
          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            ierrcd = 6
            read(icnv,'(a)',err=999,end=999) strbuffer
            strbuffer = adjustl(strbuffer)
            if(index(strbuffer,'gradient') == 2) then
#ifdef USG
              if(index(strbuffer,'gradient-top') == 2) then
                itype_grad = 2
              else if(index(strbuffer,'gradient-bottom') == 2) then
                itype_grad = 1
              else
                itype_grad = 0
              end if

              if (.not. b_use_layered_mesh) then
                itype_grad = 0
              end if
#endif
              btypezn = 'gradient'

              if(index(strbuffer,'gradient-radius') == 2) then
                ierrcd = 7
                read(icnv,*,err=999,end=999) dir_grad, rx0, ry0, rz0
                read(icnv,*,err=999,end=999) h0_grad
                read(icnv,*,err=999,end=999) slope_grad  
 
                !c reset dir_grad to 'r' for gradient-radius type
                if (dir_grad /= 'r') then
                  dir_grad = 'r'
                end if
  
              else
                ierrcd = 8
                read(icnv,*,err=999,end=999) dir_grad
                read(icnv,*,err=999,end=999) h0_grad
                read(icnv,*,err=999,end=999) slope_grad
              end if

              if (dir_grad /= 'x' .and. dir_grad /= 'y' .and.          &
                  dir_grad /= 'z' .and. dir_grad /= 'r') then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'Error in gradient direction'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            else
              btypezn = ''
              ierrcd = 9
              read(strbuffer,*,err=999,end=999) pinitial
            end if
          else
            subsection = 'hydrostatic condition'
            call findstrg(subsection,icnv,found_subsection)

            if (found_subsection) then
              hydrostatic_condition = .true.
              ierrcd = 10
              read(icnv,*,err=999,end=999) freshcol
              read(icnv,*,err=999,end=999) tot_tds
              read(icnv,*,err=999,end=999) hydro_top
            else
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'section "',trim(section_header),'"'
                write(ilog,*) 'zone "', trim(zone_name),'"'
                write(ilog,*) 'subsection "',trim(subsection),'" missing'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

          end if

!c_bubbles  read initial gas saturation for current zone
          gassat_initial = .false.

          subsection = 'initial gas saturation'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            gassat_initial = .true.
            ierrcd = 11
            read(icnv,*,err=999,end=999) sginitial

          end if 
          
!c  initial gas blocks in mip_mt model  
          gasblock_initial = .false.
          
          subsection = 'initial gas blocks'
          
          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            gasblock_initial = .true.

          end if          

!c  read coordiantes delineating zone
          type_extent_zone = -1
          type_extent_zone_box = -1

          subsection = 'extent of zone'
          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            type_extent_zone = 0
            ierrcd = 12
            read(icnv,*,err=999,end=999) ximin,ximax,yimin,yimax,   &
                                         zimin,zimax

          end if

#ifdef USG
          call read_zone_usg_input(icnv)
          if (type_extent_zone_box > 0) then
            ierrcd = 13
            read(icnv,*,err=999,end=999) ximin,ximax,yimin,yimax,   &
                                         zimin,zimax
          end if
#endif

          !c check if x dimension is valid
          if (.not.btest(cell_projection,0)) then
            ximin = -1.0d300
            ximax = 1.0d300
          end if
  
          !c check if y dimension is valid
          if (.not.btest(cell_projection,1)) then
            yimin = -1.0d300
            yimax = 1.0d300
          end if
  
          !c check if z dimension is valid
          if (.not.btest(cell_projection,2)) then
            zimin = -1.0d300
            zimax = 1.0d300
          end if

!c  write error information if 'extent of zone' is missing
          if (type_extent_zone < 0) then

            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',trim(section_header),'"'
              write(ilog,*) 'zone "', trim(zone_name),'"'
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if


!c  for hydrostatic condition using pitzer model, build spatial search tree for USG
#ifdef USG
          if (discretization_type > 0 .and. .not. b_use_layered_mesh .and. &
              hydrostatic_condition .and. (ispitzerdens.or.ishydrostatic2)) then
            call usg_mesh_data_search_build
          end if
#endif



!c  increment coordinates delineating zone

          ximin = ximin-tiny
          ximax = ximax+tiny
          yimin = yimin-tiny
          yimax = yimax+tiny
          zimin = zimin-tiny
          zimax = zimax+tiny

!c  assign initial condition to global system
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_initicdd_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, pos_grad)                                    &
    !$omp firstprivate(pinitial)
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl

!c  check limits of boundary zone
!c  temp setup
            if (((type_extent_zone==0.or.type_extent_zone_box>0) .and. &
                (xg(ivol).gt.ximin).and.(xg(ivol).lt.ximax) .and.      &
                (yg(ivol).gt.yimin).and.(yg(ivol).lt.yimax) .and.      &
                (zg(ivol).gt.zimin).and.(zg(ivol).lt.zimax)) .or.      &
                (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
                ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
              if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                if ((btest(type_extent_zone_box,1) .and.               &
                     .not. is_boundary_node(ivol)) .or.                &
                    (btest(type_extent_zone_box,2) .and.               &
                     is_boundary_node(ivol))) then
                  cycle
                end if
              end if
#endif

              property_iflag(ivol) = property_iflag(ivol) + 1

              if (hydrostatic_condition) then

!c  calculate fluid pressure as the sum of the overlying pressure of the column
!c  of freshwater (rho * gacc * length) and the overlying column of dense water
                if (ispitzerdens.or.ishydrostatic2) then
#ifdef USG
                  if (discretization_type > 0 .and. .not. b_use_layered_mesh) then
                    call hydrostatic_pitzerdens_usg(ivol)
                  else
#endif
                    call hydrostatic_pitzerdens(ivol)
#ifdef USG
                  end if
#endif
                else
                    uvsnew(ivol) = gacc * (freshcol * ref_dens       &
                                  + (ref_dens + drho_dc * tot_tds)   &
                                * (hydro_top - zg(ivol)))
                end if
              else

#ifdef USG
                if (btypezn .eq. 'gradient' .and. itype_grad > 0) then
                  if (itype_grad == 1)then
                    select case(dir_grad)
                    case ('x')
                      pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                    case ('y')
                      pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                    case ('z')
                      pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                    end select
                  else if (itype_grad == 2)then
                    select case(dir_grad)
                    case ('x')
                      pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                    case ('y')
                      pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                    case ('z')
                      pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                    end select
                  end if
                  pinitial = h0_grad + slope_grad*pos_grad
                else
#endif
                  if (btypezn.eq.'gradient')then
                    select case(dir_grad)
                    case ('x')
                      pos_grad=xg(ivol)
                    case ('y')
                      pos_grad=yg(ivol)
                    case ('z')
                      pos_grad=zg(ivol)
                    case ('r')
                      pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                      (yg(ivol) - ry0)**2 +  &
                                      (zg(ivol) - rz0)**2)
                    end select
                    pinitial = h0_grad + slope_grad*pos_grad
                  end if
#ifdef USG
                end if
#endif

                if (fluid_pressure) then
                  uvsnew(ivol) = pinitial
                else if (pressure_head) then
                  uvsnew(ivol) = pinitial*gacc*density(ivol)
                else if (fresh_head) then
                  uvsnew(ivol) = (pinitial - zg(ivol)) * &
                                  gacc * ref_dens
                else if (hydraulic_head) then
                  uvsnew(ivol) = (pinitial- zg(ivol)) *  &
                                  gacc * density(ivol)
                end if  !pressure head

              end if !(hydrostatic_condition)

              uvsold(ivol) = uvsnew(ivol)

            end if       !(zg(ivol).gt.zimin).and.(zg(ivol).lt.zimax)
                         !(yg(ivol).gt.yimin).and.(yg(ivol).lt.yimax)
                         !(xg(ivol).gt.ximin).and.(xg(ivol).lt.ximax)

          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif          

!c  reset hydrostatic condition logical variable

        end do              !end loop over zones

!c  check if all initial condition for density dependent flow have been set
        if (b_enable_output .and. rank == 0) then
          write(igen,'(2a)') "check control volume: ",                 &
                "initial condition - variably saturated flow"
        end if

        nerrs = 0
        nwarns = 0
        do ivol = 1, nngl
          if (property_iflag(ivol) == 0) then
            nerrs = nerrs + 1
          else if (property_iflag(ivol) > 1) then
            nwarns = nwarns + 1
          end if
        end do

#ifdef PETSC
        call MPI_Allreduce(nerrs,nerrs_gbl,1,MPI_INTEGER4,MPI_SUM,     &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nerrs = nerrs_gbl

        call MPI_Allreduce(nwarns,nwarns_gbl,1,MPI_INTEGER4,MPI_SUM,   &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nwarns = nwarns_gbl       
#endif     

        if (nerrs > 0) then
          if (b_enable_output .and. rank == 0) then
            write(igen,'(a,1x,i8,1x,a)')                               &
                  "Error: initial condition is not set for ",nerrs,    &
                  "control volumes"
          end if
        end if

        if (nwarns > 0) then
          if (b_enable_output .and. rank == 0) then
            write(igen,'(a,1x,i8,1x,a)')                               &
                  "Warning: initial condition is duplicate for",nwarns,&
                  "control volumes"
          end if
        end if

!cdsu the parallel version need to pass pressure to the deep layer
#ifdef PETSC
        if (hydrostatic_condition.and.(ispitzerdens.or.ishydrostatic2)) then
          nlayerz = dmda_flow%npz
          nlayerxy = dmda_flow%npx*dmda_flow%npy

          if (nlayerz > 1) then
            nvxys = dmda_flow%gxl * dmda_flow%gyl

            allocate(uvs_lower(nvxys), stat = ierr)
            uvs_lower = 0.0d0
            call checkerr(ierr,'uvs_lower',ilog)
            call memory_monitor(sizeof(uvs_lower),'uvs_lower',.true.)


            allocate(uvs_delta(nvxys), stat = ierr)
            uvs_delta = 0.0d0
            call checkerr(ierr,'uvs_delta',ilog)
            call memory_monitor(sizeof(uvs_delta),'uvs_delta',.true.)

            do ilayer = nlayerz, 2, -1
              !c step one, set the source layer (up layer)
              if (rank >= (ilayer-1)*nlayerxy .and. rank < ilayer*nlayerxy) then
                ivxystart = stencil_width*nvxys+1
                ivxyend = (stencil_width+1)*nvxys
                uvs_lower(1:nvxys) = uvsnew(ivxystart:ivxyend)
              end if

              mpitag = ilayer
              mpisrc = rank
              mpidest = rank - nlayerxy

              if (rank >= (ilayer-1)*nlayerxy .and. rank < ilayer*nlayerxy) then
                call MPI_Send(uvs_lower,nvxys,MPI_REAL8,rank-nlayerxy, &
                              mpitag,Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
              else if(rank >= (ilayer-2)*nlayerxy .and. rank < (ilayer-1)*nlayerxy) then
                call MPI_RECV(uvs_lower,nvxys,MPI_REAL8,rank+nlayerxy, &
                              mpitag,Petsc_Comm_World,mpistatus,ierrcode)
                CHKERRQ(ierrcode)
              end if

              if(rank >= (ilayer-2)*nlayerxy .and. rank < (ilayer-1)*nlayerxy) then
                ivxystart = nngl-nvxys+1
                ivxyend = nngl
                uvs_delta(1:nvxys) = uvs_lower(1:nvxys)-uvsnew(ivxystart:ivxyend)

                do iiz = 1, nvzgl
                  istart = (iiz-1)*nvxys+1
                  iend = iiz*nvxys

                  uvsnew(istart:iend) = uvsnew(istart:iend) + uvs_delta(1:nvxys)
                end do

              end if

              call petsc_mpi_barrier

            end do

            call memory_monitor(-sizeof(uvs_lower),'uvs_lower',.true.)
            call memory_monitor(-sizeof(uvs_delta),'uvs_delta',.true.)
            deallocate(uvs_lower)
            deallocate(uvs_delta)

          end if
        end if

        uvsold = uvsnew
#endif

!cdsu bug fix, move this line out of zone loop
        hydrostatic_condition = .false.   !hydrostatic condition

      end if                !initcond_file

#ifdef PETSC
      call petsc_mpi_barrier
     
      call MPI_Allreduce(b_mpi_process_flag, b_mpi_process_flag_gbl,1, &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      b_mpi_process_flag = b_mpi_process_flag_gbl
#endif

      if(b_mpi_process_flag) then
          if(rank == 0) then
            write(*,*) "stop in initicdd: ", b_mpi_process_flag
            write(ilog,*) "stop in initicdd: ", b_mpi_process_flag
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
      end if

!c  write output info to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/3a)') 'for detailed output see file ',    &
     &                       prefix(:l_prfx)//'_0.gsp'
      end if

      goto 1000

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading initial condition for variably ',  &
     &                'saturated flow'
        write(ilog,*) 'file "',prefix(:l_prfx),'.ivs"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
