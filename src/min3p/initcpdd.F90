!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 878 $
!> $Author: dsu $
!> $Date: 2024-02-14 20:08:49 -0800 (Wed, 14 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcpdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpdd
!c -------------------
!c
!c control parameters for density dependent flow
!c
!c written by:      Tom Henderson - August 21, 2002
!c
!c last modified:   Tom Henderson - September 3, 2003
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           deltol_vs          = solver update tolerance             * +
!c           dinc_vs            = increment for numerical             * +
!c                                differentiation
!c           perm_fac(nngl)       = scaling factor for permeability   * +
!c                                as a function of porosity changes 
!c           restol_vs          = solver residual tolerance           * +
!c           srelfac_vs         = user specified underrelaxation      * +
!c                                factor
!c           sw_star            = anticipated change in saturation    * +
!c                                per time step
!c           tol_vs             = convergence tolerance               * +
!c                                (variably saturated flow)
!c           uvslim             = max. allowed update                 * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           idetail_vs         = solver information level            * +
!c           level_vs           = incomplete factorization level      * +
!c           maxit_vs           = max. number of newton iterations    * +
!c                                (variably saturated flow)
!c           msolvit_vs         = max. number of solver iterations    * +
!c           nngl               = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   * +
!c                                           factor
!c           hydraulic_head     = .true.  -> initial condition in     * +
!c                                           terms of hydraulic head
!c           mass_balance_vs    = .true.  -> compute mass balance     * +
!c                                           (variably_saturated
!c                                            flow)
!c           pressure_head      = .true.  -> initial condition in     * +
!c                                           terms of pressure head
!c           rcm_ordering_vs    = .true.  -> rcm ordering for         * +
!c                                           1d scalar matrix
!c           under_relax        = .true.  -> underrelaxation          * +
!c           upstream           = .true.  -> upstream weighting       * +
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c dens.f:
!c           real*8:
!c           -------
!c           courant_target     = target courant number               * +
!c           drho_dc            = density-TDS constant drho / dTDS    * +
!c
!c
!c           integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         + -
!c           inpl               = counter for napl components         * +
!c           iter_target        = target number of Picard iterations  + -
!c           maxit_sia          = maximum number of Picard iterations * +
!c           ndd                = number of components used for       * +  
!c                                fluid density calculation
!c           nnpl               = total number of napl components     * +
!c  
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density         * + 
!c                                           dependent flow
!c           fluid_pressure     = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c           fresh_head         = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of freshwater head 
!c           init_perm          = .true. -> initial media             * +
!c                                           properties in 
!c                                           permeability units
!c           init_cond          = .true. -> initial media             * +
!c                                           properties in hydraulic 
!c                                           conductivity units
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c local:    
!c           real*8:
!c           -------
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures       * +   
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpdd
 
      use parm
      use gen
      use dens
      use chem
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, i1, ic, inpl, ierr, im, ivol, l_string, ierrcd,    &
                 itemp, ntemp

      real*8 :: rdeltemp, rtemp, relcond
      real*8, external :: relcond_freezing

      external findstrg, readbloc, zero_r8_parallel

      external checkerr

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rkelvin=273.15d0

      logical found_section, found_subsection
      character*72 :: subsection
 
!c  define or read control parameters for density dependent flow
!c  and write to temporary file

      ierrcd = 0
   
      section_header = 'control parameters - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (.not. found_section) then
        !c the following keyword was modified in FG's code, not recomment to use.
        section_header = 'control parameters - water flow'
        call readbloc (idat,itmp,section_header,found_section,.true.)
      end if

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if


!c  general control parameters

      tol_vs = 1.0d-6
      rtol_relbalance_vs = 1.0d100
      rtol_absbalance_vs = 1.0d100
      relbalance_vs = 0.0d0
      absbalance_vs = 0.0d0
      mass_balance_vs = .true.
      specify_dd_comp = .false.
      b_check_div_heat = .false.
      napl_kfunction = 'none'

!c  sequential iterative cupling parameters
!c default constant relating changes in density to changes
!c in concentration: drho_dc = drho / dTDS 

      drho_dc = 0.688   !SOLMINEQ.88 [drho_dc = 0.7143 in SEAWAT]
      maxit_sia = 10
      tol_sia = 0.1
      iter_target = 4
      courant_target = 1.0

!c  toggle for flow verification problems assuming constant density
!c  fluids.  If .true. -> flow only solution using pressure formulation

      flow_verification = .false.

!c update viscosity using polynomial in subroutine ddtds

      update_viscosity = .false.

!c  control parameters for density dependent flow
!c  default input units = fluid pressure and intrinsic permeability

      fluid_pressure = .true.
      init_perm = .true.

!c  alternate input units for fluid and media properties

      pressure_head = .false.
      fresh_head = .false.
      init_cond = .false.
      hydraulic_head = .false.

!c  hydraulic conductivity or permeability tensor
      type_cond_perm = 1

!c  default reference density for converting freshwater head
!c  initial and boundary conditions to fluid pressures

      ref_dens = 1.0d+3

!c  hardwire upstream weighting for density dependent flow
      upstream = .true.

!c  Picard iteration for seepage boundary
      maxit_seepage = 15

!c  Newton iteration
!c  increase by a factor of 10,000 for pressure formulation
!c  1 m head = 9,806.65 Pa freshwater
      dinc_vs = 1.0d+0 
      maxit_vs = 15 
      sw_star = 0.1

!c  extimated fractorization coefficient for linear solver
      coeff_fac_conn_vs = 4

!c  underrelaxation

      !c DSU, 2019-11-26
      !c update from variably_saturated to varsat_flow, 
      !c to allow underrelaxation for both saturated and unsaturated flow
      if (varsat_flow) then
        under_relax = .false.
        comp_relax = .false.
        under_relax_range_vs = .false.
      end if

!c  solver settings

      level_vs = 0
      msolvit_vs = 100
      idetail_vs = 1
      restol_vs = 0.1d0 * tol_vs
      deltol_vs = 0.1d0 * tol_vs

      iter_vs_ant = 0

      if(i_solver_type_flow == 0) then
        rcm_ordering_vs = .true.
        metis_ordering_vs = .true.
      else
        rcm_ordering_vs = .false.
        metis_ordering_vs = .false.
      end if

!c  initialize scaling factor for permeability update
 
      do ivol = 1,nngl
        perm_fac(ivol) = r1
      end do

      if (found_section) then

!c flow verification setting

        subsection = 'flow verification'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          flow_verification = .true.
        end if

!c  mass balance settings - new definition

        subsection = 'mass balance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
        else
          mass_balance_vs = .false.
        end if

        subsection = 'relative mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          ierrcd = 1
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
        end if

        subsection = 'absolute mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          ierrcd = 2
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if


        subsection = 'mass balance convergence tolerance settings'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          ierrcd = 3
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if


!c  mass balance settings - old definition

        subsection = 'mass balance settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 4
          read(itmp,*,err=999,end=999) mass_balance_vs
        end if
        
!cprovi----------------------------------------------------        
!cprovi Upstream factor for flow  
!cprovi----------------------------------------------------
        subsection = 'upstream factor for flow equation'
        !cprovi--------------------------------------------
        !cprovi Assign default reference mass fraction
        !cprovi--------------------------------------------
        ups_flow=r1 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 5
          read(itmp,*,err=999,end=999) ups_flow
          if (ups_flow>r1.or.ups_flow<r0) ups_flow=r1         
        end if  


!cdsu user specified fixed flow velocity, unit m/day
        subsection = 'fixed flow velocity'
        b_use_fixed_flow_vel = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_use_fixed_flow_vel = .true.
          ierrcd = 6
          read(itmp,*,err=999,end=999) fixed_flow_vel%x,               &
               fixed_flow_vel%y,fixed_flow_vel%z
        end if

        subsection = 'zero flow velocity'
        b_use_zero_flow_vel = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_use_zero_flow_vel = .true.
          b_use_fixed_flow_vel = .true.
          fixed_flow_vel%x = r0
          fixed_flow_vel%y = r0
          fixed_flow_vel%z = r0
        end if

#ifdef USG
        subsection = 'two-point upstream weighting'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_mpfa_upstream = .false.
        else
          b_mpfa_upstream = .true.
        end if

        subsection = 'use full hydraulic conductivity tensor'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          type_cond_perm = 2
        end if

        subsection = 'use full permeability tensor'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          type_cond_perm = 2
        end if
#endif

!cprovi split changes in densities in components
!cprovi mixing and chemical components

        subsection = 'split density changes'
        issplitdens=.false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          issplitdens=.true.          
        end if       

!cprovi Integration in hydrostatic condition 

        subsection = 'vertical integration in hydrostatic condition'
        ishydrostatic2=.false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ishydrostatic2=.true.
        end if         
!c napl identification for relative permeability calculation for
!c aqueous phase in the presence of residual (non-mobile) napl phase
!c van genuchten and corey wetting phase relative permeability options

        subsection = 'update napl permeability'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          napl_permeability = .true.
          ierrcd = 7
          read(itmp,*,err=999,end=999) napl_kfunction
          if (napl_kfunction.eq.'van genuchten') then
            napl_kfunction = 'vangenuchten'
          end if
          if (napl_kfunction.ne.'corey'.and.          &
     &        napl_kfunction.ne.'vangenuchten') then
            if (rank == 0) then  
              write(ilog,'(a)')                         &
     &        'error reading subsection "napl relative k function"'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
          ierrcd = 8
          read(itmp,*,err=999,end=999) nnpl

!c  allocate memory for one-dimensional arrays of size nm and
!c  related arrays

          allocate (namenpl(nnpl), stat = ierr)
          namenpl=''
          call checkerr(ierr,'namenpl',ilog)
          call memory_monitor(sizeof(namenpl),'namenpl',.true.)

          allocate (ianpl(nnpl), stat = ierr)
          ianpl=0 
          call checkerr(ierr,'ianpl',ilog)
          call memory_monitor(sizeof(ianpl),'ianpl',.true.)

          allocate (l_namenpl(nnpl), stat = ierr)
          l_namenpl=0 
          call checkerr(ierr,'l_namenpl',ilog)
          call memory_monitor(sizeof(l_namenpl),'l_namenpl',.true.)

!c  read napl names
 
          ierrcd = 9
          do inpl = 1,nnpl
            read(itmp,*,err=999,end=999) namenpl(inpl)
          end do

!c  define length of napl names

          do inpl = 1,nnpl
            l_namenpl(inpl) = index(namenpl(inpl),' ')-1
            if (l_namenpl(inpl).eq.-1.or.l_namenpl(inpl).gt.72) then
              l_namenpl(inpl) = 72
            end if
          end do

!c  define pointer arrays locating napl phases in mineral list

          i1 = 0
          im = 1
          do inpl = 1,nnpl
          napl_match = .false.
          do while ((im .le. nm) .and. (.not.napl_match))

            if (namenpl(inpl).eq.namem(im)) then
              i1 = i1 + 1
              ianpl(i1) = im
                napl_match = .true.
              im = 0
            end if
          im = im + 1
          end do

!c error message if napl component not located in mineral list

          if ((im .gt. nm) .and. (.not.napl_match)) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,'(72a)')('-',i=1,72)
              write(ilog,'(a)')'cannot find NAPL components in minerals'
              if (b_enable_output_gen) then
                write(igen,'(72a)')('-',i=1,72)
                write(igen,'(a)')'cannot find NAPL components in minerals'
              end if
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

          end do        !inpl = 1,nnpl   

        end if !found_subsection

!c density-dependent flow and picard iteration parameters

        subsection = 'variable density parameters'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 10
          read(itmp,*,err=999,end=999) ref_dens
          read(itmp,*,err=999,end=999) drho_dc
          read(itmp,*,err=999,end=999) maxit_sia
          read(itmp,*,err=999,end=999) iter_target
          read(itmp,*,err=999,end=999) tol_sia
          read(itmp,*,err=999,end=999) courant_target
        end if

        subsection = 'specific density change over temperature'
        !c note this parameter will be overwritten when heat transport is used.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 11
          read(itmp,*,err=999,end=999) drho_dt
        else
          drho_dt = r0
        end if

        subsection = 'use old storage derivative'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          new_stor_deri = .false.
        else
          new_stor_deri = .true.
        end if

        subsection = 'decouple porosity pressure change'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          coupled_porpress = .false.
        else
          coupled_porpress = .true.
        end if

        subsection = 'allow maximum density update at first timestep'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          allow_sia_max_t1 = .true.
        else
          allow_sia_max_t1 = .false.
        end if

        !cdsu to be further checked
        !cdsu coupled density-temperature in storage term calculation (stordd) 
        !cdsu causes convergence problem, disable this term at this moment
        coupled_drhodt = .false.
        !subsection = 'decouple density temperature change'
        !call findstrg(subsection,itmp,found_subsection)
        !if (found_subsection) then
        !  coupled_drhodt = .false.
        !else
        !  coupled_drhodt = .true.
        !end if

        !c porosity and pressure is decoupled in ice sheet model
        if (compute_ice_sheet_loading) then
          coupled_porpress = .false.
        end if

        subsection = 'average density in z'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          av_dens_z = .true.
        else
          av_dens_z = .false.
        end if

        subsection = 'update viscosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          update_viscosity = .true.
        end if 

        subsection = 'variable density components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          specify_dd_comp = .true.
          ierrcd = 12
          read(itmp,*,err=999,end=999) ndd

!c allocate memory for arrays for density calculatation componenets

          allocate (namedd(ndd), stat = ierr)
          namedd='' 
          call checkerr(ierr,'namedd',ilog)
          call memory_monitor(sizeof(namedd),'namedd',.true.)

          allocate (gfwdd(nc), stat = ierr)
          gfwdd=0.0d0
          call checkerr(ierr,'gfwdd',ilog)
          call memory_monitor(sizeof(gfwdd),'gfwdd',.true.)

          ierrcd = 13
          do ic = 1,ndd
            read(itmp,*,err=999,end=999) namedd(ic)
          end do

!c create gram formula weight vector with gram formula weights for
!c components identified for density calculation.  Gram formula weights
!c for remaining componenets set to 0.0d0

          call zero_r8_parallel(gfwdd,nc,1,1)

          do ic = 1,nc-1
            do i1 = 1,ndd
              if (namec(ic) .eq. namedd(i1)) then
                gfwdd(ic) = gfwc(ic)
                goto 101
              end if
              end do
101           continue
          end do               

        end if  !found_subsection

!c allocate memory for sequential iteration results vectors

        allocate (sia_dens(maxit_sia), stat = ierr)
        sia_dens=r0
        call checkerr(ierr,'sia_dens',ilog)
        call memory_monitor(sizeof(sia_dens),'sia_dens',.true.)
        
        allocate (sia_maxvol(maxit_sia), stat = ierr)
        sia_maxvol=0
        call checkerr(ierr,'sia_maxvol',ilog)
        call memory_monitor(sizeof(sia_maxvol),'sia_maxvol',.true.)
        
        allocate (sia_nexvol(maxit_sia), stat = ierr)
        sia_nexvol=0 
        call checkerr(ierr,'sia_nexvol',ilog)
        call memory_monitor(sizeof(sia_nexvol),'sia_nexvol',.true.)

!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
        subsection = 'density model'
        ispitzerdens=.false. 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection) then
          ierrcd = 14
          read(itmp,*,err=999,end=999) subsection
          
          if (subsection=='pitzer'.and.ispitzer) then
             ispitzerdens=.true. 
             if (heat_transport) then
                allocate (density_pitzer(nngl), stat = ierr)
                density_pitzer=r0 
                call checkerr(ierr,'density_pitzer',ilog)
                call memory_monitor(sizeof(density_pitzer),'density_pitzer',.true.)
                
                allocate (densold_pitzer(nngl), stat = ierr)
                densold_pitzer=r0 
                call checkerr(ierr,'densold_pitzer',ilog)
                call memory_monitor(sizeof(densold_pitzer),'densold_pitzer',.true.)

                allocate (densold2_pitzer(nngl), stat = ierr)
                densold2_pitzer=r0 
                call checkerr(ierr,'densold2_pitzer',ilog)
                call memory_monitor(sizeof(densold2_pitzer),'densold2_pitzer',.true.)
             end if
          end if 
          
        end if 
!cprovi----------------------------------------------------
!cprovi Update porosity for flow processes
!cprovi----------------------------------------------------

        subsection = 'update porosity'
        update_porosity_flow=.false. 
        facpormin=1.0d-10
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 15
          read(itmp,*,err=999,end=999) facpormin 
          update_porosity_flow=.true.
        end if 
!cprovi----------------------------------------------------
!cprovi Read reference viscosity 
!cprovi----------------------------------------------------
        subsection = 'reference viscosity'
        ref_visco=1.0d-3 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection) then
          ierrcd = 16
          read(itmp,*,err=999,end=999) ref_visco          
        end if                   
!cprovi----------------------------------------------------
!cprovi Update the permeability for flow processes
!cprovi----------------------------------------------------
        subsection = 'update permeability'
        update_permeability_flow=.false. 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection.and.update_porosity_flow) then             
           
           update_permeability_flow=.true. 
      
        end if 
!cprovi----------------------------------------------------
!cprovi Update porosity for flow processes
!cprovi----------------------------------------------------

        !subsection = 'iterative solver'
        !iterative_solver_flow=.false. 
        !call findstrg(subsection,itmp,found_subsection)
        !if (found_subsection) then
        !   iterative_solver_flow=.true.
        !end if


!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!c  input units for  media permeability
!c  density dependent flow
!c  default units - permeability
        subsection = 'input units for media permeability'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 17
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'permeability') then
            init_perm = .true.
          elseif (subsection.eq.'hydraulic conductivity') then
            init_cond = .true.
            init_perm = .false.
          else
            ierrcd = 18
            goto 999
          end if
        end if

!c  input units for boundary and initial conditions
!c  density dependent flow
!c  default units - fluid pressure

        subsection = 'input units for boundary and initial conditions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 19
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'pressure') then
            fluid_pressure = .true.
          
          elseif (subsection.eq.'pressure head') then
            pressure_head = .true.
            fluid_pressure = .false.
          
          elseif (subsection.eq.'freshwater head') then
            fresh_head = .true.
            fluid_pressure = .false.

          elseif (subsection.eq.'hydraulic head') then
            hydraulic_head = .true.
            fluid_pressure = .false.
          else
            ierrcd = 20
            goto 999
          end if
        end if

        
        subsection = 'input units for newton increment and tolerance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 21
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'pressure') then
            increment_tol_head = .false.          
          elseif (subsection.eq.'pressure head' .or. &
                  subsection.eq.'freshwater head' .or. &
                  subsection.eq.'hydraulic head') then
            increment_tol_head = .true.
          else
            ierrcd = 22
            goto 999
          end if
        else
          increment_tol_head = .false.
        end if
        
        !c DSU, 2019-11-26
        !c update from variably_saturated to varsat_flow, 
        !c to allow underrelaxation for both saturated and unsaturated flow
        if (varsat_flow) then

          subsection = 'user specified underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            ierrcd = 23
            read(itmp,*,err=999,end=999) srelfac_vs
          end if

          if (under_relax) then
            srelrange_vs_min = -1.0d100
            srelrange_vs_max = 1.0d100
            subsection = 'user specified underrelaxation range'
            call findstrg(subsection,itmp,found_subsection)  
            if (found_subsection) then
              under_relax_range_vs = .true.
              ierrcd = 24
              read(itmp,*,err=999,end=999) srelrange_vs_min,srelrange_vs_max
            end if
          end if

!c  compute underrelaxation factor

          subsection = 'compute underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            comp_relax = .true.
            ierrcd = 25
            read(itmp,*,err=999,end=999) uvslim
          end if

        end if              !(variably saturated) moved above Newton iteration 
!c                             settings July 14, 2003
!cdsu  water freezing parameters
        subsection = 'water freezing temperature'
        water_freezing_tempkel = rkelvin
        b_water_freezing = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_water_freezing = .true.
          ierrcd = 26
          read(itmp,*,err=999,end=999) water_freezing_tempkel
          water_freezing_tempkel = water_freezing_tempkel + rkelvin
        end if

!cdsu compute pressure melting point or use specified water freezing temperature as the default ice melting point
        b_pressure_melting = .false.
        subsection = 'compute pressure melting point'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_pressure_melting = .true.
          b_water_freezing = .true.
        end if
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(a,l1)')                                         &
                'compute pressure melting poing                  = ',  &
                b_pressure_melting
        end if   

        b_water_freezing_cond = .false.
        b_water_freezing_curve = .false.
        b_water_freezing_func = .false.
        b_water_freezing_pts = .false.        
        water_freezing_cond = 0.0d0
        if (b_water_freezing) then
          subsection = 'water freezing conductivity'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 27
            read(itmp,*,err=999,end=999) water_freezing_cond
            water_freezing_cond = water_freezing_cond*sec_per_days
            if (water_freezing_cond < 0.0d0) then
              water_freezing_cond = 0.0d0
            end if
            b_water_freezing_cond = .true.
          else
            subsection = 'water freezing relative conductivity curve'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              b_water_freezing_curve = .true.
              call findstrg(subsection,itmp,found_subsection)
              ierrcd = 28
              read(itmp,*,err=999,end=999)                             &
                   water_freezing_curve_a,                             &
                   water_freezing_curve_b,                             &
                   water_freezing_curve_c,                             &
                   water_freezing_curve_d
              read(itmp,*,err=999,end=999)                             &
                   water_freezing_curve_tempmin,                       &
                   water_freezing_curve_tempmax,                       &
                   water_freezing_relcond_min,                         &
                   water_freezing_relcond_max
            end if

            subsection = 'water freezing relative conductivity function'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              b_water_freezing_curve = .true.
              b_water_freezing_func = .true.
              call findstrg(subsection,itmp,found_subsection)
              ierrcd = 29
              read(itmp,*,err=999,end=999)                             &
                   water_freezing_curve_tempmin,                       &
                   water_freezing_curve_tempmax,                       &
                   water_freezing_relcond_min,                         &
                   water_freezing_relcond_max
            end if

            subsection = 'water freezing relative conductivity points'
            call findstrg(subsection,itmp,found_subsection)
            if (found_subsection) then
              b_water_freezing_curve = .true.
              b_water_freezing_pts = .true.
              ierrcd = 30
              read(itmp,*,err=999,end=999) ntemp

              allocate(water_freezing_pts(ntemp,2), stat = ierr)
              water_freezing_pts=0 
              call checkerr(ierr,'water_freezing_pts',ilog)
              call memory_monitor(sizeof(water_freezing_pts),'water_freezing_pts',.true.)

              ierrcd = 31
              do itemp = 1, ntemp
                read(itmp,*,err=999,end=999) water_freezing_pts(itemp,1:2)
              end do
            end if
          end if
        end if

        b_freezing_adjacent_bd = .false.
        subsection = 'disable freezing boundary connection'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_freezing_adjacent_bd = .true.
        end if

        b_freezing_no_pond = .false.
        subsection = 'apply pressure head tolerance of ponding boundary'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_freezing_no_pond = .true.
        end if

!c  check divergence for newton iteration
        subsection = 'enable divergence check'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_check_div_vs = .true.
        end if

!cdsu Run steady state flow in transient mode.
!cdsu For some steady state flow, because of transient effect, the simulation
!cdsu may encounter convergence problem if using steady state flow directly.
!cdsu In this case, transient flow can be used until flow reaches steady state condition.
!cdsu To use this feature, please set flow to transient flow and add the following keywords
      tran_steady_flow = .false.
      tran_steady_flow_converged = .false.
      tran_steady_drho_0 = .false.
      tran_steady_stop = .false.
      tran_steady_exit_time = 1.0d300
      rtol_tran_steady_flow = 1.0d-6
      atol_tran_steady_flow = 1.0d-6
      if (.not. steady_flow) then
        subsection = 'run steady state flow in transient mode'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          tran_steady_flow = .true.
        end if

        if (tran_steady_flow) then
          subsection = 'tolerance for steady state'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 32
            read(itmp,*,err=999,end=999) rtol_tran_steady_flow
            read(itmp,*,err=999,end=999) atol_tran_steady_flow
          end if

          subsection = 'disable density change in transient mode'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            tran_steady_drho_0 = .true.
          end if

          subsection = 'maximum time of transient steady state'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 33
            read(itmp,*,err=999,end=999) tran_steady_exit_time
            tran_steady_exit_time = tran_steady_exit_time*time_factor
          end if  

          subsection = 'stop after transient steady state'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            tran_steady_stop = .true.
          end if

        end if
      end if

!c  picard iteration settings for seepage face boundary conditions
      subsection = 'maximum number of seepage face iterations'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 34
        read(itmp,*,err=999,end=999) maxit_seepage
      end if

!cdsu  newton iteration settings with aniticipated iteration number
      subsection = 'newton iteration settings plus'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 35
        read(itmp,*,err=999,end=999) dinc_vs
        read(itmp,*,err=999,end=999) iter_vs_ant
        read(itmp,*,err=999,end=999) maxit_vs
        read(itmp,*,err=999,end=999) tol_vs 
        read(itmp,*,err=999,end=999) sw_star

        !c convert input units from freshwater head (m) to pressure (Pa)
        if (increment_tol_head) then
          dinc_vs = dinc_vs*ref_dens*gacc
          tol_vs = tol_vs*ref_dens*gacc
        end if
      end if 

      subsection = 'anticipated number of newton iterations'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ierrcd = 36
        read(itmp,*,err=999,end=999) iter_vs_ant
      end if

!c  newton iteration settings
!c  these parameters read for both fully and variably saturated simulations
!c  THH change - July 14, 2003

        subsection = 'newton iteration settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 37
          read(itmp,*,err=999,end=999) dinc_vs
          read(itmp,*,err=999,end=999) maxit_vs
          read(itmp,*,err=999,end=999) tol_vs 
          read(itmp,*,err=999,end=999) sw_star

          !c convert input units from freshwater head (m) to pressure (Pa)
          if (increment_tol_head) then
            dinc_vs = dinc_vs*ref_dens*gacc
            tol_vs = tol_vs*ref_dens*gacc
          end if
        end if

!c  coefficient of estimated number of factored connections, default value is 3 before

        subsection = 'coefficient of factored connections'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 38
          read(itmp,*,err=999,end=999) coeff_fac_conn_vs 
        end if

!c  solver settings

        subsection = 'solver settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 39
          read(itmp,*,err=999,end=999) level_vs 
          read(itmp,*,err=999,end=999) msolvit_vs
          read(itmp,*,err=999,end=999) idetail_vs
          read(itmp,*,err=999,end=999) restol_vs
          read(itmp,*,err=999,end=999) deltol_vs

          read(itmp,*,err=998,end=998) rcm_ordering_vs      !old

        end if

 998    subsection = 'natural ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .false.
        end if
        
        subsection = 'rcm ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .true.
        end if

#ifdef METIS
        subsection = 'metis ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          metis_ordering_vs = .true.
          rcm_ordering_vs = .false.
        else
          metis_ordering_vs = .false.
        end if
#endif

      end if                 !(found_section)

!c  assign related control parameters

!c      if (.not.pressure_head) then
!c         hydraulic_head = .true.
!c      end if

!c  write control parameters for reactive transport
!c  to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
          
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

      if (fluid_pressure) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'fluid pressure'

      elseif (pressure_head) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'pressure head'

      elseif (fresh_head) then
        write(igen,'(2a)')                                        &   
     &  'input of boundary and initial conditions in terms of ',  &
     &  'freshwater head'
      end if

      write(igen,'(a)')                                           &
     &  'upstream weighting of relative permeabilities, ',        &
     &  'fluid viscosity, and density'   
      
    !c DSU, 2019-11-26
    !c update from variably_saturated to varsat_flow, 
    !c to allow underrelaxation for both saturated and unsaturated flow
    if (varsat_flow) then
        if (under_relax) then
          if (comp_relax) then
            write(igen,'(a)')                                     &
     &      'computation of underrelaxation factor                '
            write(igen,'(a,1pe15.6e3)')                           &
     &      'max. allowed update                             = ', &
     &       uvslim 
          else
            write(igen,'(a,1pe15.6e3)')                           &
     &      'user specified underrelaxation factor           = ', &
     &       srelfac_vs
          end if
        end if
   
        write(igen,'(a,1pe15.6e3)')                               &
     &  'increment for numerical differentiation         = ',     &
     &   dinc_vs
        write(igen,'(a,i10)')                                     &
     &  'max. number of newton iterations                = ',     &
     &   maxit_vs
        write(igen,'(a,1pe15.6e3)')                               &
     &  'convergence tolerance                           = ',     &
     &   tol_vs
        write(igen,'(a,1pe15.6e3)')                               &
     &  'anticipated change in saturation per time step  = ',     &
     &   sw_star
      end if
      write(igen,'(a,i10)')                                       &
     &'incomplete factorization level                  = ',       &
     & level_vs
      write(igen,'(a,i10)')                                       &
     &'max. number of solver iterations                = ',       &
     & msolvit_vs
      write(igen,'(a,i10)')                                       &
     &'solver information level                        = ',       &
     & idetail_vs
      write(igen,'(a,1pe15.6e3)')                                 &
     &'solver residual tolerance                       = ',       &
     & restol_vs
      write(igen,'(a,1pe15.6e3)')                                 &
     &'solver update tolerance                         = ',       &
     & deltol_vs
      if (rcm_ordering_vs) then
        write(igen,'(a)')'reverse Cuthill McKee ordering'
#ifdef METIS
      else if (metis_ordering_vs) then
        write(igen,'(a)')'metis fill-reducing ordering'
#endif
      else
        write(igen,'(a)')'natural ordering'
      end if

      if (b_water_freezing_cond) then
        write(igen,'(/a,1x,1pe15.6e3,1x,a)')                      &
             'water freezing conductivity ',                      &
             water_freezing_cond,'m/day'
      else if (b_water_freezing_curve) then

        write(igen,'(/a)') 'water freezing conductivity curve'
        write(igen,'(72a)')('-',i=1,72)
        write(igen,'(a,10x,a)') 'temperature °C','relative conductivity'

        if (.not. b_water_freezing_pts) then
          rtemp = water_freezing_curve_tempmin
          relcond = water_freezing_relcond_min
          write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond

          rdeltemp = (water_freezing_curve_tempmax -                   &
                      water_freezing_curve_tempmin)/20.0
          do i = 1, 19
            rtemp = water_freezing_curve_tempmin+rdeltemp*i
            relcond = relcond_freezing(rtemp,r0)
            write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond
          end do

          rtemp = water_freezing_curve_tempmax
          relcond = water_freezing_relcond_max
          write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond
        else
          if (ntemp == 1) then
            write(igen,'(1pe15.6e3,6x,1pe15.6e3)') water_freezing_pts(1,1:2)
          else if (ntemp >= 2) then
            rdeltemp = (water_freezing_pts(ntemp,1) -                   &
                        water_freezing_pts(1,1))/20.0
            do i = 1, 21
              rtemp = water_freezing_pts(1,1)+rdeltemp*(i-1)
              relcond = relcond_freezing(rtemp,r0)
              write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rtemp, relcond
            end do
          end if
        end if

      end if

      end if

      goto 1000

999   continue
      
      if (rank == 0) then
        write(ilog,*) 'error reading input file in initcpdd, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
