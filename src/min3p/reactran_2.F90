!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/reactran_2.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine reactran_2
!c -------------------
!c
!c second half of driver subroutine for reactive transport to be called
!c only after bubble routine has converged
!c
!c written by:      Rich Amos - April 19, 2004
!c
!c last modified:  
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           tfinal             = final solution time                 + -
!c           time               = current solution time               + -
!c           time_io            = current solution time (I/O units)   + -
!c           tsrc(ntsrc)        = target read times - transient       + -
!c                                source chemistry
!c                                (reactive transport)
!c           integer*4:
!c           ----------
!c           ilog               = unit number, log book               + -
!c           itsrc              = pointer to target read time for     + +
!c                                transient source chemistry
!c                                (reactive transport)
!c           ntsrc              = pointer to target read times for    + -
!c                                transient source chemistry
!c           logical:
!c           --------
!c           mass_balance_rt    = .true.  -> compute mass balance     + -
!c                                           (reactive transport)
!c           transient_source   = .true.  -> transient source         + -
!c                                           chemistry
!c           character:
!c           ----------
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           update_activity_rt = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c chem.f:   character:
!c           ----------
!c           update_activity    = 'no_update' -> unity activity       + +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c
!c external:mbalrt   = compute mass balance (reactive transport)
!c          tsteprt  = estimate of time step (reactive transport)
!c ----------------------------------------------------------------------

      subroutine reactran_2
 
      use parm
      use gen
      use chem
      use phys
      use biol

#ifdef OPENMP
      use omp_lib 
#endif
 
      implicit none

      external mbalrt, tsteprt
      real*8, external :: satindex
      
      integer :: i, ivol, tid, i1, i2, i3, ii, im, ireac,              &
                 istart, istop, istart2, istop2, ic, ic2, icur,        &
                 icount, next
      real*8 :: gammatemp

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, conv3 = 1.0d3,      &
                           rverysmall = 1.0d-30

!c  update concentrations of minerals, mineral volumes and
!c  reactivity term 
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,tid,i,i1,i2,i3,ii,im,ireac,istart,istop,      &
    !$omp istart2,istop2,ic,ic2,icur,icount,next,gammatemp)
    !$omp do schedule(static)
#endif
      do ivol=1,nngl
#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif

!c  exclude first type boundary control volumes

        if (btypert(ivol).ne.'first') then
!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants
          if (nm.gt.0) then

            !c calculate saturation index (without log10) used in 'twothird-mix' update type
            do im = 1,nm
              if (update_type(im).eq.'twothird-mix') then
                if (.not.far_from_equil(im)) then
!c_isotope
                  if (isofrac(im)) then
                    satm(im,tid) = eqm(im,tid)**(-r1)
                    ireac = iamd(im)
                    istart = iam(im)
                    istop = iam(im+1)-1

                    do i1 = istart, istop ! loop through components in mineral
                      icount = 0
                      ic = jam(i1)
                      next = 0
                      do i = 1, nifrm(im)  ! loop through isotope sets
                        istart2 = next + iamdiso(im)
                        icur = iamdiso2(im) + i - 1
                        istop2 = iamdiso(im) + jamdiso2(icur) - 1
                        next = jamdiso2(icur)
                        gammatemp = r0
                        !loop through isotope compents in set
                        do i2 = istart2, istop2
                          ii = jamdiso(i2)
                          !check to see if component is an isotope
                          if (ii.eq.ic) then
                            icount = icount + 1
                            !if so sum the isotope activities
                            do i3 = istart2, istop2
                                ic2 = jamdiso(i3)
                                gammatemp = gammatemp+gamma(ic2,ivol)*cnew(ic2,ivol)
                            end do
                            satm(im,tid) = satm(im,tid) *gammatemp**xnum(i1)
                          end if
                        end do
                      end do
                      !if not calculate the saturaton index the normal way
                      if (icount.eq.0) then
                        satm(im,tid) = satm(im,tid)*(gamma(ic,ivol)*cnew(ic,ivol))**xnum(i1)
                      end if
                    end do   !i1
                  else
                    satm(im,tid) = satindex(cnew(1,ivol),eqm(im,tid),  &
                                      gamma(1,ivol),xnum,iam,jam,im)
                  end if
                end if
              end if
            end do

            call updtsvmp(cmnew(1,ivol),cmold(1,ivol),phi(1,ivol),     &
                          area(1,ivol),ratemdp(1,ivol),satm(1,tid),    &
                          delt,ivol,tid)
          end if
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c  mass balance computation for reactive transport

      if (mass_balance_rt .and. ngb_step == ngb_step_bk) then
        call mbalrt
      end if
      
      if (flux_out .and. ngb_step == ngb_step_bk) then
        call mbal_mcd
      end if

!c  smr: decide upstream weighting for gases in the next time step

      if (spatial_weighting.eq.'upstream' .and. ng .gt. 0) then
        call giups
      endif

!c  smr: calculate the production/consumption rate of water

      if (chemical_water) then
        call rateh2o
      endif
      
!c  estimate time increment size for next time step

      call tsteprt
      
      return

!c  update source chemistry at specified target read times
!c  this part is never called
!      if (transient_source) then
!        if (itsrc.le.ntsrc.and.abs(tsrc(itsrc)-time).le.tinytime_global) then
!
!          if (rank == 0 .and. b_enable_output) then
!!c  report to log file
!            write(ilog,'(/a,1pe15.6e3,1x,a)')                          &
!                 'update source chemistry - reactive transport, T = ', &
!                  time_io, time_unit
!            write(ilog,'(72a/)')('-',i=1,72)
!
!!c  report to screen
!            write(*,'(/1x,a,1pe15.6e3,1x,a)')                          &
!                 'update source chemistry - reactive transport, T = ', &
!                  time_io, time_unit
!            write(*,'(1x,72a/)')('-',i=1,72)
!          
!          end if
!
!!c  update boundary conditions
!
!          call tranbcrt(tid)
!
!!c  set index for next target read time
!
!          itsrc = itsrc+1
!
!!c  set target read time to time larger than final solution time after
!!c  last update of boundary conditions
!
!          if (itsrc.gt.ntsrc) then
!            tsrc(itsrc) = tfinal+tinytime_global
!          end if
!
!!c  redefine activity update technique for reactive transport
!
!          if (update_activity_rt.eq.'no_update') then
!           update_activity = 'no_update'
!          elseif (update_activity_rt.eq.'time_lagged') then
!            update_activity = 'time_lagged'
!          elseif (update_activity_rt.eq.'double_update') then
!            update_activity = 'double_update'
!          endif
!
!        end if
!      end if

      return
      end
