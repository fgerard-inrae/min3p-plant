!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/restart_r.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine restart_r
!c -------------------
!c
!c read in variable for restart option
!c
!c written by:      Rich Amos - November 27, 2005
!c
!c last modified:   Sergi Molins - Jan 30, 2007
!c                  bubbles are out
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c
!c
!c gen.f:    real*8:
!c           -------
!c           uvsold(nn)         = solution vector (old time level)    * +
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            * +
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            * +
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            * +
!c                                - old time level
!c           c(nc,nn)           = concentrations of free species      * +
!c                                - old time level [moles/l water]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species [-]
!c           phi(nm,nn)         = mineral volume fractions            + -
!c           phiold(nm,nn)      = mineral volume fractions            + -
!c                                - old time level
!c           sionold(nn)        = ionic strength of solution          * +
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgold(nc,nn)      = total gaseous component            * +
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totgnew(nc,nn)      = total gaseous component            + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           cmold(nm,nn)       = mineral concentrations              * +
!c                                - old time level [moles/l bulk]]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           gold(ng,nn)        = gas concentrations                  * +
!c                                - old time level [moles / l air]    
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           perm_fac(nn)       = scaling factor for permeability     + +
!c                                as a function of porosity changes
!c           pornew(nn)         = porosity                            + +
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number - debugging information + -
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c                                           simulation
!c
!c chem.f:   real*8:
!c           -------
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           csb_ion(nsb_ion,nthreads)
!c                              = concentrations of sorbed species    * *
!c                                - new time level (ion-exchange)
!c           csb_surf(nsb_surf,nthreads) 
!c                              = concentrations of sorbed species    * *
!c                                - new time level (surface-complex)
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c
!c           integer*4:
!c           ----------
!c           iamp(nm+1)         = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jamp(nm)           = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           nc                 = number of components                + -
!c                                (including h2o)
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c
!c local:    real*8:
!c           -------
!c           por_diff           = porosity difference between time 
!c                                steps
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           im2                = counter (minerals)
!c           isb                = counter (sorbed species)
!c           ivol               = counter (control volumes)
!c
!c external: infcvs    = compute influence coefficients (variably
!c                       saturated flow)
!c           sorbspc   = compute concentrations of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totsorb   = compute total sorbed component 
!c                       concentrations [moles/l bulk]
!c ----------------------------------------------------------------------

      subroutine restart_r

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use phys
      use dens
      use bbls
      use m_heat_transport
      use file_unit, only : lun_get, lun_free
      use file_utility, only : rewind_first_record
      use mip_bubble, only : mip_mt_enable, mip_adjust_bubble_cond,    &
                             mip_solver_output, mip_sg, mip_g,         &
                             mip_d, mip_pw, mip_te, mip_tt, mip_pg,    &
                             mip_pgt, mip_cw, mip_ct
      use mip_output, only : mip_output_params

      use biol

#ifdef OPENMP
      use omp_lib 
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only :  binary_file_open,               &
                                       restart_binary_read_header,     &
                                       binary_read_data,               &
                                       binary_file_close

#ifdef USG
      use usg_mesh_data, only : nodes, is_boundary_node,               &
                                layer_nodes_bottom,                    &
                                node_to_layer_node,                    &
                                num_nodes_per_layer
      use usg_ice_sheet, only : ice_basal_temperature_type,            &
                                layer_nodes_bottom_temp,               &
                                layer_nodes_bottom_temp_gbl      
#ifdef PETSC_HDF
      use usg_mesh_data
      use hdf5
      use hdf5_usg
#endif
#endif
      
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef USG
#ifdef PETSC_HDF
      integer :: hdf5_ierr                               ! HDF5 error code
      integer(HID_T) :: iunit_hdf5, irsrt_hdf5           ! node mapping file
#endif
#endif
      
      integer :: i, ic, ig, im, isb, ivol, ivol_bottom, ix, izn, itz,   &
                 bcvs_cnt, bcheat_cnt, bcice_cnt, disprt_cnt,           &
                 ice_scalfac_cnt, itsrc_idx, ierr, ierrcd, iunit_file
      
      real*8 :: rdummy, rtemp, strion, acoff, actw, time_temp, time_rs, &
                time_tsrc, aentry_loc
      
      integer :: tid
      
      integer :: iskip, nskip, nprcs_temp
      
      real*8 dummy
      
      character(5) :: strdata
      character*256 :: strfilename      
      character*1024 :: str_file      
      character*1024 :: strbuffer
      
      real*8, allocatable :: realbuffer_irsrt(:)

      integer :: nvars_irsrt, ivar
      
      logical :: bexist
#ifdef PETSC
      integer(kind=MPI_OFFSET_KIND) :: offset_irsrt, offset_irsrt_temp
      PetscErrorCode :: ierrcode
#else
      integer*8 :: offset_irsrt, offset_irsrt_temp

#endif

      external infcvs, sorbspc, totconc, totconcg, totsorb, restart_w,      &
               updtbcice, updtice_scalfac, tcorr, checkerr

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmall = 1.0d-10,        &
                           tiny_conc = 1.0d-20

      integer, parameter :: rfloatbit = 8
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      ierrcd = 0

!c  open restart file
      
      !irsrt=555
      
      if (b_binary_restart_read) then
#ifdef USG
#ifdef PETSC
        if (discretization_type > 0) then
          b_distributed_restart_read = .false.
        end if
#endif
#endif

        offset_irsrt = 0  
        if(b_distributed_restart_read) then
          str_file = 'restart'//trim(str_rank)//'.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
            
          irsrt = lun_get()
          call binary_file_open(Petsc_Comm_Self,irsrt,                 &
                      trim(str_file),.false.)          
          call restart_binary_read_header(Petsc_Comm_Self,irsrt,       &
                       offset_irsrt,.false.,time_rs,delt_rt,delt_vs,   &
                       time_bcvs,igstime,nprcs_temp)          
          if(nprcs_temp /= nprcs) then
              goto 996
          end if        
        else

#ifdef USG
#ifdef PETSC_HDF
          if (discretization_type > 0) then

            str_file = 'restart.dat'
            inquire(file = trim(str_file), exist = bexist)
            if(.not. bexist) then
              if(rank == 0) then
                write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"
              end if
              goto 997
            end if

            irsrt = lun_get()
            irsrt_hdf5 = int(irsrt,kind(HID_T))
            
!cdsu   read restart attributes
            call hdf5_usg_read_attribute_r(irsrt_hdf5, trim(str_file), &
                          time_rs, delt_rt, delt_vs, time_bcvs, igstime)
          
          else
#endif
#endif
            str_file = 'restart.dat'
            inquire(file = trim(str_file), exist = bexist)
            if(.not. bexist) then
              if(rank == 0) then
                write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"
              end if
              goto 997
            end if

            call binary_file_open(Petsc_Comm_World,irsrt,              &
                         'restart.dat',.true.)
            call restart_binary_read_header(Petsc_Comm_World,irsrt,    &
                         offset_irsrt,.true.,time_rs,delt_rt,delt_vs,  &
                         time_bcvs,igstime,nprcs_temp)
#ifdef USG
#ifdef PETSC_HDF
          end if
#endif
#endif
        end if
      else
         
        irsrt = lun_get()
        
        if(b_distributed_restart_read) then 
          str_file = 'restart'//trim(str_rank)//'.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
        
          open(irsrt,file='restart'//trim(str_rank)//'.dat',           &
              status='old',form='formatted',access='sequential',err=997)  
          read(irsrt,'(4e22.14,I5.2,I8)',ADVANCE='no',err=998,end=999) &
               time_rs,delt_rt,delt_vs,time_bcvs,igstime,nprcs_temp        
          if(nprcs_temp /= nprcs) then
              goto 996
          end if        
        else
          str_file = 'restart.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
            
          ierrcd = 1
          open(irsrt,file='restart.dat',status='old',                  &
               form='formatted',access='sequential',err=997) 
          read(irsrt,'(4e22.14,I5.2)',ADVANCE='no',err=998,end=999)    &
              time_rs,delt_rt,delt_vs,time_bcvs,igstime  
        end if
      end if
           
      if (ignore_restart_time) then
        time_io_rs = time_io_ini
        delt_io_rs = max(min(delt_vs,delt_rt),deltmin)/time_factor
      else
        time_io = time_rs
        time_io_rs = time_rs
        delt = max(min(delt_vs,delt_rt),deltmin)                    !reuse the projected timestep 
        delt_io_rs = max(min(delt_vs,delt_rt),deltmin)/time_factor
      end if

      if(rank == 0 .and. b_enable_output) then      
        write(*,'(a,2x,1pe15.6e3,2x,a)')'restarting simulation at',    &
     &     time_io,time_unit
        write(ilog,'(a,1x,1pe15.6e3,1x,a)')'restarting simulation at'  &
     &    ,time_io,time_unit                                           
        write(*,'(4(1pe15.6e3),1x,i3)')time_io,delt_rt,delt_vs,        &
     &                          time_bcvs,igstime
      end if
      
      
      !cdsu revert the restart time index, otherwise, some of the output will be
      !cdsu lost if the output time is changed or restart time is changed.
      if(gs_output) then
        if (ngs == 1) then
          igstime = 1
        else
          time_temp = time_io*time_factor
          do i = 1, ngs            
            if (time_temp <= gs_tout(i)) then 
              igstime = i
              exit
            end if  
          end do
        end if
      end if

!cdsu set the time index to update root density
#ifdef ARCHISIMPLE
      if (root_uptake .and. rld_field_update) then
        time_temp = time_io*time_factor

        rld_update_index = rld_update_num + 1
        do i = 1, rld_update_num
          if (time_temp >= rld_update_time(i)) then
            !c update root length density
            call updtrootdensity_ext
          else
            rld_update_index = i
            exit
          end if
        end do
      end if
#endif

!cdsu  set the time index of component-mineral recycle
      if ((passive_uptake .or. root_uptake) .and. nrcm_tz > 0) then
        time_temp = time_io*time_factor
        if (ircm_tz == 0) then
          do itz = 1, nrcm_tz
            if (time_temp <= rcm_time(1,itz)) then
              ircm_tz = itz-1
              exit
            end if
          end do
          if (time_temp > rcm_time(1,nrcm_tz) .and. time_temp <= rcm_time(3,nrcm_tz)) then
            ircm_tz = nrcm_tz
          end if
          if (time_temp > rcm_time(3,nrcm_tz)) then
            ircm_tz = nrcm_tz+1
          end if
        end if

        ircm_tz_restart = .true.
      end if
    
!c  variably saturated flow

      if (b_binary_restart_read) then
        !calculate the number variables to write  
        nvars_irsrt = 0
        if (varsat_flow.and.transient_flow) then
          nvars_irsrt = nvars_irsrt + 3
        end if
        
        if (heat_transport) then
          nvars_irsrt = nvars_irsrt + 1
        end if
        
        if (density_dependence) then
          nvars_irsrt = nvars_irsrt + 2
        end if
        
        if (update_viscosity.or.update_viscosity_temp) then
          nvars_irsrt = nvars_irsrt + 1
        end if
        
        if (trap_bubbles) then
          nvars_irsrt = nvars_irsrt + 2  
        end if
        
        if (reactive_transport) then
          nvars_irsrt = nvars_irsrt + 2*n + 1
          if (noncompetitive_sorption) then
            nvars_irsrt = nvars_irsrt + n
          end if
          if (ng.gt.0) then
            nvars_irsrt = nvars_irsrt + n + ng
          end if
          if (nsb_ion.gt.0) then
            nvars_irsrt = nvars_irsrt + n
          end if
          if (nsb_surf.gt.0) then
            nvars_irsrt = nvars_irsrt + n
          end if
          if (nm>0.or.update_porosity_flow) then
            nvars_irsrt = nvars_irsrt + 2*nm + 2
          end if
          if (mip_mt_enable .and. ng.gt.0) then
            nvars_irsrt = nvars_irsrt + 3*ng + 7
          end if
        end if 
        
        allocate(realbuffer_irsrt(nvars_irsrt), stat = ierr)
        call checkerr(ierr,'realbuffer_irsrt',ilog)
        realbuffer_irsrt = 0.0d0
        call memory_monitor(sizeof(realbuffer_irsrt),'realbuffer_irsrt',.true.)
      end if

#ifdef USG
#ifdef PETSC_HDF
      if (b_binary_restart_read .and. discretization_type > 0) then

        !c  initialize parallel data mapping if not initialized
        if (.not. b_init_hdf5_lg2g) then

          strfilename = prefix(:l_prfx)//'.domain.h5'
          inquire(file=trim(strfilename),exist=bexist)

          if (bexist) then
            iunit_file = lun_get()
            iunit_hdf5 = int(iunit_file,kind(HID_T))
            call hdf5_usg_read_node_lg2g(iunit_hdf5,                   &
                                         trim(strfilename),hdf5_ierr)
            call lun_free(iunit_file)

            if (hdf5_ierr < 0) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in reading domain from hdf5 file'
                write(ilog,*) 'file: ',trim(strfilename)
                close(ilog)
              end if
              call petsc_mpi_finalize
              stop
            else
              if (rank == 0) then
                write(*,'(a)') 'read domain from hdf5 file: done'
                write(ilog,'(a)') 'read domain from hdf5 file: done'
              end if
            end if

            b_init_hdf5_lg2g = .true.
          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading domain from hdf5 file'
              write(ilog,*) 'file is missing: ',prefix(:l_prfx)//'.domain.h5'
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop    
          end if
        end if

!cdsu   allocate memory space for global reading
        allocate(realbuffer(nngl), stat = ierr)
        realbuffer = 0.0d0
        call checkerr(ierr,'restart_r-realbuffer',ilog)
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)

        allocate(realbuffer2d(nngl,nvars_irsrt), stat = ierr)
        realbuffer2d = 0.0d0
        call checkerr(ierr,'restart_r-realbuffer2d',ilog)
        call memory_monitor(sizeof(realbuffer2d),'realbuffer2d',.true.)

        do ivar = 1, nvars_irsrt
          write(strdata,'(i0)') ivar
          call hdf5_usg_read_node_var(irsrt_hdf5, trim(str_file),      &
                    "results", trim(strdata), realbuffer, bexist,      &
                    hdf5_ierr)  
          realbuffer2d(:,ivar) = realbuffer(:)                            
          if (hdf5_ierr < 0) then
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in reading variable from hdf5 file'
              write(ilog,*) 'file: ',trim(str_file)
              close(ilog)
            end if
            call petsc_mpi_finalize
            stop
          else
            if (rank == 0) then
              write(*,'(a,i0,a)') 'read variable ',ivar,' from hdf5 file: done'
              write(ilog,'(a,i0,a)') 'read variable ',ivar,' from hdf5 file: done'
            end if
          end if          
        end do
      end if
#endif
#endif

      nskip = 0
      do ivol=1,nngl
        
#ifdef PETSC
        if(.not.(b_binary_restart_read .or.                            &
                 b_distributed_restart_read)) then
          if (discretization_type == 0) then
            do iskip = 1, node_idx_lg2g(ivol) - nskip -1
              ierrcd = 2
              read(irsrt,'(/,1e22.14)',ADVANCE='no',end=999,err=998)     &
                   rdummy
            end do
            nskip = node_idx_lg2g(ivol)
          end if
        end if
#endif
        
       
        if (.not. b_binary_restart_read) then
          ierrcd = 3
          read(irsrt,'(/,1e22.14)',err=998,end=999) dummy          
          backspace(irsrt)
        end if
      
      
        if (b_binary_restart_read) then

#ifdef USG
#ifdef PETSC_HDF
          if (discretization_type > 0) then
            do ivar = 1, nvars_irsrt
              realbuffer_irsrt(ivar) = realbuffer2d(ivol,ivar)
            end do
          else
#endif
#endif
            if (b_distributed_restart_read) then
              offset_irsrt_temp = offset_irsrt +                       &
                                  (ivol-1)*nvars_irsrt*rfloatbit
            else
              offset_irsrt_temp = offset_irsrt +                       &
                                  (node_idx_lg2g(ivol)-1)*             &
                                   nvars_irsrt*rfloatbit
            end if

            call binary_read_data(irsrt,nvars_irsrt,realbuffer_irsrt,  &
                        offset_irsrt_temp,.not.b_distributed_restart_read)

#ifdef USG
#ifdef PETSC_HDF
          end if
#endif
#endif
        end if

        ivar = 0
      
        if (varsat_flow.and.transient_flow) then
          if(b_binary_restart_read) then
            uvsold(ivol) = realbuffer_irsrt(ivar+1)
            saold(ivol) = realbuffer_irsrt(ivar+2)
            sgold(ivol) = realbuffer_irsrt(ivar+3)
            ivar = ivar+3
          else
            ierrcd = 4
            read(irsrt,'(3e22.14)',ADVANCE='no',err=998,end=999)       &
                 uvsold(ivol),saold(ivol),sgold(ivol)
          end if
        end if
                                                                       
        if (heat_transport) then
          if(b_binary_restart_read) then
            tempold(ivol) = realbuffer_irsrt(ivar+1)
            ivar = ivar + 1
          else
            ierrcd = 5
            read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)       &
                 tempold(ivol)
          end if
        end if
!cprovi------------------------------------------------------------
!cprovi If driven-density dependence is solved 
!cprovi------------------------------------------------------------          
        if (density_dependence) then
          if(b_binary_restart_read) then
            densold(ivol) = realbuffer_irsrt(ivar+1)
            tds_old(ivol) = realbuffer_irsrt(ivar+2)
            ivar = ivar + 2
          else
            ierrcd = 6
            read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)       &
                 densold(ivol),tds_old(ivol)
          end if
        end if
!cprovi------------------------------------------------------------
!cprovi If viscosity is updated 
!cprovi------------------------------------------------------------
        if (update_viscosity.or.update_viscosity_temp) then
          if(b_binary_restart_read) then
            viscosity(ivol) = realbuffer_irsrt(ivar+1)
            ivar = ivar + 1
          else
            ierrcd = 7
            read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)       &
                 viscosity(ivol)
          end if
        end if
      
!cprovi------------------------------------------------------------
!cprovi If gas bubbles and trap bubbles
!cprovi------------------------------------------------------------ 
        if (trap_bubbles) then

          if(b_binary_restart_read) then
            sgt_old(ivol) = realbuffer_irsrt(ivar+1)
            if (realbuffer_irsrt(ivar+2) > 0) then
              big_bub_old(ivol) = .true.
            else
              big_bub_old(ivol) = .false.
            end if
            ivar = ivar + 2
          else
            ierrcd = 8
            read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)       &
                 sgt_old(ivol),rtemp

            if(rtemp > 0) then
              big_bub_old(ivol) = .true.
            else
              big_bub_old(ivol) = .false.
            end if
          end if
          
        end if
      
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------    
!c  reactive transport 

        if (reactive_transport) then

!c  aqueous phase
!c  -------------
          if(b_binary_restart_read) then
            sionold(ivol) = realbuffer_irsrt(ivar+1)
            do ic = 1,n
              c(ic,ivol) = realbuffer_irsrt(ivar+2*ic)
              totcold(ic,ivol) = realbuffer_irsrt(ivar+2*ic+1)
            end do
            ivar = ivar + 2*n+1
          else
!c  reassign ionic strengtih for next time level  
            ierrcd = 9      
            read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)       &
                sionold(ivol)

!c  reassign free species concentrations for next time level
            do ic = 1,n
              ierrcd = 10
              read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)     &
                   c(ic,ivol),totcold(ic,ivol)
            end do
          end if
         
!c  reassign total aqueous and sorbed (non-competitive sorpton)
!c  component concentrations for next time level
         
          if (noncompetitive_sorption) then
            if(b_binary_restart_read) then
              do ic = 1,n
                totaold(ic,ivol) = realbuffer_irsrt(ivar+ic)
              end do
              ivar = ivar + n
            else
              do ic = 1,n
                ierrcd = 11
                read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)   &
                   totaold(ic,ivol)
              end do
            end if
          end if
        
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!c  gaseous phase
!c  -------------
!c  redox equilibrium reactions

          if (ng.gt.0) then

!c  reassign total gaseous component concentrations for next time level
            if(b_binary_restart_read) then
              do ic = 1,n
                totgold(ic,ivol) = realbuffer_irsrt(ivar+ic)
              end do 
              ivar = ivar + n
            else
              do ic = 1,n
                ierrcd = 12
                read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)   &
                     totgold(ic,ivol)
              end do
            end if

!c  reassign gas concentrations for next time level
            if(b_binary_restart_read) then
              do ig = 1,ng
                gold(ig,ivol) = realbuffer_irsrt(ivar+ig)
              end do 
              ivar = ivar + ng
            else
              do ig = 1,ng
                ierrcd = 13
                read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)   &
                     gold(ig,ivol)
              end do
            end if

          end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
            if(nsb_ion.gt.0) then
              if(b_binary_restart_read) then
                do ic = 1,n
                  totsold_ion(ic,ivol) = realbuffer_irsrt(ivar+ic)
                end do
                ivar = ivar + n
              else    
                do ic = 1,n
                  ierrcd = 14
                  read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999) &
                       totsold_ion(ic,ivol)
                end do
              end if
            end if
            
            if(nsb_surf.gt.0) then 
              if(b_binary_restart_read) then
                do ic = 1,n
                  totsold_surf(ic,ivol) = realbuffer_irsrt(ivar+ic)
                end do
                ivar = ivar + n
              else    
                do ic = 1,n
                  ierrcd = 15
                  read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999) &
                       totsold_surf(ic,ivol)
                end do
              end if
            end if

!c  reassign total sorbed component concentrations for next time level

          end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

          if (nm>0.or.update_porosity_flow) then
            if(b_binary_restart_read) then
              do im=1,nm
                cmold(im,ivol) = realbuffer_irsrt(ivar+2*im-1)
                phiold(im,ivol) = realbuffer_irsrt(ivar+2*im)
              end do
              porold(ivol) = realbuffer_irsrt(ivar+2*nm+1)
              perm_fac(ivol) = realbuffer_irsrt(ivar+2*nm+2)

              ivar = ivar + 2*nm+2
            else    
              do im=1,nm
                ierrcd = 16
                read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)   &
                     cmold(im,ivol),phiold(im,ivol)
              end do
              ierrcd = 17
              read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)     &
                   porold(ivol),perm_fac(ivol)
            end if
            pornew(ivol) = porold(ivol) 
                       
          end if

          if (mip_mt_enable) then
            if (b_binary_restart_read) then
              mip_sg(ivol) = realbuffer_irsrt(ivar+1)
              mip_g(ivol) = int(realbuffer_irsrt(ivar+2))
              mip_d(ivol) = int(realbuffer_irsrt(ivar+3))
              mip_pw(ivol) = realbuffer_irsrt(ivar+4)
              mip_te(ivol) = realbuffer_irsrt(ivar+5)
              mip_tt(ivol) = realbuffer_irsrt(ivar+6)
              mip_pgt(ivol) = realbuffer_irsrt(ivar+7)
              mip_pg(:,ivol) = realbuffer_irsrt(ivar+8:ivar+7+ng)
              mip_cw(:,ivol) = realbuffer_irsrt(ivar+8+ng:ivar+7+2*ng)
              mip_ct(:,ivol) = realbuffer_irsrt(ivar+8+2*ng:ivar+7+3*ng)

              ivar = ivar+7+3*ng
            else
              read(irsrt,'(e22.14,2i4,7e22.14)', ADVANCE='no')        &
                    mip_sg(ivol), mip_g(ivol), mip_d(ivol),            &
                    mip_pw(ivol), mip_te(ivol), mip_tt(ivol),          &
                    mip_pgt(ivol)
              do ig = 1, ng
                read(irsrt,'(1e22.14)',ADVANCE='no')  mip_pg(ig,ivol)
              end do
              do ig = 1, ng
                read(irsrt,'(1e22.14)',ADVANCE='no')  mip_cw(ig,ivol)
              end do
              do ig = 1, ng
                read(irsrt,'(1e22.14)',ADVANCE='no')  mip_ct(ig,ivol)
              end do
            end if
            saold(ivol) = r1-mip_sg(ivol)  
            sgold(ivol) = mip_sg(ivol)
          end if

        end if             !reactive_transport

        if(b_binary_restart_read) then
          if (ivar /= nvars_irsrt) then
            ierrcd = 18
            goto 999
          end if
        end if

      end do          !loop over control volumes

!c  release memory for the variables that will not be used anymore
#ifdef USG
#ifdef PETSC_HDF
      if (b_binary_restart_read .and. discretization_type > 0) then
        if (allocated(realbuffer)) then
          call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
          deallocate(realbuffer)
        end if
        if (allocated(realbuffer2d)) then
          call memory_monitor(-sizeof(realbuffer2d),'realbuffer2d',.true.)
          deallocate(realbuffer2d)
        end if
      end if
#endif
#endif

      if (allocated(node_idx_g2lg)) then
        if (.not.root_uptake) then
          call memory_monitor(-sizeof(node_idx_g2lg),'node_idx_g2lg',.true.)
          deallocate(node_idx_g2lg)
        end if
      end if
      
      if (b_binary_restart_read) then
        call memory_monitor(-sizeof(realbuffer_irsrt),'realbuffer_irsrt',.true.)
        deallocate(realbuffer_irsrt)
      end if

!cdsu close related files
      if(b_binary_restart_read) then
#ifdef USG
#ifdef PETSC_HDF
        if (discretization_type > 0) then
          call lun_free(irsrt)          
        else
#endif
#endif

          call binary_file_close(irsrt,.not.b_distributed_restart_read)
          if(b_distributed_restart_read) then
            call lun_free(irsrt)
          end if
#ifdef USG
#ifdef PETSC_HDF
        end if
#endif
#endif
      else
        close(irsrt)
        call lun_free(irsrt)
      end if

!cdsu appended restart data for specific cases
!cdsu all the processors need to read the append restart data or using broadcast operation.
      irsrt = lun_get()
      open(irsrt,file='restart.append.dat',status='unknown',form='formatted') 
     
      if ((passive_uptake .or. root_uptake) .and. nrcm_tz > 0) then
        ierrcd = 19
        read(irsrt,ascii_fmt,err=998,end=999) totrcm_c(:)
        read(irsrt,ascii_fmt,err=998,end=999) totrcm_m(:)
        read(irsrt,ascii_fmt,err=998,end=999) totrcm_c_tz(:)
        read(irsrt,ascii_fmt,err=998,end=999) totrcm_m_tz(:)
        read(irsrt,ascii_fmt,err=998,end=999) totrcm_c_nz(:,:)
        read(irsrt,ascii_fmt,err=998,end=999) totrcm_c_ave1st(:,:)
      end if

      close(irsrt)
      call lun_free(irsrt)
!cdsu end of appended restart data



      !cdsu Check mineral concentration, update the minimum mineral
      !cdsu concentration to the checked value if that value is very
      !cdsu close to the minimum mineral concentration as this may be
      !cdsu caused by decimal error
      do im = 1, nm
        do ivol = 1, nngl
          if (dabs(cmold(im,ivol)-cmcmin(im,tid)) <= tiny_conc) then
            cmold(im,ivol) = cmcmin(im,tid)
          end if
        end do
      end do
    
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_restart_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol, izn, ix, strion, aentry_loc, dummy)
    !$omp do schedule(static)
#endif
      do ivol=1,nngl
        
#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif 
                                           
        izn = mpropvs(ivol)
        if (varsat_flow.and.transient_flow) then
            uvsnew(ivol) = uvsold(ivol)
            sanew(ivol) = saold(ivol)
            sgnew(ivol)=r1-sanew(ivol)
        end if

        if (heat_transport) then
            tempnew(ivol)=tempold(ivol)
        end if

        if (heat_transport .and. ispitzerdens) then
          densold_pitzer(ivol) = densold(ivol)
          densold2_pitzer(ivol) = densold(ivol)
        end if
!cprovi------------------------------------------------------------
!cprovi If driven-density dependence is solved 
!cprovi------------------------------------------------------------          
        if (density_dependence) then
             tds_old2(ivol) = tds_old(ivol)
             tds_new(ivol) = tds_old(ivol) 

             density(ivol) = densold(ivol) 
             densold2(ivol) = densold(ivol)
             !densold1(ivol) = densold(ivol)             
         end if
!cprovi------------------------------------------------------------
!cprovi If viscosity is updated 
!cprovi------------------------------------------------------------ 
        if (update_viscosity_temp) then
          viscoold(ivol) = viscosity(ivol)
        end if
      
!cprovi------------------------------------------------------------
!cprovi If gas bubbles and trap bubbles
!cprovi------------------------------------------------------------ 
        if (trap_bubbles) then
          sgt(ivol) = sgt_old(ivol)
          big_bubble(ivol) = big_bub_old(ivol)
        end if
      
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------    
!c  reactive transport 

        if (reactive_transport) then

          if (temp_corr.or.heat_transport) then
           call tcorr(tkel(ivol),ivol,tid)
          end if

!c  aqueous phase
!c  -------------
!c  reassign ionic strengtih for next time level 

          sionnew(ivol) = sionold(ivol)

!c  reassign free species concentrations for next time level

          do ic = 1,n
            cnew(ic,ivol) = c(ic,ivol)
            totcnew(ic,ivol) = totcold(ic,ivol)
          end do

!c Calculate the secondary species concentrations totcnewf and totcoldf
          if (hmulti_diff) then
            izn = mpropvs(ivol)
                
!c  compute total concentrations of aqueous primary and secondary
!c  species times the correction factors

            call updtsvap(c(1,ivol),cxold(1,ivol),gammaold(1,ivol),   &
     &                    gammaold(nc+1,ivol),sionold(ivol),tid) 
            call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),        &
     &                  gamma(nc+1,ivol),sionnew(ivol),tid)
                
            call totconcfac(cnew(1,ivol),cx(1,ivol),totcnewf(1,ivol),izn)
            call totconcfac(c(1,ivol),cxold(1,ivol),totcoldf(1,ivol),izn)

          end if
         
!c  reassign total aqueous and sorbed (non-competitive sorpton)
!c  component concentrations for next time level
         
          if (noncompetitive_sorption) then
            do ic = 1,n
               totanew(ic,ivol) = totaold(ic,ivol)
            end do
          end if
                  
          if (redox_equil_rt.and.nr.gt.0) then

!c  compress total aqueous and sorbed (noncompetitive sorption)
!c  component concentration vector

            call comptotc(totcnew(1,ivol))
            if (noncompetitive_sorption) then
              call comptotc(totanew(1,ivol))
            end if

          end if

!c  recompute activity coefficients

!c  compute concentrations of aqueous complexes
 
          do ix = 1,nx
            call secspec(c(1,ivol),cx(ix,ivol),eqx(ix,tid),gamma(1,ivol),&
                         gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)

          end do
 
!c  update ionic strength
 
          call ionstr(c,cx,strion,chargec,chargex,nc-1,nx,namec)
 
!c  make sure new ionic strength is not larger than maximum
!c  allowed ionic strength to avoid convergence problems
 
          strion = dmin1(strion,sionmax)

          if (update_activity(tid).eq.'time_lagged') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

            if (temp_corr.or.heat_transport) then
              call tcorr(tkel(ivol),ivol,tid)
            end if

!cprovi----------------------------------------------      
!cprovi It was added by Sergio Andres Bea Jofre 
!cprovi----------------------------------------------      
            if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi---------------------------------------------- 
              call pitzer (phase,gamma(1:nc,ivol),                    &
     &                     gamma(nc+1:nc+nx,ivol),                    &
     &                     cnew(1:nc,ivol),cx(1:nx,ivol),             &
     &                     nc,nx,ilog)
            else
!cprovi----------------------------------------------    
!cprovi for free species
!cprovi----------------------------------------------

              do ic=1,nc
                   gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),    &
     &                              sionnew(ivol),chargec(ic),        &
     &                              dhac(ic),dhbc(ic),                &
     &                              dhad(tid),dhbd(tid),              &
     &                              adav,bdav,acth2omin,nc,           &
     &                              nx,namec(ic),namec,ic,            &
     &                              issit,asit,basit,coepsil,         &
     &                              iasit,jasit)
              end do

!c  --> for secondary aqueous species

              do ix=1,nx
                   gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol), &
     &                                 sionnew(ivol),chargex(ix),     &
     &                                 dhax(ix),dhbx(ix),             &
     &                                 dhad(tid),dhbd(tid),           &
     &                                 adav,bdav,acth2omin,nc,        &
     &                                 nx,namex(ix),namec,            &
     &                                 nc+ix,issit,asit,basit,        &
     &                                 coepsil,iasit,jasit)
              end do
               
            end if
          end if
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!c  gaseous phase
!c  -------------
!c  redox equilibrium reactions

          if (ng.gt.0) then

!c  reassign total gaseous component concentrations for next time level

            do ic = 1,n
               totgnew(ic,ivol) = totgold(ic,ivol)
            end do

!c  reassign gas concentrations for next time level

            do ig = 1,ng
               gnew(ig,ivol) = gold(ig,ivol)
            end do
          
            if (redox_equil_rt.and.nr.gt.0) then

!c  recompute total gaseous component concentrations

              call totconcg(gnew(1,ivol),totgnew(1,ivol))

            end if

!c  compress total gaseous component concentrations

            if (redox_equil_rt.and.nr.gt.0) then

              call comptotc(totgnew(1,ivol))

            end if

          end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
            if(nsb_ion.gt.0) then  
                do ic = 1,n
                   totsnew_ion(ic,ivol) = totsold_ion(ic,ivol)
                end do
            end if
            
            if(nsb_surf.gt.0) then  
                do ic = 1,n
                   totsnew_surf(ic,ivol) = totsold_surf(ic,ivol)
                end do
            end if
 
            if (redox_equil_rt.and.nr.gt.0) then

!c  recompute sorbed species concentrations

              do isb = 1,nsb_ion
                call sorbspc(csb_ion(isb,tid),dummy,cec_g(ivol),      &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,isb,0,                &
                     sorption_type_ion,                               &
                     sorption_type_surf,sorption_group,isactcexch)
              end do
              
              do isb = 1,nsb_surf
                call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),     &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,0,isb,                &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
              end do

!c  recompute total sorbed component concentrations

              call totsorb(csb_ion(:,tid),csb_surf(:,tid),            &
                   chargesb_ion,rhobulk_g(ivol),                      &
                   totsnew_ion(1,ivol),totsnew_surf(1,ivol),          &
                   xnusb_ion,xnusb_surf,                              &
                   iasb_ion,iasb_surf,jasb_ion,jasb_surf,nc,          &
                   nsb_ion,nsb_surf,namec)

!c  compress total sorbed component concentration vector
              if(nsb_ion.gt.0) then
                call comptotc(totsnew_ion(1,ivol))
              end if
              
              if(nsb_surf.gt.0) then
                call comptotc(totsnew_surf(1,ivol))
              end if
              
            end if

!c  reassign total sorbed component concentrations for next time level

          end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

          if (nm>0.or.update_porosity_flow) then

            do im=1,nm                   
              cmnew(im,ivol) = cmold(im,ivol)                          
              phi(im,ivol) = phiold(im,ivol)                           
            end do            
            
          end if      
        
!!c  recalculate influence coefficients for variably-saturated flow,
!!c  if permeability is updated
!!c  Bug fixed, call infcvs one time, DSU
!
!         if (update_permeability) then
!            call infcvs
!          end if

        end if             !reactive_transport
        
        
        if (heat_transport.and.evaporation) then
           if (reactive_transport) then
             actw=gamma(nc,ivol)
           else
             actw=r1
           end if

           if (soilhydrfunc_field) then
             aentry_loc = aentry_vol(ivol)
           else
             izn = mpropvs(ivol)
             aentry_loc = aentry(izn)
           end if

           call vapor_prop (densvnew(ivol),dummy,ddensvdpa(ivol),     &
     &                      ddensvdt(ivol),latvapnew(ivol),           &
     &                      tempnew(ivol),aentry_loc,                 &
     &                      uvsnew(ivol),actw,                        &
     &                      density(ivol),ivol)                        
           densvold(ivol)=densvnew(ivol)                               
           latvapold(ivol)=latvapnew(ivol)                             
           call surf_tens_prop (dummy,dsurftensdt(ivol),              &
     &                          tempnew(ivol))
        end if

      end do          !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c  recalculate influence coefficients for variably-saturated flow,
!c  if permeability is updated
!c  Bug fixed, call infcvs one time, DSU
      if (reactive_transport .and. update_permeability .or.            &
          (mip_mt_enable .and. mip_adjust_bubble_cond)) then
        if(discretization_type == 0) then
          call infcvs
#ifdef USG
        else
          call infcvs_usg
#endif
        end if
      end if

#ifdef USG
      !c temperature at the bottom of layered simualtion domain
      if (heat_transport .and. ice_basal_temperature_type == 2) then
        !c reset value to a very small one
        layer_nodes_bottom_temp = -1.0d300
            
        do ivol = 1, nngl
          if (is_boundary_node(ivol)) then
            ivol_bottom = node_to_layer_node(ivol)
            if (abs(nodes(ivol)%z - layer_nodes_bottom(ivol_bottom)%z) < rsmall) then
              layer_nodes_bottom_temp(ivol_bottom) = tempnew(ivol)
            end if
          end if
        end do

#ifdef PETSC
        call MPI_Allreduce(layer_nodes_bottom_temp,                &
                           layer_nodes_bottom_temp_gbl,            &
                           num_nodes_per_layer,MPI_REAL8,MPI_MAX,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        layer_nodes_bottom_temp = layer_nodes_bottom_temp_gbl
#endif
      end if
#endif
    
    !cprovi-----------------------------------------------
      !cprovi Compute new densities and other parameters
      !cprovi related with 
      !cprovi-----------------------------------------------
      if (density_dependence) then
        if (.not. tran_steady_drho_0) then
          if (.not.flow_verification) then
            if (heat_transport) then
              call ddtds_energybal(.false.)
              if (ispitzerdens) then
                densold_pitzer=density_pitzer
                densold2_pitzer=densold_pitzer
              end if
            else
              call ddtds
            end if
          end if 
        end if
      end if


      if (update_bcvs) then
        bcvs_cnt=0
        time_temp = time_io_ini - tinytime_global

        if (rank == 0 .and. b_enable_output) then
          write(*,*) "restart - update flow boundary condition"
          write(ilog,*) "restart - update flow boundary condition"
        end if
      
        !rewind(ibcvs)
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(ibcvs)
        do while (time_io.gt.time_temp)
          time_bcvs_prev = time_temp
          read(ibcvs,*,err=998,end=990) time_temp
          bcvs_cnt=bcvs_cnt+1
        end do

990     continue

        if (time_io.gt.time_temp) then
          !cdsu set the time to the final time later
          time_bcvs = 1.1d0*tfinal/time_factor
          !cdsu backspace of this file, need for updtbcvs and updtbcdd
          backspace(ibcvs)
        else
          time_bcvs = time_temp
        end if

        if (density_dependence) then
          call updtbcdd
        else
          call updtbcvs
        end if

        b_restart_update_bcvs = .false.

      end if

      if (update_bcheat) then
        bcheat_cnt=0
        time_temp = time_io_ini - tinytime_global

        if (rank == 0 .and. b_enable_output) then
          write(*,*) "restart - update heat boundary condition"
          write(ilog,*) "restart - update heat boundary condition"
        end if
      
        !rewind(ibcheat)
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(ibcheat)
        do while (time_io.gt.time_temp)
          time_bcheat_prev = time_temp
          read(ibcheat,*,err=998,end=991) time_temp
          bcheat_cnt=bcheat_cnt+1
        end do

991     continue

        if (time_io.gt.time_temp) then
          !cdsu set the time to the final time later
          time_bcheat = 1.1d0*tfinal/time_factor
          !cdsu backspace of this file, need for updtbcheat and updtbcdd
          backspace(ibcheat)
        else
          time_bcheat = time_temp
        end if

        call updtbcenergybal

        b_restart_update_bcheat = .false.
      
      end if



      !c update ice boundary condition
      if (update_bcice) then
        bcice_cnt=0
        time_temp = time_io_ini - tinytime_global

        if (rank == 0 .and. b_enable_output) then
          write(*,*) "restart - update ice sheet boundary condition"
          write(ilog,*) "restart - update ice sheet boundary condition"
        end if
      
        !rewind(ibcice)
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(ibcice)
        do while (time_io .gt. time_temp)
          time_bcice_prev = time_temp
          read(ibcice,*,err=998,end=992) time_temp
          bcice_cnt=bcice_cnt+1
        end do

992     continue

        if (time_io .gt. time_temp) then
          !cdsu set the time to the final time later
          time_bcice = 1.1d0*tfinal/time_factor
          !cdsu backspace of this file, need for updtbcice
          backspace(ibcice)
        else
          time_bcice = time_temp
        end if

        !c note: ice sheet thickness change is an indicator of ice sheet growth or decay.
        !c when restart file is used, the ice sheet thickness before current time_io should
        !c be retrieved
        if (bcice_cnt > 2) then
          backspace(ibcice)          !c back to the previous update time
          call updtbcice             !c retrieve the previous update
          call updtbcice             !c retrieve the current update
        else
          call updtbcice             !c retrieve the current update
        end if

        b_restart_update_bcice = .false.
        
      end if

      !c transient dispersivity
      if (reactive_transport .and. update_disprt) then
        disprt_cnt=0
        time_temp = time_io_ini - tinytime_global

        if (rank == 0 .and. b_enable_output) then
          write(*,*) "restart - update dispersivity for reactive transport"
          write(ilog,*) "restart - update dispersivity for reactive transport"
        end if
      
        !rewind(idisprt)
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(idisprt)
        do while (time_io.gt.time_temp)
          time_disprt_prev = time_temp
          read(idisprt,*,err=998,end=993) time_temp
          disprt_cnt=disprt_cnt+1
        end do

993     continue

        if (time_io.gt.time_temp) then
          !cdsu set the time to the final time later
          time_disprt = 1.1d0*tfinal/time_factor
          !cdsu backspace of this file, need for updtdisprt and updtbcdd
          backspace(idisprt)
        else
          time_disprt = time_temp
        end if

        call updtdisprt

        b_restart_update_disprt = .false.
      end if

!c update scaling factor of pressure head, pore stress and boundary pore pressure 
      if (update_ice_scalfac) then
        ice_scalfac_cnt=0
        time_temp = time_io_ini - tinytime_global

        if (rank == 0 .and. b_enable_output) then
          write(*,*) "restart - update scaling factors due to ice sheet loading/unloading"
          write(ilog,*) "restart - update scaling factors due to ice sheet loading/unloading"
        end if
      
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(file_ice_scalfac)
        do while (time_io .gt. time_temp)
          time_ice_scalfac_prev = time_temp
          read(file_ice_scalfac,*,err=998,end=994) time_temp
          ice_scalfac_cnt = ice_scalfac_cnt+1
        end do

994     continue

        if (time_io .gt. time_temp) then
          !cdsu set the time to the final time later
          time_ice_scalfac = 1.1d0*tfinal/time_factor
          !cdsu backspace of this file, need for updtbcice
          backspace(file_ice_scalfac)
        else
          time_ice_scalfac = time_temp
        end if

        !c when restart file is used, the scalinf factors before current time_io should
        !c be retrieved
        if (ice_scalfac_cnt > 2) then
          backspace(file_ice_scalfac)      !c back to the previous update time
          call updtice_scalfac             !c retrieve the previous update
          call updtice_scalfac             !c retrieve the current update
        else
          call updtice_scalfac             !c retrieve the current update
        end if

        b_restart_update_ice_scalfac = .false.
        
      end if

!c  transient source
      if (transient_source) then

        time_tsrc = time_io*time_factor

        do itsrc_idx = 1, ntsrc
          if (time_tsrc > tsrc(itsrc_idx) .and. time_tsrc <= tsrc(itsrc_idx+1)) then
            itsrc = itsrc_idx + 1
            exit
          end if
        end do
      end if

      if (mip_mt_enable) then
        !c output parameters
        call mip_output_params
        !c pass MIP variable back to MIN3P
        call mip_solver_output
      end if

      return
      
995   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'Number of processors used for restart ',   &
             'file should be one or same as the current running'
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'Number of processors used for restart ',      &
             'file should be one or same as the current running'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

996   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'number of restart file does not match'
        write(*,*) 'SIMULATION TERMINATED'
        write(*,*) 'number of restart file does not match'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop     

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error when opening restart file'
        write(*,*) 'SIMULATION TERMINATED'
        write(*,*) 'error when opening restart file'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop      

998   continue     
      backspace(irsrt)
      read(irsrt,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(3a,i0)') 'error reading in restart file: ',       &
              trim(strbuffer), 'error code ', ierrcd
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(3a,i0)') 'error reading in restart file: ',          &
              trim(strbuffer), 'error code ', ierrcd
        close(ilog)
      end if
      
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'end in reading restart file, error code ', ierrcd
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

      end
