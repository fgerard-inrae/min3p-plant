!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/bdryflux.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function bdryflux
!c ------------------------
!c
!c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!c have to add storage here ...... for transient conditions
!c i.e. do local mass balance ....(only needed for seepage face in case 
!c switching bewteen types)
!c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!c compute water flux across boundary control volumes
!c
!c written by:      Uli Mayer - September 5, 96
!c
!c last modified:   Tom Henderson - March 24, 2003
!c                  added point source
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           bdryflux           = water flux across boundary face     * + 
!c
!c           integer*4:
!c           ----------
!c           ivol               = pointer to current control volume   + -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           hhead(nn)          = hydraulic head                      + -
!c           relperm(nn)        = relative permeability               + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  + -
!c
!c           integer*4:
!c           ----------
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           iups(ncon-1)       = upstream pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           upstream           = .true.  -> upstream weighting       + -
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c                                'free-drainage' = free-drainage
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c        
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control 
!c                                volumes)
!c           icon               = counter (off-diagonal 
!c                                connections)
!c           iend               = pointer (end)
!c           istart             = pointer (start) 
!c           jvol               = pointer (column in 1d-scalar 
!c                                matrix)
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit
!c                                search
!c
!c external: fluxvs    = water flux at interface for variably
!c                       saturated conditions
!c           fluxfs    = water flux at interface for fully
!c                       saturated conditions
!c ----------------------------------------------------------------------
 
      real*8 function bdryflux(ivol)
 
      use parm
      use gen
      use phys, only : is_cell_based_relp
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
 
#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols, num_edge_maxcells
      use gradient_usg, only : gradient_cross_diff
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxvs_usg, only : fluxvs_usg
      use mod_fluxfs_usg, only : fluxfs_usg
#endif
      implicit none
      
      integer :: i1, ibvs, icon, istart, iend, ivol, jvol, kvol
      
      real*8, external :: fluxvs, fluxfs

#ifdef USG
      integer :: i2, icell, idvol, ndvol, ncell, nrelp
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_flow_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_flow_locs(num_crossdifficv_max),             &
                     grad_flow_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_flow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif
      
      real*8 :: vsflux_loc
      character*1 :: iups_loc

      real*8, parameter :: r0 = 0.0d0, r2 = 2.0d0, r3 = 3.0d0

      bdryflux = r0             !initialize boundary flux
      ibvs = ivol2bvs(ivol)
      
      if (ibvs == 0) then
        return
      end if

!      if (ibvs == 0) then
!        if (rank == 0) then  
!          write(ilog,*) ' warning .....................'
!          write(ilog,*) ' no water flux across boundary'
!          !write(igen,*) ' warning .....................'
!          !write(igen,*) ' no water flux across boundary'
!        end if
!#ifdef PETSC
!        call petsc_mpi_finalize
!#endif
!        stop
!      end if

!c  compute water flux across boundary

!c  fluxes at first type control volumes or zero pressure seepage
!c  control volumes

      if ((btypevs(ibvs).eq.'first').or.              & !first type (Dirichlet)
          (btypevs(ibvs).eq.'idle').or.               & !first type (Dirichlet), flow through control volume
          ((btypevs(ibvs).eq.'seepage'.or.            &
            btypevs(ibvs).eq.'seepage-second').and.   & !first type (seepage)
            ibits(seepage_bits(ibvs),0,1).eq.1)) then

        istart = iavs(ivol)+1     !pointer - start of row
        iend = iavs(ivol+1)-1     !pointer - end of row
        icon = 0                  !counter (connections)

        do i1=istart,iend         !loop over connections

          jvol = javs(i1)         !column pointer
          icon = icon+1           !counter (connections)

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

!c  consistent with upstream weighting
          if (upstream) then
            iups_loc = 'i'                           !h_i >= h_j
            if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
              iups_loc = 'j'
            end if
          end if

!c  water flux calculations

          if (b_use_fixed_flow_vel) then

            if (b_use_zero_flow_vel) then
              vsflux_loc = r0
            else
              !c TBD
            end if

          else

            if (variably_saturated) then
#ifdef USG
              if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                grad_flow_mids = vector_zero
                flux_flow_hls_corr = r0

                if (b_use_cross_diffusion_flow) then
                  call gradient_cross_diff(i1,ivol,jvol,hhead,         &
                                grad_flow_locs,grad_flow_mids,         &
                                grad_weights,flux_flow_hls_corr,       &
                                grad_flow_hls_loc)
                end if

!cdsu calculate influence coefficient for variable saturated flow
                call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                             cinfvs_usg_cross_loc)

                relps_loc = 0.0d0
                if (is_cell_based_relp) then
                  nrelp = ncell
                  do icell = 1, ncell
                    i2 = jacell(icell,i1)
                    if (i2 > 0) then
                      relps_loc(icell) = relperm(i2)
                    end if
                  end do
                else
                  nrelp = 2
                  relps_loc(1:2) = (/relperm(ivol),relperm(jvol)/)
                end if

                vsflux_loc = -fluxvs_usg(upstream,hhead(ivol),hhead(jvol),        &
                                   num_edge_dvols,ncell,                          &
                                   grad_flow_mids(1:num_edge_dvols,1:ncell),      &
                                   flux_flow_hls_corr(1:num_edge_dvols,1:ncell),  &
                                   is_cell_based_relp,nrelp,                      &
                                   relps_loc(1:nrelp),iups_loc,                   &
                                   cinfvs_usg_loc(1:num_edge_dvols,1:ncell),      &
                                   cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell))
              else       !structured grid or unstructured grid with VD method
#endif

                vsflux_loc = - fluxvs(upstream,                           &
                                      hhead(ivol),hhead(jvol),            &
                                      relperm(ivol),relperm(jvol),        &
                                      iups_loc,cinfvs_a(i1))
#ifdef USG
              end if
#endif

            elseif (fully_saturated) then

#ifdef USG
              if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                grad_flow_mids = vector_zero
                flux_flow_hls_corr = r0

                if (b_use_cross_diffusion_flow) then
                  call gradient_cross_diff(i1,ivol,jvol,uvsnew,        &
                                grad_flow_locs,grad_flow_mids,         &
                                grad_weights,flux_flow_hls_corr,       &
                                grad_flow_hls_loc)
                end if

!cdsu calculate influence coefficient for variable saturated flow
                call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,      &
                                             cinfvs_usg_cross_loc)

                vsflux_loc = -fluxfs_usg(uvsnew(ivol),uvsnew(jvol),            &
                              num_edge_dvols,ncell,                            &
                              grad_flow_mids(1:num_edge_dvols,1:ncell),        &
                              flux_flow_hls_corr(1:num_edge_dvols,1:ncell),    &
                              cinfvs_usg_loc(1:num_edge_dvols,1:ncell),        &
                              cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell))
              else
#endif
                vsflux_loc = - fluxfs(uvsnew(ivol),uvsnew(jvol),cinfvs_a(i1))
#ifdef USG
              end if
#endif
            end if

          end if             !not fixed zero flow velocity

          bdryflux = bdryflux + vsflux_loc

        end do                    !loop over connections

!c        write(idbg,*) 'bdryflux',bdryflux

!c  fluxes at specified flux control volumes

      elseif ((btypevs(ibvs).eq.'second') .or. &
              (btypevs(ibvs).eq.'free-drainage') .or. &
              (btypevs(ibvs).eq.'point') .or. &
              (btypevs(ibvs).eq.'seepage-second' .and. &
              ibits(seepage_bits(ibvs),1,1).eq.1)) then

        bdryflux = bcondvs(ibvs)       
       
      end if                      !boundary type (flow)
 
      return
      end
