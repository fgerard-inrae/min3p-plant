!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/mem_etr.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mem_etr
!c ------------------
!c
!c allocate memory for evapo-transpiration parameters 
!c
!c written by:      Valerie Maquere - January, 2008
!c
!c last modified:   Frederic Gerard - June, 2009
!c                  arrays initialized, except logical and character ones
!c    Celine Blitz Frayret (CBF) for Frederic Gerard, December 14, 2018
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    integer*4:
!c           ----------
!c           ilog                 = unit number, logbook file           + -
!c           nngl                 = number of control volumes           + -
!c
!c phys.f:   real*8:
!c     -------
!c           dualhcrit(nzn)       = h value for onset of increased hydr conductivity
!c           dualmag(nzn)         = scaling factor for dual permeability composite fn
!c
!c biol.F90: real*8:
!c     -------
!c           qroot(nngl)          = root water uptake for current
!c                                  control volume
!c
!c           qrootinc(nngl)       = root water uptake for current
!c                                  control volume (incremented)
!c           dqroot(nngl)         = derivative of root water uptake
!c
!c           DSU Comment - Not necessary to declare qrootinc and dqroot as global variables
!c
!c
!c           uptakefactor(nzn)    = passive uptake factor (by zone)
!c           rootlengthdens(nzn)  = root length density
!c           rld(nngl)            = root length density  in each control volume,
!c                                  read from external file
!c
!c     logical:
!c     --------
!c           BINev(nngl)          = binary matrix of track control volume
!c                                 subjected to evaporation CBF
!c           BINT(nngl)           = binary matrix of track control volume
!c                                 subjected to transpiration CBF
!c
!c local:    integer*4:
!c           ----------
!c           ierr                 = 0 -> memory allocation successful
!c
!c external: checkerr  = check for error during memory allocation
!c ----------------------------------------------------------------------

    subroutine mem_etr
 
      use parm
      use gen
      use phys
      use dual
      use biol
      
      implicit none

      integer :: ierr

      real*8, parameter :: r0 = 0.0d0
 
      external checkerr !FG added zero-x subroutine to initialize the arrays (integer and relative numbers)

!c allocate memory for material parameters read from file

      if (root_uptake) then
!c zone parameters
        allocate (h1lim(nzn), stat = ierr)
        call checkerr(ierr,'h1lim',ilog)
        h1lim = r0
        call memory_monitor(sizeof(h1lim),'h1lim',.true.)

        allocate (h1opt(nzn), stat = ierr)
        call checkerr(ierr,'h1opt',ilog)
        h1opt = r0
        call memory_monitor(sizeof(h1opt),'h1opt',.true.)

        allocate (h1field(nzn), stat = ierr)
        call checkerr(ierr,'h1field',ilog)
        h1field = r0
        call memory_monitor(sizeof(h1field),'h1field',.true.)

        allocate (rootlengthdens(nzn), stat = ierr)
        call checkerr(ierr,'rootlengthdens',ilog)
        rootlengthdens = r0
        call memory_monitor(sizeof(rootlengthdens),'rootlengthdens',.true.)
      
        allocate (uptakefactor(nzn), stat = ierr)
        call checkerr(ierr,'uptakefactor',ilog)
        uptakefactor = r0
        call memory_monitor(sizeof(uptakefactor),'uptakefactor',.true.)
      
!c DSU - Change nn to nngl for domain decomposition parallelization.
!c       nn is local nodes, nngl is local nodes and ghost nodes.
!c       For sequential version, nngl = nn

        if (.not. allocated(rld)) then
          allocate (rld(nngl), stat = ierr)
          call checkerr(ierr,'rld',ilog)
          rld = r0
          call memory_monitor(sizeof(rld),'rld',.true.)
        end if

      end if

!cdsu evaporation and transpiration fluxes - variably saturated flow
!cdsu BINev is set in binmatevap, but actually never used with other functions,
!cdsu comment this part
      !allocate (BINev(nngl), stat = ierr)
      !call checkerr(ierr,'BINev',ilog)
      !BINev = .false.               !DSU - Initialize with false

!FG not an integer => conflict      call zero_i4(BINev,nngl,1,1) ! clean array !FG april 2013, corrected. It is a binary matrix

!cdsu BINT is set in binmattransp, but actually never used with other functions,
!cdsu comment this part
      !allocate (BINT(nngl), stat = ierr)
      !call checkerr(ierr,'BINT',ilog)
      !BINT = .false.                !DSU - Initialize with false

!FG not an integer => conflict      call zero_i4(BINT,nngl,1,1) ! clean array !FG april 2013, corrected. It is a binary matrix

      !allocate (qroot(nngl), stat = ierr)
      !call checkerr(ierr,'mpropvs',ilog)
      !qroot = r0
      !call memory_monitor(sizeof(qroot),'qroot',.true.)

!c DSU Comment - Not necessary to declare qrootinc and dqroot as global variables
      !allocate (qrootinc(nngl), stat = ierr)
      !call checkerr(ierr,'mpropvs',ilog)
      !qrootinc = r0
      !call memory_monitor(sizeof(qrootinc),'qrootinc',.true.)

      !allocate (dqroot(nngl), stat = ierr)
      !call checkerr(ierr,'mpropvs',ilog)
      !dqroot = r0
      !call memory_monitor(sizeof(dqroot),'dqroot',.true.)
      
      !c rate for root respiration
      allocate(resprate(n,nzn), stat = ierr)
      call checkerr(ierr,'resprate',ilog)
      resprate = r0
      call memory_monitor(sizeof(resprate),'resprate',.true.)
      
      !c specified minimum aqueous concentration to activate solute uptake.
      allocate(totc_uptake_min(n,nzn), stat = ierr)
      call checkerr(ierr,'totc_uptake_min',ilog)
      totc_uptake_min = 0.0d0
      call memory_monitor(sizeof(totc_uptake_min),'totc_uptake_min',.true.)

      return

    end

!c extra memory allocation for node based root water uptake variables
    subroutine mem_etr_rwu
 
      use parm
      use gen
      use phys
      use dual
      use biol
      
      implicit none

      integer :: ierr

      real*8, parameter :: r0 = 0.0d0
 
      external checkerr !FG added zero-x subroutine to initialize the arrays (integer and relative numbers)

!c allocate memory for material parameters read from file

      if (root_uptake) then
!c zone parameters
        allocate (h1lim_vol(nngl), stat = ierr)
        call checkerr(ierr,'h1lim_vol',ilog)
        h1lim_vol = r0
        call memory_monitor(sizeof(h1lim_vol),'h1lim_vol',.true.)

        allocate (h1opt_vol(nngl), stat = ierr)
        call checkerr(ierr,'h1opt_vol',ilog)
        h1opt_vol = r0
        call memory_monitor(sizeof(h1opt_vol),'h1opt_vol',.true.)

        allocate (h1field_vol(nngl), stat = ierr)
        call checkerr(ierr,'h1field_vol',ilog)
        h1field_vol = r0
        call memory_monitor(sizeof(h1field_vol),'h1field_vol',.true.)
     
        allocate (uptakefactor_vol(nngl), stat = ierr)
        call checkerr(ierr,'uptakefactor_vol',ilog)
        uptakefactor_vol = r0
        call memory_monitor(sizeof(uptakefactor_vol),'uptakefactor_vol',.true.)

        allocate (satwlim_vol(nngl), stat = ierr)
        call checkerr(ierr,'satwlim_vol',ilog)
        satwlim_vol = r0
        call memory_monitor(sizeof(satwlim_vol),'satwlim_vol',.true.)

        allocate (satwfield_vol(nngl), stat = ierr)
        call checkerr(ierr,'satwfield_vol',ilog)
        satwfield_vol = r0
        call memory_monitor(sizeof(satwfield_vol),'satwfield_vol',.true.)

        allocate (satwopt_vol(nngl), stat = ierr)
        call checkerr(ierr,'satwopt_vol',ilog)
        satwopt_vol = r0
        call memory_monitor(sizeof(satwopt_vol),'satwopt_vol',.true.)

        allocate (alpha_vol(nngl), stat = ierr)
        call checkerr(ierr,'alpha_vol',ilog)
        alpha_vol = r0
        call memory_monitor(sizeof(alpha_vol),'alpha_vol',.true.)

        allocate (v_prop_vol(nngl), stat = ierr)
        call checkerr(ierr,'v_prop_vol',ilog)
        v_prop_vol = r0
        call memory_monitor(sizeof(v_prop_vol),'v_prop_vol',.true.)
      
!c DSU - Change nn to nngl for domain decomposition parallelization.
!c       nn is local nodes, nngl is local nodes and ghost nodes.
!c       For sequential version, nngl = nn
        if (.not.allocated(rld)) then
          allocate (rld(nngl), stat = ierr)
          call checkerr(ierr,'rld',ilog)
          rld = r0
          call memory_monitor(sizeof(rld),'rld',.true.)
        end if

      end if

      return

    end

!c extra memory allocation for node based root water uptake variables
    subroutine mem_etr_brf
 
      use parm
      use gen
      use phys
      use dual
      use biol
      
      implicit none

      integer :: ierr

      real*8, parameter :: r0 = 0.0d0
 
      external checkerr !FG added zero-x subroutine to initialize the arrays (integer and relative numbers)

!c allocate memory for material parameters read from file

      if (root_uptake) then

        allocate (p1_vol(nngl), stat = ierr)
        call checkerr(ierr,'p1_vol',ilog)
        p1_vol = r0
        call memory_monitor(sizeof(p1_vol),'p1_vol',.true.)

        allocate (rew0_vol(nngl), stat = ierr)
        call checkerr(ierr,'rew0_vol',ilog)
        rew0_vol = r0
        call memory_monitor(sizeof(rew0_vol),'rew0_vol',.true.)

      end if

      return

    end


