!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initopgs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initopgs
!c -------------------
!c
!c output control parameters  (global system)
!c
!c written by:      Uli Mayer - May 12, 96 
!c
!c last modified:   Uli Mayer - November 25, 96
!c                  Tom Henderson - March 11, 04
!c
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           ------- 
!c           elevmax            = max. elevation in solution domain   + -
!c           gs_tout(ngs)       = specified output times for          * +
!c                                contour data
!c           smass(nmb)         = total mass of selected species in   * +
!c                                aqueous phase [moles]
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           tfinal             = final solution time                 + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           itmp               = unit number, temporary storage      + -
!c           ngb                = number of output locations for      * +
!c                                transient data
!c           ngb_step           = number of time steps between        * +
!c                                output of transient data
!c           ngb_vol(ngb)       = number of control volumes for       * +
!c                                output of transient data
!c           ngs                = number of output times for          * +
!c                                contour data
!c           nmb                = number of selected species          * +
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c
!c           logical:
!c           --------
!c           depth_output       = .true.  -> output in terms of       + -
!c                                           depth instead of
!c                                           elevation
!c           extended_output_gs = .true.  -> extended output of       * +
!c                                           contour data for
!c                                           reaction-transport
!c                                           simulation
!c                                .false. -> basic output of
!c                                           contour data for
!c                                           for reaction-transport
!c                                           simulation
!c           gb_output          = .true.  -> output of transient data * +
!c           gs_output          = .true.  -> output of contour data   * +
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           tec_header         = .true.  -> write header for tecplot * +
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c
!c           character:
!c           ----------
!c           namemb(nmb)        = names of selected species           * +
!c           section_header     = section header                      * +
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c
!c chem.f:   real*8:
!c           -------
!c           phimin_out(nm)     = cutoff mineral volume fractions     * +
!c                                for output
!c
!c           integer*4:
!c           ----------
!c           nc                 = number of components                + -
!c           nm                 = number of minerals                  + -
!c           nx                 = number of aqueous complexes         + -
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           namem(nm)          = mineral names                       + -
!c           namex(nx)          = names of aqueous complexes          + -
!c
!c local:    real*8:
!c           -------
!c           small              = small increment
!c           tiny               = tiny increment
!c           zout               = output for z-coordinate in terms
!c                                depth or elevation
!c
!c           integer*4:
!c           ----------
!c           nread              = pointer
!c           i                  = counter
!c           ic                 = counter (components)
!c           ierr               = 0 -> memory allocation successful
!c           igb                = counter (number of spatial
!c                                output locations)
!c           igs                = counter (number of output times 
!c                                for contour data)
!c           im                 = counter (minerals)
!c           istart             = pointer
!c           istop              = pointer
!c           imb                = counter (selected species)
!c           ix                 = counter (aqueous complexes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found              = .true.  -> exit search loop
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           findstrg  = find text string in file
!c           readbloc  = read section of input file and write to 
!c                       temporary file
!c           rsort     = sort real*8 array entries in increasing 
!c                       order
!c           zoutput   = assign depth coordinate in terms of depth
!c                       or elevation
!c ----------------------------------------------------------------------
 
      subroutine initopgs

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use nobleGasIngrowth
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use usg_mesh_data, only : nodes, is_boundary_node, cell_projection
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box
#endif

      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: i, info_debug, l_string, ierr, im, istart, istop,     &
                 igb, igs, ivx, ivy, ivz, ivol, idum, itemp_vol,       &
                 imb, ic, icur, ix, i1, icount, ii, iiso, inic, izn,   &
                 ilink, ierrcd
      real*8 :: xcoord, ycoord, zcoord,                                &
                dist_x, dist_y, dist_z, dist_min, dist, zout,          &
                xcoord2(2), ycoord2(2), zcoord2(2),                    &
                xpmin, xpmax, ypmin, ypmax, zpmin, zpmax
      
      real*8 :: isodeltat(100)

      real*8, external :: zoutput

      external checkerr, findstrg, readbloc, rsort

      logical found, found_section, found_subsection, use_coord
      character*72 subsection
      
#ifdef PETSC
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer*4 :: mpireduce_irank
      PetscErrorCode :: ierrcode
#endif

      integer, parameter :: nread = 4
      real*8, parameter :: small = 1.0d-10,tiny = 1.0d-300,            &
                           small_spatial = 1.0d-6,                     &
                           r0=0.0d0, rhalf = 0.5d0, r1 = 1.0d0

      ierrcd = 0
      
      info_debug = 0
 
!c  read output control parameters and write to temporary file   
   
      section_header = 'output control'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for output control parameters 

      skip_time_gb = .false.
      b_output_restart = .false.
      b_disable_flush = .false.
      b_output_binary = .false.
      b_output_trans_binary = .false.
      b_output_mpiio_single = .true.
      b_output_separate_mesh_result = .false.      
      hdf5_compress_level = 0


      if (nprcs > 1) then
        b_output_multizone = .false.
      else
        b_output_multizone = .true.  
      end if
      
      depth_output = .false.
      gs_output = .false.
      extended_output_gs = .true.
      extended_output_gb = .true.
      combined_gst_gsb_output = .false.
      use_coord = .false.
      ngs = 1      
      allocate (gs_tout(ngs), stat = ierr)
      gs_tout=0.0d0
      call checkerr(ierr,'gs_tout',ilog)
      call memory_monitor(sizeof(gs_tout),'gs_tout',.true.)

      gs_tout(1) = tfinal/time_factor
      gb_output = .false.
      gb_output_faceflux = .false.
      tec_header = .true.
      nmb = 0
      do im = 1,nm
        phimin_out(im) = tiny
      end do

!c  read output control parameters 

      if (found_section) then

        gs_output = .true.

        !c output restarts after restart
        if (restart_sim) then
          subsection = 'output spatial data after restart'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            b_output_restart = .true.
          end if
        end if

          
        subsection = 'use binary format'  
        call findstrg(subsection,itmp,found_subsection)
#ifdef PETSC
        if (found_subsection) then
          b_output_binary = .true.
          b_output_trans_binary = .true.
          tec_header = .true.
        else
#endif
          if (found_subsection) then
            if (rank == 0) then
              write(ilog,'(a)') 'Binary output is only available when built with MPI'
            end if
          end if
          b_output_binary = .false.
          b_output_trans_binary = .false.
          b_output_mpiio_single = .false.
#ifdef PETSC
        end if
#endif

        subsection = 'use double precision'  
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ascii_fmt = '(1000(1pe25.17e3))'
          ascii_fmt_iir = '(2(i10,1x),1000(1pe25.17e3))'
        else
          ascii_fmt = '(1000(1pe15.6e3))'
          ascii_fmt_iir = '(2(i10,1x),1000(1pe15.6e3))'
        end if
        
        if (.not.varsat_flow .and. .not.reactive_transport) then
          return  
        end if

#ifdef PETSC
        subsection = 'use separated file for spatial subdomain output' 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_output_mpiio_single = .false.
        end if
#else
        b_output_mpiio_single = .true.
#endif

#ifdef PETSC
        subsection = 'use multizone data format for spatial output'  
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_output_multizone = .true.
        end if 
#else
        b_output_multizone = .true.
#endif

#ifdef PETSC
        subsection = 'use ascii data format for transient output'  
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_output_trans_binary = .false.
        end if 

        !c appending transient output only works for ascii format
        if (b_output_trans_binary .and. i_append_sim > 0) then
          if (rank == 0) then
            write(*,'(2a)') 'Error: please use ascii data format',     &
              ' for transient output when results need to be appended' 
            write(ilog,'(2a)') 'Error: please use ascii data format',  &
              ' for transient output when results need to be appended' 
          end if

          call petsc_mpi_finalize
          stop

        end if
#endif

#ifdef PETSC
        subsection = 'use separated mesh and result data'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_output_separate_mesh_result = .true.
        end if
#endif

#ifdef PETSC
        subsection = 'compression level of result data'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 1
          read(itmp,*,err=999,end=999) hdf5_compress_level
          if (hdf5_compress_level < 0) then
            hdf5_compress_level = 0
          else if (hdf5_compress_level > 9) then
            hdf5_compress_level = 9
          end if
        end if

        !cdsu compression of hdf5 data requires HDF1.10.x version and later,
        !cdsu which is included in PETSc-3.11.x dev version or future PETSc-3.12.x version
        !cdsu here we disable hdf5 compression since parallel I/O does not support for early hdf5 version
#if (PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR < 11)
        hdf5_compress_level = 0
#elif (PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR == 11 && PETSC_VERSION_RELEASE > 0)
        hdf5_compress_level = 0
#endif

#endif

#ifdef WINDOWS
        !!!bug report, by DSU, 20160324: for the Windows version, binary output using  
        !!!MPI_TYPE_CREATE_SUBARRAY is not supported, in this case, use multizone format
        !!!to avoid using this function
        if (b_output_binary .and. .not.b_output_multizone) then
          b_output_multizone = .true.
          if (rank == 0 .and. b_enable_output) then
            write(*,'(a)') "Warning: MPI I/O output to single zone under Windows is not supported." 
            write(*,'(a)') "         Change the output to multiple zones" 
            write(ilog,'(a)') "Warning: MPI I/O output to single zone under Windows is not supported." 
            write(ilog,'(a)') "         Change the output to multiple zones" 
          end if
        end if
#endif

        subsection = 'output in terms of depth'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          depth_output = .true.
        end if

!c  optional use of coordinates for transient output of data

        subsection = 'coordinate output'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          use_coord = .true.
        end if

        subsection = 'define output locations as coordinates'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          use_coord = .true.
        end if

        subsection = 'disable external flush'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_disable_flush = .true.
        end if        
        
        
!c  activity coefficient output
        if (reactive_transport) then
          subsection = 'output activity coefficients'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            b_output_activity = .true.
          else
            b_output_activity = .false.
          end if
        end if

!c  spatial data
!c ---------------------------------------------------------------------- 

        if (reactive_transport.or.transient_flow) then

!c  extended ouput for spatial data
!c ---------------------------------------------------------------------- 

          if (reactive_transport) then

            subsection = 'limited output of spatial data'
  
            call findstrg(subsection,itmp,found_subsection)
  
            if (found_subsection) then
              extended_output_gs = .false.
            end if
  
          end if          

          subsection = 'output of spatial data'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            gs_output = .true.

!c  number of output times

            ierrcd = 2
            read(itmp,*,err=999,end=999) ngs
            
            call memory_monitor(-sizeof(gs_tout),'gs_tout',.true.)
            deallocate(gs_tout, stat = ierr)
            call checkerr(ierr,'gs_tout',ilog)

            allocate (gs_tout(ngs+1), stat = ierr)  !THH patch
            gs_tout=0.0d0 
            call checkerr(ierr,'gs_tout',ilog)
            call memory_monitor(sizeof(gs_tout),'gs_tout',.true.)

!c  output times

            do i = 1,ngs,nread

              istart = i
              istop = i+nread-1
              if (istop.gt.ngs) then
                istop = ngs
              end if
              ierrcd = 3
              read(itmp,*,err=999,end=999) (gs_tout(igs),     &
     &                                      igs=istart,istop)
            end do

!c  exit program, if specified output time > final solution time

            do igs = 1,ngs
              if (gs_tout(igs).gt.tfinal/time_factor+small) then
                if (rank == 0) then  
                  write(ilog,*) 'ABNORMAL EXIT from initopgs'
                  write(ilog,*) 'specified output time ',           &
     &                          'greater than final solution time' 
                  write(ilog,*) 'check section "output control" ',  &
     &                          'in input file'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end do

!c  exit program, if specified output time is not in incremental order

            do igs = 2,ngs
              if (gs_tout(igs) .le. gs_tout(igs-1)) then
                if (rank == 0) then
                  write(ilog,*) 'ABNORMAL EXIT from initopgs'
                  write(ilog,*) 'specified output time ',           &
     &                          'is not in incremental order'
                  write(ilog,*) 'check section "output control" ',  &
     &                          'in input file'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end do

!c  sort output times in increasing order

            call rsort(gs_tout,ngs)

!c  add output time, if last output time < final solution time
!c  this block crashed August 20, 02

            if (ngs > 0) then
              if (gs_tout(ngs).lt.tfinal/time_factor-small) then
                 ngs = ngs+1
                 gs_tout(ngs) = tfinal/time_factor         !THH - different from original
              end if
            else
              ngs = 1
              gs_tout(ngs) = tfinal/time_factor
            end if

          end if              !(found_section)

        end if                !(reactive_transport.or.transient_flow)

!c  combined output of aqueous and sorbed concentrations
        if (reactive_transport) then

          subsection = 'combined output of aqueous and sorbed concentrations'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            combined_gst_gsb_output = .true.
          end if

        end if

!c  cutoff for mineral volume fractions
!c ---------------------------------------------------------------------- 

        subsection = 'cutoff mineral volume fractions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

!c  read in user specified value

          do im = 1,nm
            ierrcd = 4
            read(itmp,*,err=999,end=999) phimin_out(im)
          end do

        end if

!c  transient data
!c ---------------------------------------------------------------------- 

        if (reactive_transport.or.transient_flow) then

!c  extended ouput for transient data
!c ---------------------------------------------------------------------- 

          if (reactive_transport) then

            subsection = 'limited output of transient data'
  
            call findstrg(subsection,itmp,found_subsection)
  
            if (found_subsection) then
              extended_output_gb = .false.
            end if
  
          end if

          subsection = 'skip time of transient data'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            ierrcd = 20
            skip_time_gb = .true.
            read(itmp,*,err=999,end=999) skip_time_gb_start, skip_time_gb_end
            skip_time_gb_start = skip_time_gb_start*time_factor
            skip_time_gb_end = skip_time_gb_end*time_factor
          end if

          !cdsu initialize ngb_step with 1 in case output of transient data is not used.
          ngb_step = 1
          ngb_step_bk = 1

          subsection = 'output of transient data'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            gb_output = .true.
            ierrcd = 5
            read(itmp,*,err=999,end=999) ngb    !number of control volumes

            allocate (ngb_vol(ngb), stat = ierr)
            ngb_vol=0 
            call checkerr(ierr,'ngb_vol',ilog)
            call memory_monitor(sizeof(ngb_vol),'ngb_vol',.true.)
            
!c  allocate file units for binary output using mpi
                
            !allocate binary output control parameters for breakthrough data
            allocate (igbp_mpi(ngb), stat = ierr)
            igbp_mpi = -1
            call checkerr(ierr,'igbp_mpi',ilog)
            call memory_monitor(sizeof(igbp_mpi),'igbp_mpi',.true.)

            allocate (offset_igbp(ngb), stat = ierr)
            offset_igbp = 0
            call checkerr(ierr,'offset_igbp',ilog)
            call memory_monitor(sizeof(offset_igbp),'offset_igbp',.true.)

            allocate (offset_igbp_ijk(ngb), stat = ierr)
            offset_igbp_ijk = 0
            call checkerr(ierr,'offset_igbp_ijk',ilog)
            call memory_monitor(sizeof(offset_igbp_ijk),'offset_igbp_ijk',.true.)
            
            allocate (igbt_mpi(ngb), stat = ierr)
            igbt_mpi = -1
            call checkerr(ierr,'igbt_mpi',ilog)
            call memory_monitor(sizeof(igbt_mpi),'igbt_mpi',.true.)
            
            allocate (offset_igbt(ngb), stat = ierr)
            offset_igbt = 0
            call checkerr(ierr,'offset_igbt',ilog)
            call memory_monitor(sizeof(offset_igbt),'offset_igbt',.true.)

            allocate (offset_igbt_ijk(ngb), stat = ierr)
            offset_igbt_ijk = 0
            call checkerr(ierr,'offset_igbt_ijk',ilog)
            call memory_monitor(sizeof(offset_igbt_ijk),'offset_igbt_ijk',.true.)
            
            allocate (igbc_mpi(ngb), stat = ierr)
            igbc_mpi = -1
            call checkerr(ierr,'igbc_mpi',ilog)
            call memory_monitor(sizeof(igbc_mpi),'igbc_mpi',.true.)

            allocate (offset_igbc(ngb), stat = ierr)
            offset_igbc = 0
            call checkerr(ierr,'offset_igbc',ilog)
            call memory_monitor(sizeof(offset_igbc),'offset_igbc',.true.)

            allocate (offset_igbc_ijk(ngb), stat = ierr)
            offset_igbc_ijk = 0
            call checkerr(ierr,'offset_igbc_ijk',ilog)
            call memory_monitor(sizeof(offset_igbc_ijk),'offset_igbc_ijk',.true.)
            
            allocate (igbm_mpi(ngb), stat = ierr)
            igbm_mpi = -1
            call checkerr(ierr,'igbm_mpi',ilog)
            call memory_monitor(sizeof(igbm_mpi),'igbm_mpi',.true.)

            allocate (offset_igbm(ngb), stat = ierr)
            offset_igbm = 0
            call checkerr(ierr,'offset_igbm',ilog)
            call memory_monitor(sizeof(offset_igbm),'offset_igbm',.true.)

            allocate (offset_igbm_ijk(ngb), stat = ierr)
            offset_igbm_ijk = 0
            call checkerr(ierr,'offset_igbm_ijk',ilog)
            call memory_monitor(sizeof(offset_igbm_ijk),'offset_igbm_ijk',.true.)
            
            allocate (igbg_mpi(ngb), stat = ierr)
            igbg_mpi = -1
            call checkerr(ierr,'igbg_mpi',ilog)
            call memory_monitor(sizeof(igbg_mpi),'igbg_mpi',.true.)

            allocate (offset_igbg(ngb), stat = ierr)
            offset_igbg = 0
            call checkerr(ierr,'offset_igbg',ilog)
            call memory_monitor(sizeof(offset_igbg),'offset_igbg',.true.)

            allocate (offset_igbg_ijk(ngb), stat = ierr)
            offset_igbg_ijk = 0
            call checkerr(ierr,'offset_igbg_ijk',ilog)
            call memory_monitor(sizeof(offset_igbg_ijk),'offset_igbg_ijk',.true.)
            
            allocate (igbgr_mpi(ngb), stat = ierr)
            igbgr_mpi = -1
            call checkerr(ierr,'igbgr_mpi',ilog)
            call memory_monitor(sizeof(igbgr_mpi),'igbgr_mpi',.true.)

            allocate (offset_igbgr(ngb), stat = ierr)
            offset_igbgr = 0
            call checkerr(ierr,'offset_igbgr',ilog)
            call memory_monitor(sizeof(offset_igbgr),'offset_igbgr',.true.)

            allocate (offset_igbgr_ijk(ngb), stat = ierr)
            offset_igbgr_ijk = 0
            call checkerr(ierr,'offset_igbgr_ijk',ilog)
            call memory_monitor(sizeof(offset_igbgr_ijk),'offset_igbgr_ijk',.true.)
            
            allocate (igbi_mpi(ngb), stat = ierr)
            igbi_mpi = -1
            call checkerr(ierr,'igbi_mpi',ilog)
            call memory_monitor(sizeof(igbi_mpi),'igbi_mpi',.true.)

            allocate (offset_igbi(ngb), stat = ierr)
            offset_igbi = 0
            call checkerr(ierr,'offset_igbi',ilog)
            call memory_monitor(sizeof(offset_igbi),'offset_igbi',.true.)

            allocate (offset_igbi_ijk(ngb), stat = ierr)
            offset_igbi_ijk = 0
            call checkerr(ierr,'offset_igbi_ijk',ilog)
            call memory_monitor(sizeof(offset_igbi_ijk),'offset_igbi_ijk',.true.)
            
            allocate (igbb_mpi(ngb), stat = ierr)
            igbb_mpi = -1
            call checkerr(ierr,'igbb_mpi',ilog)
            call memory_monitor(sizeof(igbb_mpi),'igbb_mpi',.true.)

            allocate (offset_igbb(ngb), stat = ierr)
            offset_igbb = 0
            call checkerr(ierr,'offset_igbb',ilog)
            call memory_monitor(sizeof(offset_igbb),'offset_igbb',.true.)

            allocate (offset_igbb_ijk(ngb), stat = ierr)
            offset_igbb_ijk = 0
            call checkerr(ierr,'offset_igbb_ijk',ilog)
            call memory_monitor(sizeof(offset_igbb_ijk),'offset_igbb_ijk',.true.)
            
            allocate (igbs_mpi(ngb), stat = ierr)
            igbs_mpi = -1
            call checkerr(ierr,'igbs_mpi',ilog)
            call memory_monitor(sizeof(igbs_mpi),'igbs_mpi',.true.)

            allocate (offset_igbs(ngb), stat = ierr)
            offset_igbs = 0
            call checkerr(ierr,'offset_igbs',ilog)
            call memory_monitor(sizeof(offset_igbs),'offset_igbs',.true.)

            allocate (offset_igbs_ijk(ngb), stat = ierr)
            offset_igbs_ijk = 0
            call checkerr(ierr,'offset_igbs_ijk',ilog)
            call memory_monitor(sizeof(offset_igbs_ijk),'offset_igbs_ijk',.true.)
            
            allocate (igbv_mpi(ngb), stat = ierr)
            igbv_mpi = -1
            call checkerr(ierr,'igbv_mpi',ilog)
            call memory_monitor(sizeof(igbv_mpi),'igbv_mpi',.true.)

            allocate (offset_igbv(ngb), stat = ierr)
            offset_igbv = 0
            call checkerr(ierr,'offset_igbv',ilog)
            call memory_monitor(sizeof(offset_igbv),'offset_igbv',.true.)

            allocate (offset_igbv_ijk(ngb), stat = ierr)
            offset_igbv_ijk = 0
            call checkerr(ierr,'offset_igbv_ijk',ilog)
            call memory_monitor(sizeof(offset_igbv_ijk),'offset_igbv_ijk',.true.)
            
            allocate (igbd_mpi(ngb), stat = ierr)
            igbd_mpi = -1
            call checkerr(ierr,'igbd_mpi',ilog)
            call memory_monitor(sizeof(igbd_mpi),'igbd_mpi',.true.)

            allocate (offset_igbd(ngb), stat = ierr)
            offset_igbd = 0
            call checkerr(ierr,'offset_igbd',ilog)
            call memory_monitor(sizeof(offset_igbd),'offset_igbd',.true.)

            allocate (offset_igbd_ijk(ngb), stat = ierr)
            offset_igbd_ijk = 0
            call checkerr(ierr,'offset_igbd_ijk',ilog)
            call memory_monitor(sizeof(offset_igbd_ijk),'offset_igbd_ijk',.true.)
            
            allocate (igbx_mpi(ngb), stat = ierr)
            igbx_mpi = -1
            call checkerr(ierr,'igbx_mpi',ilog)  
            call memory_monitor(sizeof(igbx_mpi),'igbx_mpi',.true.)

            allocate (offset_igbx(ngb), stat = ierr)
            offset_igbx = 0
            call checkerr(ierr,'offset_igbx',ilog)
            call memory_monitor(sizeof(offset_igbx),'offset_igbx',.true.)

            allocate (offset_igbx_ijk(ngb), stat = ierr)
            offset_igbx_ijk = 0
            call checkerr(ierr,'offset_igbx_ijk',ilog)
            call memory_monitor(sizeof(offset_igbx_ijk),'offset_igbx_ijk',.true.)
            
            allocate (igbis_mpi(ngb), stat = ierr)
            igbis_mpi = -1
            call checkerr(ierr,'igbis_mpi',ilog)
            call memory_monitor(sizeof(igbis_mpi),'igbis_mpi',.true.)

            allocate (igbmip_mpi(ngb), stat = ierr)
            igbmip_mpi = -1
            call checkerr(ierr,'igbmip_mpi',ilog)
            call memory_monitor(sizeof(igbmip_mpi),'igbmip_mpi',.true.)

            allocate (igbroot_mpi(ngb), stat = ierr)
            igbroot_mpi = -1
            call checkerr(ierr,'igbroot_mpi',ilog)
            call memory_monitor(sizeof(igbroot_mpi),'igbroot_mpi',.true.)

            allocate (offset_igbis(ngb), stat = ierr)
            offset_igbis = 0
            call checkerr(ierr,'offset_igbis',ilog)
            call memory_monitor(sizeof(offset_igbis),'offset_igbis',.true.)

            allocate (offset_igbis_ijk(ngb), stat = ierr)
            offset_igbis_ijk = 0
            call checkerr(ierr,'offset_igbis_ijk',ilog)
            call memory_monitor(sizeof(offset_igbis_ijk),'offset_igbis_ijk',.true.)

            allocate (offset_igbmip(ngb), stat = ierr)
            offset_igbmip = 0
            call checkerr(ierr,'offset_igbmip',ilog)
            call memory_monitor(sizeof(offset_igbmip),'offset_igbmip',.true.)

            allocate (offset_igbroot(ngb), stat = ierr)
            offset_igbroot = 0
            call checkerr(ierr,'offset_igbroot',ilog)
            call memory_monitor(sizeof(offset_igbroot),'offset_igbroot',.true.)

            allocate (igbac_mpi(ngb), stat = ierr)
            igbac_mpi = -1
            call checkerr(ierr,'igbac_mpi',ilog)
            call memory_monitor(sizeof(igbac_mpi),'igbac_mpi',.true.)

            allocate (offset_igbac(ngb), stat = ierr)
            offset_igbac = 0
            call checkerr(ierr,'offset_igbac',ilog)
            call memory_monitor(sizeof(offset_igbac),'offset_igbac',.true.)

            allocate (offset_igbac_ijk(ngb), stat = ierr)
            offset_igbac_ijk = 0
            call checkerr(ierr,'offset_igbac_ijk',ilog)
            call memory_monitor(sizeof(offset_igbac_ijk),'offset_igbac_ijk',.true.)

!cdsu concentration of radioelement related to noble gas ingrowth
            if (b_use_ngi .and. ngre_i > 0) then
              allocate (conc_ngre_loc(ngre_i), stat = ierr)
              conc_ngre_loc = r0
              call checkerr(ierr,'conc_ngre_loc',ilog)
              call memory_monitor(sizeof(conc_ngre_loc),'conc_ngre_loc',.true.)

              allocate (igbre_mpi(ngb), stat = ierr)
              igbre_mpi = -1
              call checkerr(ierr,'igbre_mpi',ilog)
              call memory_monitor(sizeof(igbre_mpi),'igbre_mpi',.true.)
            end if

            allocate (offset_igbre(ngb), stat = ierr)
            offset_igbre = 0
            call checkerr(ierr,'offset_igbre',ilog)
            call memory_monitor(sizeof(offset_igbre),'offset_igbre',.true.)

            allocate (offset_igbre_ijk(ngb), stat = ierr)
            offset_igbre_ijk = 0
            call checkerr(ierr,'offset_igbre_ijk',ilog)
            call memory_monitor(sizeof(offset_igbre_ijk),'offset_igbre_ijk',.true.)
            
!c  number of time steps between output 
            ierrcd = 6
            read(itmp,*,err=999,end=999) ngb_step

            ngb_step_bk = ngb_step
            if (skip_time_gb) then              
              ngb_step = 2147483647 
            end if

!c  assign control volume using user specified xyz coordinates
!c  assumes level model domain

            if (use_coord) then

              do igb = 1,ngb
                ierrcd = 7
                read(itmp,*,err=999,end=999) xcoord,ycoord,zcoord

                !c new method, loop over all nodes
                dist_x = xg(1) - xcoord
                dist_y = yg(1) - ycoord
                dist_z = zg(1) - zcoord
                dist_min = dist_x*dist_x+dist_y*dist_y+dist_z*dist_z !just compare, not necessary to do sqrt
                ngb_vol(igb) = 1

                do ivol = 2, nngl
                  dist_x = xg(ivol) - xcoord
                  dist_y = yg(ivol) - ycoord
                  dist_z = zg(ivol) - zcoord
                  dist = dist_x*dist_x+dist_y*dist_y+dist_z*dist_z   !just compare, not necessary to do sqrt
                  if(dist < dist_min) then
                    dist_min = dist
                    ngb_vol(igb) = ivol
                  end if
                end do

#ifdef PETSC
                !c find the subdomain with closest vertex
                mpireduce_in(1) = dist_min    !returns the reduced value
                mpireduce_in(2) = rank        !returns the rank of process that owns it
                call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                                   MPI_2DOUBLE_PRECISION,MPI_MINLOC,             &
                                   Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)

                dist_min = mpireduce_out(1)
                mpireduce_irank = int(mpireduce_out(2))

                !c keep the subdomain with the closest vertex found
                if (rank /= mpireduce_irank) then
                  ngb_vol(igb) = -1
                end if
#endif

              end do !igb = 1,ngb

            else !read control volume numbers directly

              do i = 1,ngb,nread

                istart = i
                istop = i+nread-1
                if (istop.gt.ngb) then
                  istop = ngb
                end if
                ierrcd = 8
                read(itmp,*,err=999,end=999) (ngb_vol(igb),           &
     &                                      igb=istart,istop)

              end do
              
!c  convert global node number to local node number
#ifdef PETSC
              info_debug = 0
#ifdef DEBUG
              if(info_debug > 0) then
                  write(idbg,'(a)') "output of transient data mapping"
              end if
#endif
                  
              do igb = 1,ngb
                itemp_vol = ngb_vol(igb)
                ngb_vol(igb) = -1
                do ivol = 1, nngl
                    if(node_idx_lg2l(ivol) > 0 .and.                   &
                       node_idx_lg2g(ivol) == itemp_vol) then
                         ngb_vol(igb) = ivol
                         exit
                    end if
                end do                

#ifdef DEBUG
                if (info_debug > 0) then
                  if(ngb_vol(igb) > 0) then  
                    write(idbg,'(2(a,1x,i6,1x))')                      &  
                      "local volume number",ngb_vol(igb),              &
                      "global volume number", node_idx_lg2g(ngb_vol(igb))
                  end if
                end if
#endif
              end do
#endif     
            end if !(use_coord)
            
!c  check array dimensions

            do igb = 1,ngb
              if (ngb_vol(igb).gt.nngl) then
                if (rank == 0) then  
                  write(ilog,*) 'ABNORMAL EXIT from initopgs'
                  write(ilog,*) 'ngb_vol > nn'
                  write(ilog,*) 'check section "output control" ',     &
     &                          'in input file'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end do

          end if              !(found_subsection)
       
!c  output for total flux/mass through specified interface
!c ----------------------------------------------------------------------
          subsection = 'output of transient data for interface fluxes'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection .and. discretization_type == 0) then

            gb_output_faceflux = .true.
            ierrcd = 9
            read(itmp,*,err=999,end=999) ngb_ijface    !number of control volumes

            allocate (ngb_vol_ijface(2,ngb_ijface), stat = ierr)
            ngb_vol_ijface = 0 
            call checkerr(ierr,'ngb_vol_ijface',ilog)  
            call memory_monitor(sizeof(ngb_vol_ijface),'ngb_vol_ijface',.true.)
            
            allocate (ngb_vol_ijface_jtemp(ngb_ijface), stat = ierr)
            ngb_vol_ijface_jtemp = 0 
            call checkerr(ierr,'ngb_vol_ijface_jtemp',ilog) 
            call memory_monitor(sizeof(ngb_vol_ijface_jtemp),'ngb_vol_ijface_jtemp',.true.)
            
            allocate (ngb_vol_ijface_area(ngb_ijface), stat = ierr)
            ngb_vol_ijface_area = 0.0d0
            call checkerr(ierr,'ngb_vol_ijface_area',ilog) 
            call memory_monitor(sizeof(ngb_vol_ijface_area),'ngb_vol_ijface_area',.true.)
            
            allocate (ngb_vol_ijface_velratio(3,ngb_ijface), stat = ierr)
            ngb_vol_ijface_velratio = 0.0d0
            call checkerr(ierr,'ngb_vol_ijface_velratio',ilog) 
            call memory_monitor(sizeof(ngb_vol_ijface_velratio),'ngb_vol_ijface_velratio',.true.)
               
!allocate binary output control parameters for breakthrough data
!currently not supported

!c  number of time steps between output 
            ierrcd = 10
            read(itmp,*,err=999,end=999) ngb_step_ijface

!c  assign control volume using user specified xyz coordinates
!c  assumes level model domain

            if (use_coord) then
             
              do igb = 1,ngb_ijface
                ierrcd = 11
                read(itmp,*,err=999,end=999) xcoord2(1),ycoord2(1),zcoord2(1), &
                                             xcoord2(2),ycoord2(2),zcoord2(2)
              
                do ilink = 1, 2
                  xcoord = xcoord2(ilink)
                  ycoord = ycoord2(ilink)
                  zcoord = zcoord2(ilink)              
                  
                  !c new method, loop over all nodes
                  dist_x = xg(1) - xcoord
                  dist_y = yg(1) - ycoord
                  dist_z = zg(1) - zcoord
                  dist_min = dist_x*dist_x+dist_y*dist_y+dist_z*dist_z !just compare, not necessary to do sqrt
                  ngb_vol_ijface(ilink,igb) = 1

                  do ivol = 2, nngl
                    dist_x = xg(ivol) - xcoord
                    dist_y = yg(ivol) - ycoord
                    dist_z = zg(ivol) - zcoord
                    dist = dist_x*dist_x+dist_y*dist_y+dist_z*dist_z   !just compare, not necessary to do sqrt
                    if(dist < dist_min) then
                      dist_min = dist
                      ngb_vol_ijface(ilink,igb) = ivol
                    end if
                  end do

#ifdef PETSC
                  !c find the subdomain with closest vertex
                  mpireduce_in(1) = dist_min    !returns the reduced value
                  mpireduce_in(2) = rank        !returns the rank of process that owns it
                  call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,   &
                                     MPI_2DOUBLE_PRECISION,MPI_MINLOC, &
                                     Petsc_Comm_World,ierrcode)
                  CHKERRQ(ierrcode)

                  dist_min = mpireduce_out(1)
                  mpireduce_irank = int(mpireduce_out(2))

                  !c keep the subdomain with the closest vertex found
                  if (rank /= mpireduce_irank) then
                    ngb_vol_ijface(ilink,igb) = -1
                  end if
#endif
                end do
              end do !igb = 1,ngb_ijface

            else !read control volume numbers directly

              do i = 1,ngb_ijface,nread                               !maximum nread pair every line, 8 number here

                istart = i
                istop = i+nread-1
                if (istop.gt.ngb_ijface) then
                  istop = ngb_ijface
                end if
                ierrcd = 12
                read(itmp,*,err=999,end=999) ((ngb_vol_ijface(ilink,igb),ilink=1,2),&
                                              igb=istart,istop)
              end do
              
!c  convert global node number to local node number
#ifdef PETSC
              info_debug = 0
#ifdef DEBUG
              if(info_debug > 0) then
                  write(idbg,'(a)') "output of transient data mapping"
              end if
#endif
                  
              do igb = 1,ngb_ijface
                do ilink  = 1, 2
                  itemp_vol = ngb_vol_ijface(ilink,igb)
                  ngb_vol_ijface(ilink,igb) = -1
                  do ivol = 1, nngl
                    if(node_idx_lg2l(ivol) > 0 .and.                   &
                       node_idx_lg2g(ivol) == itemp_vol) then
                       ngb_vol_ijface(ilink,igb) = ivol
                      exit
                    end if
                  end do                
                  
#ifdef DEBUG      
                  if (info_debug > 0) then
                    if(ngb_vol(igb) > 0) then  
                      write(idbg,'(2(a,1x,i6,1x))')                    &  
                        "local volume number",                         &
                        ngb_vol_ijface(ilink,igb),                     &
                        "global volume number",                        &
                        node_idx_lg2g(ngb_vol_ijface(ilink,igb))
                    end if
                  end if
#endif            
                end do
              end do
#endif     
            end if !(use_coord)
            
!c  check array dimensions

            do igb = 1,ngb_ijface
              do ilink = 1, 2
                if (ngb_vol_ijface(ilink,igb).gt.nngl) then
                  if (rank == 0) then  
                    write(ilog,*) 'ABNORMAL EXIT from initopgs-3'
                    write(ilog,*) 'ngb_vol > nn'
                    write(ilog,*) 'check section "output control" ',   &
                                  'in input file'
                  end if
#ifdef PETSC    
                  call petsc_mpi_finalize
#endif          
                  stop
                end if
              end do
            end do            
          end if              !(found_subsection) 
          
        end if                !(reactive_transport or transient_flow)


!c  output for total flux/mass through specified boundary nodes
!c ----------------------------------------------------------------------
        if (varsat_flow .or. reactive_transport) then

          subsection = 'output of mass through specified boundary'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ierrcd = 13
            read(itmp,*,err=999,end=999) ntmsb

            if (ntmsb > 63) then
              if (rank == 0) then
                write(*,'(a)') "Error: maximum number of specified boundary is 63"
                write(ilog,'(a)') "Error: maximum number of specified boundary is 63"
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

            b_overlap_tmsb = .false.
            subsection = 'allow overlap in specified boundary'
            call findstrg(subsection,itmp,b_overlap_tmsb)

            if (ntmsb > 0) then
              allocate(name_tmsb(ntmsb), stat = ierr)
              name_tmsb = ''
              call checkerr(ierr,'name_tmsb',ilog)
              call memory_monitor(sizeof(name_tmsb),'name_tmsb',.true.)

              allocate(mproptmsb(nngl), stat = ierr)
              mproptmsb = 0
              call checkerr(ierr,'mproptmsb',ilog)
              call memory_monitor(sizeof(mproptmsb),'mproptmsb',.true.)
            end if

            do izn = 1, ntmsb

              subsection = 'number and name of zone'
              call findzone(subsection,itmp,found_subsection,izn,zone_name)

              if (found_subsection) then
                call readzone(itmp,icnv,ilog,zone_name,found_subsection)
              else
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone number "',izn, '" missing'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if

              name_tmsb(izn) = zone_name

              type_extent_zone = -1
              type_extent_zone_box = -1

              subsection = 'extent of zone'

              call findstrg(subsection,icnv,found_subsection)

              if (found_subsection) then
                type_extent_zone = 0
                ierrcd = 14
                read(icnv,*,err=999,end=999) xpmin,xpmax,ypmin,ypmax,  &
                                             zpmin,zpmax
              end if

#ifdef USG
              call read_zone_usg_input(icnv)
              if (type_extent_zone_box > 0) then
                ierrcd = 15
                read(icnv,*,err=999,end=999) xpmin,xpmax,ypmin,ypmax,  &
                                             zpmin,zpmax
              end if
#endif

              !c check if x dimension is valid
              if (.not.btest(cell_projection,0)) then
                xpmin = -1.0d300
                xpmax = 1.0d300
              end if
      
              !c check if y dimension is valid
              if (.not.btest(cell_projection,1)) then
                ypmin = -1.0d300
                ypmax = 1.0d300
              end if
      
              !c check if z dimension is valid
              if (.not.btest(cell_projection,2)) then
                zpmin = -1.0d300
                zpmax = 1.0d300
              end if

!c  write error information if 'extent of zone' is missing
              if (type_extent_zone < 0) then

                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error reading input file'
                  write(ilog,*) 'section "',trim(section_header),'"'
                  write(ilog,*) 'zone "', trim(zone_name),'"'
                  write(ilog,*) 'subsection "',trim(subsection),'" missing'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

              end if

              xpmin = xpmin-small_spatial
              xpmax = xpmax+small_spatial
              ypmin = ypmin-small_spatial
              ypmax = ypmax+small_spatial
              zpmin = zpmin-small_spatial
              zpmax = zpmax+small_spatial

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)
    !$omp do schedule(static)
#endif
              do ivol = 1,nngl                  !loop over control volumes

                if (((type_extent_zone==0.or.type_extent_zone_box>0) .and. &
                    (xg(ivol).gt.xpmin).and.(xg(ivol).lt.xpmax) .and.      &
                    (yg(ivol).gt.ypmin).and.(yg(ivol).lt.ypmax) .and.      &
                    (zg(ivol).gt.zpmin).and.(zg(ivol).lt.zpmax)) .or.      &
                    (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
                    ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
                  if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                    if ((btest(type_extent_zone_box,1) .and.           &
                         .not. is_boundary_node(ivol)) .or.            &
                        (btest(type_extent_zone_box,2) .and.           &
                         is_boundary_node(ivol))) then
                      cycle
                    end if
                  end if
#endif
                  if (b_overlap_tmsb) then
                    mproptmsb(ivol) = ibset(mproptmsb(ivol),izn-1)
                  else
                    mproptmsb(ivol) = 0
                    mproptmsb(ivol) = ibset(mproptmsb(ivol),izn-1)
                  end if

                end if       !(zg(ivol).gt.zpmin).and.(zg(ivol).lt.zpmax)
                             !(yg(ivol).gt.ypmin).and.(yg(ivol).lt.ypmax)
                             !(xg(ivol).gt.xpmin).and.(xg(ivol).lt.xpmax)
              end do         !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            end do           !loop over zones

            if (ntmsb > 0) then
              allocate(iatmsb(ntmsb+1), stat = ierr)
              iatmsb = 0
              call checkerr(ierr,'iatmsb',ilog)
              call memory_monitor(sizeof(iatmsb),'iatmsb',.true.)

              if(b_overlap_tmsb) then
                icount = 0
                do ivol = 1, nngl
                  do izn = 1, ntmsb
                    if (btest(mproptmsb(ivol),izn-1)) then
                      icount = icount + 1
                    end if
                  end do
                end do
              else
                icount = count(mproptmsb>0)
              end if

              if (icount > 0) then
                allocate(jatmsb(icount), stat = ierr)
                jatmsb = 0
                call checkerr(ierr,'jatmsb',ilog)
                call memory_monitor(sizeof(jatmsb),'jatmsb',.false.)

                iatmsb(1) = 1
                ii = 0
                do izn = 1, ntmsb
                  do ivol = 1, nngl
                    if (btest(mproptmsb(ivol),izn-1)) then
                      ii = ii + 1
                      jatmsb(ii) = ivol
                    end if
                  end do
                  iatmsb(izn+1) = ii + iatmsb(1)
                end do
              end if
            end if
          else
            ntmsb = 0
          end if
        else
          ntmsb = 0
        end if


!c  output for postprocessing with xmgr

        subsection = 'postprocessing with x/lmgr'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          tec_header = .false.
        end if
        
        if (b_output_binary .or. b_output_trans_binary) then
           tec_header = .true. 
        end if
        
!c_isotope
!c  read parameters for output of isotope data

        iso_output = .false.

        subsection = 'isotope output'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

!c_read number of isotope pairs
          iso_output = .true.

          !read number of isotopes component sets
          ierrcd = 16
          read(itmp,*,err=999,end=999) nip    

          allocate (isodelta(nip*10), stat = ierr)
          call checkerr(ierr,'isodelta',ilog)
          isodelta = r1
          call memory_monitor(sizeof(isodelta),'isodelta',.true.)

          allocate (iamdisoo(nip*10), stat = ierr)
          call checkerr(ierr,'iamdisoo',ilog)
          call memory_monitor(sizeof(iamdisoo),'iamdisoo',.true.)

          allocate (jamdisoo(nip*10), stat = ierr)
          call checkerr(ierr,'jamdisoo',ilog)
          call memory_monitor(sizeof(jamdisoo),'jamdisoo',.true.)

          iamdisoo(1) = 1

          do i=1,nip
            ierrcd = 17
            read(itmp,*,err=999,end=999) inic, (namet(ii),ii = 1,inic)
            read(itmp,*,err=999,end=999) (isodeltat(ii), ii=1,inic-1)    
            iamdisoo(i+1) = iamdisoo(i) + inic
            icount = 0
            do iiso = 1,inic
              ic = 0
              found = .false.
              do while ((ic.lt.nc).and.(.not.found))                    
                ic = ic+1
                if (namet(iiso).eq.namec(ic)) then
                  found = .true.
                  icount = icount+1
                  icur = iamdisoo(i)+iiso-1
                  jamdisoo(icur) = ic
                  if (iiso.gt.1) then
                    isodelta(icur) = isodeltat(iiso-1)
                  end if
                end if
              end do
            end do

            if (rank == 0 .and. b_enable_output) then
              if (icount.ne.(inic)) then
                write(ilog,'(72a)') ('-',i1=1,72)
                write(ilog,'(2a,a12,a)') 'c component ',               &
                      'listed for isotope output is missing'
                write(ilog,'(72a)') ('-',i1=1,72)
                stop
              end if
            end if
          end do
          
        end if          !(found_subsection)

!c  select species for mass balance output

        subsection = 'select species for mass balance output'

        call findstrg(subsection,itmp,found_subsection)

!c  this option is no longer used and has been passivated

        found_subsection = .false.

        if (found_subsection) then
          ierrcd = 18
          read(itmp,*,err=999,end=999) nmb

          allocate (namemb(nmb), stat = ierr)
          namemb=''
          call checkerr(ierr,'namemb',ilog)
          call memory_monitor(sizeof(namemb),'namemb',.true.)
          
          allocate (iamb(nmb), stat = ierr)
          iamb=0 
          call checkerr(ierr,'iamb',ilog)
          call memory_monitor(sizeof(iamb),'iamb',.true.)
          
          allocate (smass(nmb), stat = ierr)
          smass=0.0d0
          call checkerr(ierr,'smass',ilog)
          call memory_monitor(sizeof(smass),'smass',.true.)
          
          allocate (smass_gbl(nmb), stat = ierr)
          smass_gbl=0.0d0
          call checkerr(ierr,'smass_gbl',ilog)
          call memory_monitor(sizeof(smass_gbl),'smass_gbl',.true.)

          do imb = 1,nmb
            ierrcd = 19
            read(itmp,*,err=999,end=999) namemb(imb)
          end do

        end if           !(found_subsection)

      end if             !(found_section)
      
      if (.not.varsat_flow .and. .not.reactive_transport) then
        return  
      end if

!c  return to calling routine if appropriate

      if (.not.reactive_transport.and..not.transient_flow) then
        return
      end if

!c  write output control parameters to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  spatial data
!c ---------------------------------------------------------------------- 

      if (gs_output) then
        if (b_enable_output .and. b_enable_output_gen) then
          if (reactive_transport) then
            if (extended_output_gs) then
              write(igen,'(a/)') 'extended output of spatial data'
            else
              write(igen,'(a/)') 'limited output of spatial data'
            end if
          end if
          write(igen,'(a,i10)')                                     &
     &    'number of output times for spatial data         = ',ngs
          write(igen,'(a/)')                                        &
     &    'specified output times for spatial data:          '
          do igs = 1,ngs
            write(igen,'(a,1pe15.6e3,1x,a)') 'T = ',gs_tout(igs),time_unit
          end do
          write(igen,*) 
        end if
!c  conversion of time units for computation in days

        do igs = 1,ngs
          gs_tout(igs) = time_factor*gs_tout(igs)
        end do

      end if                 !(gs_output)

!c  transient data
!c ---------------------------------------------------------------------- 

      if (gb_output .and. b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a/)') 'output of transient data:'
        write(igen,'(a,i10)')                                          &
        'number of time steps between output of          = ',ngb_step
        write(igen,'(a,i10)')                                          &
        'number of spatial locations for output of       = ',ngb
        write(igen,'(a/)')                                             &
        'control volume numbers and spatial locations:'
        do igb = 1,ngb
          ivol = ngb_vol(igb)

!c  assign depth coordinate in terms of depth or elevation
          if(ivol > 0) then
            zout = zoutput(depth_output,zg(ivol),elevmax)
#ifdef PETSC
            write(igen,'(2(a,i10,1x),3(a,1pe15.6e3,a))')              &
     &                          'local ivol = ',ivol,                 &
     &                          'global ivol = ', node_idx_lg2g(ivol),&
     &                          ', x = ',xg(ivol),' m',               &
     &                          ', y = ',yg(ivol),' m',               &
     &                          ', z = ',zout,' m'
#else
          write(igen,'(a,i6,3(a,1pe15.6e3,a))') 'ivol = ',ivol,       &
     &                                        ', x = ',xg(ivol),' m', &
     &                                        ', y = ',yg(ivol),' m', &
     &                                        ', z = ',zout,' m'
#endif
          end if
        end do
      end if

!c  output in terms of depth or elevation

      if (nvzgl.gt.1 .and. b_enable_output .and.       &
          b_enable_output_gen) then
        if (depth_output) then
          write(igen,'(/a)') 'output in terms of depth'
        else
          write(igen,'(/a)') 'output in terms of elevation'
        end if
      end if
      
!c_isotope
!c  isotope data
!c ---------------------------------------------------------------------- 

      if (rank == 0 .and. b_enable_output .and. iso_output) then
        write(igen,'(a/)') 'output of isotope data:'
        write(igen,'(a,i10/a)')                                        &
        'number of isotope component sets = ', nip                      
                                                                        
        do i = 1, nip                                                   
            istart = iamdisoo(i)                                        
            istop = iamdisoo(i+1)-1                                     
              write(igen,'(a22,i2,a2)') 'isotope component set '       &
                       ,i, ': '                                         
              write(igen,'(a8)')                                       &
                         namec(jamdisoo(istart))                        
            do i1 = istart+1,istop                                      
                  write(igen,'(a8,f6.3)') namec(jamdisoo(i1)),         &
                         isodelta(i1)
              end do
        end do
      end if

!c  read number of selcted species for mass balance output
!c  and specify species

      if (mass_balance_rt.and.nmb.gt.0) then

!c  assign pointer array for selected species to free species
!c  and aqueous complex concentration arrays

        do imb = 1,nmb

          ic = 0
          ix = 0
          found = .false.

!c  free species

          do while (.not.found.and.ic.lt.nc-1)
            ic = ic+1
            if (namemb(imb).eq.namec(ic)) then
              found = .true.
              iamb(imb) = ic
            end if
          end do

!c  aqueous complexes 

          do while (.not.found.and.ix.lt.nx)
            ix = ix+1
            if (namemb(imb).eq.namex(ix)) then
              found = .true.
              iamb(imb) = ix+nc
            end if
          end do

!c  exit, if search was not successful

          if (.not.found) then
            if (rank == 0) then  
              write(ilog,'(72a)') ('-',i=1,72)
              write(ilog,'(a,a,a/a/a)')'species ',trim(namemb(imb)),      &
     &        ' was selected for mass balance output',                    &
     &        'this species is not part of the chemical system specified',&
     &        'stop in routine initopgs'
              write(ilog,'(72a)') ('-',i=1,72)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

        end do

      end if                  !(mass_balance_rt)

!c  outupt of total flux/mass through specified boundary
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(72a)')('-',i=1,72)
        write(igen,'(a)')                                              &
              'output of mass through specified boundary'
        write(igen,'(72a)')('-',i=1,72)

        write(igen,'(/a,i10)')                                          &
              'number of specified boundaries                 = ',ntmsb

        if (ntmsb > 0) then
          do izn = 1, ntmsb
            write(igen,'(/a,i10,2a)')                                  &
                  'specified boundary: ',izn,', name: ',               &
                  trim(name_tmsb(izn))
            write(igen,'(72a)')('-',i=1,72)
            write(igen,'(a)')                                          &
                  '  volume     x               y               z'
            do i = iatmsb(izn),iatmsb(izn+1)-1
              ivol = jatmsb(i)
              write(igen,'(i8,2x,3(1x,1pe15.6e3))')                    &
                    ivol,xg(ivol),yg(ivol),zg(ivol)
            end do
          end do
        end if
      end if
 
      goto 1000

!998   continue

      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'transient output coordinates    &                 
     &                 outside of model domain'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
