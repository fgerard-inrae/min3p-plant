!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updtbcenergybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

! ----------------------------------------------------------------------
! subroutine updtbcenergybal                                            
! -------------------                                                   
!                                                                       
! boundary conditions (variably saturated flow)                         
!                                                                       
! first type boundary conditions:                                       
! -> define zone by delineating nodes located within zone               
!                                                                       
! second type boundary condition:                                       
! -> define area (only on surface of solution domain)                   
!                                                                       
! seepage face boundary condition:                                      
! -> define area (only on surface of solution domain)                   
!                                                                       
! written by:
!
!c last modified:   -
!c
!c                  Danyang Su - Jan. 28, 2020
!c                  Unstructured grid and HPC capabilities
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!                                                                    I O
! passed:   -                                                           
!                                                                       
! common:                                                               
! gen.f:    real*8:                                                     
!           -------                                                     
!           bcondheat(nbheat)  = boundary condition                  * +
!                                temperature or heat flux                         
!           dimcv(3,nn)        = spatial dimensions of control       + -
!                                volumes                                
!           hhead(nn)          = hydraulic head                      + +
!           rwork(:,:)         = real*8 work array                   * *
!           time_bcheat        = next read time for flow boundary    * +
!                                conditions                             
!           tempold(nn)        = solution vector (old time level)    + +
!           tempnew(nn)        = solution vector (new time level)    + +
!           sec_per_days       = conversion factor from SI input     + -
!                                units for physico-chemical             
!                                parameters internal time units         
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibcheat            = unit number, transient boundary     * +
!                                             conditions,       
!                                             heat transport            
!           idat               = unit number, run specific input     + -
!                                             file                      
!           igen               = unit number, generic output file    + -
!           ilog               = unit number, log book               + -
!           itmp               = unit number, temporary storage      + -
!           iabheat(nbheat     = pointer to boundary control volumes * +
!                                for heat transport
!           iwork(:)           = integer work array                  * *
!           l_prfx             = length of prefix of I/O files       + -
!           l_zone_name        = length of zone name                 * +
!           nn                 = total number of control volumes     + -
!           nbheat             = number of specified boundary        * +
!                                control volumes                        
!                                (heat transport)              
!           nseep_first        = number of seepage face nodes        * +
!                                                                       
!           logical:                                                    
!           --------                                                    
!           update_bcheat      = .true.  -> transient boundary       * +
!                                           condition for       
!                                           heat transport
!                                                                       
!           character:                                                  
!           ----------                                                  
!           prefix             = prefix name for all I/O files       + -
!           zone_name          = name of zone                        * +
!           btypeheat(nbheat)  = boundary type array                 * +
!                                (heat transport)              
!                                'first'   = Dirichlet                  
!                                'second'  = Neumann                    
!           section_header     = section header                      * +
!                                                                       
! local:    real*8:                                                     
!           -------                                                     
!           r0                 = constant                               
!           r1                 = constant                               
!           tiny               = small increment                        
!           xbmin              = min. x-coordinate of boundary          
!                                zone                                   
!           xbmax              = max. x-coordinate of boundary          
!                                zone                                   
!           ybmin              = min. y-coordinate of boundary          
!                                zone                                   
!           ybmax              = max. y-coordinate of boundary          
!                                zone                                   
!           zbmin              = min. z-coordinate of boundary          
!                                zone                                   
!           zbmax              = max. z-coordinate of boundary          
!                                zone                                   
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibheat             = counter (boundary control volumes)     
!           ibz                = counter (zones)                        
!           ierr               = 0 -> memory allocation successful      
!           ivol               = counter (control volumes)              
!           istart             = pointer (control volume)               
!           iend               = pointer (control volume)               
!           l_string           = length of text string
!           nbzheat            = number of boundary zones               
!                                                                       
!           logical:                                                    
!           --------                                                    
!           found              = logical variable to exit search        
!           found_section      = .true.  -> section header was          
!                                           found in input file         
!           found_subsection   = .true.  -> subsection header was       
!                                           found in input file         
!           xy_plane           = boundary zone parallel tp xy-plane     
!           xz_plane           = boundary zone parallel to xz-plane     
!           yz_plane           = boundary zone parallel to yz-plane     
!                                                                       
!           character:                                                  
!           ----------                                                  
!           bcond              = btypeheat = 'first'                      
!                                -> temperature
!                                btypeheat = 'second'                     
!                                -> specified flux
!           btypezn            = boundary type of zone                  
!           subsection         = name of subsection in input file       
!                                                                       
! external: checkerr  = check for error during memory allocation        
!           findstrg  = find text string in file                        
!           findzone  = find zone in input section                      
!           readbloc  = read section of input file and write to         
!                       temporary file                                  
!           readzone  = read zone in section of input file and          
!                       write to temporary file                         
! ----------------------------------------------------------------------
                                                                        
      subroutine updtbcenergybal
                                                                        
      use parm 
      use gen 
      use dens 
      use m_heat_transport
      use math_common, only : math_common_linear
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, num_nodes_per_cell,  &
                                node_cells, node_num_cells,            &
                                cell2halfid, CellFaceCenter, cells,    &                                
                                cal_cellface_index, cell_projection,   &
                                num_faces_per_cell, CellFaceScaledNorm,&
                                is_boundary_node, num_edge_dvols,      &
                                node_to_layer_node, layer_nodes_top,   &
                                layer_nodes_bottom, CellCvolFaceArea,  &
                                get_cell_edge_cvol_id
      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#endif
      implicit none
                                                                        
      external checkerr, findstrg, findzone, readbloc, readzone
      
      real*8 :: r0, r1, tiny, r86400, r1000
      real*8 :: areaf, temp0_grad, slope_grad, factiny,                &
                bcond, xbmin, xbmax, ybmin, ybmax, zbmin, zbmax,       &
                pos_grad, timebcheatloc, dummy
      real*8 :: rx0, ry0, rz0     !center of gradient-radius type i.c. or b.c. condition
      integer :: i, ibz, ierr, istart, iend, ivol, jvol, jvol1, jvol2, &
                 l_string, jtemp, ibheat, iflag, ierrcd
      integer :: itype_grad       !0: normal, 1: bottom, 2: top (layered mesh)

      parameter (r0=0.0d0,r1=1.0d0, tiny=1.0d-5,                       &
                 r86400=86400.0d0, r1000=1000.0d0)
                                                                        
      logical :: xy_plane,xz_plane,yz_plane,found,found_section,       &
                 found_subsection,b_updt_next_only,b_updtbc_back
      character*1  :: dir_grad
      character*32 :: btypezn 
      character*72 :: subsection
      character*256 :: strbuffer
#ifdef USG
      real*8 :: ratio_flux
      integer :: icell, icell2, iface, cindex, idvol, idvol_r, iedge_r,&
                 jvol3, jvol4
      type(point) :: pts(4)
#endif
                                                                        
      ierrcd = 0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
      b_updt_next_only = .false.
      b_updtbc_back = .false.
      
      areaf = r0
      l_string = 0

      if ((.not. b_interpolation_bcheat .and.                          &
          time_io >= time_bcheat_prev .and. time_io < time_bcheat) .or.&
          time_bcheat > tfinal/time_factor) then
        return
      end if      

      if (.not. b_first_update_bcheat .and. &
         (time_io < time_bcheat_prev .or. time_io > time_bcheat)) then        
        b_updtbc_back = .true.
      end if
     
      if (time_io.ge.time_bcheat .or.                                  &
          b_restart_update_bcheat .or. b_first_update_bcheat.or.       &
          b_updtbc_recall .or. b_updtbc_back) then                                              
          
        if(rank == 0 .and. b_enable_output) then
          write(*,*) 
          write(*,*) 'update boundary conditions - energy balance'                                       
          write(*,*) ('-',i=1,72) 
          write(*,*)
                       
           write(ilog,*)                                                   
          write(ilog,'(2a)') 'update boundary conditions - energy balance'                               
          write(ilog,'(72a/)')('-',i=1,72) 
          write(ilog,*)
        end if  
                                                                        
!  read section header for boundary conditions of heat transport simulation   

        bcondheat=r0
        if(update_ext_type_bcheat) then
          do 
            section_header = 'time for boundary condition' 
            call readbloc (ibcheat1,itmp,section_header,found_section,.false.)
            if (found_section) then 
              ierrcd = 1
              read(itmp,*,err=999,end=999) timebcheatloc
              if (timebcheatloc==time_bcheat) then
                !cprovi  preliminary allocation of memory for boundary conditions
                ierrcd = 2
                read(itmp,*,err=999,end=999)
                exit 
              end if 
            else
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'time for boundary condition' 
                write(ilog,*) 'time not found:',time_bcheat 
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            end if 
          end do 
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------          
        else if (update_bcheat_value_only) then
          goto 100
        else
          section_header = 'boundary conditions - energy balance' 
          call readbloc (idat,itmp,section_header,found_section,.true.) 
        end if    
                                                                        
!  define length of section header                                      
                                                                        
        l_string = index(section_header,'  ')-1 
        if (l_string.eq.-1.or.l_string.gt.72) then 
           l_string=72 
        end if 

                                                                                                                                          
!  read number of boundary zones                                        
                                                                        
        ierrcd = 3
        read(itmp,*,err=999,end=999) nbzheat 
!c  read values of new boundary conditions
100     continue
!c  allocate array for reading new boundary conditions
        allocate (rwork(2,nbzheat), stat = ierr)
        rwork=r0 
        call checkerr(ierr,'rwork',ilog)
        call memory_monitor(sizeof(rwork),'rwork',.true.)

        allocate (rwork_next(2,nbzheat), stat = ierr)
        rwork_next=r0 
        call checkerr(ierr,'rwork_next',ilog)
        call memory_monitor(sizeof(rwork_next),'rwork_next',.true.)

!c  assign new boundary conditions for variably-saturated flow
        if (b_first_update_bcheat .and.                                &
            time_io.ge.time_bcheat_prev .and.                          &
            time_io.le.time_bcheat) then

          b_updt_next_only = b_first_update_bcheat
          backspace(ibcheat)

          read(ibcheat,*,err=998,end=997) time_bcheat_prev,            &
              (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
          do while (time_io < time_bcheat_prev)
            backspace(ibcheat)
            backspace(ibcheat)
            read(ibcheat,*,err=998,end=997) time_bcheat_prev,          &
                (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
          end do
          
          do while (time_io > time_bcheat)
            read(ibcheat,*,err=998,iostat=iflag) time_bcheat_prev,     &
                (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
            !c end of file has reached
            if (iflag < 0) then
              time_bcheat = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else    
              if (time_io < time_bcheat_prev) then
                backspace(ibcheat)
                backspace(ibcheat)
                read(ibcheat,*,err=998,end=997) time_bcheat_prev,      &
                    (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
                exit
              end if
            end if
          end do

          read(ibcheat,*,err=998,iostat=iflag) time_bcheat,            &
              (rwork_next(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat) 
          !c end of file has reached
          if (iflag < 0) then
            time_bcheat = (tfinal+delt)/time_factor
            rwork_next = rwork
          end if 
        else 
          backspace(ibcheat)
          read(ibcheat,*,err=998,end=997) time_bcheat_prev,            &
              (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)

          do while (time_io < time_bcheat_prev)
            backspace(ibcheat)
            backspace(ibcheat)
            read(ibcheat,*,err=998,end=997) time_bcheat_prev,          &
                (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
          end do
    
          do while (time_io > time_bcheat)
            read(ibcheat,*,err=998,iostat=iflag) time_bcheat_prev,     &
                (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
            !c end of file has reached
            if (iflag < 0) then
              time_bcheat = (tfinal+delt)/time_factor
              rwork_next = rwork
              exit
            else    
              if (time_io < time_bcheat_prev) then
                backspace(ibcheat)
                backspace(ibcheat)
                read(ibcheat,*,err=998,end=997) time_bcheat_prev,        &
                    (rwork(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
                exit
              end if
            end if
          end do

          if (b_interpolation_bcheat) then
            read(ibcheat,*,err=998,iostat=iflag) time_bcheat,          &
                (rwork_next(1:bzheat_nparms(ibz),ibz),ibz=1,nbzheat)
            !c end of file has reached
            if (iflag < 0) then
              time_bcheat = (tfinal+delt)/time_factor
              rwork_next = rwork
            end if
            !c backspace, time_bcheat will be read again later
            backspace(ibcheat)
          end if
        end if
                                                                       
!c  if boundary type and zone is unchanged, just update the value
!c  without reading zone and type again, DSU 2019-10-28
!c  note: actually the boundary type and zone cannot be changed in the current version
        if (update_bcheat_value_only) then

          if (nbheat > 0) then
            do ibheat = 1, nbheat
              ivol = iabheat(ibheat)

              if (ivol < 0) then
                cycle  
              end if

              btypezn = btypeheat(ibheat)
              ibz = ivol2bzheat(ivol)
              dir_grad = bzheat_dir_grad(ibz)
              if (dir_grad == 'r') then
                rx0 = bzheat_radius_center(ibz)%x
                ry0 = bzheat_radius_center(ibz)%y
                rz0 = bzheat_radius_center(ibz)%z
              end if
              itype_grad = bzheat_itype_grad(ibz)

              if (btypezn .eq. 'first' .and. bzheat_nparms(ibz) .eq. 2) then
                btypezn = 'gradient'
              end if

              if (btypezn.eq.'initial') then

                btypeheat(ibheat) = 'first'
                bcondheat(ibheat) = tempnew(ivol)

!c  first type boundary condition - constant pressure head

              elseif (btypezn.eq.'first') then
                if (b_interpolation_bcheat) then
                  if (.not.b_updt_next_only .or. b_restart_update_bcheat) then
                    bcondheat_prev(ibheat)= rwork(1,ibz)
                  end if
                  bcondheat_next(ibheat)= rwork_next(1,ibz)
  
                  bcondheat(ibheat) = math_common_linear(                &
                                           time_bcheat_prev, time_bcheat,&
                                           bcondheat_prev(ibheat),       &
                                           bcondheat_next(ibheat),time_io)
                else
                  bcondheat(ibheat)= rwork(1,ibz)
                end if
  
                if (.not. b_restart_update_bcheat) then
                  tempnew(ivol)  = bcondheat(ibheat)
                end if 

!c  gradient type boundary condition - variably temperature
              elseif (btypezn.eq.'gradient')then

#ifdef USG
                if (itype_grad == 1)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                  end select
                else if (itype_grad == 2)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                  end select
                else
#endif
                  select case(dir_grad)
                  case ('x')
                    pos_grad=xg(ivol)
                  case ('y')
                    pos_grad=yg(ivol)
                  case ('z')
                    pos_grad=zg(ivol)
                  case ('r')
                    pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                    (yg(ivol) - ry0)**2 +  &
                                    (zg(ivol) - rz0)**2)
                  end select
#ifdef USG
                end if
#endif

                if (b_interpolation_bcheat) then
                  if (.not.b_updt_next_only .or. b_restart_update_bcheat) then
                    bcondheat_prev(ibheat)= rwork(1,ibz) + rwork(2,ibz)*pos_grad
                  end if
                  bcondheat_next(ibheat)= rwork_next(1,ibz) + rwork_next(2,ibz)*pos_grad
                  bcondheat(ibheat) = math_common_linear(                &
                                           time_bcheat_prev, time_bcheat,&
                                           bcondheat_prev(ibheat),       &
                                           bcondheat_next(ibheat),time_io)
                else
                  bcondheat(ibheat)= rwork(1,ibz) + rwork(2,ibz)*pos_grad
                end if
  
                if (.not. b_restart_update_bcheat) then
                  tempnew(ivol)  = bcondheat(ibheat)
                end if
  
                !c btypeheat(ibheat) = 'first'
  
              elseif (btypezn.eq.'free'.or.btypezn.eq.'seepage') then
              
                if (b_interpolation_bcheat) then
                  if (.not.b_updt_next_only .or. b_restart_update_bcheat) then
                    bcondheat_prev(ibheat) = rwork(1,ibz)
                  end if
                  bcondheat_next(ibheat) = rwork_next(1,ibz)
  
                  bcondheat(ibheat) = math_common_linear(                &
                                           time_bcheat_prev, time_bcheat,&
                                           bcondheat_prev(ibheat),       &
                                           bcondheat_next(ibheat),time_io)
                else
                  bcondheat(ibheat) = rwork(1,ibz)
                end if
     
!c  second type boundary condition - specified flux

              elseif (btypezn.eq.'second') then

!c  assign second type boundary condition and convert to internal
!c  time units
                if (b_interpolation_bcheat) then
                  if (.not.b_updt_next_only .or. b_restart_update_bcheat) then
                    bcondheat_prev(ibheat) = areaf_bheat(ibheat)*rwork(1,ibz)/ &
                                             r1000*sec_per_days
                  end if
                  bcondheat_next(ibheat) = areaf_bheat(ibheat)*rwork_next(1,ibz)/ &
                                           r1000*sec_per_days
  
                  bcondheat(ibheat) = math_common_linear(                &
                                           time_bcheat_prev, time_bcheat,&
                                           bcondheat_prev(ibheat),       &
                                           bcondheat_next(ibheat),time_io)
                else
                  bcondheat(ibheat) = areaf_bheat(ibheat)*rwork(1,ibz)/  &
                                      r1000*sec_per_days
                end if
              elseif (btypezn.eq.'point') then
                if (b_interpolation_bcheat) then
                  if (.not.b_updt_next_only .or. b_restart_update_bcheat) then
                    bcondheat_prev(ibheat) = rwork(1,ibz)/r1000*sec_per_days
                  end if
                  bcondheat_next(ibheat) = rwork_next(1,ibz)/r1000*sec_per_days
  
                  bcondheat(ibheat) = math_common_linear(                &
                                           time_bcheat_prev, time_bcheat,&
                                           bcondheat_prev(ibheat),       &
                                           bcondheat_next(ibheat),time_io)
                else
                  bcondheat(ibheat) = rwork(1,ibz)/r1000*sec_per_days
                end if
              end if   !(btypezn.eq.'first'.or.btypezn.eq.'second')

              bcondheat0(ibheat) = bcondheat(ibheat)
            end do
          end if
          b_first_update_bcheat = .false.
          goto 500
        end if
        
 
        nbheat = 0
        ivol2bheat(:) = 0
        ivol2bzheat(:) = 0                                                                       
                                                                        
!  read name of zone                                                   
                                  !loop over number of zones            
        do ibz=1,nbzheat 

                                  !temporary pointer for output     
                                                                        
!  find current zone in input file and write to temporary file          
                                                                        
          subsection = 'number and name of zone' 
                                                                        
          call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                        
          if (found_subsection) then
            call readzone(itmp,icnv,ilog,zone_name,found_subsection) 
          end if
                                                         
!  define length of zone name                                           
                                                                        
          l_zone_name = index(zone_name,'  ')-1 
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
            l_zone_name = 72 
          end if 
                                                                        
                                                                        
!  define type and value of boundary condition                          
                                                                        
          subsection = 'boundary type' 
                                                                        
          call findstrg(subsection,icnv,found_subsection) 
                                                                        
          if (found_subsection) then
            ierrcd = 4
            read(icnv,*,err=999,end=999) btypezn 
            if(index(btypezn,'gradient') == 2) then
              btypezn = 'gradient'
              itype_grad = bzheat_itype_grad(ibz)
              dir_grad = bzheat_dir_grad(ibz)
              if (dir_grad == 'r') then
                rx0 = bzheat_radius_center(ibz)%x
                ry0 = bzheat_radius_center(ibz)%y
                rz0 = bzheat_radius_center(ibz)%z
              end if
            end if
          end if 
                                                                        
!  read coordiantes defining boundary zone,
          type_extent_zone = -1
          type_extent_zone_box = -1
                                                                        
          subsection = 'extent of zone' 

          call findstrg(subsection,icnv,found_subsection)
                                                                        
          if (found_subsection) then 

            type_extent_zone = 0                                                                        
            ierrcd = 5
            read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,      &
                                         zbmin,zbmax

          end if

#ifdef USG
          call read_zone_usg_input(icnv)
          if (type_extent_zone_box > 0) then
            ierrcd = 6
            read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,      &
                                         zbmin,zbmax
          end if
#endif

          !c check if x dimension is valid
          if (.not.btest(cell_projection,0)) then
            xbmin = -1.0d300
            xbmax = 1.0d300
          end if
        
          !c check if y dimension is valid
          if (.not.btest(cell_projection,1)) then
            ybmin = -1.0d300
            ybmax = 1.0d300
          end if
        
          !c check if z dimension is valid
          if (.not.btest(cell_projection,2)) then
            zbmin = -1.0d300
            zbmax = 1.0d300
          end if
                                                                        
!c  write error information if 'extent of zone' is missing
          if (type_extent_zone < 0) then
                   
            if (rank == 0) then  
              write(ilog,*) 'SIMULATION TERMINATED' 
              write(ilog,*) 'error reading input file' 
              write(ilog,*) 'section "',trim(section_header),'"'
              write(ilog,*) 'zone "', trim(zone_name),'"'
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
                                                                        
          end if 
                                                                        
!  define boundary face to be considered (only needed for calculation   
!  of boundary face area for second type boundary conditions)           
                                                                        
          if (type_extent_zone == 0 .and.                              &
              type_extent_zone_box <= 0 .and. btypezn.eq.'second') then
                                                                          
            found = .false. 
            xy_plane = .false. 
            xz_plane = .false. 
            yz_plane = .false. 
                                                                          
                                                    !xy_plane             
            if (dabs(zbmax-zbmin).lt.tiny) then 
              if ((dabs(xbmax-xbmin).lt.tiny).or.                      &
                  (dabs(ybmax-ybmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "', section_header(:l_string),'"' 
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face' 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                xy_plane = .true. 
                found = .true. 
              end if 
            end if 
                                                                        
                                                   !xz_plane            
            if (.not.found) then 
              if (dabs(ybmax-ybmin).lt.tiny) then 
                if ((dabs(xbmax-xbmin).lt.tiny).or.                    &
                    (dabs(zbmax-zbmin).lt.tiny)) then 
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "', section_header(:l_string),'"' 
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face' 
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                else 
                  xz_plane = .true. 
                  if (xy_plane) then
                    if (rank == 0) then  
                      write(ilog,*) 'SIMULATION TERMINATED' 
                      write(ilog,*) 'error in input file' 
                      write(ilog,*) 'section "',                       &
                                     section_header(:l_string),'"'          
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                      write(ilog,*) 'unable to specify boundary face'
                      close(ilog)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop 
                  end if 
                  found = .true. 
                end if 
              end if 
            end if 
                                                                        
                                                   !yz_plane            
            if (.not.found) then 
              if (dabs(xbmax-xbmin).lt.tiny) then 
                if ((dabs(ybmax-ybmin).lt.tiny).or.                    &
                    (dabs(zbmax-zbmin).lt.tiny)) then  
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',section_header(:l_string),'"' 
                    write(ilog,*) 'zone "',zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                else 
                  yz_plane = .true. 
                  if (xy_plane.or.xz_plane) then 
                    if (rank == 0) then
                      write(ilog,*) 'SIMULATION TERMINATED' 
                      write(ilog,*) 'error in input file' 
                      write(ilog,*) 'section "',                       &
                                     section_header(:l_string),'"'          
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                      write(ilog,*) 'unable to specify boundary face'
                      close(ilog)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop 
                  end if 
                  found = .true. 
                end if 
              end if 
            end if 
                                                                        
!  exit if boundary face was not found                                  
                                                                        
            if (.not.found) then
#ifdef USG
              if(cell_projection /= projection_xyz) then
#endif
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "', section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
#ifdef USG
              end if
#endif
            end if 

          !c define flux direction for unstructured grid
#ifdef USG
            if (discretization_type > 0 .and. type_flux_direction == 0) then
              if (xy_plane) then
                type_flux_direction = 2
                flux_direction = math_common_set_vector(0.0d0,0.0d0,1.0d0)
              else if (yz_plane) then
                type_flux_direction = 2
                flux_direction = math_common_set_vector(1.0d0,0.0d0,0.0d0)
              else if (xz_plane) then
                type_flux_direction = 2
                flux_direction = math_common_set_vector(0.0d0,1.0d0,0.0d0)
              end if
            end if
#endif
                                  !(btypezn.eq.'second')                
          end if 
                                                                        
!  increment boundary coordinates                                       
                                                                        
          xbmin = xbmin-tiny 
          xbmax = xbmax+tiny 

          ybmin = ybmin-tiny 
          ybmax = ybmax+tiny 

          zbmin = zbmin-tiny 
          zbmax = zbmax+tiny 
                                                                        
!  store type of boundary condition and boundary condition              
!  for global system in compressed storage                              
                                                                        
          do ivol = 1,nngl 
                                                                        
!  check limits of boundary zone                                        
                                                                        
            if (((type_extent_zone==0.or.type_extent_zone_box>0) .and. &
                (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.      &
                (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.      &
                (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.      &
                (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.   &
                ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
              if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                if ((btest(type_extent_zone_box,1) .and.               &
                     .not. is_boundary_node(ivol)) .or.                &
                    (btest(type_extent_zone_box,2) .and.               &
                     is_boundary_node(ivol))) then
                  cycle
                end if
              end if
#endif
                                                                        
!  assign boundary type and boundary condition                          
                                                                        
              nbheat = nbheat + 1

              iabheat(nbheat) = ivol
              btypeheat(nbheat) = btypezn
              ivol2bheat(ivol) = nbheat
              ivol2bzheat(ivol) = ibz
                                                                        
!  exit if nbheat > nn                                                    
                                                                        
              if (nbheat.gt.nngl) then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'nbheat > nn ...'
                end if
#ifdef PETSC  
                call petsc_mpi_finalize
#endif
                stop
              end if
                                                                        
                                                                       
!  first type boundary condition - constant temperature 

              if (btypezn.eq.'first') then
                bcondheat(nbheat)= rwork(1,ibz)
                if (.not. b_restart_update_bcheat) then
                  tempnew(ivol)  = rwork(1,ibz)                
                end if
             
              elseif (btypezn.eq.'free' .or. btypezn.eq.'seepage') then
                       
                bcondheat(nbheat) = rwork(1,ibz)

!c  gradient type boundary condition - variably temperature
              elseif (btypezn.eq.'gradient')then

#ifdef USG
                if (itype_grad == 1)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                  end select
                else if (itype_grad == 2)then
                  select case(dir_grad)
                  case ('x')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                  case ('y')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                  case ('z')
                    pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                  end select
                else
#endif
                  select case(dir_grad)
                  case ('x')
                    pos_grad=xg(ivol)
                  case ('y')
                    pos_grad=yg(ivol)
                  case ('z')
                    pos_grad=zg(ivol)
                  case ('r')
                    pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                    (yg(ivol) - ry0)**2 +  &
                                    (zg(ivol) - rz0)**2)
                  end select
#ifdef USG
                end if
#endif
                bcondheat(nbheat)= rwork(1,ibz) + rwork(2,ibz)*pos_grad
                if (.not. b_restart_update_bcheat) then
                  tempnew(ivol)  = bcondheat(nbheat)
                end if 
              
                btypeheat(nbheat) = 'first'

!c  second type boundary condition - specified flux

              elseif (btypezn.eq.'second') then

!c  calculate flux area

                if (discretization_type == 0) then
                  if (xy_plane) then
                    areaf = dimcv(1,ivol) * dimcv(2,ivol)
                  elseif (xz_plane) then
                    areaf = dimcv(1,ivol) * dimcv(3,ivol)
                  elseif (yz_plane) then
                    areaf = dimcv(2,ivol) * dimcv(3,ivol)
                  end if
#ifdef USG
                else
                  if (cell_type == cell_type_tri .or.                  &
                      cell_type == cell_type_quad) then
                    !c connected control volume
                    if (is_boundary_node(ivol)) then
                      jvol1 = javs(iavs(ivol)+1)
                      jvol2 = javs(iavs(ivol+1)-1)
                      areaf = geometry_veclength(nodes(ivol)-            &
                              nodes(jvol1),flux_direction,               &
                              type_flux_direction)*0.5
                      areaf = areaf+geometry_veclength(nodes(ivol)-      &
                              nodes(jvol2),flux_direction,               &
                              type_flux_direction)*0.5
                    else
                      areaf = 0.0d0
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          if (icell2 > 0) then
                            do idvol = 1, num_edge_dvols
                              call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                              areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                            end do
                          end if
                        end do
                      end do
                    end if
  
                  else if (cell_type == cell_type_tetra) then
                    areaf = 0.0d0
                    if (is_boundary_node(ivol)) then
                      do icell = 1, node_num_cells(ivol)
                        cindex = node_cells(icell,ivol)
                        do iface = 1,  num_faces_per_cell           !number of faces
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)
  
                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if
  
                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
                          end if
                        end do
                      end do
                    else
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end do
                      end do
                    end if
                  else if (cell_type == cell_type_hexa) then
                    areaf = 0.0d0
                    if (is_boundary_node(ivol)) then
                      do icell = 1, node_num_cells(ivol)
                        cindex = node_cells(icell,ivol)
                        do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                            jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)
  
                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if
  
                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol4 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(2) = nodes(jvol4)
                              pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
                          end if
                        end do
                      end do
                    else
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end do
                      end do
                    end if
  
                  else if (cell_type == cell_type_prism) then
                    areaf = 0.0d0
                    if (is_boundary_node(ivol)) then
                      do icell = 1, node_num_cells(ivol)
                        cindex = node_cells(icell,ivol)
                        do iface = 1, 2                              !number of faces, top and bottom faces of prism
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
  
                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if
  
                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
  
                          end if
                        end do
  
                        do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                          if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                            jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                            jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                            jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                            jvol4 = cells(face_node_mapping_prism(4,iface),cindex)
  
                            if (type_flux_direction == 2) then
                              ratio_flux = abs(geometry_vector_cos(                &
                                                  CellFaceScaledNorm(iface,cindex),&
                                                  flux_direction))
                            else
                              ratio_flux = 1.0d0
                            end if
  
                            if (jvol1 == ivol) then
                              pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(2) = nodes(jvol1)
                              pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol2 == ivol) then
                              pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                              pts(2) = nodes(jvol2)
                              pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol3 == ivol) then
                              pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                              pts(2) = nodes(jvol3)
                              pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            else if (jvol4 == ivol) then
                              pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                              pts(2) = nodes(jvol4)
                              pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                              pts(4) = CellFaceCenter(iface,cindex)
                              areaf = areaf + geometry_area(4,pts)*ratio_flux
                            end if
                          end if
                        end do
                      end do
                    else
                      istart = iavs(ivol)+1
                      iend = iavs(ivol+1)-1
                      do jtemp = istart, iend
                        jvol = javs(jtemp)
                        do icell = 1, janumcell(jtemp)
                          icell2 = jacell(icell,jtemp)
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end do
                      end do
                    end if
                  else
                    if (rank == 0) then
                      write(ilog,'(2a,i2)') 'boundary surface area calculation ',  &
                            'does not support cell_type updtbcenergybal',cell_type
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if
#endif
                end if
!cprovi---------------------------------------------------------
!cprovi assign second type boundary condition
!cprovi Transform J => Kj 
!cprovi---------------------------------------------------------
                bcondheat(nbheat) = areaf*rwork(1,ibz)/r1000 *sec_per_days
                !print *, ' bcondheat(nbheat) ',  bcondheat(nbheat)  
              elseif (btypezn.eq.'point') then

                bcondheat(nbheat) = rwork(1,ibz)/r1000 *sec_per_days

              end if     !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.
                         ! btypezn.eq.'seepage')
              ! print *, 'bcondheat(nbheat) ', bcondheat(nbheat)

              bcondheat0(nbheat) = bcondheat(nbheat)

            end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                         !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                         !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)


          end do         !loop over control volumes

!c  write header for boundary zone to generic output file
        end do            !end loop over zones
      
500     continue  

!c  comment tempold = tempnew. Is this necessary? DSU, 2020-05-04
        !if (heat_transport) then
        !  tempold(1:nngl) = tempnew(1:nngl)            
        !end if 

!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!c  deallocate workarray for reading transient boundary conditions       
        call memory_monitor(-sizeof(rwork),'rwork',.true.)
        deallocate (rwork, stat = ierr)
        call checkerr(ierr,'rwork',ilog)

        call memory_monitor(-sizeof(rwork_next),'rwork_next',.true.)
        deallocate (rwork_next, stat = ierr)
        call checkerr(ierr,'rwork_next',ilog)

!c  array iabheat
        allocate (iwork(nbheat), stat = ierr)
        call checkerr(ierr,'iwork',ilog)

        do ibheat = 1,nbheat
          iwork(ibheat) = iabheat(ibheat)
        end do

        deallocate (iabheat, stat = ierr)
        call checkerr(ierr,'iabheat',ilog)

        allocate (iabheat(nbheat), stat = ierr)
        call checkerr(ierr,'iabheat',ilog)
      

        do ibheat = 1,nbheat
          iabheat(ibheat) = iwork(ibheat)
        end do
      
        do ibheat = 1,nbheat
          do i = nbheat, ibheat + 1, -1
            if (iabheat(i) == iabheat(ibheat)) then
              iabheat(ibheat) = -iabheat(ibheat)
              exit
            end if
          end do
        end do

        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)
      
!c  restore the reading position to previous record
        if (b_updt_next_only) then
          backspace(ibcheat)
        end if

!c  assign next read time
        if (time_bcheat < tfinal/time_factor) then
          read(ibcheat,*,err=998,end=997) time_bcheat
        end if

        return

!c  assign next read time greater than final solution time, if no more
!c  read times left and return
!cdsu replace 1.1*tfinal since tfinal can be negative

997     time_bcheat = (tfinal+1.0d100)/time_factor
        return


998     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcheat'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

999     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file, error code ', ierrcd
          write(ilog,*) 'section "',section_header(:l_string),'"'
          write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      else if (b_interpolation_bcheat) then
        if (nbheat > 0) then
          do ibheat = 1, nbheat
            ivol = iabheat(ibheat)

            if (ivol < 0) then
              cycle  
            end if

            btypezn = btypeheat(ibheat)
            
            bcondheat(ibheat) = math_common_linear(                    &
                                     time_bcheat_prev, time_bcheat,    &
                                     bcondheat_prev(ibheat),           &
                                     bcondheat_next(ibheat),time_io)

            bcondheat0(ibheat) = bcondheat(ibheat)

            if (btypezn.eq.'first') then
              tempnew(ivol)  = bcondheat(ibheat)            
            end if
          end do
        end if
      end if 

      return

      end
