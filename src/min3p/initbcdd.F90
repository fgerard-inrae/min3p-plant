!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initbcdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initbcdd
!c -------------------
!c
!c boundary conditions (variably saturated density dependent flow) 
!c
!c first type boundary conditions: 
!c -> define zone by delineating nodes located within zone
!c
!c second type boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c seepage face boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - August 21, 2002
!c
!c last modified:   Tom Henderson - March 24, 2004
!c 
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  * +
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           dimcv(3,nn)        = spatial dimensions of control       + -
!c                                volumes
!c           rwork(:,:)         = real*8 work array                   * *
!c           time_bcvs          = next read time for flow boundary    * +
!c                                conditions
!c           uvsold(nn)         = solution vector (old time level)    + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           sec_per_days       = conversion factor from SI input     + -
!c                                units for physico-chemical 
!c                                parameters internal time units
!c
!c           integer*4:
!c           ----------
!c           ibcvs              = unit number, transient boundary     * +
!c                                             conditions, variably
!c                                             saturated flow
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           iabvs(nbvs)        = pointer to boundary control volumes * +
!c                                for variably saturated flow
!c           iwork(:)           = integer work array                  * *
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        * +
!c                                control volumes
!c                                (variably saturated flow)
!c           nseep_first        = number of seepage face nodes        * +
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           update_bcvs        = .true.  -> transient boundary       * +
!c                                           condition for variably 
!c                                           saturated flow
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions 
!c           hydraulic_head     = .true.  -> initial condition in     + -
!c                                           terms of hydraulic head
!c           pressure_head      = .true.  -> initial condition in     + -
!c                                           terms of pressure heada
!c           seepage_face       = .true.  -> seepage face boundary    * +
!c                                           specified
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           zone_name          = name of zone                        * +
!c           btypevs(nbvs)      = boundary type array                 * +
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c                                'seepage-second'
!c                                          = mixed seepage face and 
!c                                            Nuemann
!c                                'free-drainage' = free-drainage
!c           section_header     = section header                      * +
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure
!c           density(nn)        = fluid density 
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures
!c           logical:
!c           --------
!c           fluid_pressure     = .true.  -> initial and boundary
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c           fresh_head         = .true.  -> initial and boundary
!c                                           conditions in terms 
!c                                           of freshwater head 
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c           tiny               = small increment
!c           xbmin              = min. x-coordinate of boundary
!c                                zone
!c           xbmax              = max. x-coordinate of boundary
!c                                zone
!c           ybmin              = min. y-coordinate of boundary
!c                                zone
!c           ybmax              = max. y-coordinate of boundary
!c                                zone
!c           zbmin              = min. z-coordinate of boundary
!c                                zone
!c           zbmax              = max. z-coordinate of boundary
!c                                zone
!c
!c           integer*4:
!c           ----------
!c           ibvs               = counter (boundary control volumes)
!c           ibz                = counter (zones)
!c           ierr               = 0 -> memory allocation successful
!c           ivol               = counter (control volumes)
!c           istart             = pointer (control volume)
!c           iend               = pointer (control volume)
!c           l_string           = length of text string
!c           nbvsp              = start of boundary zone 
!c                                (temporary)
!c           nbzvs              = number of boundary zones
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit search 
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           xy_plane           = boundary zone parallel tp xy-plane
!c           xz_plane           = boundary zone parallel to xz-plane
!c           yz_plane           = boundary zone parallel to yz-plane
!c
!c           character:
!c           ----------
!c           bcond              = btypevs = 'first' 
!c                                -> hydraulic head
!c                                btypevs = 'second' 
!c                                -> specified flux
!c                                btypevs = 'seepage' 
!c                                -> initial seepage face heigth
!c           btypezn            = boundary type of zone        
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine initbcdd
 
      use parm
      use gen
      use dens
      use file_unit, only : lun_get
      use file_utility, only : rewind_first_record
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, num_nodes_per_cell,  &
                                node_cells, node_num_cells,            &
                                node_to_layer_node,                    &
                                layer_nodes_top, layer_nodes_bottom,   &
                                cell2halfid, CellFaceCenter, cells,    &
                                cal_cellface_index, cell_projection,   &
                                num_faces_per_cell, CellFaceScaledNorm,&
                                is_boundary_node, num_edge_dvols,      &
                                CellCvolFaceArea, get_cell_edge_cvol_id

      use read_zone_usg, only : read_zone_usg_input,                   &
                                type_extent_zone, type_extent_zone_box,&
                                type_flux_direction, flux_direction
#endif
      implicit none
      
      integer :: i, ibz, ibvs, ibrt, ierr, ivol, jvol, jvol1, jvol2,   &
                 l_string, nbvsp, istart, iend, jtemp, ierrcd
      integer :: itype_grad       !0: normal, 1: bottom, 2: top (layered mesh)                 
      real*8 :: h0_grad, slope_grad, bcond, xbmin, xbmax,              &
                ybmin, ybmax, zbmin, zbmax, pos_grad, areaf,           &
                tol_pond_loc
      real*8 :: rx0, ry0, rz0     !center of gradient-radius type i.c. or b.c. condition

      external checkerr, findstrg, findzone, readbloc, readzone

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, tiny = 1.d-5

      logical :: xy_plane,xz_plane,yz_plane,found,found_section,       &
                 found_subsection

      character*1   :: dir_grad
      character*32  :: btypezn
      character*72  :: subsection
      character*256 :: strbuffer
      character*16, allocatable :: cwork(:)

      logical, external :: freezing_adjacent_bd

      real*8, external :: pressure_melt_k

#ifdef USG
      real*8 :: ratio_flux
      integer :: icell, icell2, idvol, idvol_r, iedge_r, iface, cindex,&
                 jvol3, jvol4
      type(point) :: pts(4)
#endif
      
      integer :: ntemp

      ierrcd = 0
      pos_grad = r0
      areaf = r0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
      
!cprovi-------------------------------------------------------------------
!cprovi Set initial values for density-driven gradient 
!cprovi-------------------------------------------------------------------
      h0_grad=r0
      slope_grad=r1
      dir_grad='z'      

!c  define defaults

      if(rank == 0 .and. b_enable_output) then
        write(*,*) 'boundary conditions - ',                           &
     &             'variably saturated density dependent flow'
        write(*,*) ('-',i=1,72)

        write(ilog,'(2a)') 'boundary conditions - ',                   &
     &                     'variably saturated density dependent flow'
        write(ilog,'(72a/)')('-',i=1,72)
      end if

!c  read section header for boundary conditions of density dependent
!c  flow simulation
   
      section_header = 'boundary conditions - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)


!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to generic output file  
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  initialize variables for seepage face iteration

      seepage_face = .false.
      nseep_first = 0

!c  preliminary allocation of memory for boundary conditions

      allocate (bcondvs(nngl), stat = ierr)
      bcondvs=0.0d0 
      call checkerr(ierr,'bcondvs',ilog)
      call memory_monitor(sizeof(bcondvs),'bcondvs',.true.)

      allocate (iabvs(nngl), stat = ierr)
      iabvs=0 
      call checkerr(ierr,'iabvs',ilog)
      call memory_monitor(sizeof(iabvs),'iabvs',.true.)

      allocate (btypevs(nngl), stat = ierr)
      btypevs=' '
      call checkerr(ierr,'btypevs',ilog)
      call memory_monitor(sizeof(btypevs),'btypevs',.true.)
      
      allocate (ivol2bvs(nngl), stat = ierr)
      ivol2bvs=0 
      call checkerr(ierr,'ivol2bvs',ilog)
      call memory_monitor(sizeof(ivol2bvs),'ivol2bvs',.true.)

      allocate (ivol2bzvs(nngl), stat = ierr)
      ivol2bzvs=0
      call checkerr(ierr,'ivol2bzvs',ilog)
      call memory_monitor(sizeof(ivol2bzvs),'ivol2bzvs',.true.)

      allocate (areaf_bvs(nngl), stat = ierr)
      areaf_bvs=0
      call checkerr(ierr,'areaf_bvs',ilog)
      call memory_monitor(sizeof(areaf_bvs),'areaf_bvs',.true.)

      allocate (gradf_bvs(nngl), stat = ierr)
      gradf_bvs=0
      call checkerr(ierr,'gradf_bvs',ilog)
      call memory_monitor(sizeof(gradf_bvs),'gradf_bvs',.true.)

      allocate (tol_freezing_pond(nngl), stat = ierr)
      tol_freezing_pond=1.0d300
      call checkerr(ierr,'tol_freezing_pond',ilog)
      call memory_monitor(sizeof(tol_freezing_pond),'tol_freezing_pond',.true.)

      allocate (seepage_bits(nngl), stat = ierr)
      seepage_bits=0
      call checkerr(ierr,'seepage_bits',ilog)
      call memory_monitor(sizeof(seepage_bits),'seepage_bits',.true.)

!c  read number of boundary zones
 
      ierrcd = 1
      read(itmp,*,err=999,end=999) nbzvs
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                       &
     &  'number of boundary zones                        = ',nbzvs
      end if

!c  initialize pointer array for storage of boundary conditions

      nbvs = 0
      iabvs(1) = 1
      
      ivol2bvs(:) = 0
      ivol2bzvs(:) = 0

      tol_freezing_pond(:) = 1.0d300
      seepage_bits(:) = 0

!c  allocate variables for 'gradient' type boundary conditions
      allocate (bzvs_dir_grad(nbzvs), stat = ierr)
      bzvs_dir_grad=' '
      call checkerr(ierr,'bzvs_dir_grad',ilog)
      call memory_monitor(sizeof(bzvs_dir_grad),'bzvs_dir_grad',.true.)

      allocate (bzvs_itype_grad(nbzvs), stat = ierr)
      bzvs_itype_grad=0
      call checkerr(ierr,'bzvs_itype_grad',ilog)
      call memory_monitor(sizeof(bzvs_itype_grad),'bzvs_itype_grad',.true.)

      allocate (bzvs_nparms(nbzvs), stat = ierr)
      bzvs_nparms=1
      call checkerr(ierr,'bzvs_nparms',ilog)
      call memory_monitor(sizeof(bzvs_nparms),'bzvs_nparms',.true.)

      allocate (bzvs_radius_center(nbzvs), stat = ierr)
      bzvs_radius_center%x = r0
      bzvs_radius_center%y = r0
      bzvs_radius_center%z = r0
      call checkerr(ierr,'bzvs_radius_center',ilog)
      call memory_monitor(sizeof(bzvs_radius_center),'bzvs_radius_center',.true.)

!c  read name of zone

      do ibz=1,nbzvs              !loop over number of zones

        nbvsp = nbvs+1            !temporary pointer for output

!c  find current zone in input file and write to temporary file

        subsection = 'number and name of zone'

        call findzone(subsection,itmp,found_subsection,ibz,zone_name)

        if (found_subsection) then

          call readzone(itmp,icnv,ilog,zone_name,found_subsection)

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error in input file'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define length of zone name

        l_zone_name = index(zone_name,'  ')-1
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
          l_zone_name = 72
        end if

!c  define if freezing ponding boundary is required
!c  the pressure head cannot exceed the specified tolerance

        subsection = 'pressure head tolerance of ponding boundary'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then
          ierrcd = 2
          read(icnv,*,err=999,end=999) tol_pond_loc
          tol_pond_loc = tol_pond_loc*ref_dens*gacc
        else
          tol_pond_loc = 1.0d300
        end if

     
 
!c  define type and value of boundary condition

        subsection = 'boundary type'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then
          ierrcd = 3
          read(icnv,'(a)',err=999,end=999) strbuffer
          strbuffer = adjustl(strbuffer)

          if(index(strbuffer,'gradient') == 2) then
#ifdef USG
            if(index(strbuffer,'gradient-top') == 2) then
              itype_grad = 2
            else if(index(strbuffer,'gradient-bottom') == 2) then
              itype_grad = 1
            else
              itype_grad = 0
            end if

            if (.not. b_use_layered_mesh) then
              itype_grad = 0
            end if
#endif
            btypezn = 'gradient'

            if(index(strbuffer,'gradient-radius') == 2) then
              ierrcd = 4
              read(icnv,*,err=999,end=999) dir_grad, rx0, ry0, rz0
              read(icnv,*,err=999,end=999) h0_grad
              read(icnv,*,err=999,end=999) slope_grad

              bzvs_radius_center(ibz)%x = rx0
              bzvs_radius_center(ibz)%y = ry0
              bzvs_radius_center(ibz)%z = rz0

              !c reset dir_grad to 'r' for gradient-radius type
              if (dir_grad /= 'r') then
                dir_grad = 'r'
              end if

            else
              ierrcd = 5
              read(icnv,*,err=999,end=999) dir_grad
              read(icnv,*,err=999,end=999) h0_grad
              read(icnv,*,err=999,end=999) slope_grad
            end if
            
            if (dir_grad /= 'x'.and. dir_grad /= 'y'.and.              &
                dir_grad /= 'z' .and. dir_grad /= 'r') then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "',section_header(:l_string),'"'
                write(ilog,*) 'Error in gradient direction'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

            bzvs_dir_grad(ibz) = dir_grad
            bzvs_itype_grad(ibz) = itype_grad
            bzvs_nparms(ibz) = 2

          else
            ierrcd = 6
            read(strbuffer,*,err=999,end=999) btypezn, bcond
          end if

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  read coordiantes defining boundary zone, 
        type_extent_zone = -1
        type_extent_zone_box = -1

        subsection = 'extent of zone'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          type_extent_zone = 0
          ierrcd = 7
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax

        end if

#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 8
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
                                       zbmin,zbmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xbmin = -1.0d300
          xbmax = 1.0d300
        end if

        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ybmin = -1.0d300
          ybmax = 1.0d300
        end if

        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zbmin = -1.0d300
          zbmax = 1.0d300
        end if


!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then

          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define boundary face to be considered (only needed for calculation
!c  of boundary face area for second type boundary conditions) 

        if (type_extent_zone == 0 .and. type_extent_zone_box <= 0 .and.&
           (btypezn.eq.'second' .or. btypezn.eq.'free-drainage' .or.   &
            btypezn.eq.'seepage-second' .or.                           &
           (btypezn.eq.'atmospheric'.and.evaporation))) then
   
          found = .false.
          xy_plane = .false.
          xz_plane = .false.
          yz_plane = .false.

          if (dabs(zbmax-zbmin).lt.tiny) then     !xy_plane
            if ((dabs(xbmax-xbmin).lt.tiny).or.                        &
                (dabs(ybmax-ybmin).lt.tiny)) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            else
              xy_plane = .true.
              found = .true.
            end if
          end if

          if (.not.found) then                     !xz_plane
            if (dabs(ybmax-ybmin).lt.tiny) then
              if ((dabs(xbmax-xbmin).lt.tiny).or.                 &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "', section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                xz_plane = .true.
                if (xy_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                      &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

          if (.not.found) then                     !yz_plane
            if (dabs(xbmax-xbmin).lt.tiny) then
              if ((dabs(ybmax-ybmin).lt.tiny).or.                 &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "',zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                yz_plane = .true.
                if (xy_plane.or.xz_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                      &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

!  exit if boundary face was not found
!  for the structured grid, the boundary plane can only be xy_plane, yz_plane or xz_plane
!  for the unstructured grid in 3D, it can be in any direction
          if (.not.found) then
#ifdef USG
            if(cell_projection /= projection_xyz) then
#endif
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
#ifdef USG
            end if
#endif
          end if

          !c define flux direction for unstructured grid
#ifdef USG
          if (discretization_type > 0 .and. type_flux_direction == 0) then
            if (xy_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,0.0d0,1.0d0)
            else if (yz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(1.0d0,0.0d0,0.0d0)
            else if (xz_plane) then
              type_flux_direction = 2
              flux_direction = math_common_set_vector(0.0d0,1.0d0,0.0d0)
            end if
          end if
#endif

        end if                    !(btypezn.eq.'second' .or. 'free-drainage', for structured grid only)

!c  increment boundary coordinates

        xbmin = xbmin-tiny
        xbmax = xbmax+tiny
        ybmin = ybmin-tiny
        ybmax = ybmax+tiny
        zbmin = zbmin-tiny
        zbmax = zbmax+tiny

!c  store type of boundary condition and boundary condition
!c  for global system in compressed storage

        do ivol = 1,nngl

!c  check limits of boundary zone

          if (((type_extent_zone==0.or.type_extent_zone_box>0) .and.   &
              (xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax) .and.        &
              (yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax) .and.        &
              (zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) .or.        &
              (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.     &
              ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
            if (discretization_type > 0 .and. type_extent_zone_box > 0) then
              if ((btest(type_extent_zone_box,1) .and.                 &
                   .not. is_boundary_node(ivol)) .or.                  &
                  (btest(type_extent_zone_box,2) .and.                 &
                   is_boundary_node(ivol))) then
                cycle
              end if
            end if
#endif

!c  assign boundary type and boundary condition

            nbvs = nbvs+1

!c  exit if nbvs > nn

            if (nbvs.gt.nngl) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'nbvs > nn ...'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

!c  assign pointer and 
!c
            iabvs(nbvs) = ivol
            btypevs(nbvs) = btypezn

            ivol2bvs(ivol) = nbvs
            ivol2bzvs(ivol) = ibz

            tol_freezing_pond(nbvs) = tol_pond_loc

!c  first type boundary condition - constant head or fluid pressure 

            if (btypezn.eq.'first') then
              if (fluid_pressure) then
                uvsnew(ivol) = bcond

              elseif (pressure_head) then
                uvsnew(ivol) = bcond*density(ivol)*gacc

              elseif (fresh_head) then
                uvsnew(ivol) = (bcond - zg(ivol)) *   &
                                   gacc * ref_dens

              elseif (hydraulic_head) then
                uvsnew(ivol) = (bcond- zg(ivol)) *    &
                                gacc * density(ivol)

              end if !fluid pressure

              bcondvs(nbvs) = uvsnew(ivol)
              uvsold(ivol) = uvsnew(ivol)


            elseif (btypezn.eq.'gradient')then

#ifdef USG
              if (itype_grad == 1)then
                select case(dir_grad)
                case ('x')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%x
                case ('y')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%y
                case ('z')
                  pos_grad=layer_nodes_bottom(node_to_layer_node(ivol))%z
                end select
              else if (itype_grad == 2)then
                select case(dir_grad)
                case ('x')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%x
                case ('y')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%y
                case ('z')
                  pos_grad=layer_nodes_top(node_to_layer_node(ivol))%z
                end select
              else
#endif
                select case(dir_grad)
                case ('x')
                  pos_grad=xg(ivol)
                case ('y')
                  pos_grad=yg(ivol)
                case ('z')
                  pos_grad=zg(ivol)
                case ('r')
                  pos_grad = sqrt((xg(ivol) - rx0)**2 +  &
                                  (yg(ivol) - ry0)**2 +  &
                                  (zg(ivol) - rz0)**2)
                end select
#ifdef USG
              end if
#endif

              bcond=h0_grad + slope_grad*pos_grad

              if (fluid_pressure) then
                uvsnew(ivol) = bcond
              elseif (pressure_head) then
                uvsnew(ivol) = bcond*density(ivol)*gacc
              elseif (fresh_head) then
                uvsnew(ivol) = (bcond - zg(ivol)) *   &
                                 gacc * ref_dens
              elseif (hydraulic_head) then
                uvsnew(ivol) = (bcond- zg(ivol)) *    &
                                  gacc * density(ivol)
              end if !fluid pressure
              bcondvs(nbvs) = uvsnew(ivol)
              uvsold(ivol) = uvsnew(ivol)
              btypevs(nbvs) = 'first'


!  tracer type boundary condition - mark the node only
            else if (btypezn.eq.'idle') then
              !c nothing is required here
              !c idle boundary is disigned for solute transport through 
              !c internal node where there is flow

!c  second type boundary condition - specified flux
            elseif (btypezn.eq.'second' .or.                           &
                    btypezn.eq.'free-drainage' .or.                    &
                    btypezn.eq.'seepage-second') then

!c  calculate flux area

              if (discretization_type == 0) then
                if (xy_plane) then
                  areaf = dimcv(1,ivol) * dimcv(2,ivol)
                elseif (xz_plane) then
                  areaf = dimcv(1,ivol) * dimcv(3,ivol)
                elseif (yz_plane) then
                  areaf = dimcv(2,ivol) * dimcv(3,ivol)
                end if
#ifdef USG
              else
                if (cell_type == cell_type_tri .or.                    &
                    cell_type == cell_type_quad) then
                  !c connected control volume
                  if (is_boundary_node(ivol)) then
                    jvol1 = javs(iavs(ivol)+1)
                    jvol2 = javs(iavs(ivol+1)-1)
                    areaf = geometry_veclength(nodes(ivol)-            &
                            nodes(jvol1),flux_direction,               &
                            type_flux_direction)*0.5
                    areaf = areaf+geometry_veclength(nodes(ivol)-      &
                            nodes(jvol2),flux_direction,               &
                            type_flux_direction)*0.5
                  else
                    areaf = 0.0d0
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        if (icell2 > 0) then
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end if
                      end do
                    end do

                  end if

                else if (cell_type == cell_type_tetra) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if
                else if (cell_type == cell_type_hexa) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_prism) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1, 2                              !number of faces, top and bottom faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                        end if
                      end do

                      do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_prism(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if
                else
                  if (rank == 0) then
                    write(ilog,'(2a,i2)') 'boundary surface area calculation ', &
                          'does not support cell_type initbcdd-1',cell_type
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
#endif
              end if

!c  assign second type boundary condition
!c  flux volume only - density stored in ssdens array calculated in 
!c  subroutine initbcrt.  Volume flux converted to mass flux in 
!c  jacbvs and jacbrt
!c
              if (btypezn.eq.'second' .or. btypezn.eq.'seepage-second') then

                if (btypezn.eq.'seepage-second') then
                  seepage_face = .true.         !initialize seepage face
                end if

                bcondvs(nbvs) = areaf * bcond
                areaf_bvs(nbvs) = areaf
                if (btypezn.eq.'seepage-second') then
                  seepage_bits(nbvs) = 2
                end if
              else if (btypezn.eq.'free-drainage') then
                gradf_bvs(nbvs) = bcond
                areaf_bvs(nbvs) = areaf
              end if

!c flow verification problem toggle
!c multiply flux volume by reference density

              if (flow_verification) then
                bcondvs(nbvs) = bcondvs(nbvs) * ref_dens
              end if

            elseif (btypezn.eq.'atmospheric') then

              
              if (.not.evaporation) then
                ierrcd = 9
                goto 999
              end if
!c  calculate flux area

              if (discretization_type == 0) then
                if (xy_plane) then
                  areaf = dimcv(1,ivol) * dimcv(2,ivol)
                elseif (xz_plane) then
                  areaf = dimcv(1,ivol) * dimcv(3,ivol)
                elseif (yz_plane) then
                  areaf = dimcv(2,ivol) * dimcv(3,ivol)
                end if
#ifdef USG
              else
                if (cell_type == cell_type_tri .or.                    &
                    cell_type == cell_type_quad) then
                  !c connected control volume
                  if (is_boundary_node(ivol)) then
                    jvol1 = javs(iavs(ivol)+1)
                    jvol2 = javs(iavs(ivol+1)-1)
                    areaf = geometry_veclength(nodes(ivol)-            &
                            nodes(jvol1),flux_direction,               &
                            type_flux_direction)*0.5
                    areaf = areaf+geometry_veclength(nodes(ivol)-      &
                            nodes(jvol2),flux_direction,               &
                            type_flux_direction)*0.5
                  else
                    areaf = 0.0d0
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        if (icell2 > 0) then
                          do idvol = 1, num_edge_dvols
                            call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                            areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                          end do
                        end if
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_tetra) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_tetra(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_tetra(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_tetra(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_hexa) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1,  num_faces_per_cell           !number of faces, get boundary face
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_hexa(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_hexa(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_hexa(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_hexa(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if

                else if (cell_type == cell_type_prism) then
                  areaf = 0.0d0
                  if (is_boundary_node(ivol)) then
                    do icell = 1, node_num_cells(ivol)
                      cindex = node_cells(icell,ivol)
                      do iface = 1, 2                              !number of faces, top and bottom faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if

                        end if
                      end do

                      do iface = 3,  num_faces_per_cell           !number of faces, side faces of prism
                        if (cal_cellface_index(cell2halfid(iface,cindex)) == cindex) then
                          jvol1 = cells(face_node_mapping_prism(1,iface),cindex)
                          jvol2 = cells(face_node_mapping_prism(2,iface),cindex)
                          jvol3 = cells(face_node_mapping_prism(3,iface),cindex)
                          jvol4 = cells(face_node_mapping_prism(4,iface),cindex)

                          if (type_flux_direction == 2) then
                            ratio_flux = abs(geometry_vector_cos(                &
                                                CellFaceScaledNorm(iface,cindex),&
                                                flux_direction))
                          else
                            ratio_flux = 1.0d0
                          end if

                          if (jvol1 == ivol) then
                            pts(1) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(2) = nodes(jvol1)
                            pts(3) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol2 == ivol) then
                            pts(1) = (nodes(jvol1) + nodes(jvol2))*0.5d0
                            pts(2) = nodes(jvol2)
                            pts(3) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol3 == ivol) then
                            pts(1) = (nodes(jvol2) + nodes(jvol3))*0.5d0
                            pts(2) = nodes(jvol3)
                            pts(3) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          else if (jvol4 == ivol) then
                            pts(1) = (nodes(jvol3) + nodes(jvol4))*0.5d0
                            pts(2) = nodes(jvol4)
                            pts(3) = (nodes(jvol4) + nodes(jvol1))*0.5d0
                            pts(4) = CellFaceCenter(iface,cindex)
                            areaf = areaf + geometry_area(4,pts)*ratio_flux
                          end if
                        end if
                      end do
                    end do
                  else
                    istart = iavs(ivol)+1
                    iend = iavs(ivol+1)-1
                    do jtemp = istart, iend
                      jvol = javs(jtemp)
                      do icell = 1, janumcell(jtemp)
                        icell2 = jacell(icell,jtemp)
                        do idvol = 1, num_edge_dvols
                          call get_cell_edge_cvol_id(idvol,ivol,jvol,icell2,idvol_r,iedge_r)
                          areaf = areaf + CellCvolFaceArea(idvol_r,iedge_r,icell2)
                        end do
                      end do
                    end do
                  end if
                else
                  if (rank == 0) then
                    write(ilog,'(2a,i2)') 'boundary surface area calculation ',  &
                          'does not support cell_type initbcdd-2',cell_type
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
#endif
              end if

!c  assign second type boundary condition
!c  flux volume only - density stored in ssdens array calculated in 
!c  subroutine initbcrt.  Volume flux converted to mass flux in 
!c  jacbvs and jacbrt
!c

              bcondvs(nbvs) = areaf

!c injection point: input units are cubic meters per second

            elseif (btypezn.eq.'point') then

              bcondvs(nbvs) = bcond

!c  seepage boundary condition - zero pressure or zero flux
!c  not converted yet to pressure pdv formulation!!
                

            elseif (btypezn.eq.'seepage') then

              seepage_face = .true.         !initialize seepage face

              if (zg(ivol).lt.bcond) then   !assign first type b.c
                uvsnew(ivol) = r0
                uvsold(ivol) = r0
                hhead(ivol) = r0 + zg(ivol)                
                                              !identify zero pressure
                !bcondvs(nbvs) = -r1
                seepage_bits(nbvs) = 1
              else
                                              !identify zero-flux
                !bcondvs(nbvs) = r1
                seepage_bits(nbvs) = 2
              end if

            else if (btypezn.eq.'initial') then

              btypevs(nbvs) = 'first'

              bcondvs(nbvs) = uvsnew(ivol)

            end if     !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.
                       ! btypezn.eq.'free-draiange'.or.btypezn.eq.'seepage')
          end if       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes

!c  write header for boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
            
        write(igen,'(/a,i0,a,1x,a)') 'zone ',ibz,':',zone_name
        write(igen,'(72a)')('-',i=1,72)

        if (btypezn.eq.'first' .or. btypezn.eq.'gradient') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                          'pressure'
        elseif (btypezn.eq.'second') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                          'specified mass flux'
        elseif (btypezn.eq.'free-drainage') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                          'free-drainage'
        elseif (btypezn.eq.'idle') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                          'idle'
        elseif (btypezn.eq.'seepage') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                          'initial guess'
        elseif (btypezn.eq.'seepage-second') then
          write(igen,'(2x,a,3x,a,5x,a/)') 'volume','boundary type',    &
                                          'specified seepage flux'
        end if
        
        end if

!c  write boundary condition for zone to generic output file

        if (btypezn.ne.'seepage') then         !first and second type
          if (b_enable_output .and. b_enable_output_gen) then   
          do ibvs=nbvsp,nbvs
            ivol = iabvs(ibvs)
            write(igen,'(i8,3x,a16,1pe15.6e3)') ivol,btypevs(ibvs),    &
     &                                          bcondvs(ibvs)
          end do
          end if 
        else                                   !seepage face
          do ibvs=nbvsp,nbvs
            ivol = iabvs(ibvs)
            if (bcondvs(ibvs).lt.r0) then
              if (b_enable_output .and. b_enable_output_gen) then   
              write(igen,'(i8,3x,a16,4x,a)') ivol,btypevs(ibvs),      &
     &                                       'zero pressure'
              end if 
              nseep_first = nseep_first + 1  
                                             
            else
              if (b_enable_output .and. b_enable_output_gen) then  
              write(igen,'(i8,3x,a16,4x,a)') ivol,btypevs(ibvs),      &
     &                                       'zero flux'
              end if
            end if
          end do
        end if

!c  conversion of time units for computation in days
!c  if second type boundary condition is specified

        if ((btypezn.eq.'second') .or.        &
            (btypezn.eq.'point') .or.         &
            (btypezn.eq.'seepage-second')) then
          do ibvs=nbvsp,nbvs
            if (b_water_freezing) then
              ivol = iabvs(ibvs)
              if (tkel(ivol) > pressure_melt_k(ivol,r0)) then
                if (b_freezing_adjacent_bd) then
                  if (freezing_adjacent_bd(ivol)) then
                    bcondvs(ibvs) = r0
                  else
                    bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days
                  end if
                else
                  bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days
                end if
              else
                bcondvs(ibvs) = r0
              end if
            else
              bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days
            end if

          end do
        end if

      end do            !end loop over zones

!c  define if boundary conditions are to updated
      update_bcvs=.false. 

      subsection = 'transient boundary conditions'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        update_bcvs = .true.
      else
        subsection = 'transient flow boundary conditions'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          update_bcvs = .true.
        end if        
      end if

!cdsu only update the boundary condition values, with boundary type and zone unchanged.
      update_bcvs_value_only=.false.

      subsection = 'transient boundary conditions: values only'
      call findstrg(subsection,itmp,found_subsection)
      if (found_subsection) then
        update_bcvs = .true.
        update_bcvs_value_only = .true.
      else
        subsection = 'transient flow boundary conditions: values only'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          update_bcvs = .true.
          update_bcvs_value_only = .true.
        end if        
      end if

!cdsu linear interpolation for boundary conditions, only if the 
!cdsu boundary condition type remains the same
      b_interpolation_bcvs = .false.
      b_first_update_bcvs = .false.

      if (update_bcvs_value_only) then
        subsection = 'linear interpolation of boundary conditions'
        call findstrg(subsection,itmp,found_subsection) 
        if (found_subsection) then
          b_interpolation_bcvs = .true.
          b_first_update_bcvs = .true.
        end if 
      end if      

!c  open file containing boundary conditions for variably saturated flow
!c  and read first read time

      if (update_bcvs) then

        !ibcvs = 15
        ibcvs = lun_get()
        open(ibcvs,file=prefix(:l_prfx)//'.bcvs',err=997, status='old')
        !cdsu skip comment line and rewind to the first record
        call rewind_first_record(ibcvs)
        read(ibcvs,*,err=998,end=998) time_bcvs
             
      end if
      
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
      update_ext_type_bcvs=.false. 
      subsection = 'update extension and type boundary conditions'
      call findstrg(subsection,itmp,found_subsection) 

      if (found_subsection) then
        update_ext_type_bcvs = .true.
      end if

      if (update_ext_type_bcvs) then
       
       !ibcvs1 = 17
       ibcvs1 = lun_get()

       open(ibcvs1,file=prefix(:l_prfx)//'.bcvs1',err=997, status='old')
             
      end if
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
       
!c  minimize memory requirement for boundary arrays

!c  array bcondvs

      allocate (rwork(nbvs,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      call memory_monitor(sizeof(rwork),'initbcdd-rwork',.true.)

      do ibvs = 1,nbvs
        rwork(ibvs,1) = bcondvs(ibvs)
      end do

      call memory_monitor(-sizeof(bcondvs),'bcondvs',.true.)
      deallocate (bcondvs, stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)

      allocate (bcondvs(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)
      call memory_monitor(sizeof(bcondvs),'bcondvs',.true.)

      do ibvs = 1,nbvs
        bcondvs(ibvs) = rwork(ibvs,1)
      end do

!c  allocate array for linear interpolation of boundary conditions
      allocate (bcondvs_prev(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs_prev',ilog)
      call memory_monitor(sizeof(bcondvs_prev),'bcondvs_prev',.true.)
      bcondvs_prev = bcondvs

      allocate (bcondvs_next(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs_next',ilog)
      call memory_monitor(sizeof(bcondvs_next),'bcondvs_next',.true.)
      bcondvs_next = bcondvs

!c  array tol_freezing_pond
      do ibvs = 1,nbvs
        rwork(ibvs,1) = tol_freezing_pond(ibvs)
      end do

      call memory_monitor(-sizeof(tol_freezing_pond),'tol_freezing_pond',.true.)
      deallocate (tol_freezing_pond, stat = ierr)
      call checkerr(ierr,'tol_freezing_pond',ilog)

      allocate (tol_freezing_pond(nbvs), stat = ierr)
      call checkerr(ierr,'tol_freezing_pond',ilog)
      call memory_monitor(sizeof(tol_freezing_pond),'tol_freezing_pond',.true.)

      do ibvs = 1,nbvs
        tol_freezing_pond(ibvs) = rwork(ibvs,1)
      end do


!c  array areaf_bvs
      do ibvs = 1,nbvs
        rwork(ibvs,1) = areaf_bvs(ibvs)
      end do

      call memory_monitor(-sizeof(areaf_bvs),'areaf_bvs',.true.)
      deallocate (areaf_bvs, stat = ierr)
      call checkerr(ierr,'areaf_bvs',ilog)

      allocate (areaf_bvs(nbvs), stat = ierr)
      call checkerr(ierr,'areaf_bvs',ilog)
      call memory_monitor(sizeof(areaf_bvs),'areaf_bvs',.true.)

      do ibvs = 1,nbvs
        areaf_bvs(ibvs) = rwork(ibvs,1)
      end do

!c  array gradf_bvs
      do ibvs = 1,nbvs
        rwork(ibvs,1) = gradf_bvs(ibvs)
      end do

      call memory_monitor(-sizeof(gradf_bvs),'gradf_bvs',.true.)
      deallocate (gradf_bvs, stat = ierr)
      call checkerr(ierr,'gradf_bvs',ilog)

      allocate (gradf_bvs(nbvs), stat = ierr)
      call checkerr(ierr,'gradf_bvs',ilog)
      call memory_monitor(sizeof(gradf_bvs),'gradf_bvs',.true.)

      do ibvs = 1,nbvs
        gradf_bvs(ibvs) = rwork(ibvs,1)
      end do  
      
!c  array for interpolation of boundary conditions
      allocate (gradf_bvs_prev(nbvs), stat = ierr)
      call checkerr(ierr,'gradf_bvs_prev',ilog)
      call memory_monitor(sizeof(gradf_bvs_prev),'gradf_bvs_prev',.true.)
      gradf_bvs_prev = gradf_bvs

      allocate (gradf_bvs_next(nbvs), stat = ierr)
      call checkerr(ierr,'gradf_bvs_next',ilog)
      call memory_monitor(sizeof(gradf_bvs_next),'gradf_bvs_next',.true.)
      gradf_bvs_next = gradf_bvs

!c  release temporary array
      call memory_monitor(-sizeof(rwork),'initbcdd-rwork',.true.)
      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)


!c  array seepage_bits
      allocate (iwork(nbvs), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initbcdd-iwork',.true.)

      do ibvs = 1,nbvs
        iwork(ibvs) = seepage_bits(ibvs)
      end do

      call memory_monitor(-sizeof(seepage_bits),'seepage_bits',.true.)
      deallocate (seepage_bits, stat = ierr)
      call checkerr(ierr,'seepage_bits',ilog)

      allocate (seepage_bits(nbvs), stat = ierr)
      call checkerr(ierr,'seepage_bits',ilog)
      call memory_monitor(sizeof(seepage_bits),'seepage_bits',.true.)

      do ibvs = 1,nbvs
        seepage_bits(ibvs) = iwork(ibvs)
      end do  

      call memory_monitor(-sizeof(iwork),'initbcdd-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

!c  array iabvs

      allocate (iwork(nbvs), stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'initbcdd-iwork',.true.)

      do ibvs = 1,nbvs
        iwork(ibvs) = iabvs(ibvs)
      end do

      call memory_monitor(-sizeof(iabvs),'iabvs',.true.)
      deallocate (iabvs, stat = ierr)
      call checkerr(ierr,'iabvs',ilog)

      allocate (iabvs(nbvs), stat = ierr)
      call checkerr(ierr,'iabvs',ilog)
      call memory_monitor(sizeof(iabvs),'iabvs',.true.)

      do ibvs = 1,nbvs
        iabvs(ibvs) = iwork(ibvs)
      end do

      do ibvs = 1, nbvs
        do i = nbvs, ibvs + 1, -1
          if (iabvs(i) == iabvs(ibvs)) then
            iabvs(ibvs) = -iabvs(ibvs)
            exit
          end if
        end do
      end do

      call memory_monitor(-sizeof(iwork),'initbcdd-iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

!c  array btypevs
      allocate (cwork(nbvs), stat = ierr)
      call checkerr(ierr,'cwork',ilog)
      call memory_monitor(sizeof(cwork),'initbcvs-cwork',.true.)

      do ibvs = 1,nbvs
        cwork(ibvs) = btypevs(ibvs)
      end do

      call memory_monitor(-sizeof(btypevs),'btypevs',.true.)
      deallocate (btypevs, stat = ierr)
      call checkerr(ierr,'btypevs',ilog)

      allocate (btypevs(nbvs), stat = ierr)
      call checkerr(ierr,'btypevs',ilog)
      call memory_monitor(sizeof(btypevs),'btypevs',.true.)

      do ibvs = 1,nbvs
        btypevs(ibvs) = cwork(ibvs)
      end do

      call memory_monitor(-sizeof(cwork),'initbcvs-cwork',.true.)
      deallocate (cwork, stat = ierr)
      call checkerr(ierr,'cwork',ilog)
      
      !Check if the boundary condition is valid
      !allocate(bvalid_iabvs(nbvs), stat = ierr)
      !call checkerr(ierr,'bvalid_iabvs',ilog)
      !bvalid_iabvs = .true.
      !do ibvs = 1,nbvs
      !    do ibvs2 = ibvs +1, nbvs
      !        if(iabvs(ibvs) == iabvs(ibvs2)) then
      !            bvalid_iabvs(ibvs) = .false.
      !            exit
      !        end if
      !    end do
      !end do
      
!cprovi-----------------------------------------------------------------------
!cprovi Store the initial boundary conditions values
!cprovi When ice sheet loading is computed, boundary
!cprovi conditions for flow are transient. However, we
!cprovi restart the initial values startyin the new
!cprovi time step 
!cprovi Idem for transport boundary conditions 
!cprovi-----------------------------------------------------------------------      
      if (compute_ice_sheet_loading) then 
         !nbvs0=nbvs
         !nbrt0=nbrt
         allocate (bcondvs0(nbvs), stat = ierr)
         call checkerr(ierr,'bcondvs0',ilog)
         call memory_monitor(sizeof(bcondvs0),'bcondvs0',.true.)
         bcondvs0 = bcondvs

         allocate (bcondvs1(nbvs), stat = ierr)
         call checkerr(ierr,'bcondvs1',ilog)
         call memory_monitor(sizeof(bcondvs1),'bcondvs1',.true.)
         bcondvs1 = bcondvs

         !allocate (iabvs0(nbvs0), stat = ierr)
         !call checkerr(ierr,'iabvs0',ilog)
         
         !allocate (jabrt0(nbrt0), stat = ierr)
         !call checkerr(ierr,'jabrt0',ilog)
         
         !do ibrt = 1,nbrt0
         !  jabrt0(ibrt) = jabrt(ibrt)
         !end do

         allocate (b_iabvs_ice(nbvs), stat = ierr)
         b_iabvs_ice = .true.
         call checkerr(ierr,'b_iabvs_ice',ilog)
         call memory_monitor(sizeof(b_iabvs_ice),'b_iabvs_ice',.true.)
         
         allocate (b_jabrt_ice(nbrt), stat = ierr)
         b_jabrt_ice = .true.
         call checkerr(ierr,'b_jabrt_ice',ilog)
         call memory_monitor(sizeof(b_jabrt_ice),'b_jabrt_ice',.true.)
         
         ntemp = max(nbvs, nbrt)
         
         allocate (iwork_bc(ntemp), stat = ierr)
         iwork_bc = 0
         call checkerr(ierr,'iwork_bc',ilog)
         call memory_monitor(sizeof(iwork_bc),'iwork_bc',.true.)
         
         allocate (rwork_bc(ntemp), stat = ierr)
         rwork_bc = 0.0d0
         call checkerr(ierr,'rwork_bc',ilog)
         call memory_monitor(sizeof(rwork_bc),'rwork_bc',.true.)
      end if
!cprovi-----------------------------------------------------------------------
!cprovi Store the 
!cprovi-----------------------------------------------------------------------      
      goto 1000

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'file ', prefix(:l_prfx)//'.bcvs missing'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading input file, error code ',ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
