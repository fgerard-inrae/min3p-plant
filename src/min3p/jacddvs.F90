!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacddvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacddvs
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (density-dependent flow)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - August 16, 2002
!c
!c last modified:   Tom Henderson - September 10, 2003
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c                  Celine Blitz Frayret (CBF) for Frederic Gerard, December 14, 2018 
!c                    (DSU Comment) Removed qroot, qrootinc and dqroot as local variables to use them as global variables from biol.F90 module,
!c                    (DSU Comment) Removed qroot computation (now computed for each control volume in jacvs subroutine)
!c
!c                  Danyang Su - Only qroot is necessary to be declared global variable
!c                               qrootinc and dqroot is always locally calculated and used, not necessary to used as global variable
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     - +
!c           bvs(nn)            = rhs vector                          - +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation
!c           pornew(nn)         = porosity (new time level)           + -
!c           relperm(nn)        = relative permeability               * +
!c           relpinc(nn)        = relative permeability (incremented) * *
!c           sainc(nn)          = aqueous phase saturation            * *
!c                                - incremented
!c           sanew(nn)          = aqueous phase saturation            * +
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           uvsinc(nn)         = solution vector (incremented)       * *
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c dens.f:   real*8:
!c           -------
!c           density(nn)        = fluid density                       + - 
!c           dcoef(ncon-1)      = coefficient including density,      + -
!c                                viscosity, and relative 
!c                                permeability 
!c           viscosity(nn)      = fluid viscosity                     + -
!c
!c
!c
!c           integer*4
!c           ---------
!c           iter_sia           = iteration counter -Picard iteration * - 
!c
!c phys.f:   
!c   
!c         logical:
!c           --------
!c           pure_evap   = .true.  -> physical evaporation only ! CBF 
!c
!c biol.F90:  real*8:
!c          -------
!c          qroot(nn)          = root water uptake for current
!c                                control volume ! CBF
!c            qrootinc(nn)       = root water uptake for current
!c                                control volume (incremented) ! CBF
!c            dqroot(nn)         = derivative of root water uptake ! CBF
!c
!c local:    real*8:
!c           -------
!c           dqroot             = derivative of root water uptake
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsstor            = derivative of storage term
!c           dvsflux            = derivative of flux term
!c           gacc               = gravitational acceleration [m s^-2]
!c           hhinc              = hydraulic head (incremented)
!c           qroot              = root water uptake for current
!c                                control volume
!c           qrootinc           = root water uptake for current 
!c                                control volume (incremented)
!c           totvsflux          = total flux into current control 
!c                                volume
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           r0                 = constant
!c           r1                 = constant
!c
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ivol               = counter (control volumes)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           isym               = symmetry pointer
!c           jvol               = row-column pointer
!c
!c external: fluxdd    = flux function for density dependent flow
!c           rhsvs     = assembly of rhs vector
!c           rootwat   = function for computing root water uptake
!c           soilparm  = soil hydraulic parameters
!c           stordd    = storage function for density dependent 
!c                       flow 
!c ----------------------------------------------------------------------
 
      subroutine jacddvs
 
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif
      use parm
      use gen
      use phys
      use dens
      use biol


#ifdef OPENMP
      use omp_lib 
#endif 
 
#ifdef USG
      use math_common
      use geometry
      use usg_mesh_data, only : num_edge_dvols,cells, num_cells,       &
                                num_nodes_per_cell, num_edge_maxcells
      use gradient_usg, only : gradient_cross_diff_dd,                 &
                               gradient_cross_diff_dd_inc
      use usg_face_utility, only : usg_face_utility_cinfvs
      use mod_fluxdd_usg, only : fluxdd_usg
#endif
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      real(kind=8) :: rewm_gbl, rsum_vprop_gbl, rsum_vprop_inc_gbl
      PetscErrorCode :: ierrcode
#endif

      real*8 :: delt_loc, densnew_ivol, densold_ivol,                  &
                densnewc_ivol, densoldc_ivol, totvsflux,               &
                tdsnew_ivol, tdsold_ivol, sanew_ivol, saold_ivol,      &
                porinc_ivol, qrootinc, dqroot, vsstor, dtotvsflux,     &
                del_pinc, vsfluxinc, dvsflux, vsstorinc, dvsstor,      &
                qroot,transp,soilevapo, rsum_vprop_inc, rew,           &
                dummy1, dummy2
      real*8, external :: fluxdd, rootwat, stordd, porosity_flow
      real*8, external :: evapo

      integer :: i1, icon, idiag, istart, iend, isym, ivol, izn, jvol, &
                 chunk

      external rhsvs, soilprdd

      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1=1.0d0,        &
                           r2 = 2.0d0, r3 = 3.0d0

#ifdef USG
      integer :: i2, icell, idvol, kvol, ncell, ndvol, nrelp
      real*8 :: relps_loc(num_edge_maxcells)
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: flux_ddflow_hls_corr(num_edge_dvols,num_edge_maxcells),    &
                flux_ddflow_inc_hls_corr(num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_locs(num_crossdifficv_max)
      type(point) :: grad_ddflow_mids(num_edge_dvols,num_edge_maxcells),   &
                     grad_ddflow_inc_mids(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_ddflow_hls_loc(num_edge_dvols)
      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)
#endif

!cdsu
!c Small round-off error in OpenMP reduction operation (:sum) causes 
!c significant difference in the final results. The code looks very sensitive
!c to the value of rsum_vprop
      real(kind=16) :: rewm_quad, rsum_vprop_quad, rsum_vprop_inc_quad
    
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
        if(mod(chunk, i_chunksize_factor_flow) > 0) then
            chunk = chunk/i_chunksize_factor_flow + 1
        else
            chunk = chunk/i_chunksize_factor_flow
        end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif
    
      if (iter_sia==1) then
        delt_loc=delt_tds
      else
        delt_loc=delt
      end if

!c  compute total potential root uptake and estimate 
      rewm_quad = real(r0,kind=16)
      rsum_vprop_quad = real(r0,kind=16)
      rsum_vprop_inc_quad = real(r0,kind=16)

!c  scaling factor
      
!c  build jacobian matrix
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, dummy1, dummy2,                                      &
#endif
    !$omp ivol, izn)                                                  &
    !$omp reduction(+:rewm_quad,rsum_vprop_quad,rsum_vprop_inc_quad)
#endif

#ifdef USG
      if (is_cell_based_relp) then
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
#endif
        do ivol = 1,nngl             !loop over control volumes

!c  increment primary unknown (pressure)
!c  modified increment here

          uvsinc(ivol) = uvsnew(ivol) + dinc_vs

          izn = mpropvs(ivol)

          if (.not. b_disable_sat_updt) then
            if (soilhydrfunc_field) then
              call soilprdd(uvsinc(ivol),sainc(ivol),sginc(ivol),      &
                            dummy1,dummy2,snnew(ivol),                 &
                            swr_vol(ivol),aentry_vol(ivol),            &
                            spalpha_vol(ivol),spbeta_vol(ivol),        &
                            expn_vol(ivol),spgamma_vol(ivol),          &
                            napl_permeability,                         &
                            napl_kfunction,sgr,isovendrying(izn),      &
                            beta_ovendry(izn),hm_ovendry(izn),         &
                            w0_ovendry(izn),cp0_ovendry(izn),          &
                            ref_dens,gacc)
            else
              call soilprdd(uvsinc(ivol),sainc(ivol),sginc(ivol),      &
                            dummy1,dummy2,snnew(ivol),                 &
                            swr(izn),aentry(izn),spalpha(izn),         &
                            spbeta(izn),expn(izn),spgamma(izn),        &
                            napl_permeability,                         &
                            napl_kfunction,sgr,isovendrying(izn),      &
                            beta_ovendry(izn),hm_ovendry(izn),         &
                            w0_ovendry(izn),cp0_ovendry(izn),          &
                            ref_dens,gacc)
            end if
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif


#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
        do icell = 1, num_cells            !loop over control volumes

!c  increment primary unknown (pressure)
!c  modified increment here

          izn = mpropvs_cell(icell)

          if (.not. b_disable_sat_updt) then
            if (soilhydrfunc_field) then
              call soilprdd(uvsinc(ivol),dummy1,dummy2,                  &
                            relpinc(icell),relpincg(icell),snnew(ivol),  &
                            swr_vol(ivol),aentry_vol(ivol),              &
                            spalpha_vol(ivol),spbeta_vol(ivol),          &
                            expn_vol(ivol),spgamma_vol(ivol),            &
                            napl_permeability,                           &
                            napl_kfunction,sgr,isovendrying(izn),        &
                            beta_ovendry(izn),hm_ovendry(izn),           &
                            w0_ovendry(izn),cp0_ovendry(izn),            &
                            ref_dens,gacc)
            else
              call soilprdd(uvsinc(ivol),dummy1,dummy2,                  &
                            relpinc(icell),relpincg(icell),snnew(ivol),  &
                            swr(izn),aentry(izn),                        &
                            spalpha(izn),spbeta(izn),                    &
                            expn(izn),spgamma(izn),                      &
                            napl_permeability,                           &
                            napl_kfunction,sgr,isovendrying(izn),        &
                            beta_ovendry(izn),hm_ovendry(izn),           &
                            w0_ovendry(izn),cp0_ovendry(izn),            &
                            ref_dens,gacc)
            end if
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif

      else
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
        do ivol = 1,nngl             !loop over control volumes

!c  increment primary unknown (pressure)
!c  modified increment here

          uvsinc(ivol) = uvsnew(ivol) + dinc_vs

          izn = mpropvs(ivol)

          if (.not. b_disable_sat_updt) then
            if (soilhydrfunc_field) then
              call soilprdd(uvsinc(ivol),sainc(ivol),sginc(ivol),      &
                            relpinc(ivol),relpincg(ivol),snnew(ivol),  &
                            swr_vol(ivol),aentry_vol(ivol),            &
                            spalpha_vol(ivol),spbeta_vol(ivol),        &
                            expn_vol(ivol),spgamma_vol(ivol),          &
                            napl_permeability,                         &
                            napl_kfunction,sgr,isovendrying(izn),      &
                            beta_ovendry(izn),hm_ovendry(izn),         &
                            w0_ovendry(izn),cp0_ovendry(izn),          &
                            ref_dens,gacc)
            else
              call soilprdd(uvsinc(ivol),sainc(ivol),sginc(ivol),      &
                            relpinc(ivol),relpincg(ivol),snnew(ivol),  &
                            swr(izn),aentry(izn),                      &
                            spalpha(izn),spbeta(izn),                  &
                            expn(izn),spgamma(izn),                    &
                            napl_permeability,                         &
                            napl_kfunction,sgr,isovendrying(izn),      &
                            beta_ovendry(izn),hm_ovendry(izn),         &
                            w0_ovendry(izn),cp0_ovendry(izn),          &
                            ref_dens,gacc)
            end if
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif


#ifdef USG
      end if
#endif

!c DSU compute mean reserve of extractible water : correction method for water stress = 2
!c DSU move this part output of jacobian matrix assembly. This is only related to sanew variable
!c DSU and the other variables used in rewm calculation remain unchanged.

      if (root_uptake) then
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
        do ivol = 1, nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          rewm_quad = rewm_quad + real(cvol(ivol)*rew(sanew,ivol)/cvol_tot,kind=16)
          rsum_vprop_quad = rsum_vprop_quad + real(rld(ivol)*sanew(ivol)*cvol(ivol),kind=16)
          rsum_vprop_inc_quad = rsum_vprop_inc_quad + real(rld(ivol)*sainc(ivol)*cvol(ivol),kind=16)
        end do
#ifdef OPENMP
    !$omp end do
#endif
      end if
#ifdef OPENMP
    !$omp end parallel
#endif

     if (root_uptake) then

        rewm = real(rewm_quad,kind=8)
        rsum_vprop = real(rsum_vprop_quad,kind=8)
        rsum_vprop_inc = real(rsum_vprop_inc_quad,kind=8)

#ifdef PETSC
!!cdsu MPI_REAL16 works just fine when use Intel Fortran and Intel MPI,
!!cdsu However, it does not return right value when use OpenMPI or MPICH.
!!cdsu For example, OpenMPI 1.6 or MPICH 3.3.

!        call MPI_Allreduce(rewm_quad, rewm_gbl,1,MPI_REAL16,           &
!                           MPI_SUM,Petsc_Comm_World,ierrcode)
!        CHKERRQ(ierrcode)
!        rewm_quad = rewm_gbl
!
!        call MPI_Allreduce(rsum_vprop_quad,rsum_vprop_gbl,1,MPI_REAL16,&
!                           MPI_SUM,Petsc_Comm_World,ierrcode)
!        CHKERRQ(ierrcode)
!        rsum_vprop_quad = rsum_vprop_gbl
!
!        call MPI_Allreduce(rsum_vprop_inc_quad,rsum_vprop_inc_gbl,1,   &
!                           MPI_REAL16,MPI_SUM,Petsc_Comm_World,ierrcode)
!        CHKERRQ(ierrcode)
!        rsum_vprop_inc_quad = rsum_vprop_inc_gbl
!
!        rewm = rewm_quad
!        rsum_vprop = rsum_vprop_quad
!        rsum_vprop_inc = rsum_vprop_inc_quad

!!cdsu alternative code

        call MPI_Allreduce(rewm, rewm_gbl,1,MPI_REAL8,           &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rewm = rewm_gbl

        call MPI_Allreduce(rsum_vprop,rsum_vprop_gbl,1,MPI_REAL8,&
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rsum_vprop = rsum_vprop_gbl

        call MPI_Allreduce(rsum_vprop_inc,rsum_vprop_inc_gbl,1,   &
                           MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rsum_vprop_inc = rsum_vprop_inc_gbl
#endif
      end if



#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp i2, icell, idvol, kvol, ncell, ndvol, nrelp, relps_loc,     &
    !$omp dummy1, dummy2,                                             &
    !$omp grad_ddflow_mids, grad_ddflow_inc_mids, grad_locs,          &
    !$omp flux_ddflow_hls_corr, flux_ddflow_inc_hls_corr,             &
    !$omp grad_weights, grad_ddflow_hls_loc,                         &
    !$omp cinfvs_usg_loc, cinfvs_usg_cross_loc,                       &
#endif
    !$omp i1, icon, idiag, iend, istart, isym, ivol, izn,             &
    !$omp iups, jvol, dcoef, del_p, del_pinc, sanew_ivol, saold_ivol, &
    !$omp densnewc_ivol, densoldc_ivol, tdsnew_ivol, tdsold_ivol,     &
    !$omp del_z, densnew_ivol, densold_ivol, qrootinc, dqroot,        &
    !$omp transp, soilevapo, qroot,                                   &
    !$omp dtotvsflux, dvsflux, dvsstor, porinc_ivol, rho_av,          &
    !$omp totvsflux, vsflux, vsfluxinc, vsstor, vsstorinc)
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided)
#else
    !$omp do schedule(auto)
#endif
#endif
      do ivol = 1,nngl             !loop over control volumes

        !cdsu convergence problem if using formula below
        !cdsu need further check, DSU 2020-01-07
        !if (iter_sia==1) then
        !  densnew_ivol = densold(ivol)
        !  densold_ivol = densold2(ivol)
        !  sanew_ivol = saold(ivol)
        !  saold_ivol = saold2(ivol)
        !  tdsnew_ivol = tds_old(ivol)
        !  tdsold_ivol = tds_old2(ivol)   
        !else
        !  densnew_ivol = density(ivol)
        !  densold_ivol = densold(ivol)
        !  sanew_ivol = sanew(ivol)
        !  saold_ivol = saold(ivol)
        !  tdsnew_ivol = tds_new(ivol)
        !  tdsold_ivol = tds_old(ivol)
        !end if

        densnew_ivol = density(ivol)
        densold_ivol = densold(ivol)
        sanew_ivol = sanew(ivol)
        saold_ivol = saold(ivol)
        tdsnew_ivol = tds_new(ivol)
        tdsold_ivol = tds_old(ivol)

        if (ispitzerdens) then  
          if (heat_transport) then
            densoldc_ivol = densold_pitzer(ivol)
            densnewc_ivol = density_pitzer(ivol)
          else
            !c density_pitzer is not avaialbe without heat transport
            !c use the following formula which is same as non-pitzer density
            densoldc_ivol = drho_dc*tds_old(ivol)
            densnewc_ivol = drho_dc*tds_new(ivol)
          end if
        else
          densoldc_ivol = r0
          densnewc_ivol = r0
        end if


        idiag = iavs(ivol)       !pointer - diagonal 
        istart = iavs(ivol)+1    !pointer - start (off-diagonal entries)
        iend = iavs(ivol+1)-1    !pointer - end (off-diagonal entries)
        
        izn = mpropvs(ivol)
     
        if (modify_por(ivol)) then
            porinc_ivol = porosity_flow(porold(ivol),uvsinc(ivol),    &
                          uvsold(ivol),stor(ivol),                    &
                          por_stress_dt(ivol),por_init(ivol),facpormin)
        else                  
            porinc_ivol = pornew(ivol)               
        end if
        

!c  calculate storage and flux terms for current control volume

        totvsflux = r0           !initialize total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          jvol = javs(i1)        !column pointer

!c  compute total pressure potentials (psi) for current and adjacent 
!c  control volumes
  
          icon = icon+1          !counter (row entries)

          del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
          del_z(icon) = zg(jvol) - zg(ivol)

          if (del_z(icon) .ne. r0) then
            rho_av = rhalf * (density(ivol) + density(jvol))

            if (av_dens_z) then
              del_p(icon) = rho_av*(uvsnew(jvol)/density(jvol)-        &
                                    uvsnew(ivol)/density(ivol))
            end if

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential

            del_z(icon) = del_z(icon) * rho_av * gacc
            del_p(icon) = del_p(icon) + del_z(icon)
          end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
 

          if (.not.is_cell_based_relp) then
            if (upstream) then
              if (del_p(icon) .gt. r0) then
                iups(icon) = 'j'
                dcoef(icon) = relperm(jvol) * density(jvol)/viscosity(jvol)
              else
                iups(icon) = 'i'
                dcoef(icon) = relperm(ivol) * density(ivol)/viscosity(ivol) !upstream kr, density & visc
              end if
            else
              dcoef(icon) = (density(ivol)+density(jvol))/             &
                            (viscosity(ivol)+viscosity(jvol))
            end if
          end if

#ifdef USG
          if (discretization_type > 0 .and. is_cell_based_relp) then
            dcoef(icon) = (density(ivol)+density(jvol))/               &
                          (viscosity(ivol)+viscosity(jvol))
          end if
#endif

!c  compute fluxes between current control volume and adjacent 
!c  control volumes
          if (b_use_fixed_flow_vel) then
                        
            if (b_use_zero_flow_vel) then
              vsflux(icon) = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
!c calculate gradient for jvol
            if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_ddflow_mids = vector_zero
              flux_ddflow_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_dd(i1,ivol,jvol,              &
                     grad_locs,grad_ddflow_mids,grad_weights,          &
                     flux_ddflow_hls_corr,grad_ddflow_hls_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relperm(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = 1.0d0
              end if

              vsflux(icon) = -fluxdd_usg(del_p(icon),num_edge_dvols,ncell,       &
                                 grad_ddflow_mids(1:num_edge_dvols,1:ncell),     &
                                 flux_ddflow_hls_corr(1:num_edge_dvols,1:ncell), &
                                 cinfvs_usg_loc(1:num_edge_dvols,1:ncell),       &
                                 cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell), &
                                 is_cell_based_relp,nrelp,                       &
                                 relps_loc(1:nrelp)*dcoef(icon))

            else
#endif
              vsflux(icon) = - fluxdd(del_p(icon),cinfvs_a(i1), dcoef(icon))

#ifdef USG
            end if
#endif
          end if

!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no fluid flux between them
!cdsu fix bug
          !if (pore_clogging) then
          !  if (pornew(ivol) <= por_thresh_min .or.                    &
          !      pornew(jvol) <= por_thresh_min)  then
          !     vsflux(icon) = r0
          !  end if        
          !end if 

          totvsflux = totvsflux + vsflux(icon)

        end do                   !loop over connected control volumes

!c  compute storage term (lumped) for current control volume, 
!c  only for transient conditions

        if (transient_flow) then
          vsstor = cvol(ivol)*stordd(delt,delt_loc,                    &
                                     pornew(ivol),porold(ivol),        &
                                     sanew_ivol,saold_ivol,            &
                                     densnew_ivol,densold_ivol,        & 
                                     densnewc_ivol,densoldc_ivol,      & 
                                     tdsnew_ivol,tdsold_ivol,          &
                                     r0,r0,drho_dc,drho_dt,            &
                                     uvsnew(ivol),uvsold(ivol),        &
                                     stor(ivol),ispitzerdens,          &
                                     new_stor_deri,coupled_porpress,   &
                                     coupled_drhodt)
        else
          vsstor = r0
        end if                    

!c  compute root water uptake for current control volume
!c  DSU qroot computation here
!c  DSU compute mean reserve of extractible water : correction method for water stress = 2

        if (root_uptake) then
          transp = cvol(ivol)*rootwat(sanew,ivol,rsum_vprop)
        else
          transp = r0
        end if

        soilevapo = r0
        if (root_uptake .or. pure_evap) then
          if (soilhydrfunc_field) then
            if (h1dry_vol(ivol).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sanew,ivol)
            end if
          else          
            if (h1dry(izn).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sanew,ivol)
            end if
          end if
        end if
          
        qroot = transp + soilevapo        

!c  assembly of storage and flux terms in rhs vector
!c Anna Harrison added qh2o term Jan 24 2014
        if(water_removal) then
          totvsflux = totvsflux+qh2o(ivol)/delt
        end if

        call rhsvs(vsstor,totvsflux,bvs(ivol))

!c  add root water uptake to rhs vector

        bvs(ivol) = bvs(ivol)-qroot

!c  calculate derivatives of storage and flux terms for current 
!c  control volume (assembly columnwise)

        dtotvsflux = r0          !initialize derivative of total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes

#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

          jvol = javs(i1)        !column pointer
          isym = isymvs(i1)      !symmetry pointer

          icon = icon+1

          del_pinc = uvsnew(jvol) - uvsinc(ivol)
          del_pinc = del_pinc + del_z(icon)

!c  Use incremented relative permeability only if psi_i >= psi_j
!c  Change upstream point here may cause significant convergence problem.
!c  The upstream point should remain unchanged to the pressure increment.
!c  Bug fixed by DSU on 2019-12-18
          if (.not. is_cell_based_relp) then
            if (upstream) then
              !cdsu old code
              !if (del_pinc  .gt. r0) then
              !  dcoef(icon) = relperm(jvol)*density(jvol)/viscosity(jvol)
              !else
              !  dcoef(icon) = relpinc(ivol)*density(ivol)/viscosity(ivol)
              !end if
              !cdsu new code
              if (iups(icon) == 'i') then
                dcoef(icon) = relpinc(ivol)*density(ivol)/viscosity(ivol)
              else
                dcoef(icon) = relperm(jvol)*density(jvol)/viscosity(jvol)
              end if
            else
              dcoef(icon) = (relpinc(ivol)+relperm(jvol))*rhalf*       &
                            (density(ivol)+density(jvol))/             &
                            (viscosity(ivol)+viscosity(jvol))
            end if
          end if

#ifdef USG
          if (discretization_type > 0 .and. is_cell_based_relp) then
            !c apply relative permeability later for cell based relative permeability
            dcoef(icon) = (density(ivol)+density(jvol))/               &
                          (viscosity(ivol)+viscosity(jvol))
          end if
#endif

!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions
!c  flux with incremented variables and derivative of flux
          if (b_use_fixed_flow_vel) then
                        
            if (b_use_zero_flow_vel) then
              vsfluxinc = r0
            else
              !c TBD
            end if
          
          else
#ifdef USG
!c calculate gradient for ivol
            if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
              grad_ddflow_inc_mids = vector_zero
              flux_ddflow_inc_hls_corr = r0

              if (b_use_cross_diffusion_flow) then
                call gradient_cross_diff_dd_inc(i1,ivol,jvol,          &
                     dinc_vs,r0,grad_locs,                             &
                     grad_ddflow_inc_mids,grad_weights,                &
                     flux_ddflow_inc_hls_corr,grad_ddflow_hls_loc)                
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                                           cinfvs_usg_cross_loc)

              relps_loc = 0.0d0
              if (is_cell_based_relp) then
                nrelp = ncell
                do icell = 1, ncell
                  i2 = jacell(icell,i1)
                  if (i2 >0) then
                    relps_loc(icell) = relpinc(i2)
                  end if
                end do
              else
                nrelp = 2
                relps_loc(1:2) = 1.0d0
              end if

              vsfluxinc = -fluxdd_usg(del_pinc,num_edge_dvols,ncell,             &
                              grad_ddflow_inc_mids(1:num_edge_dvols,1:ncell),    &
                              flux_ddflow_inc_hls_corr(1:num_edge_dvols,1:ncell),&
                              cinfvs_usg_loc(1:num_edge_dvols,1:ncell),          &
                              cinfvs_usg_cross_loc(1:num_edge_dvols,1:ncell),    &
                              is_cell_based_relp,nrelp,                          &
                              relps_loc(1:nrelp)*dcoef(icon))

            else
#endif

              vsfluxinc = - fluxdd(del_pinc,cinfvs_a(i1),dcoef(icon))
#ifdef USG
            end if
#endif
          end if

          dvsflux = (vsfluxinc - vsflux(icon))/dinc_vs

!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no fluid flux between them
!cdsu fix bug, comment to avoid setting matrix diag entry to zero
          !if (pore_clogging) then
          !  if (pornew(ivol) <= por_thresh_min .or.                    &
          !      pornew(jvol) <= por_thresh_min)  then
          !    dvsflux = r0
          !    vsfluxinc = r0
          !  end if        
          !end if          
          
          dtotvsflux = dtotvsflux + vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
 
          avs(isym) = avs(isym) - dvsflux    !off-diagonal entries 

        end do                  !loop over connected control volumes

!c  compute storage term with incremented variables (lumped) 
!c  for current control volume, only for transient conditions

        if (transient_flow) then

          vsstorinc = cvol(ivol)*stordd(delt,delt_loc,                     &
                                        porinc_ivol,porold(ivol),          &
                                        sainc(ivol),saold_ivol,            &
                                        densnew_ivol,densold_ivol,         &
                                        densnewc_ivol,densoldc_ivol,       &
                                        tdsnew_ivol,tdsold_ivol,           &
                                        r0,r0,drho_dc,drho_dt,             &
                                        uvsinc(ivol),uvsold(ivol),         &
                                        stor(ivol),ispitzerdens,           &
                                        new_stor_deri,coupled_porpress,    &
                                        coupled_drhodt)
        else
         
          vsstorinc = r0
      
        end if                  
        
       
!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs

        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  !diagonal entry

!c      write(idbg,'(4x,4a12)') 'idiag       ',
!c     &                        'avs(idiag)  ',
!c     &                        'dvsstor     ',
!c     &                        'dtotvsflux  ' 
!c
!c      write(idbg,'(4(g12.4,2x))') idiag,
!c     &                            avs(idiag),
!c     &                            dvsstor,    
!c     &                            dtotvsflux

!c  compute derivative of root water uptake for current control volume
!c  DSU this part is missing in FG & CBF's version
!c  DSU need further modification if it's different from variably saturated flow

        if (root_uptake) then
          transp = cvol(ivol)*rootwat(sainc,ivol,rsum_vprop_inc)
        else
          transp = r0
        end if

        soilevapo = r0
        if (root_uptake .or. pure_evap) then
          if (soilhydrfunc_field) then
            if (h1dry_vol(ivol).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sainc,ivol)
            end if
          else
            if (h1dry(izn).gt.r0) then
              soilevapo = cvol(ivol)*evapo(sainc,ivol)
            end if
          end if
        end if

        qrootinc = transp + soilevapo

        dqroot = (qrootinc-qroot)/dinc_vs

        avs(idiag) = avs(idiag) + dqroot

      end do                        !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

 
!c      do ivol=1,nngl
!c        istart = iavs(ivol)
!c        iend = iavs(ivol+1)-1
!c        write(idbg,'(8es10.3)')(avs(i1),i1=istart,iend),bvs(ivol) 
!c      end do
!c      stop


      return
      end
