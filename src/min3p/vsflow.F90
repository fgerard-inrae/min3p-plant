!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/vsflow.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine vsflow
!c -----------------
!c
!c driver subroutine for variably saturated flow 
!c
!c written by:      Uli Mayer - May 6, 96
!c
!c last modified:   Uli Mayer - December 6, 96
!c                  Sergi Molins - January 18,2003
!c                  - computation of influence coeff.
!c                    in terms of conductivities
!c                  - new var passed to soilparm 
!c                  Sergi Molins - May 15, 2006
!c                  added new var -> passed to soilparm 
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     * +
!c           afvs(njafvs)       = incomplete factorization            * +
!c           bvs(nn)            = rhs vector                          * +
!c           deltol_vs          = solver update tolerance             + -
!c           hhead(nn)          = hydraulic head                      + +
!c           sanew(nn)          = aqueous phase saturation            + +
!c                                - new tim level
!c           uvs(nn)            = update towards solution-vector      * +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           restol_vs          = solver residual tolerance           + -
!c           res_vs(nn)          = residual                            * + 
!c           rmupdate           = maximum solution update (solver)    * +
!c           rnorm              = residual 2-norm                     * +
!c           rwork(8*nn)        = real*8 work array                   * *
!c           tol_vs             = convergence tolerance               + -
!c                                (variably saturated flow)
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           relperm()          = relative permeability               * +
!c           relpermg()         = relative permeability               * +
!c
!c
!c           integer*4:
!c           ----------
!c
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log file               + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           iafvs(nn+1)        = row pointer array for afvs          + -
!c           iafdvs(nn)         = diagonal pointer array for afvs     + -
!c           idbg               = unit number, debugging file         + -
!c           idetail_vs         = information level                   + -
!c           invordvs(nn)       = array containing inverse ordering   + -
!c           iter_seep          = iteration counter                   * +
!c                                (seepage face iteration)
!c           iter_vs            = iteration counter                   * +
!c                                (variably saturated flow)
!c           itseep_tot         = total number of seepage face        * +
!c                                iterations
!c           ittot_vs           = total number of iterations          * +
!c                                (variably saturated flow)
!c           iwork(*)           = integer work array                  * *
!c           javs(njavs)        = connectivity list                   + -
!c           jafvs(njafvs)      = column pointer array for afvs       + -
!c           lordervs(nn)       = array containing ordering           + -
!c           maxit_vs           = max. number of newton iterations    + -
!c                                (variably saturated flow)
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           msolvit_vs         = max. number of solver iterations    + -
!c           njavs              = number of global connections        + -
!c           njafvs             = number of factored connections      + -
!c           nn                 = total number of control volumes     + -
!c           itsolv             = actual number of solver iterations  * +
!c           itsolvtot_vs       = total number of solver              + +
!c                                iterations
!c                                (variably saturated flow)
!c          
!c           logical:
!c           --------
!c           not_converged      = .true.  -> continue Newton          * +
!c                                           iteration
!c           reduce_timestep    = .true.  -> restart with reduced     + +
!c                                           timestep
!c           seepage_face       = .true.  -> seepage face boundary    + -
!c                                           specified
!c           seep_iter          = .true.  -> continue seepage face    + +
!c                                           iteration
!c           steady_flow        = .true.  -> steady state flow        + -
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow   
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c           ilist              = pointer (integer work array)
!c           ivol               = counter (control volumes)
!c           izn                = pointer (material property)
!c     
!c           logical:
!c           --------
!c           over_flow          = .true.  -> ||r||_2 norm -> infinity
!c
!c external: checkerr = check for error during memory allocation
!c           zero_r8   = clear real*8 array
!c           jacvs     = construct Jacobian matrix 
!c                       (variably saturated flow)
!c           jacbvs    = incorporate boundary terms in Jacobian 
!c                       (variably saturated flow)
!c           incompletefactorization = incomplete lu-decomposition of
!c                                     stiffness matrix
!c           ws209     = iterative solution of matrix equation
!c           updatevs  = update solution vector, secondary variables
!c                       and check for convergence
!c           soilparm  = compute soil hydraulic parameters
!c           infcvs_cp = compute influence coefficients in terms 
!c                       of conductivities  
!c ----------------------------------------------------------------------

      subroutine vsflow

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use bbls
      use phys
      use chem
      use dgml, only : dgm, maxwell 
      use mip_bubble, only : mip_mt_enable,mip_update_relperm,mip_g
      use solver_results, only : solver_results_check_output
      use file_unit, only : lun_get, lun_free

      
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PARDISO      
      use solver_pardiso, only : pardiso_symbolicfactorization,      &
                                 pardiso_numfactorization,           &
                                 pardiso_substitution, ptvs, iparm_vs
#endif      
      
#ifdef PETSC
      use solver_dd, only : solver_dd_snes_solve_flow_heat
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef LIS
      use solver_lis, only : solver_lis_solve_flow
#endif

      use matrix_utility, only: export_mmformat, export_arrays1d,      &
                                export_mmformat_gbl

#ifdef USG
      use usg_mesh_data, only : cells, num_cells, num_nodes_per_cell
#endif
      
      
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      real*8, external :: cputime
      integer :: i, ic, im, ierr, ilist, iter_sia, ivol, izn, iter_div,&
                 n_unknown_vs, ibvs, maxvol, mip_g_loc
      integer :: ifile, idummy, iskip, nskip
      character*256 :: strdummy, strfile

      real*8 :: rdummy, sa_min_loc,sgt_loc,sgt_old_loc, uvsmax,        &
                sa_app_loc,sa_eff_loc,sg_eff_loc,sgr_imbi_loc
      logical :: unsaturated_loc,drainage_loc,main_drain_loc,          &
                 big_bubble_loc,solvegb_loc

#ifdef PETSC
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer*4 :: mpireduce_irank
      PetscErrorCode :: ierrcode
#endif

#ifdef USG
      integer :: i2, icell
      real*8 :: uvsnew_cell,sanew_cell,sonew_cell
#endif

      external checkerr, zero_r8, jacvs, jacbvs, updatevs, soilparm,   &
               incompletefactorization, ws209, infcvs_cp,     &
               soilparm_perm
                                                                       
      logical over_flow, b_redo_symbfac, b_freezing_pond
      
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
      integer, parameter :: i0 = 0
      
      iter_sia = 0
                      
      if (b_use_zero_flow_vel) then
        not_converged = .false.
                                                                       
        if (seepage_face) then                                           
          iter_seep = 0                                                  
          seep_iter = .false.                                             
        end if
      else
        not_converged = .true.
                                                                       
        if (seepage_face) then                                           
          iter_seep = 0                                                  
          seep_iter = .true.                                             
        end if
      end if    
                                                                       
      do while (seep_iter.or.not_converged)   !seepage face iteration  
                                                                       
        if (seepage_face) then                                         
          iter_seep = iter_seep+1                                      
          itseep_tot = itseep_tot + 1   
 
          if(rank == 0 .and. b_enable_output)  then              
            write(ilog,'(/,2x,a,i2,a)') 'Seepage Face Iteration ',    &
                                       iter_seep,':'                   
            write(ilog,'(2x,a,i4/)')                                  &
                  'Number of seepage face nodes: ',nseep_first           
          end if
        end if

        iter_vs = 0
        not_converged = .true.

        do while (not_converged)          !newton iteration loop
          
          prt_flow_tot = cputime()

          iter_vs = iter_vs+1             !iteration counter (current)
          ittot_vs = ittot_vs+1           !iteration counter (total)
          if (idetail_vs.eq.2 .and. rank == 0 .and. b_enable_output) then
            write(ilog,'(/a,i3,a)') 'Newton iteration ',iter_vs,':'
            write(ilog,'(a)') '---------------------'
          end if

!c  allocate memory for solver
          !if (i_solver_type_flow == 0) then
          !    allocate (rwork(8*nn,1), stat = ierr)
          !    rwork=0.0d0 
          !    call checkerr(ierr,'rwork',ilog)
          !
          !    allocate (iwork(nn), stat = ierr)
          !    iwork=0 
          !    call checkerr(ierr,'iwork',ilog)
          !    
          !    allocate (afvs(njafvs), stat = ierr)
          !    afvs=0.0d0 
          !    call checkerr(ierr,'afvs',ilog)
          !end if
          
          if (.not. allocated(avs)) then
              allocate (avs(njavs), stat = ierr)
              avs=0.0d0 
              call checkerr(ierr,'avs',ilog)
              call memory_monitor(sizeof(avs),'avs',.true.)
          end if
          
          if (i_solver_type_flow == 0) then
              if (.not. allocated(afvs)) then
                  allocate (afvs(njafvs), stat = ierr)
                  afvs=0.0d0 
                  call checkerr(ierr,'afvs',ilog)
                  call memory_monitor(sizeof(afvs),'afvs',.true.)
              end if
          end if      

         
!c  clear arrays
          call zero_r8(avs,njavs,1,1)
          call zero_r8(bvs,nngl,1,1)
          call zero_r8(uvs,nngl,1,1)

!c  construct jacobian matrix and rhs vector
          prt_flow_jac = cputime()

!c  compute influence coefficients in terms of conductivities
          if (gas_advection .or. dgm .or. maxwell) then
            call infcvs_cp
          end if 

          call jacvs
        !Export sparse matrix dataset and right hand side. For test only, dsu.  
        if((b_output_matrix.or.itimestep_output_matrix == mtime .or.   &
            (itimestep_output_matrix > 0 .and. mtime == 0)).and.       &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs_exb", ittot_vs)
            else if(itype_matrix_format == 1) then
                call export_mmformat(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs_exb", ittot_vs)
            end if
        end if

!c  incorporate boundary terms
        call jacbvs
       
        !Export sparse matrix dataset and right hand side. For test only, dsu.  
        if((b_output_matrix.or.itimestep_output_matrix == mtime .or.   &
            (itimestep_output_matrix > 0 .and. mtime == 0)).and.       &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs", ittot_vs)
            else if(itype_matrix_format == 1) then
                call export_mmformat(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs", ittot_vs)
            end if
#ifdef PETSC
            call export_mmformat_gbl(nn,nngl,njavs,iavs,javs,          &
                        avs,bvs,uvs,.true.,.true.,.false.,             &
                        "vsflow_vs",nngl,nngbl,.true.,ittot_vs)
#endif
        end if

!cprovi--------------------------------------------------------------------
!cprovi Estimate condition number for the current matrix. 
!cprovi This is used for testing when newton iteration failed.
!cprovi-------------------------------------------------------------------- 
#ifdef CONDITION_NUMBER
         if(b_output_condition_number) then
            call cond_num_cal(nngl, njavs, iavs, javs, avs,            &
                      condition_number, condition_number_info)
            
            if (rank == 0 .and. b_enable_output) then
            
            if (condition_number_info(1) .ge. 0) then
              write(*,"(2(a, 1pe15.6e3, 1x))")                         &
                    " classical cond. num. ",condition_number(1),      &
                    " skeel cond. num. ", condition_number(2)
              write(ilog,"(2(a, 1pe15.6e3, 1x))")                      &
                    " classical cond. num. ",condition_number(1),      &
                    " skeel cond. num. ", condition_number(2)
            else
              write(*,*)                                               &
                  ' error in estimating condition number, info(1) ',   &
                  condition_number_info(1)
              write(ilog,*)                                            &
                  ' error in estimating condition number, info(1) ',   &
                  condition_number_info(1)
            endif 
            
            if(i_solver_type_flow == 1) then
              if(condition_number(1) > 1.0d10 .and.                    &
                      condition_number(2) > 1.0d10) then
                  write(*,"(a)")                                       &
                      " Warning: matrix is ill-conditioned."
                  write(ilog,"(a)")                                    &
                      " Warning: matrix is ill-conditioned."
              end if
            end if
            
            end if
            
         end if     
#endif          
        prt_flow_jac = cputime() - prt_flow_jac        
       
        prt_flow_solver = 0.0d0
          
        !! use ws209 solver
        if (i_solver_type_flow == 0) then
#ifdef PARDISO   
          if(b_solver_test_pardiso) then
    !$omp parallel                                                    &
    !$omp if (njavs > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
              !!reset value of a
              do i = 1, njavs
                  avs_std(i) = avs(imapvs_std(i))
              end do
    !$omp end do
    !$omp end parallel
           
              b_redo_symbfac = .true.
100           prt_flow_symbfac_comp = cputime()
              if(bsymbolicfactor_vs .or.                               &
                      i_symfactor_type_flow == 1) then                 
                  call pardiso_symbolicfactorization(iparm_vs,ptvs,    &
                           nngl, njavs, iavs, javs_std, avs_std)       
                  n_unknown_vs = nngl                                  
                  bsymbolicfactor_vs = .false.                         
              end if                                                   
              prt_flow_symbfac_comp = cputime()-prt_flow_symbfac_comp  
                                                                       
              prt_flow_fac_comp = cputime()                            
              call pardiso_numfactorization(iparm_vs, ptvs, nngl,      &
                       njavs, iavs, javs_std, avs_std)                 
              prt_flow_fac_comp = cputime() - prt_flow_fac_comp        
                                                                       
              prt_flow_sub_comp = cputime()                            
              call pardiso_substitution(ilog, msolvit_vs, itsolv,      &
                       idetail_vs, res_vs, restol_vs, deltol_vs,       &
                       over_flow, rnorm, rmupdate, iparm_vs, ptvs,     &
                       nngl, njavs, iavs, javs_std, avs_std, bvs,      &
                       uvs_std)   
              prt_flow_sub_comp = cputime() - prt_flow_sub_comp
              
              if (b_redo_symbfac .and. (itsolv > n_max_iteration_flow  &
                  .or. rnorm > r_max_residual_flow .or. over_flow)) then
                  bsymbolicfactor_vs = .true. 
                  b_redo_symbfac = .false.
                  goto 100
              end if

          end if
#endif            

#ifdef PETSC
          if(b_solver_test_petsc) then
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_flow_heat(ilog,.true.,           &
                    idetail_vs,avs,bvs,uvs_std,iavs,javs,nngl,itsolv,  &
                    over_flow,rnorm,row_idx_l2pg_vs,                   &
                    col_idx_l2pg_vs,.false.)
            over_flow_vs = over_flow
#ifdef DEBUG
             if(rank == 0) then
                write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')       &
                "vsflow-A: rank, iteration, over_flow, rnorm ",        &
                rank, itsolv, over_flow, rnorm 
             end if
#endif
          end if
#endif

#ifdef LIS   
          if(b_solver_test_lis) then
            !only solver the local part, update the ghost value
            call solver_lis_solve_flow(ilog,idetail_vs,avs,bvs,        &
                      uvs_std,iavs,javs,nngl,nn,1,itsolv,over_flow,    &
                      rnorm,row_idx_l2pg_vs,col_idx_l2pg_vs,.false.)
          over_flow_vs = over_flow
#ifdef DEBUG
          if(rank == 0 .and. b_enable_output) then
            write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')           &
                  "vsflow-A2: rank, iteration, over_flow, rnorm ",     &
                  rank, itsolv, over_flow, rnorm
          end if
#endif
          end if 
#endif 

!c  Scale [avs] and {bvs} to produce unit diagonal
!c  Generate re-ordered preconditioner [af]

          ilist = 1
          prt_flow_fac = cputime()
          call incompletefactorization(nngl,njavs,njafvs,bvs,avs,afvs, &
                                      rwork_max,iavs,javs,iafvs,iafdvs,&
                                      jafvs,iwork_max(ilist),lordervs, &
                                      invordvs,numofthreads_ws209)       
          prt_flow_fac = cputime() - prt_flow_fac   
                                                                    
!c  solve [avs] * {uvs} = {bvs}
          prt_flow_sub = cputime()      
          call ws209(ilog,nngl,msolvit_vs,itsolv,idetail_vs,iavs,javs, &
                     iafvs,iafdvs,jafvs,lordervs,avs,afvs,uvs,bvs,     &
                     res_vs,rwork_max,restol_vs,deltol_vs,njavs,njafvs,&
                     over_flow,rnorm,rmupdate,numofthreads_ws209,      &
                     rank,b_enable_output)
          prt_flow_sub = cputime() - prt_flow_sub

#ifdef PARDISO
          if (b_solver_test_pardiso) then
            call solver_results_check_output(ittot_vs, nngl, uvs,      &
                     uvs_std, "vsflow_vs") 
          end if     
#endif  

#ifdef PETSC             
          if (b_solver_test_petsc) then        
              call solver_results_check_output(ittot_vs, nngl, uvs,    &
                       uvs_std, "vsflow_vs_petsc") 
          end if       
#endif
#ifdef LIS             
          if (b_solver_test_lis) then        
              call solver_results_check_output(ittot_vs, nngl, uvs,    &
                       uvs_std, "vsflow_vs_lis") 
          end if       
#endif 
          prt_flow_solver = prt_flow_symbfac+prt_flow_fac+prt_flow_sub
          
        !! use pardiso solver
        else if (i_solver_type_flow == 1) then               
#ifdef PARDISO
    !$omp parallel                                                    &
    !$omp if (njavs > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            !!reset value of a
            do i = 1, njavs
                avs_std(i) = avs(imapvs_std(i))
            end do
    !$omp end do
    !$omp end parallel
           
            b_redo_symbfac = .true.
200         prt_flow_symbfac = cputime()
            if(bsymbolicfactor_vs  .or.                                &
                    i_symfactor_type_flow == 1) then
                !write(idbg, *) "pardiso symbolic factorization for vsflow line 280"
                call pardiso_symbolicfactorization(iparm_vs, ptvs,     &
                         nngl, njavs, iavs, javs_std, avs_std)
                n_unknown_vs = nngl
                bsymbolicfactor_vs = .false.
            end if  
            prt_flow_symbfac = cputime() - prt_flow_symbfac
            
            !write(idbg, *) "pardiso numerical factorization for vsflow line 285"
            prt_flow_fac = cputime()
            call pardiso_numfactorization(iparm_vs, ptvs, nngl,        &
                     njavs, iavs, javs_std, avs_std)
            prt_flow_fac = cputime() - prt_flow_fac

            !write(idbg, *) "pardiso substitution for vsflow line 290"
            prt_flow_sub = cputime()
            call pardiso_substitution(ilog, msolvit_vs, itsolv,        &
                     idetail_vs, res_vs, restol_vs, deltol_vs,         &
                     over_flow, rnorm, rmupdate, iparm_vs, ptvs, nngl, &
                     njavs, iavs, javs_std, avs_std, bvs, uvs) 
            prt_flow_sub = cputime() - prt_flow_sub
            
            if (b_redo_symbfac .and. (itsolv > n_max_iteration_flow    &
                .or. rnorm > r_max_residual_flow .or. over_flow)) then
                bsymbolicfactor_vs = .true.
                b_redo_symbfac = .false.
                goto 200
            end if         
#endif    
            prt_flow_solver=prt_flow_symbfac+prt_flow_fac+prt_flow_sub 
        !! use PETSc solver
        else if (i_solver_type_flow == 2) then
#ifdef PETSC   
            prt_flow_solver = cputime()
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_flow_heat(ilog,.true.,           &
                      idetail_vs,avs,bvs,uvs,iavs,javs,nngl,itsolv,    &
                      over_flow,rnorm,row_idx_l2pg_vs,                 &
                      col_idx_l2pg_vs,.false.) 
            over_flow_vs = over_flow
            prt_flow_solver = cputime() - prt_flow_solver
#ifdef DEBUG
             if(rank == 0 .and. b_enable_output) then
                write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')       &
                "vsflow-A: rank, iteration, over_flow, rnorm ",        &
                rank, itsolv, over_flow, rnorm
             end if
#endif
#endif        
        !! use LIS solver
        else if (i_solver_type_flow == 3) then
#ifdef LIS   
          prt_flow_solver = cputime()
          !only solver the local part, update the ghost value
          call solver_lis_solve_flow(ilog,idetail_vs,avs,bvs,          &
                      uvs,iavs,javs,nngl,nn,1,itsolv,over_flow,rnorm,  &
                      row_idx_l2pg_vs,col_idx_l2pg_vs,.false.)
          over_flow_vs = over_flow
          prt_flow_solver = cputime() - prt_flow_solver
#ifdef DEBUG
          if(rank == 0 .and. b_enable_output) then
            write(*,'(a, 2(1x, i5), 1x, l1, 1x, 1pe15.6e3)')           &
                  "vsflow-A: rank, iteration, over_flow, rnorm ",      &
                  rank, itsolv, over_flow, rnorm
          end if
#endif
#endif        

        end if  
      
        !Export sparse matrix dataset and right hand side. For test only, dsu.        
        if((b_output_matrix.or.itimestep_output_matrix == mtime .or.   &
            (itimestep_output_matrix > 0 .and. mtime == 0)).and.       &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(nngl,njavs,iavs,javs,avs,bvs,     &
                       uvs,.false.,.false.,.true.,"vsflow_vs",ittot_vs)
            else if(itype_matrix_format == 1) then
                call export_mmformat(nngl,njavs,iavs,javs,avs,bvs,     &
                       uvs,.false.,.false.,.true.,"vsflow_vs",ittot_vs)
            end if
#ifdef PETSC
            call export_mmformat_gbl(nn,nngl,njavs,iavs,javs,          &
                        avs,bvs,uvs,.false.,.false.,.true.,            &
                        "vsflow_vs",nngl,nngbl,.true.,ittot_vs)
#endif
        end if

!cdsu  debug part, use external solution (written in sequential order) to test
!        if (mtime >= 1 .and. mtime <= 100 .and. ittot_vs <= 1000) then
!           call export_mmformat_gbl(nn,nngl,njavs,iavs,javs,           &
!                       avs,bvs,uvs,.false.,.false.,.true.,             &
!                       "vsflow_vs",nngl,nngbl,.false.,ittot_vs)
!        
!          if (rank == 0) then
!            write(*,*) "-->read hydraulic head and temperature change from external"
!          end if
!        
!          ifile = lun_get()
!          write(strfile, *) ittot_vs
!          strfile = "x_vsflow_vs_"//trim(adjustl(strfile))//"_natgbl.txt"
!          open(ifile,file=trim(strfile),status='old',form='formatted')
!          uvs = 0.0d0
!          nskip = 0
!          read(ifile,*) strdummy
!          do ivol = 1, nngl
!#ifdef PETSC
!            do iskip = 1, node_idx_lg2g(ivol) - nskip -1
!              read(ifile,*) idummy
!            end do
!            nskip = node_idx_lg2g(ivol)
!#endif  
!            read(ifile,*) idummy,uvs(ivol)
!          end do
!        
!          call lun_free(ifile)
!        end if
!cdsu  debug part, use external solution (written in sequential order) to test, end


!c  deallocate memory for solver
          !if (i_solver_type_flow == 0) then
          !    deallocate (rwork, stat = ierr)
          !    call checkerr(ierr,'rwork',ilog)
          !
          !    deallocate (iwork, stat = ierr)
          !    call checkerr(ierr,'iwork',ilog)
          !    
          !    deallocate (afvs, stat = ierr)
          !    call checkerr(ierr,'afvs',ilog)
          !end if
          
          if (b_dynamic_memory) then
              call memory_monitor(-sizeof(avs),'avs',.true.)
              deallocate (avs, stat = ierr)
              call checkerr(ierr,'avs',ilog)
              
              if (i_solver_type_flow == 0) then
                  call memory_monitor(-sizeof(afvs),'afvs',.true.)
                  deallocate (afvs, stat = ierr)
                  call checkerr(ierr,'afvs',ilog)
              end if
          end if

!c  total number of solver iterations

          itsolvtot_vs = itsolvtot_vs + itsolv

!c  update solution vector and secondary variables and check for
!c  convergence if inner iteration successful  

          if (.not.over_flow) then
            
            !Parallelized, OpenMP, DSU 
            call updatevs

!cdsu ---------------------------------------------------------------------------------------------------
!cdsu check if newton iteration is diverged based on the saved maximum update value in newton iteration
!cdsu ---------------------------------------------------------------------------------------------------
            if (b_check_div_vs .and. iter_vs >= 5) then
              iter_div = mod(iter_vs,5)
              if (iter_div == 0) then
                if (div_vs(5) > div_vs(4)*1.1d0 .and.                  &
                    div_vs(4) > div_vs(3)*1.1d0 .and.                  &
                    div_vs(3) > div_vs(2)*1.1d0 .and.                  &
                    div_vs(2) > div_vs(1)*1.1d0) then
                  reduce_timestep = .true.
                end if
              else if (iter_div == 1) then
                if (div_vs(1) > div_vs(5)*1.1d0 .and.                  &
                    div_vs(5) > div_vs(4)*1.1d0 .and.                  &
                    div_vs(4) > div_vs(3)*1.1d0 .and.                  &
                    div_vs(3) > div_vs(2)*1.1d0) then
                  reduce_timestep = .true.
                end if
              else if (iter_div == 2) then
                if (div_vs(2) > div_vs(1)*1.1d0 .and.                  &
                    div_vs(1) > div_vs(5)*1.1d0 .and.                  &
                    div_vs(5) > div_vs(4)*1.1d0 .and.                  &
                    div_vs(4) > div_vs(3)*1.1d0) then
                  reduce_timestep = .true.
                end if
              else if (iter_div == 3) then
                if (div_vs(3) > div_vs(2)*1.1d0 .and.                  &
                    div_vs(2) > div_vs(1)*1.1d0 .and.                  &
                    div_vs(1) > div_vs(5)*1.1d0 .and.                  &
                    div_vs(5) > div_vs(4)*1.1d0) then
                  reduce_timestep = .true.
                end if
              else if (iter_div == 4) then
                if (div_vs(4) > div_vs(3)*1.1d0 .and.                  &
                    div_vs(3) > div_vs(2)*1.1d0 .and.                  &
                    div_vs(2) > div_vs(1)*1.1d0 .and.                  &
                    div_vs(1) > div_vs(5)*1.1d0) then
                  reduce_timestep = .true.
                end if
              end if
              if (reduce_timestep) then
                if (steady_flow) then
                  if (rank == 0) then
                    write(ilog,*)                                      &
                    '-------------------------------------------'
                    write(ilog,*)                                      &
                    '   terminated in routine vsflow            '
                    write(ilog,*)                                      &
                    '   newton solver diverges                  '
                    write(ilog,*)                                      &
                    '   bye now ...                             '
                    write(ilog,*)                                      &
                    '-------------------------------------------'
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                else
                  if (rank == 0 .and. b_enable_output .and. idetail_vs.gt.0) then
                    write(*,*) 'reduce time step: newton iteration diverged'
                    write(ilog,*) 'reduce time step: newton iteration diverged'
                  end if
                end if
              end if
            end if

!c  max. number of iterations is exceeded and convergence tolerance
!c  not satisfied
!c  steady state problem -> terminate execution


            if ((iter_vs.ge.maxit_vs).and.(not_converged)) then
              if (steady_flow) then
                  
                if (rank == 0 ) then  
                  write(ilog,*)                                       &
                   '-------------------------------------------'       
                  write(ilog,*)                                       &
                   '   terminated in routine vsflow            '       
                  write(ilog,*)                                       &
                   '   maximum number of iterations exceeded   '       
                  write(ilog,*)                                       &
                   '   bye now ...                             '       
                  write(ilog,*)                                       &
                   '-------------------------------------------'   
                end if
                
                if (rank == 0 .and. b_enable_output .and. b_enable_output_gen) then 
                  write(igen,*)                                       &
                   '-------------------------------------------'       
                  write(igen,*)                                       &
                   '   terminated in routine vsflow            '       
                  write(igen,*)                                       &
                   '   maximum number of iterations exceeded   '       
                  write(igen,*)                                       &
                   '   bye now ...                             '       
                  write(igen,*)                                       &
                   '-------------------------------------------'
                end if

#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

!c  transient problem -> reduce time step

              elseif (transient_flow) then 
               
                if(rank == 0  .and. b_enable_output)  then                    
                  write(ilog,*)                                       &
                   '-------------------------------------------'       
                  write(ilog,*)                                       &
                   '   maximum number of iterations exceeded   '       
                  write(ilog,*)                                       &
                   '             reducing time step            '       
                  write(ilog,*)                                       &
                   '-------------------------------------------'  
                end if
                
                reduce_timestep = .true.
              end if
            end if
!c  overflow occurred
!c  steady state problem -> terminate execution

          elseif (over_flow) then
            if (steady_flow) then
              
              if (rank == 0) then
                write(ilog,*)'-------------------------------------------'
                write(ilog,*)'   failure in solver - overflow occurred in vsflow   '
                write(ilog,*)'   bye now ...                             '
                write(ilog,*)'-------------------------------------------'
              end if
              
              if (rank == 0 .and. b_enable_output .and. b_enable_output_gen) then 
                write(igen,*)'-------------------------------------------'
                write(igen,*)'   failure in solver - overflow occurred in vsflow   '
                write(igen,*)'   bye now ...                             '
                write(igen,*)'-------------------------------------------'
              end if

#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop

!c  transient problem -> reduce time step

            elseif (transient_flow) then
                
              if(rank == 0 .and. b_enable_output)  then   
                write(ilog,*)'-------------------------------------------'
                write(ilog,*)'   failure in solver - overflow occurred in vsflow   '
                write(ilog,*)'             reducing time step            '
                write(ilog,*)'-------------------------------------------'
              end if
              
              reduce_timestep = .true.
            end if
          end if                      !(over_flow)
          
          prt_flow_tot = cputime() - prt_flow_tot
          
!c  write runtime to file 
          if(rank == 0 .and. b_prtfile) then
            write(iprt_flow,"(i8,1x,3(i3,1x),i8,1x,7(1pe15.6e3,2x))")  &
                  mtime, iter_sia, iter_seep, iter_vs, ittot_vs,       &
                  prt_flow_jac, prt_flow_symbfac, prt_flow_fac,        &
                  prt_flow_sub, prt_flow_solver, (prt_flow_tot -       &
                  prt_flow_jac - prt_flow_solver), prt_flow_tot

            if(b_solver_test_pardiso) then
              write(iprt_flow_comp,                                    &
                    "(i8,1x,3(i3, 1x),i8,1x,5(1pe15.6e3,2x))")         &
                    mtime, iter_sia, iter_seep, iter_vs, ittot_vs,     &
                    prt_flow_fac, prt_flow_sub,                        &
                    prt_flow_symbfac_comp, prt_flow_fac_comp,          &
                    prt_flow_sub_comp
            end if
          end if
          
!c  reset primary and secondary unknowns for reduced time step        
          if (reduce_timestep) then
            exit
          end if
 
        end do          !newton iteration loop

!c  seepage face iteration update
        if (.not. reduce_timestep) then
          if (seepage_face) then
            !Parallelized, OpenMP, DSU              
            call seepface
            if (seep_iter .and. iter_seep.ge.maxit_seepage) then
              reduce_timestep = .true.
              if (rank == 0 .and. b_enable_output .and. idetail_vs.gt.0) then
                write(*,'(/,1x,a)') 'Reduce time step for seepage iteration'
                write(ilog,'(/,1x,a)') 'Reduce time step for seepage iteration'
              end if
            end if
          end if
        end if

!c check if boundary nodes with influx is ponding
        if (b_water_freezing .and. b_freezing_no_pond .and.        &
            .not.reduce_timestep) then
          b_freezing_pond = .false.

          uvsmax = r0
          maxvol = i0

          do ibvs = 1, nbvs          
            ivol = iabvs(ibvs)
            if (ivol < 0) then
              cycle  
            end if
            if ((btypevs(ibvs).eq.'second' .or. &
                 btypevs(ibvs).eq.'point' .or. &
                 btypevs(ibvs).eq.'seepage-second') .and. &
                 uvsnew(ivol) > tol_freezing_pond(ibvs)) then
              bcondvs(ibvs) = r0
              b_freezing_pond = .true.
              reduce_timestep = .true.
              if (uvsnew(ivol) > uvsmax) then
                uvsmax = uvsnew(ivol)
                maxvol = ivol
              end if
            end if
          end do
#ifdef PETSC
          call MPI_Allreduce(b_freezing_pond,reduce_timestep,1,    &
                   MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)

          if (reduce_timestep) then
            mpireduce_in(1) = uvsmax      !returns the reduced value
            mpireduce_in(2) = rank        !returns the rank of process that owns it
            call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                               MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                               Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            uvsmax = mpireduce_out(1)
            mpireduce_irank = int(mpireduce_out(2))
            
            call MPI_BCAST(maxvol, 1, MPI_INTEGER4, mpireduce_irank,         &
                           Petsc_Comm_World, ierrcode) 
            CHKERRQ(ierrcode)                
          end if
#endif
    
          if (reduce_timestep) then
            if (rank == 0 .and. b_enable_output .and. idetail_vs.gt.0) then
#ifdef PETSC
              write(*,'(1x,a,1x,1pe11.4,1x,a,1x,i9,1x,a,1x,i6)')             &
                   'Reduce time step for boundary nodes with pond, max',     &
                    uvsmax,'m, vol',maxvol,'rank',mpireduce_irank
              write(ilog,'(1x,a,1x,1pe11.4,1x,a,1x,i9,1x,a,1x,i6)')          &
                   'Reduce time step for boundary nodes with pond, max',     &
                    uvsmax,'m, vol',maxvol,'rank',mpireduce_irank
#else
              write(*,'(1x,a,1x,1pe11.4,1x,a,1x,i9)')                        &
                   'Reduce time step for boundary nodes with pond, max',     &
                    uvsmax,'m, vol',maxvol
              write(ilog,'(1x,a,1x,1pe11.4,1x,a,1x,i9)')                     &
                   'Reduce time step for boundary nodes with pond, max',     &
                    uvsmax,'m, vol',maxvol
#endif
            end if
          end if
        end if

        if (reduce_timestep) then
#ifdef OPENMP
    !$omp parallel                                                     &                                                                
    !$omp if (nngl > numofloops_thred_global)                          & 
    !$omp num_threads(numofthreads_global)                             &
    !$omp default(shared)                                              &
    !$omp private (ivol)                                             
    !$omp do schedule(static)
#endif               
            do ivol=1,nngl
              uvsnew(ivol) = uvsold(ivol)
              hhead(ivol) = uvsold(ivol)+zg(ivol)
            end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c_bubbles update reactive transport varibale also
            if (gas_bubbles .or. mip_mt_enable) then
#ifdef OPENMP
    !$omp parallel                                                     &                                                                
    !$omp if (nngl > numofloops_thred_global)                          & 
    !$omp num_threads(numofthreads_global)                             &
    !$omp default(shared)                                              &
    !$omp private (ivol, ic, im)                                             
    !$omp do schedule(static)
#endif 
              do ivol=1,nngl
                sionnew(ivol) = sionold(ivol)
!c_bubbles reset saturations to old time level
                sanew(ivol) = saold(ivol)
                if(zero_storage) then
                  sgnew(ivol)=sgold(ivol)
                else
                  sgnew(ivol) = r1-saold(ivol)
                end if
                if (trap_bubbles) then
                  sa_min(ivol) = sa_min_old(ivol)
                  big_bubble(ivol) = big_bub_old(ivol)
                  sgt(ivol) = sgt_old(ivol)
                end if
                do ic=1,n
                  cnew(ic,ivol) = c(ic,ivol)
                end do
                if (nm.gt.r0)then
                  do im=1,nm
                    phi(im,ivol)=phiold(im,ivol)
                    cmnew(im,ivol)=cmold(im,ivol)
                  end do
                end if
              end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            end if
!c  return and start over with reduced time step 
          exit
        end if
        
      end do            !seepage face iteration loop

!c  update soil hydraulic parameters
!c  Parallelized, OpenMP, DSU

#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_relp) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,izn,rdummy,                                   &
    !$omp sa_min_loc,solvegb_loc,sgt_loc,sgt_old_loc,sa_app_loc,      &
    !$omp sa_eff_loc,sg_eff_loc,unsaturated_loc,drainage_loc,         &
    !$omp main_drain_loc,big_bubble_loc,sgr_imbi_loc,mip_g_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl
        izn = mpropvs(ivol)

        if (gas_bubbles) then
          sa_min_loc = sa_min(ivol)
          solvegb_loc = solvegb(ivol)
          sgt_loc = sgt(ivol)
          sgt_old_loc = sgt_old(ivol)
        end if

        if (trap_bubbles) then
          sa_app_loc = sa_app(ivol)
          sa_eff_loc = sa_eff(ivol)
          sg_eff_loc = sg_eff(ivol)
          unsaturated_loc = unsaturated(ivol)
          drainage_loc = drainage(ivol)
          main_drain_loc = main_drain(ivol)
          big_bubble_loc = big_bubble(ivol)
          if (soilhydrfunc_field) then
            sgr_imbi_loc = sgr_imbi_vol(ivol)
          else
            sgr_imbi_loc = sgr_imbi(izn)
          end if
        end if

        if (mip_mt_enable) then
          mip_g_loc = mip_g(ivol)
        else
          mip_g_loc = 0
        end if

        !c here local variables *_loc were used as these variables may not be
        !c allocated if gas_bubbles or trap_bubbles are not set.
        if (.not.b_disable_sat_updt) then
          if (soilhydrfunc_field) then
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry_vol(ivol),swr_vol(ivol),              &
                          spalpha_vol(ivol),spbeta_vol(ivol),          &
                          spgamma_vol(ivol),expn_vol(ivol),            &
                          rdummy,rdummy,                               &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          else
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry(izn),swr(izn),                        &
                          spalpha(izn),spbeta(izn),                    &
                          spgamma(izn),expn(izn),                      &
                          rdummy,rdummy,                               &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          end if
        end if

        if (gas_bubbles) then
          sa_min(ivol) = sa_min_loc
          sgt(ivol) = sgt_loc
        end if

        if (trap_bubbles) then
          sa_app(ivol) = sa_app_loc
          sa_eff(ivol) = sa_eff_loc
          sg_eff(ivol) = sg_eff_loc
          big_bubble(ivol) = big_bubble_loc
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (num_cells > numofloops_thred_global)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (icell,ivol,izn,i2,uvsnew_cell,sanew_cell,sonew_cell)
    !$omp do schedule(static)
#endif
      do icell = 1, num_cells
        izn = mpropvs_cell(ivol)
        uvsnew_cell = 0.0d0
        sanew_cell = 0.0d0
        sonew_cell = 0.0d0
        do i2 = 1, num_nodes_per_cell
          ivol = cells(i2,icell)
          uvsnew_cell = uvsnew_cell + uvsnew(ivol)
          sanew_cell = sanew_cell + sanew(ivol)
          sonew_cell = sonew_cell + sonew(ivol)
        end do
        uvsnew_cell = uvsnew_cell/num_nodes_per_cell
        sanew_cell = sanew_cell/num_nodes_per_cell
        sonew_cell = sonew_cell/num_nodes_per_cell

        call soilparm_perm(uvsnew_cell,sanew_cell,sonew_cell,          &
                           aentry(izn),swr(izn),spgamma(izn),expn(izn),&
                           relperm(icell),relpermg(icell),bubble_perm, &
                           gas_bubbles,oil_saturation,                 &
                           mip_mt_enable,mip_update_relperm)
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

      else
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,izn,                                          &
    !$omp sa_min_loc,solvegb_loc,sgt_loc,sgt_old_loc,sa_app_loc,      &
    !$omp sa_eff_loc,sg_eff_loc,unsaturated_loc,drainage_loc,         &
    !$omp main_drain_loc,big_bubble_loc,sgr_imbi_loc,mip_g_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1, nngl
        izn = mpropvs(ivol)

        if (gas_bubbles) then
          sa_min_loc = sa_min(ivol)
          solvegb_loc = solvegb(ivol)
          sgt_loc = sgt(ivol)
          sgt_old_loc = sgt_old(ivol)
        end if

        if (trap_bubbles) then
          sa_app_loc = sa_app(ivol)
          sa_eff_loc = sa_eff(ivol)
          sg_eff_loc = sg_eff(ivol)
          unsaturated_loc = unsaturated(ivol)
          drainage_loc = drainage(ivol)
          main_drain_loc = main_drain(ivol)
          big_bubble_loc = big_bubble(ivol)
          if (soilhydrfunc_field) then
            sgr_imbi_loc = sgr_imbi_vol(ivol)
          else
            sgr_imbi_loc = sgr_imbi(izn)
          end if
        end if

        if (mip_mt_enable) then
          mip_g_loc = mip_g(ivol)
        else
          mip_g_loc = 0
        end if

        !c here local variables *_loc were used as these variables may not be
        !c allocated if gas_bubbles or trap_bubbles are not set.
        if (.not.b_disable_sat_updt) then
          if (soilhydrfunc_field) then
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry_vol(ivol),swr_vol(ivol),              &
                          spalpha_vol(ivol),spbeta_vol(ivol),          &
                          spgamma_vol(ivol),expn_vol(ivol),            &
                          relperm(ivol),relpermg(ivol),                &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          else
            call soilparm(uvsnew(ivol),uvsold(ivol),                   &
                          sanew(ivol),saold(ivol),sonew(ivol),         &
                          sa_app_loc,sa_eff_loc,sg_eff_loc,sa_min_loc, &
                          aentry(izn),swr(izn),                        &
                          spalpha(izn),spbeta(izn),                    &
                          spgamma(izn),expn(izn),                      &
                          relperm(ivol),relpermg(ivol),                &
                          trap_bubbles,bubble_perm,gas_bubbles,        &
                          oil_saturation,unsaturated_loc,drainage_loc, &
                          main_drain_loc,big_bubble_loc,solvegb_loc,   &
                          sgr_imbi_loc,sgt_loc,sgt_old_loc,            &
                          mip_mt_enable,mip_update_relperm,mip_g_loc)
          end if
        end if

        if (gas_bubbles) then
          sa_min(ivol) = sa_min_loc
          sgt(ivol) = sgt_loc
        end if

        if (trap_bubbles) then
          sa_app(ivol) = sa_app_loc
          sa_eff(ivol) = sa_eff_loc
          sg_eff(ivol) = sg_eff_loc
          big_bubble(ivol) = big_bubble_loc
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef USG
      end if
#endif

!c  estimate time step size for next time level
!c  Parallelized, OpenMP, DSU
      if (transient_flow .and. .not.reduce_timestep) then
        call tstepvs 
      end if 

      return
      end
