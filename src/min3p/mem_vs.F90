!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/mem_vs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mem_vs
!c -----------------
!c
!c allocate memory for flow simulation
!c
!c written by:      Uli Mayer - Januray 6, 2000
!c                  Sergi Molins - May 15, 2006
!c                  allocated sonew(nn)
!c                  Anna Harrison - Jan 24, 2014
!c                  allocated qh2o for hydrated carb water sequestn
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c last modified:   -
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           hhead(nngl)          = hydraulic head                      * +
!c           perm_fac(nngl)       = scaling factor for permeability     * +
!c                                as a function of porosity changes
!c           tau_fac(nngl)        = updated tortuosity as the function
!c                                of changed porosity
!c                                tau = tau_0 * por^alpha / por_0^alpha
!c                                tauupdate_fac = por^alpha / por_0^alpha
!c           pornew(nngl)         = porosity                            * +
!c           por_init(nngl)       = initial porosity                    * +
!c           sgnew(nngl)          = gaseous phase saturation            * +
!c                                (new time level)
!c           sgold(nngl)          = gaseous phase saturation            * +
!c                                (old time level)
!c           sainc(nngl)          = aqueous phase saturation            * +
!c                                (incremented)
!c           sanew(nngl)          = aqueous phase saturation            * +
!c                                (new time level)
!c           snnew(nngl)          = NAPL phase saturation               * +
!c                                (new time level)
!c           saold(nngl)          = aqueous phase saturation            * +
!c                                (time level N)
!c           saold2(nngl)          = aqueous phase saturation            * +
!c                                (time level N-1)
!c           relperm(nngl)        = relative permeability               * +
!c           relpinc(nngl)        = relative permeability (incremented) * +
!c           uvsinc(nngl)         = solution vector (incremented)       * +
!c           uvsnew(nngl)         = solution vector (new time level)    * +
!c           uvsold(nngl)         = solution vector (old time level)    * +
!c           vsflux(ncon-1)     = interfacial fluxes                  * +
!c           bvs(nngl)            = rhs vector                          * +
!c           res_vs(nngl)          = residual                            * +
!c           uvs(nngl)            = update towards solution-vector      * +
!c           relpermg(nn)       = relative gas permeability           * +
!c
!c
!c           integer*4:
!c           ----------
!c           ilog               = unit number, logbook file           + -
!c           iavs(nngl+1)         = row pointer array for 1d-scalar     * +
!c                                matrix
!c           iafvs(nngl+1)        = row pointer array for afvs          * +
!c           iafdvs(nngl)         = diagonal pointer array for afvs     * +
!c           lordervs(nngl)       = array containing ordering           * +
!c           invordvs(nngl)       = array containing inverse ordering   * +
!c           mpropvs(nngl)        = pointer array for allocation of     * +
!c                                material properties
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * +
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c
!c external: checkerr  = check for error during memory allocation 
!c
!c---------------------------------------------------------------------- 
!c WARNING
!c---------------------------------------------------------------------- 
!c All allocated variables are initialized to some value. This depends  
!c of its type:
!c 
!c real*8      => 0.0d0
!c integer     => 0 
!c character   => ' '    
!c logical     => .false. 
!c 
!c Sergio Andres Bea Jofre (2009)
!c
!c ----------------------------------------------------------------------
  
      subroutine mem_vs
 
      use parm
      use gen
      use bbls
      use phys, only : is_cell_based_relp
#ifdef USG
      use geometry_definition
      use usg_mesh_data, only : num_cells      
#endif

#ifdef OPENMP
      use omp_lib 
#endif

      implicit none
      
      integer :: ierr, ivol, icon

      external checkerr
 
!c  allocate memory for reactive transport simulation

!c  main variables - variably saturated flow

      allocate (uvsnew(nngl), stat = ierr)
      uvsnew=0.0d0
      call checkerr(ierr,'uvsnew',ilog)
      call memory_monitor(sizeof(uvsnew),'uvsnew',.true.)
 
      allocate (uvsold(nngl), stat = ierr)
      uvsold=0.0d0
      call checkerr(ierr,'uvsold',ilog)
      call memory_monitor(sizeof(uvsold),'uvsold',.true.)
 
      allocate (uvsinc(nngl), stat = ierr)
      uvsinc=0.0d0
      call checkerr(ierr,'uvsinc',ilog)
      call memory_monitor(sizeof(uvsinc),'uvsinc',.true.)
 
      allocate (hhead(nngl), stat = ierr)
      hhead=0.0d0
      call checkerr(ierr,'hhead',ilog)
      call memory_monitor(sizeof(hhead),'hhead',.true.)
 
      allocate (saold(nngl), stat = ierr)
      saold=0.0d0
      call checkerr(ierr,'saold',ilog)
      call memory_monitor(sizeof(saold),'saold',.true.)
 
      allocate (sanew(nngl), stat = ierr)
      sanew=0.0d0
      call checkerr(ierr,'sanew',ilog)
      call memory_monitor(sizeof(sanew),'sanew',.true.)

      allocate (tkel(nngl), stat = ierr)
      tkel=0.0d0
      call checkerr(ierr,'tkel',ilog)
      call memory_monitor(sizeof(tkel),'tkel',.true.)      
 
      allocate (stor(nngl), stat = ierr)
      stor=0.0d0
      call checkerr(ierr,'stor',ilog)
      call memory_monitor(sizeof(stor),'stor',.true.)

      allocate (i2up(nngl), stat = ierr)
      i2up=0
      call checkerr(ierr,'i2up',ilog)
      call memory_monitor(sizeof(i2up),'i2up',.true.)

!cprovi---------------------------------------------
!cprovi---------------------------------------------
!cprovi--------------------------------------------- 
 
      if (compute_ice_sheet_loading) then   
        allocate (skempton(nngl), stat = ierr)
        skempton=1.0d0
        call checkerr(ierr,'skempton',ilog)
        call memory_monitor(sizeof(skempton),'skempton',.true.)

        allocate (loading_factor(nngl), stat = ierr)
        loading_factor=1.0d0
        call checkerr(ierr,'loading_factor',ilog)
        call memory_monitor(sizeof(loading_factor),'loading_factor',.true.)
      end if 
!cprovi---------------------------------------------
!cprovi---------------------------------------------
!cprovi--------------------------------------------- 
 
      allocate (sgold(nngl), stat = ierr)
      sgold=0.0d0
      call checkerr(ierr,'sgold',ilog)
      call memory_monitor(sizeof(sgold),'sgold',.true.)
 
      allocate (sgnew(nngl), stat = ierr)
      sgnew=0.0d0
      call checkerr(ierr,'sgnew',ilog)
      call memory_monitor(sizeof(sgnew),'sgnew',.true.)
 
      allocate (sainc(nngl), stat = ierr)
      sainc=0.0d0
      call checkerr(ierr,'sainc',ilog)
      call memory_monitor(sizeof(sainc),'sainc',.true.)

      allocate (sginc(nngl), stat = ierr)
      sginc=0.0d0
      call checkerr(ierr,'sginc',ilog)
      call memory_monitor(sizeof(sginc),'sginc',.true.)

      allocate (sonew(nngl), stat = ierr)
      sonew=0.0d0
      call checkerr(ierr,'sonew',ilog)
      call memory_monitor(sizeof(sonew),'sonew',.true.)

      allocate (taugas(nngl), stat = ierr)
      taugas=0.0d0
      call checkerr(ierr,'taugas',ilog)
      call memory_monitor(sizeof(taugas),'taugas',.true.)

      allocate (qwater(nngl), stat = ierr)
      qwater=0.0d0
      call checkerr(ierr,'qwater',ilog)
      call memory_monitor(sizeof(qwater),'qwater',.true.)

#ifdef USG
      if (discretization_type > 0 .and. is_cell_based_relp) then

        allocate (relperm(num_cells), stat = ierr)
        relperm=1.0d0
        call checkerr(ierr,'relperm',ilog)
        call memory_monitor(sizeof(relperm),'relperm',.true.)

        allocate (relpermg(num_cells), stat = ierr)
        relpermg=1.0d0
        call checkerr(ierr,'relpermg',ilog)
        call memory_monitor(sizeof(relpermg),'relpermg',.true.)

        allocate (relpinc(num_cells), stat = ierr)
        relpinc=0.0d0
        call checkerr(ierr,'relpinc',ilog)
        call memory_monitor(sizeof(relpinc),'relpinc',.true.)

        allocate (relpincg(num_cells), stat = ierr)
        relpincg=0.0d0
        call checkerr(ierr,'relpincg',ilog)
        call memory_monitor(sizeof(relpincg),'relpincg',.true.)

      else
#endif

        allocate (relperm(nngl), stat = ierr)
        relperm=1.0d0
        call checkerr(ierr,'relperm',ilog)
        call memory_monitor(sizeof(relperm),'relperm',.true.)

        allocate (relpermg(nngl), stat = ierr)
        relpermg=1.0d0
        call checkerr(ierr,'relpermg',ilog)
        call memory_monitor(sizeof(relpermg),'relpermg',.true.)

        allocate (relpinc(nngl), stat = ierr)
        relpinc=0.0d0
        call checkerr(ierr,'relpinc',ilog)
        call memory_monitor(sizeof(relpinc),'relpinc',.true.)

         allocate (relpincg(nngl), stat = ierr)
        relpincg=0.0d0
        call checkerr(ierr,'relpincg',ilog)
        call memory_monitor(sizeof(relpincg),'relpincg',.true.)

#ifdef USG
      end if
#endif

      allocate (perm_fac(nngl), stat = ierr)
      perm_fac=0.0d0
      call checkerr(ierr,'perm_fac',ilog)
      call memory_monitor(sizeof(perm_fac),'perm_fac',.true.)

      allocate (tau_fac(nngl), stat = ierr)
      tau_fac = 1.0d0
      call checkerr(ierr,'tau_fac',ilog)
      call memory_monitor(sizeof(tau_fac),'tau_fac',.true.)

      allocate (marchies(nngl), stat = ierr)
      marchies = 0.0d0
      call checkerr(ierr,'marchies',ilog)
      call memory_monitor(sizeof(marchies),'marchies',.true.)

      allocate (pornew(nngl), stat = ierr)
      pornew=0.0d0
      call checkerr(ierr,'pornew',ilog)
      call memory_monitor(sizeof(pornew),'pornew',.true.)

      allocate (por_stress_dt(nngl), stat = ierr)
      por_stress_dt=0.0d0
      call checkerr(ierr,'por_stress_dt',ilog)
      call memory_monitor(sizeof(por_stress_dt),'por_stress_dt',.true.)

      !allocate (por_stress(nngl), stat = ierr)
      !por_stress=0.0d0
      !call checkerr(ierr,'por_stress',ilog)
      !call memory_monitor(sizeof(por_stress),'por_stress',.true.)

      allocate (porold(nngl), stat = ierr)
      porold=0.0d0
      call checkerr(ierr,'porold',ilog)
      call memory_monitor(sizeof(porold),'porold',.true.)

      allocate (por_init(nngl), stat = ierr)
      por_init=0.0d0
      call checkerr(ierr,'por_init',ilog)
      call memory_monitor(sizeof(por_init),'por_init',.true.)

      allocate (qh2o(nngl), stat = ierr)
      qh2o = 0.0d0
      call checkerr(ierr,'qh2o',ilog)
      call memory_monitor(sizeof(qh2o),'qh2o',.true.)

      allocate (mpropvs(nngl), stat = ierr)
      mpropvs=0
      call checkerr(ierr,'mpropvs',ilog)
      call memory_monitor(sizeof(mpropvs),'mpropvs',.true.)

      allocate (property_iflag(nngl), stat = ierr)
      property_iflag=0
      call checkerr(ierr,'property_iflag',ilog)
      call memory_monitor(sizeof(property_iflag),'property_iflag',.true.)

      allocate (snnew(nngl), stat = ierr)
      snnew=0.0d0
      call checkerr(ierr,'snnew',ilog)
      call memory_monitor(sizeof(snnew),'snnew',.true.)

      allocate (saold2(nngl), stat = ierr)
      saold2=0.0d0
      call checkerr(ierr,'saold2',ilog)
      call memory_monitor(sizeof(saold2),'saold2',.true.)

 
!c  newton iteration - variably saturated flow 
      if (discretization_type == 0) then
        allocate (vsflux(ncon-1), stat = ierr)
        vsflux=0.0d0
        call checkerr(ierr,'vsflux',ilog)
        call memory_monitor(sizeof(vsflux),'vsflux',.true.)


        allocate (iups(ncon-1), stat = ierr)
        iups=' '
        call checkerr(ierr,'iups',ilog)
        call memory_monitor(sizeof(iups),'iups',.true.)

#ifdef USG
      else
        allocate (vsflux(ncon_usg-1), stat = ierr)
        vsflux=0.0d0
        call checkerr(ierr,'vsflux',ilog)
        call memory_monitor(sizeof(vsflux),'vsflux',.true.)

        allocate (iups(ncon_usg-1), stat = ierr)
        iups=' '
        call checkerr(ierr,'iups',ilog)
        call memory_monitor(sizeof(iups),'iups',.true.)
        
        if (b_use_cell_vel) then
          allocate (vels(num_cells), stat = ierr)
        else
          allocate (vels(nngl), stat = ierr)
        end if
        vels = vector_zero
        call checkerr(ierr,'vels',ilog)
        call memory_monitor(sizeof(vels),'vels',.true.)

#endif
      end if

!c  data structure and solver - variably saturated flow 
      allocate (bvs(nngl), stat = ierr)
      bvs=0.0d0
      call checkerr(ierr,'bvs',ilog)
      call memory_monitor(sizeof(bvs),'bvs',.true.)

 
      allocate (uvs(nngl), stat = ierr)
      uvs=0.0d0
      call checkerr(ierr,'uvs',ilog)
      call memory_monitor(sizeof(uvs),'uvs',.true.)

 
      allocate (res_vs(nngl), stat = ierr)
      res_vs=0.0d0
      call checkerr(ierr,'res_vs',ilog)
      call memory_monitor(sizeof(res_vs),'res_vs',.true.)

 
      allocate (iavs(nngl+1), stat = ierr)
      iavs=0
      call checkerr(ierr,'iavs',ilog)
      call memory_monitor(sizeof(iavs),'iavs',.true.)

#ifdef PETSC
 
      allocate (row_idx_l2pg_vs(nngl+1), stat = ierr)
      row_idx_l2pg_vs=0
      call checkerr(ierr,'row_idx_l2pg_vs',ilog)
      call memory_monitor(sizeof(row_idx_l2pg_vs),'row_idx_l2pg_vs',.true.)

#endif

 
      allocate (iafvs(nngl+1), stat = ierr)
      iafvs=0
      call checkerr(ierr,'iafvs',ilog)
      call memory_monitor(sizeof(iafvs),'iafvs',.true.)

 
      allocate (iafdvs(nngl), stat = ierr)
      iafdvs=0 
      call checkerr(ierr,'iafdvs',ilog)
      call memory_monitor(sizeof(iafdvs),'iafdvs',.true.)

 
      allocate (lordervs(nngl), stat = ierr)
      lordervs=0 
      call checkerr(ierr,'lordervs',ilog)
      call memory_monitor(sizeof(lordervs),'lordervs',.true.)

 
      allocate (invordvs(nngl), stat = ierr)
      invordvs=0 
      call checkerr(ierr,'invordvs',ilog)
      call memory_monitor(sizeof(invordvs),'invordvs',.true.)

      
!c_bubbles variables for bubble problem
 
      if (gas_bubbles) then

        allocate (unsaturated(nngl), stat = ierr)
        unsaturated = .false.
        call checkerr(ierr,'unsaturated',ilog)
        call memory_monitor(sizeof(unsaturated),'unsaturated',.true.)

        allocate (solvegb(nngl), stat = ierr)
        solvegb = .false.
        call checkerr(ierr,'solvegb',ilog)
        call memory_monitor(sizeof(solvegb),'solvegb',.true.)

        allocate (sg_temp(nngl), stat = ierr)
        sg_temp=0.0d0
        call checkerr(ierr,'sg_temp',ilog)
        call memory_monitor(sizeof(sg_temp),'sg_temp',.true.)

        allocate (sgt(nngl), stat = ierr)
        sgt=0.0d0
        call checkerr(ierr,'sgt',ilog)
        call memory_monitor(sizeof(sgt),'sgt',.true.)

        allocate (sgt_old(nngl), stat = ierr)
        sgt_old=0.0d0
        call checkerr(ierr,'sgt_old',ilog)
        call memory_monitor(sizeof(sgt_old),'sgt_old',.true.)
      
        allocate (sa_min_old(nngl), stat = ierr)
        sa_min_old=0.0d0
        call checkerr(ierr,'sa_min_old',ilog)
        call memory_monitor(sizeof(sa_min_old),'sa_min_old',.true.)

        allocate (sa_min(nngl), stat = ierr)
        sa_min=0.0d0
        call checkerr(ierr,'sa_min',ilog)
        call memory_monitor(sizeof(sa_min),'sa_min',.true.)
    
      end if
    
 
      if (trap_bubbles) then
          
        allocate (sa_app(nngl), stat = ierr)
        sa_app=0.0d0
        call checkerr(ierr,'sa_app',ilog)
        call memory_monitor(sizeof(sa_app),'sa_app',.true.)
        
        allocate (sa_eff(nngl), stat = ierr)
        sa_eff=0.0d0
        call checkerr(ierr,'sa_eff',ilog)
        call memory_monitor(sizeof(sa_eff),'sa_eff',.true.)
        
        allocate (sg_eff(nngl), stat = ierr)
        sg_eff=0.0d0
        call checkerr(ierr,'sg_eff',ilog)
        call memory_monitor(sizeof(sg_eff),'sg_eff',.true.)

        allocate (drainage(nngl), stat = ierr)
        drainage = .false.
        call checkerr(ierr,'drainage',ilog)
        call memory_monitor(sizeof(drainage),'drainage',.true.)

        allocate (main_drain(nngl), stat = ierr)
        main_drain = .false.
        call checkerr(ierr,'main_drain',ilog)
        call memory_monitor(sizeof(main_drain),'main_drain',.true.)

        allocate (big_bubble(nngl), stat = ierr)
        big_bubble = .false.
        call checkerr(ierr,'big_bubble',ilog)
        call memory_monitor(sizeof(big_bubble),'big_bubble',.true.)

        allocate (big_bub_old(nngl), stat = ierr)
        big_bub_old = .false.
        call checkerr(ierr,'big_bub_old',ilog)
        call memory_monitor(sizeof(big_bub_old),'big_bub_old',.true.)

      end if
      
      return
      end
