!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/mem_nx.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mem_nx
!c -----------------
!c
!c allocate memory for one-dimensional arrays of size nx and 
!c related arrays
!c
!c written by:      Uli Mayer - January 7, 2000
!c
!c last modified:   -
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    integer:
!c           --------
!c           ilog               = unit number, logbook file           + -
!c
!c chem.f:   real*8:
!c           -------
!c           alkfacx(nx)        = alkalinity factors for secondary    * +
!c                                aqueous species
!c           chargex(nx)        = charge of secondary aqueous         * +
!c                                species
!c           cxc(nx)            = concentrations of secondary         * +
!c                                aqueous species
!c                                - new time level [moles/l water]
!c           cxmax(nx)          = maximum concentration of secondary  * +
!c                                aqueous species in solution domain
!c           dhax(nx)           = debye-huckel a for secondary        * +
!c                                aqueous species
!c           dhbx(nx)           = debye-huckel b for secondary        * +
!c                                aqueous species
!c           dhcx(nx)           = enthalpy change for secondary       * +
!c                                aqueous species
!c           eqx(nx,nthreads)   = equilibrium constants for           * +
!c                                secondary aqueous species
!c           eqxs(nx)           = equilibrium constants for
!c                                secondary aqueous species           * +
!c                                at standard temperature
!c           gamma_l(nc+nx)     = activity coefficients of aqueous    * +
!c                                species
!c           gfwx(nx)           = gram formula weight of secondary    * +
!c                                aqueous species
!c           xnux(nx*nc)        = stoichiometric coefficient matrix   * +
!c                                for formation of secondary aqueous
!c                                species from components
!c           cxinc(nx,nthreads) = secondary aqueous species           * +
!c                                concentrations dependent on
!c                                incremented concentrations of
!c                                components as species in solution
!c                                [moles/l h2o]
!c
!c           integer:
!c           --------
!c           iax(nx+1)          = row pointer array to                * +
!c                                stoichiometric coefficients of
!c                                components in secondary aqueous
!c                                species
!c           jax(nx*nc)         = column pointer array to             * +
!c                                stoichiometric coefficients of
!c                                components in secondary aqueous
!c                                species
!c           l_namex(nx)        = length of names of secondary        * +
!c                                aqueous species
!c           nc                 = number of components including h2o  + -
!c           nx                 = number of aqueous complexes         + -
!c
!c           character:
!c           ----------
!c           namex(nx)          = names of secondary aqueous species  * +
!c
!c local:    integer:
!c           --------
!c           ierr               = 0 -> memory allocation successful
!c
!c external: checkerr  = check for error during memory allocation
!c
!c---------------------------------------------------------------------- 
!c WARNING
!c---------------------------------------------------------------------- 
!c All allocated variables are initialized to some value. This depends  
!c of its type:
!c 
!c real*8      => 0.0d0
!c integer     => 0 
!c character   => ' '    
!c logical     => .false. 
!c 
!c Sergio Andres Bea Jofre (2009)
!c
!c ----------------------------------------------------------------------
  
      subroutine mem_nx
 
      use parm
      use gen
      use chem
      
      implicit none
      
      integer :: ierr
 
      external checkerr

!c  main variables - aqueous species

      allocate (alkfacx(nx), stat = ierr)
      alkfacx=0.0d0
      call checkerr(ierr,'alkfacx',ilog)
      call memory_monitor(sizeof(alkfacx),'alkfacx',.true.)

      if (nx.gt.0) then
        allocate (gamma_l(nc+nx), stat = ierr)
        gamma_l=0.0d0
        call checkerr(ierr,'gamma_l',ilog)
        call memory_monitor(sizeof(gamma_l),'gamma_l',.true.)
      else
        allocate (gamma_l(nc+1), stat = ierr)
        gamma_l=0.0d0 
        call checkerr(ierr,'gamma_l',ilog)
        call memory_monitor(sizeof(gamma_l),'gamma_l',.true.)
      end if

      allocate (cxc(nx), stat = ierr)
      cxc=0.0d0 
      call checkerr(ierr,'cxc',ilog)
      call memory_monitor(sizeof(cxc),'cxc',.true.)

      allocate (cxmax(nx), stat = ierr)
      cxmax=0.0d0 
      call checkerr(ierr,'cxmax',ilog)
      call memory_monitor(sizeof(cxmax),'cxmax',.true.)

      allocate (cxmax_gbl(nx), stat = ierr)
      cxmax_gbl=0.0d0
      call checkerr(ierr,'cxmax_gbl',ilog)
      call memory_monitor(sizeof(cxmax_gbl),'cxmax_gbl',.true.)

      allocate (chargex(nx), stat = ierr)
      chargex=0.0d0 
      call checkerr(ierr,'chargex',ilog)
      call memory_monitor(sizeof(chargex),'chargex',.true.)

      allocate (eqx(nx,nthreads), stat = ierr)
      eqx=0.0d0 
      call checkerr(ierr,'eqx',ilog)
      call memory_monitor(sizeof(eqx),'eqx',.true.)

      allocate (eqxs(nx), stat = ierr)
      eqxs=0.0d0 
      call checkerr(ierr,'eqxs',ilog)
      call memory_monitor(sizeof(eqxs),'eqxs',.true.)

      allocate (gfwx(nx), stat = ierr)
      gfwx=0.0d0 
      call checkerr(ierr,'gfwx',ilog)
      call memory_monitor(sizeof(gfwx),'gfwx',.true.)

      allocate (dhcx(nx), stat = ierr)
      dhcx=0.0d0 
      call checkerr(ierr,'dhcx',ilog)
      call memory_monitor(sizeof(dhcx),'dhcx',.true.)

      allocate (dhax(nx), stat = ierr)
      dhax=0.0d0 
      call checkerr(ierr,'dhax',ilog)
      call memory_monitor(sizeof(dhax),'dhax',.true.)

      allocate (dhbx(nx), stat = ierr)
      dhbx=0.0d0 
      call checkerr(ierr,'dhbx',ilog)
      call memory_monitor(sizeof(dhbx),'dhbx',.true.)

      allocate (xnux(nx*nc), stat = ierr)
      xnux=0.0d0 
      call checkerr(ierr,'xnux',ilog)
      call memory_monitor(sizeof(xnux),'xnux',.true.)

      allocate (xnuxc(nx*nc), stat = ierr)
      xnuxc=0.0d0 
      call checkerr(ierr,'xnuxc',ilog)
      call memory_monitor(sizeof(xnuxc),'xnuxc',.true.)
      
      allocate (cpz_loc(nc+nx), stat = ierr)
      cpz_loc=0.0d0 
      call checkerr(ierr,'cpz_loc',ilog)
      call memory_monitor(sizeof(cpz_loc),'cpz_loc',.true.)

      allocate (iax(nx+1), stat = ierr)
      iax=0 
      call checkerr(ierr,'iax',ilog)
      call memory_monitor(sizeof(iax),'iax',.true.)

      allocate (jax(nx*nc), stat = ierr)
      jax=0 
      call checkerr(ierr,'jax',ilog)
      call memory_monitor(sizeof(jax),'jax',.true.)

      allocate (l_namex(nx), stat = ierr)
      l_namex=0 
      call checkerr(ierr,'l_namex',ilog)
      call memory_monitor(sizeof(l_namex),'l_namex',.true.)

      allocate (namex(nx), stat = ierr)
      namex=' ' 
      call checkerr(ierr,'namex',ilog)
      call memory_monitor(sizeof(namex),'namex',.true.)

      allocate (iacx(nc+1), stat = ierr)
      iacx=0 
      call checkerr(ierr,'iacx',ilog)
      call memory_monitor(sizeof(iacx),'iacx',.true.)

      allocate (jacx(nx*nc), stat = ierr)
      jacx=0 
      call checkerr(ierr,'jacx',ilog)
      call memory_monitor(sizeof(jacx),'jacx',.true.)

!c  newton iteration

      allocate (cxinc(nx,nthreads), stat = ierr)
      cxinc=0.0d0 
      call checkerr(ierr,'cxinc',ilog)
      call memory_monitor(sizeof(cxinc),'cxinc',.true.)

      return
      end
